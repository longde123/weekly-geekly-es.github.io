<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚒 👨🏾‍🔬 💨 So schreiben Sie einen Pionier in Phaser und führen eine HTML5-Entwicklertestaufgabe aus 🎶 🚶 🍜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag, liebe Kollegen! 

 Mein Name ist Alexander, ich bin Entwickler von HTML5-Spielen. 

 In einem der Unternehmen, an das ich meinen Lebenslauf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So schreiben Sie einen Pionier in Phaser und führen eine HTML5-Entwicklertestaufgabe aus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476682/"> Guten Tag, liebe Kollegen! <br><br>  Mein Name ist Alexander, ich bin Entwickler von HTML5-Spielen. <br><br>  In einem der Unternehmen, an das ich meinen Lebenslauf gesendet habe, wurde ich gebeten, eine Testaufgabe abzuschließen.  Ich habe zugestimmt und nach 1 Tag als Ergebnis das Spiel gesendet, das gemäß TOR HTML5 entwickelt wurde. <br><br><img src="https://habrastorage.org/webt/4t/ng/dn/4tngdnvlxq3izqrpk2nykww2dvs.png"><br><br>  Da ich eine Ausbildung in Spielprogrammierung absolviere und meinen Code effizienter nutzen möchte, habe ich mich dazu entschlossen, einen Schulungsartikel über das abgeschlossene Projekt zu verfassen.  Und da der abgeschlossene Test eine positive Bewertung erhielt und zu einer Einladung zu einem Vorstellungsgespräch führte, hat meine Entscheidung wahrscheinlich das Recht zu existieren und wird möglicherweise in Zukunft jemandem helfen. <br><br>  Dieser Artikel gibt einen Überblick über den Arbeitsaufwand, der ausreicht, um die durchschnittliche Testaufgabe für die HTML5-Position des Entwicklers erfolgreich abzuschließen.  Das Material kann auch für jeden von Interesse sein, der sich mit dem Phaser-Framework vertraut machen möchte.  Wenn Sie bereits mit Phaser arbeiten und in JS schreiben, erfahren Sie, wie Sie ein Projekt in TypeScript entwickeln. <br><br>  Unter cat gibt es also viel TypeScript-Code! <br><a name="habracut"></a><br><h2>  Einleitung </h2><br>  Wir geben eine kurze Erklärung des Problems. <br><br><ol><li>  Wir werden ein einfaches HTML5-Spiel entwickeln - einen klassischen Pionier. </li><li>  Als Haupttools werden wir Phaser 3, Typoscript und Webpack verwenden. </li><li>  Das Spiel wird für den Desktop entworfen und im Browser ausgeführt. </li></ol><br>  Wir bieten Links zum endgültigen Projekt. <br><br><div class="spoiler">  <b class="spoiler_title">Links zur Demo und Quelle</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spielbare Demo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub-Quellcode</a> <br></div></div><br>  Und erinnere dich an die Mechanik des Pioniers, wenn plötzlich jemand die Spielregeln vergessen hat.  Da dies jedoch unwahrscheinlich ist, werden die Regeln unter den Spoiler gestellt :) <br><br><div class="spoiler">  <b class="spoiler_title">Sapper-Regeln</b> <div class="spoiler_text">  Das Spielfeld besteht aus Zellen, die in einer Tabelle angeordnet sind.  Standardmäßig sind beim Start des Spiels alle Zellen geschlossen.  In einigen Zellen sind Bomben platziert. <br><br>  Wenn Sie mit der linken Maustaste auf eine geschlossene Zelle klicken, wird diese geöffnet.  Wenn sich eine Bombe in einer offenen Zelle befand, endet das Spiel mit einer Niederlage. <br><br>  Wenn sich keine Bombe in der Zelle befand, wird eine Zahl darin angezeigt, die die Anzahl der Bomben angibt, die sich in benachbarten Zellen befinden, bezogen auf die derzeit geöffnete Bombe.  Wenn keine Bomben in der Nähe sind, sieht die Zelle leer aus. <br><br>  Ein Rechtsklick auf eine geschlossene Zelle setzt ein Flag darauf.  Der Spieler hat die Aufgabe, alle ihm zur Verfügung stehenden Flaggen so anzuordnen, dass sie alle verminteten Zellen markieren.  Nachdem alle Flaggen platziert wurden, drückt der Spieler die linke Maustaste auf eine der offenen Zellen, um zu überprüfen, ob er gewonnen hat. <br></div></div><br>  Als nächstes gehen wir direkt zum Handbuch.  Das gesamte Material ist in kleine Schritte unterteilt, von denen jeder die Implementierung einer bestimmten Aufgabe in kurzer Zeit beschreibt.  Wenn wir also Schritt für Schritt kleine Ziele erreichen, werden wir am Ende ein vollständiges Spiel erstellen.  Verwenden Sie das Inhaltsverzeichnis, wenn Sie schnell zu einem bestimmten Schritt übergehen möchten. <br><br><div class="spoiler">  <b class="spoiler_title">Inhaltsverzeichnis</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1. Vorbereitung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.1 Projektvorlage</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.2 Build-Konfiguration</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.3 Module installieren</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.4 Vermögensvorbereitung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2. Szenen erstellen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.1 Einstiegspunkt</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2 Startszene</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.3 Texte der Startszene</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.4 Übergang in die Spielebene</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2,5 Level Szene</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.6 Szenen am Einstiegspunkt einstellen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3. Spielobjekte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.1 Spielbrett</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.2 Zellenmodell</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.3 Zellenansicht</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.4 Erstellen eines Sprites in einer Ansichtsklasse</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.5 Sprite-Positionierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.6 Erstellen einer Instanz von FieldView</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.7 Anzeigetafelfelder.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.8 Bomben bauen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.9 Werte einstellen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4. Behandlung von Eingabeereignissen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.1 Verfolgen von Mausklickereignissen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linksklickverarbeitung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.4 Rechtsklickverarbeitung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.5 GameSceneView-Objekt</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5. Animationen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5.1 Animation zum Füllen von Brettern</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5.2 Animationen zum Umblättern von Zellen</a> <br></div></div><br><a name="section-1"></a><h2>  <font color="#008080">1. Vorbereitung</font> </h2><br><a name="section-1-1"></a><h3>  <font color="#008080">1.1 Projektvorlage</font> </h3><br>  Laden Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standard-Phaser-Projektvorlage</a> herunter.  Dies ist die empfohlene Vorlage des Autors des Frameworks und bietet uns die folgende Verzeichnisstruktur: <br><div class="scrollable-table"><table><tbody><tr><td>  index.html </td><td colspan="2">  HTML-Seite, die das Spiel startet </td></tr><tr><td rowspan="2">  Webpack / </td><td>  base.js </td><td>  build config für die Testumgebung </td></tr><tr><td>  prod.js </td><td>  build config für die Produktion </td></tr><tr><td rowspan="2">  src / </td><td>  Vermögenswerte / </td><td>  Spiele-Assets (Sprites, Sounds, Schriften) </td></tr><tr><td>  index.js </td><td>  Einstiegspunkt </td></tr></tbody></table></div> Für unser Projekt benötigen wir die aktuelle Datei <code>index.js</code> nicht. Löschen Sie sie daher.  Erstellen Sie dann das Verzeichnis <code>/src/scripts/</code> und platzieren Sie die leere Datei <code>index.ts</code> darin.  Wir werden alle unsere Skripte zu diesem Ordner hinzufügen. <br>  Beachten Sie auch, dass beim Erstellen eines Projekts für die Produktion im Stammverzeichnis ein <code>dist</code> Verzeichnis erstellt wird, in dem der Release-Build abgelegt wird. <br><br><a name="section-1-2"></a><h3>  <font color="#008080">1.2 Build-Konfiguration</font> </h3><br>  Wir werden das Webpack für die Montage verwenden.  Da unsere Vorlage ursprünglich für die Arbeit mit JavaScript vorbereitet war und wir in TypeScript schreiben, müssen wir kleine Änderungen an der Konfiguration des Kollektors vornehmen. <br><br>  <code>webpack/base.js</code> den <code>webpack/base.js</code> hinzu, der den Einstiegspunkt beim <code>webpack/base.js</code> unseres Projekts angibt, sowie die Konfiguration von <code>ts-loader</code> , die die Regeln für das <code>webpack/base.js</code> TS-Skripten beschreibt: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// webpack/base.js //... module.exports = { entry: './src/scripts/index.ts', // ... resolve: { extensions: [ '.ts', '.tsx', '.js' ] }, module: { rules: [{ test: /\.tsx?$/, use: 'ts-loader', exclude: /node_modules/ }, //...</span></span></code> </pre><br>  Wir müssen auch die Datei tsconfig.json im Projektstamm erstellen.  Für mich hat es folgenden Inhalt: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"compilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"module"</span></span>: <span class="hljs-string"><span class="hljs-string">"commonjs"</span></span>, <span class="hljs-string"><span class="hljs-string">"lib"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"dom"</span></span>, <span class="hljs-string"><span class="hljs-string">"es5"</span></span>, <span class="hljs-string"><span class="hljs-string">"es6"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2015"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2017"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2015.promise"</span></span> ], <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-string"><span class="hljs-string">"es5"</span></span>, <span class="hljs-string"><span class="hljs-string">"skipLibCheck"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"exclude"</span></span>: [<span class="hljs-string"><span class="hljs-string">"node_modules"</span></span>, <span class="hljs-string"><span class="hljs-string">"dist"</span></span>] }</code> </pre> <br><a name="section-1-3"></a><h3>  <font color="#008080">1.3 Module installieren</font> </h3><br>  Installieren Sie alle Abhängigkeiten von package.json und fügen Sie die typescript- und ts-loader-Module hinzu: <br><br><pre> <code class="plaintext hljs">npm i npm i typescript --save-dev npm i ts-loader --save-dev</code> </pre><br>  Jetzt kann das Projekt mit der Entwicklung beginnen.  Wir verfügen über 2 Befehle, die bereits in der Eigenschaft <code>scripts</code> in der Datei <code>package.json</code> definiert sind. <br><br><ol><li>  Erstellen Sie ein Projekt zum Debuggen und öffnen Sie es in einem Browser über einen lokalen Server <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> </li><li>  Führen Sie den Build for Sale aus und legen Sie den Release-Build im Ordner dist / ab <br><br><pre> <code class="plaintext hljs">npm run build</code> </pre> </li></ol><br><a name="section-1-4"></a><h3>  <font color="#008080">1.4 Vermögensvorbereitung</font> </h3><br>  Alle Assets für dieses Spiel werden ehrlich von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenGameArt</a> (Version 61x61) heruntergeladen und haben die freundlichste der Lizenzen namens <i>Feel free to use</i> , die uns auf der Seite mit dem Paket sorgfältig mitgeteilt wird.  Der Code im Artikel hat übrigens die gleiche Lizenz!  ;) <br><br>  Ich habe das Uhrbild aus dem heruntergeladenen Satz gelöscht und den Rest der Dateien umbenannt, um einfach zu verwendende Frame-Namen zu erhalten.  Die Liste der Namen und der entsprechenden Dateien wird auf dem Bildschirm unten angezeigt. <br><br>  Aus den resultierenden Sprites erstellen wir einen <code>Phaser JSONArray</code> im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TexturePacker-</a> Programm (es gibt mehr als genug kostenlose Versionen, ich habe noch keine Arbeit erhalten) und legen die generierten Dateien <code>spritesheet.png</code> und <code>spritesheet.json</code> im Projektverzeichnis <code>src/assets/</code> . <br><br><img src="https://habrastorage.org/webt/ms/ki/z9/mskiz9zmuidbxk8hhcbksfmny4k.png"><br><br><a name="section-2"></a><h2>  <font color="#008080">2. Szenen erstellen</font> </h2><br><a name="section-2-1"></a><h3>  <font color="#008080">2.1 Einstiegspunkt</font> </h3><br>  Wir beginnen die Entwicklung mit der Erstellung des Einstiegspunkts, der in der Webpack-Konfiguration beschrieben ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// src/scripts/index.ts import * as Phaser from "phaser"; new Phaser.Game({ type: Phaser.AUTO, parent: "minesweeper", width: window.innerWidth, height: window.innerHeight, backgroundColor: "#F0FFFF", scene: [] });</span></span></code> </pre><br>  Da das Spiel für den Desktop entwickelt wurde und den gesamten Bildschirm ausfüllt, verwenden wir mutig die gesamte Breite und Höhe des Browsers für die Felder <code>width</code> und <code>height</code> . <br>  Das <code>scene</code> ist momentan ein leeres Array und wir werden es reparieren! <br><br><a name="section-2-2"></a><h3>  <font color="#008080">2.2 Startszene</font> </h3><br>  Erstellen Sie die Klasse der ersten Szene in der <code>src/scripts/scenes/StartScene.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartScene</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scene</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">'Start'</span></span>); } public preload(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } public create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  Für eine gültige Vererbung <code>Phaser.Scene</code> den <code>Phaser.Scene</code> als Parameter an den Konstruktor der übergeordneten Klasse. <br><br>  Diese Szene kombiniert die Funktionalität des Vorladens von Ressourcen und des Startbildschirms und lädt den Benutzer zum Spiel ein. <br><br>  Normalerweise durchläuft ein Spieler in meinen Projekten zwei Szenen, bevor er zur Startszene gelangt, und zwar in dieser Reihenfolge: <br><br><pre> <code class="plaintext hljs">Boot =&gt; Preload =&gt; Start</code> </pre><br>  Aber in diesem Fall ist das Spiel so einfach und es gibt so wenige Assets, dass es keinen Grund gibt, das Preload in eine separate Szene zu stellen, und noch mehr den anfänglichen separaten Bootloader. <br><br>  Wir werden alle Assets in der <code>preload</code> Methode laden.  Um in Zukunft mit dem erstellten Atlas arbeiten zu können, müssen wir zwei Schritte ausführen: <br><br><ol><li>  <code>png</code> sich sowohl <code>png</code> als auch <code>json</code> Atlas-Dateien mit <code>require</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.ts const spritesheetPng = require("./../../assets/spritesheet.png"); const spritesheetJson = require("./../../assets/spritesheet.json"); // ...</span></span></code> </pre><br></li><li>  Laden Sie sie in die <code>preload</code> Methode der Startszene: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.ts // ... public preload(): void { this.load.atlas("spritesheet", spritesheetPng, spritesheetJson); } // ...</span></span></code> </pre><br></li></ol><br><a name="section-2-3"></a><h3>  <font color="#008080">2.3 Texte der Startszene</font> </h3><br>  In der Startszene sind noch 2 Dinge zu tun: <br><br><ol><li>  Sagen Sie dem Spieler, wie er das Spiel starten soll </li><li>  starte das Spiel auf Initiative des Spielers </li></ol><br>  Um den ersten Punkt zu erfüllen, erstellen wir zunächst zwei Aufzählungen am Anfang der Szenendatei, um die Texte und ihre Stile zu beschreiben: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js enum Texts { Title = 'Minesweeper HTML5', Message = 'Click anywhere to start' } enum Styles { Color = '#008080', Font = 'Arial' } //...</span></span></code> </pre><br>  Und erstellen Sie dann beide Texte als Objekte in der Methode <code>create</code> .  Lassen Sie mich daran erinnern, dass die <code>create</code> von Szenen in <code>Phaser</code> erst aufgerufen wird, nachdem alle Ressourcen in der <code>preload</code> Methode <code>preload</code> , und dies ist für uns durchaus geeignet. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js //... public create(): void { this.add.text( this.cameras.main.centerX, this.cameras.main.centerY - 100, Texts.Title, {font: `52px ${Styles.Font}`, fill: Styles.Color}) .setOrigin(0.5); this.add.text( this.cameras.main.centerX, this.cameras.main.centerY + 100, Texts.Message, {font: `28px ${Styles.Font}`, fill: Styles.Color}) .setOrigin(0.5); } //...</span></span></code> </pre><br>  In einem anderen größeren Projekt könnten wir die Texte und Stile entweder in JSON-Locale-Dateien oder in separate Konfigurationsdateien aufnehmen. Da wir jetzt nur noch zwei Zeilen haben, halte ich diesen Schritt für überflüssig und schlage in diesem Fall vor, unser Leben nicht zu verkomplizieren. Beschränken wir uns auf Listen am Anfang der Szenendatei. <br><br><a name="section-2-4"></a><h3>  <font color="#008080">2.4 Übergang in die Spielebene</font> </h3><br>  Das Letzte, was wir in dieser Szene tun werden, bevor wir weitermachen, ist das Verfolgen des Mausklick-Ereignisses, um den Spieler in das Spiel zu starten: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js //... public create(): void { //... this.input.once('pointerdown', () =&gt; { this.scene.start('Game'); }); } //...</span></span></code> </pre> <br><a name="section-2-5"></a><h3>  <font color="#008080">2,5 Level Szene</font> </h3><br>  <code>this.scene.start</code> Parameters <code>"Game"</code> , der an die Methode <code>this.scene.start</code> Sie bereits vermutet, dass es an der Zeit ist, eine zweite Szene zu erstellen, die die Hauptspiellogik verarbeitet.  Erstelle die <code>src/scripts/scenes/GameScene.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameScene</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scene</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">'Game'</span></span>); } public create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  In dieser Szene benötigen wir die Methode <code>preload</code> , weil  In der vorherigen Szene haben wir bereits alle erforderlichen Ressourcen geladen. <br><br><a name="section-2-6"></a><h3>  <font color="#008080">2.6 Szenen am Einstiegspunkt einstellen</font> </h3><br>  Nachdem beide Szenen erstellt wurden, fügen Sie sie unserem Einstiegspunkt hinzu <br>  <code>src/scripts/index.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//... import { StartScene } from "./scenes/StartScene"; import { GameScene } from "./scenes/GameScene"; //... new Phaser.Game({ // ... scene: [StartScene, GameScene] });</span></span></code> </pre><br><a name="section-3"></a><h2>  <font color="#008080">3. Spielobjekte</font> </h2><br>  Die <code>GameScene</code> Klasse implementiert also die Logik auf Spielebene.  Und was erwarten wir vom Sapper-Level?  Visuell erwarten wir ein Spielfeld mit geschlossenen Zellen.  Wir wissen, dass das Feld eine Tabelle ist, was bedeutet, dass es eine bestimmte Anzahl von Zeilen und Spalten hat, in denen mehrere Bomben bequem platziert sind.  Somit verfügen wir über genügend Informationen, um eine separate Entität zu erstellen, die das Spielfeld beschreibt. <br><br><a name="section-3-1"></a><h3>  <font color="#008080">3.1 Spielbrett</font> </h3><br>  Erstellen Sie die <code>src/scripts/models/Board.ts</code> in die wir die <code>Board</code> Klasse <code>src/scripts/models/Board.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Field"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Board</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Events</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _rows: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _cols: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _bombs: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _fields: Field[] = []; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, rows: number, cols: number, bombs: number) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rows = rows; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cols = cols; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bombs = bombs; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._fields = []; } public get cols(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cols; } public get rows(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rows; } }</code> </pre> <br>  Machen wir die Klasse zum Nachfolger von Phaser.Events.EventEmitter, um auf die Schnittstelle zum Registrieren und Aufrufen von Ereignissen zuzugreifen, die wir in Zukunft benötigen werden. <br><br>  Ein Array von Objekten der <code>Field</code> Klasse wird in der Privateigenschaft <code>_fields</code> gespeichert.  Wir werden dieses Modell später implementieren. <br><br>  Wir richten private numerische Eigenschaften <code>_rows</code> und <code>_cols</code> , um die Anzahl der Zeilen und Spalten des Spielfelds anzugeben.  Erstellen Sie öffentliche Getter zum Lesen von <code>_rows</code> und <code>_cols</code> . <br><br>  Das Feld <code>_bombs</code> die Anzahl der Bomben an, die für das Level generiert werden müssen.  Und im Parameter <code>_scene</code> wir einen Verweis auf das Objekt der <code>GameScene</code> -Spielszene, in dem wir eine Instanz der <code>Board</code> Klasse erstellen. <br><br>  Es ist erwähnenswert, dass wir das Szenenobjekt nur zur weiteren Übertragung in die Ansichten auf das Modell übertragen, wo wir es nur zum Anzeigen der Ansicht verwenden.  Tatsache ist, dass Phaser das Szenenobjekt direkt zum Rendern von Sprites verwendet und uns daher verpflichtet, einen Link zur aktuellen Szene bereitzustellen, wenn Prefabs für Sprites erstellt werden, die wir in Zukunft entwickeln werden.  Wir erklären uns damit einverstanden, dass wir den Link zur Szene nur zur weiteren Verwendung als Display-Engine übertragen und die benutzerdefinierten Methoden der Szene in Modellen und Ansichten nicht direkt aufrufen. <br><br>  Nachdem wir uns für die <code>GameScene</code> entschieden haben, schlage ich vor, diese in der <code>GameScene</code> zu initialisieren und die <code>GameScene</code> Klasse <code>GameScene</code> : <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// GameScene.ts import { Board } from "../models/Board"; const Rows = 8; const Cols = 8; const Bombs = 8; export class GameScene extends Phaser.Scene { private _board: Board = null; //... public create(): void { this._board = new Board(this, Rows, Cols, Bombs); } }</span></span></code> </pre> <br>  Wir nehmen die Board-Parameter zu Konstanten am Anfang der Szenendatei und übergeben sie an den <code>Board</code> Konstruktor, wenn wir eine Instanz dieser Klasse erstellen. <br><br><a name="section-3-2"></a><h3>  <font color="#008080">3.2 Zellenmodell</font> </h3><br>  Die Tafel besteht aus Zellen, die Sie auf dem Bildschirm anzeigen möchten.  Jede Zelle muss an der entsprechenden Position platziert werden, die durch die Zeile und Spalte bestimmt wird. <br><br>  Zellen werden auch als separate Einheit ausgewählt.  Erstellen Sie die <code>src/scripts/models/Field.ts</code> in der die Klasse platziert wird, die die Zelle beschreibt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Board } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Board"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Field</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Events</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _board: Board = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _row: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _col: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, board: Board, row: number, col: number) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._init(scene, board, row, col); } public get col(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._col; } public get row(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._row; } public get board(): Board { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._board; } private _init(scene: Phaser.Scene, <span class="hljs-attr"><span class="hljs-attr">board</span></span>: Board, <span class="hljs-attr"><span class="hljs-attr">row</span></span>: number, <span class="hljs-attr"><span class="hljs-attr">col</span></span>: number): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._board = board; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._row = row; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._col = col; } }</code> </pre><br>  Jede Zelle sollte über Zeilen- und Spaltenmetriken verfügen, in denen sie sich befindet.  Wir richten die Parameter <code>_board</code> und <code>_scene</code> um Verknüpfungen zu Objekten der Platine und der Szene <code>_scene</code> .  Wir implementieren Getter zum Lesen der <code>_row</code> , <code>_col</code> und <code>_board</code> . <br><br><a name="section-3-3"></a><h3>  <font color="#008080">3.3 Zellenansicht</font> </h3><br>  Die abstrakte Zelle wird erstellt und nun möchten wir sie visualisieren.  Um eine Zelle auf dem Bildschirm anzuzeigen, müssen Sie ihre Ansicht erstellen.  Erstellen Sie die <code>src/scripts/views/FieldView.ts</code> und <code>src/scripts/views/FieldView.ts</code> die Ansichtsklasse ein: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../models/Field"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameObjects</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sprite</span></span></span><span class="hljs-class"> </span></span>{ private _model: Field = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, model: Field) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(scene, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'spritesheet'</span></span>, <span class="hljs-string"><span class="hljs-string">'closed'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._model = model; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._init(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._create(); } private _init(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } private _create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  Bitte beachten Sie, dass wir diese Klasse zum Nachkommen von <code>Phaser.GameObjects.Sprite</code> .  In Phaser-Begriffen ist diese Klasse zu einem Sprite-Fertighaus geworden.  Das heißt, ich habe die Funktionalität des Spielobjekts des Sprites, das wir mit unseren eigenen Methoden weiter ausbauen werden. <br><br>  Schauen wir uns den Konstruktor dieser Klasse an.  Hier müssen wir zunächst den Konstruktor der übergeordneten Klasse mit den folgenden Parametersätzen aufrufen: <br><br><ul><li>  Verknüpfen mit dem Szenenobjekt (wie ich in Abschnitt 3.1 gewarnt habe: Phaser erfordert, dass wir eine Verknüpfung mit der aktuellen Szene herstellen, um Sprites zu rendern.) </li><li>  <code>x</code> und <code>y</code> Koordinaten auf Leinwand </li><li>  der String-Schlüssel, für den der Atlas verfügbar ist, den wir in der <code>preload</code> Methode der <code>preload</code> geladen haben </li><li>  Geben Sie den Schlüssel für die Frame-Zeichenfolge in diesem Atlas ein, den Sie auswählen möchten, um das Sprite anzuzeigen </li></ul><br>  <code>_model</code> in der Eigenschaft private <code>_model</code> einen Verweis auf das Modell ( <code>_model</code> eine Instanz der <code>Field</code> Klasse) <code>_model</code> . <br><br>  Wir haben auch vorsichtig 2 derzeit leere <code>_init</code> und <code>_create</code> , die wir etwas später implementieren werden. <br><br><a name="section-3-4"></a><h3>  <font color="#008080">3.4 Erstellen eines Sprites in einer Ansichtsklasse</font> </h3><br>  So wurde die Ansicht erstellt, aber sie weiß immer noch nicht, wie man ein Sprite zeichnet.  Um das Sprite mit dem von uns benötigten Rahmen auf der <code>_create</code> , müssen Sie unsere eigene private <code>_create</code> Methode <code>_create</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.js //... private _create(): void { this.scene.add.existing(this); //      this.setOrigin(0.5); //  pivot point    } //...</span></span></code> </pre><br><a name="section-3-5"></a><h3>  <font color="#008080">3.5 Sprite-Positionierung</font> </h3><br>  Im Moment werden alle erstellten Sprites in den Koordinaten (0, 0) der Zeichenfläche platziert.  Wir müssen auch jede Zelle an der entsprechenden Position auf dem Brett platzieren.  Das heißt, an die Stelle, die der Zeile und Spalte dieser Zelle entspricht.  Dazu müssen wir einen Code zur Berechnung der Koordinaten jeder Instanz der <code>FieldView</code> Klasse <code>FieldView</code> . <br><br>  Fügen <code>_position</code> der Klasse die Eigenschaft <code>_position</code> , die für die endgültigen Koordinaten der Zelle auf dem Spielfeld verantwortlich ist: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... interface Vec2 {x: number, y: number}; export class FieldView extends Phaser.GameObjects.Sprite { private _position: Vec2 = {x: 0, y: 0}; //...</span></span></code> </pre><br>  Da wir die <code>_offset</code> und dementsprechend die Zellen in ihr relativ zur Mitte des Bildschirms ausrichten möchten, benötigen wir auch die Eigenschaft <code>_offset</code> , die den Versatz dieser bestimmten Zelle relativ zum linken und oberen Rand des Bildschirms angibt.  Füge es mit einem privaten Getter hinzu: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private get _offset(): Vec2 { return { x: (this.scene.cameras.main.width - this._model.board.cols * this.width) / 2, y: (this.scene.cameras.main.height - this._model.board.rows * this.height) / 2 }; } //...</span></span></code> </pre><br>  So haben wir: <br><br><ol><li>  <code>this._scene.cameras.main.width</code> die gesamte Bildschirmbreite in <code>this._scene.cameras.main.width</code> . </li><li>  Wir erhalten die Gesamtbreite der <code>this._board.cols * this.width</code> indem wir die Anzahl der Zellen mit der Breite einer Zelle <code>this._board.cols * this.width</code> : <code>this._board.cols * this.width</code> . </li><li>  Indem wir die Breite der Tafel von der Breite des Bildschirms entfernen, erhalten wir einen Platz auf dem Bildschirm, der nicht von der Tafel belegt ist. </li><li>  Teilen Sie die resultierende Zahl durch 2 und Sie erhalten den Einrückungswert links und rechts von der Tafel. </li><li>  Indem wir jede Zelle um den Wert dieser Einrückung verschieben, garantieren wir die Ausrichtung der gesamten Platine entlang der <code>x</code> Achse. </li></ol><br>  Wir führen absolut ähnliche Aktionen durch, um eine vertikale Verschiebung zu erhalten. <br><br>  In der <code>_init</code> Methode muss noch der erforderliche Code <code>_init</code> werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts // ... private _init(): void { const offset = this._offset; this.x = this._position.x = offset.x + this.width * this._model.col + this.width / 2; this.y = this._position.y = offset.y + this.height * this._model.row + this.height / 2; } // ...</span></span></code> </pre><br>  Die hier angegebenen Eigenschaften <code>this.x</code> , <code>this.y</code> , <code>this.width</code> und <code>this.height</code> sind die geerbten Eigenschaften der übergeordneten Klasse <code>Phaser.GameObjects.Sprite</code> .  Das Ändern der Eigenschaften von <code>this.x</code> und <code>this.y</code> führt zur korrekten Positionierung des Sprites auf der Leinwand. <br><br><a name="section-3-6"></a><h3>  <font color="#008080">3.6 Erstellen einer Instanz von FieldView</font> </h3><br>  Erstellen Sie eine Ansicht in der <code>Field</code> Klasse: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts // ... private _view: FieldView = null; public get view(): FieldView { return this._view; } private _init(scene: Phaser.Scene, board: Board, row: number, col: number): void { //... this._view = new FieldView(this._scene, this); } // ...</span></span></code> </pre><br><a name="section-3-7"></a><h3>  <font color="#008080">3.7 Anzeigetafelfelder.</font> </h3><br>  Kehren wir zur <code>Board</code> Klasse zurück, die im Wesentlichen eine Sammlung von <code>Field</code> Objekten ist und Zellen erstellt. <br><br>  Wir werden den Board-Erstellungscode in eine separate <code>_create</code> Methode aufnehmen und diese Methode vom Konstruktor aus aufrufen.  Da wir wissen, dass wir in der <code>_create</code> Methode nicht nur Zellen erstellen, sondern auch den Code zum Erstellen von Zellen in einer separaten <code>_createFields</code> Methode <code>_createFields</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts constructor(scene: Phaser.Scene, rows: number, cols: number, bombs: number) { // ... this._create(); } private _create(): void { this._createFields(); } private _createFields(): void { }</span></span></code> </pre><br>  In dieser Methode erstellen wir die gewünschte Anzahl von Zellen in einer verschachtelten Schleife: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts // ... private _createFields(): void { for (let row = 0; row &lt; this._rows; row++) { for (let col = 0; col &lt; this._cols; col++) { this._fields.push(new Field(this._scene, this, row, col)); } } } //...</span></span></code> </pre><br>  Es ist Zeit, die Assembly zum Debuggen zum ersten Mal mit dem Befehl auszuführen <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br>  Stellen Sie sicher, dass in der Mitte des Bildschirms 64 Zellen in 8 Zeilen angezeigt werden. <br><br><a name="section-3-8"></a><h3>  <font color="#008080">3.8 Bomben bauen</font> </h3><br>  Früher habe ich berichtet, dass in der <code>_create</code> Methode der <code>Board</code> Klasse nicht nur Felder erstellt werden.  Was noch  Es werden auch Bomben erzeugt und die erzeugten Zellen auf die Anzahl benachbarter Bomben eingestellt.  Beginnen wir mit den Bomben. <br><br>  Wir müssen N Bomben in zufälligen Zellen auf dem Brett platzieren.  Wir beschreiben den Prozess der Herstellung von Bomben mit einem ungefähren Algorithmus: <br><br><pre> <code class="plaintext hljs">                        </code> </pre><br>  Bei jeder Iteration der Schleife erhalten wir eine zufällige Zelle aus der Eigenschaft <code>this._fields</code> bis wir so viele Bomben erstellt haben, wie im Feld <code>this._bombs</code> sind.  Wenn die empfangene Zelle leer ist, installieren wir eine Bombe und aktualisieren den Zähler der Bomben, die für die Erzeugung erforderlich sind. <br><br>  Um eine Zufallszahl zu generieren, verwenden wir die statische Methode <code>Phaser.Math.Between</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createBombs(): void { let count = this._bombs; //      while (count &gt; 0) { //       let field = this._fields[Phaser.Math.Between(0, this._fields.length - 1)]; //    if (field.empty) { //     field.setBomb(); //     --count; //    } } }</span></span></code> </pre><br>  Vergessen Sie nicht, den Aufruf von <code>this._createBombs();</code> in die Datei <code>Board.ts</code> zu schreiben <code>this._createBombs();</code>  am Ende der <code>_create</code> Methode <br><br>  Wie Sie bereits bemerkt haben, müssen Sie die <code>Field</code> Klasse verfeinern, indem Sie den <code>empty</code> Getter und die <code>setBomb</code> Methode hinzufügen, damit dieser Code ordnungsgemäß <code>setBomb</code> . <br><br>  Fügen <code>_value</code> der Field- <code>_value</code> ein privates <code>_value</code> Feld hinzu, das den Inhalt der Zelle regelt.  Wir akzeptieren die folgenden Vereinbarungen. <br><div class="scrollable-table"><table><tbody><tr><td>  <code>_value</code> === 0 </td><td>  Die Zelle ist leer und enthält keine Minen oder Werte </td></tr><tr><td>  <code>_value</code> === -1 </td><td>  In der Zelle ist eine Mine </td></tr><tr><td>  <code>_value</code> &gt; 0 </td><td>  In der Zelle befindet sich die Anzahl der Minen neben der aktuellen Zelle </td></tr></tbody></table></div><br>  Nach diesen Regeln entwickeln wir Methoden in der <code>Field</code> Klasse, die mit der <code>_value</code> Eigenschaft arbeiten: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts // ... private _value: number = 0; // ... public get value(): number { return this._value; } public set value(value) { this._value = value; } public get empty(): boolean { return this._value === 0; } public get mined(): boolean { return this._value === -1; } public get filled(): boolean { return this._value &gt; 0; } public setBomb(): void { this._value = -1; } // ...</span></span></code> </pre><br><a name="section-3-9"></a><h3>  <font color="#008080">3.9 Werte einstellen</font> </h3><br>  Die Bomben sind angeordnet und jetzt haben wir alle Daten, um die numerischen Werte in allen Zellen festzulegen, die sie benötigen. <br><br>  Lassen Sie mich daran erinnern, dass die Zelle nach den Regeln des Pioniers die Nummer haben muss, die der Anzahl der Bomben entspricht, die sich neben dieser Zelle befinden.  Basierend auf dieser Regel schreiben wir den entsprechenden Pseudocode. <br><br><pre> <code class="plaintext hljs">                  </code> </pre><br>  Erstellen Sie in der <code>Board</code> Klasse eine neue Methode und übersetzen Sie den angegebenen Pseudocode in echten Code: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createValues() { //      this._fields.forEach(field =&gt; { //      if (field.mined) { //     field.getClosestFields().forEach(item =&gt; { //      if (item.value &gt;= 0) { ++item.value; } }); } }); } //...</span></span></code> </pre><br>  Mal sehen, welche der von uns verwendeten Schnittstellen nicht implementiert sind.  Sie müssen die <code>getClosestFields</code> Methode hinzufügen, um die benachbarten Zellen <code>getClosestFields</code> . <br><br>  Wie erkennt man benachbarte Zellen? <br><br>  Betrachten Sie beispielsweise eine beliebige Zelle der Platine, die sich nicht am Rand befindet, dh nicht in der äußersten Reihe und nicht in der äußersten Spalte.  Solche Zellen haben eine maximale Anzahl von Nachbarn: 1 oben, 1 unten, 3 links und 3 rechts (einschließlich der diagonalen Zellen). <br><br>  Daher unterscheiden sich die Indikatoren <code>_row</code> und <code>_col</code> in jeder der benachbarten Zellen nicht um mehr als 1. Dies bedeutet, dass wir die Differenz zwischen den Parametern <code>_row</code> und <code>_col</code> im Voraus mit dem aktuellen Feld angeben können.  Fügen Sie der Klassenbeschreibung eine Konstante am Anfang der Datei hinzu: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts const Positions = [ {row : 0, col : 1}, //  {row : 0, col : -1}, //  {row : 1, col : 0}, //  {row : 1, col : 1}, //   {row : 1, col : -1}, //   {row : -1, col : 0}, //  {row : -1, col : 1}, //   {row : -1, col : -1} //   ]; //...</span></span></code> </pre><br>  Und jetzt können wir die fehlende Methode hinzufügen, in der wir dieses Array durchlaufen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public getClosestFields(): Field[] { let results = []; //      Positions.forEach(position =&gt; { //      let field = this._board.getField(this._row + position.row, this._col + position.col); //       if (field) { //     results.push(field); } }); return results; }; //...</span></span></code> </pre><br>  Vergessen Sie nicht, die Feldvariable bei jeder Iteration zu überprüfen, da nicht alle Zellen auf der Karte 8 Nachbarn haben.  Beispielsweise hat die obere linke Zelle keine Nachbarn links von ihr und so weiter. <br><br>  Es bleibt die Methode <code>getField</code> zu implementieren und der Methode <code>_create</code> in der Klasse <code>Board</code> alle erforderlichen Aufrufe hinzuzufügen <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public getField(row: number, col: number): Field { return this._fields.find(field =&gt; field.row === row &amp;&amp; field.col === col); } //... private _create(): void { this._createFields(); this._createBombs(); this._createValues(); } //...</span></span></code> </pre><br><a name="section-4"></a><h2> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Behandlung von Eingabeereignissen</font></font></font> </h2><br><a name="section-4-1"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1 Verfolgen von Mausklickereignissen</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Moment ist das Board vollständig initialisiert, es enthält Bomben und es gibt Zellen mit Zahlen, aber alle sind derzeit geschlossen und es gibt keine Möglichkeit, sie zu öffnen. </font><font style="vertical-align: inherit;">Wir werden dies korrigieren und das Öffnen von Zellen durch Klicken mit der linken Maustaste implementieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst müssen wir genau diesen Klick verfolgen. </font><font style="vertical-align: inherit;">Fügen Sie in der Klasse </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">folgenden Code </font><font style="vertical-align: inherit;">ganz am Ende der Methode hinzu </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FielView.ts //... private _create(): void { // ... this.setInteractive(); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Phaser können Sie Objekte aus dem Namespace für verschiedene Ereignisse abonnieren </font></font><code>Phaser.GameObjects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Insbesondere abonnieren wir das click-Ereignis ( </font></font><code>pointerdown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) als Prefab des Sprites selbst, dh als Objekt einer Klasse, von der es </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geerbt wurde </font></font><code>Phaser.GameObjects.Sprite</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuvor müssen wir jedoch explizit darauf hinweisen, dass das Sprite möglicherweise interaktiv ist, dh, Sie müssen im Allgemeinen die Benutzereingaben abhören. Sie müssen dies tun, indem Sie die Methode </font></font><code>setInteractive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ohne Parameter für das Sprite selbst </font><font style="vertical-align: inherit;">aufrufen </font><font style="vertical-align: inherit;">, wie wir es im obigen Beispiel getan haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem das Sprite interaktiv geworden ist, kehren wir zu der Klasse zurück, </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der neue Modellobjekte erstellt wurden </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nämlich die Methode, </font></font><code>_createFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und registrieren den Rückruf für die Eingabeereignisse für die Ansicht:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createFields(): void { for (let row = 0; row &lt; this._rows; row++) { for (let col = 0; col &lt; this._cols; col++) { const field = new Field(this._scene, this, row, col) field.view.on('pointerdown', this._onFieldClick.bind(this, field)); this._fields.push(field); } } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobald wir festgestellt haben, dass wir die Methode ausführen möchten, indem wir auf das Sprite klicken </font></font><code>_onFieldClick</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, müssen wir sie implementieren. Wir werden jedoch die Logik der Verarbeitung des Klicks aus der Klasse entfernen </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es wird angenommen, dass es besser ist, das Modell in Abhängigkeit von der Eingabe zu verarbeiten und seine Daten entsprechend in einem separaten Controller zu ändern, dessen Ähnlichkeit die Klasse der Spielszene ist </font></font><code>GameScene</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Daher müssen wir das Klickereignis weiterleiten, von der Klasse </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bis zur Szene. Also machen wir:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _onFieldClick(field: Field, pointer: Phaser.Input.Pointer): void { if (pointer.leftButtonDown()) { this.emit(`left-click`, field); } else if (pointer.rightButtonDown()) { this.emit(`right-click`, field); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier werfen wir nicht nur das Klickereignis so wie es war, sondern spezifizieren auch, welches Klickereignis es war. </font><font style="vertical-align: inherit;">Dies wird in Zukunft nützlich sein, wenn wir in der Szenenklasse jede Option anders verarbeiten. </font><font style="vertical-align: inherit;">Natürlich wäre es möglich, das Klick-Ereignis so zu senden, wie es ist, aber wir werden den Szenencode vereinfachen und einen Teil der Logik bezüglich des Ereignisses selbst in der Klasse belassen </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kehren wir nun zur Klasse der Spielszene zurück </font></font><code>GameScene</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und fügen am Ende der Methode einen </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code hinzu, </font><font style="vertical-align: inherit;">der </font><font style="vertical-align: inherit;">Ereignisse eines Klickens auf Zellen aufzeichnet:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... import { Field } from "../models/Field"; //... public create(): void { this._board = new Board(this, Rows, Cols, Bombs); this._board.on('left-click', this._onFieldClickLeft, this); this._board.on('right-click', this._onFieldClickRight, this); } private _onFieldClickLeft(field: Field): void { } private _onFieldClickRight(field: Field): void { } //...</span></span></code> </pre><br><a name="section-4-2"></a><h3>  <font color="#008080">4.2.</font> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linksklickverarbeitung</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir implementieren nun die Verarbeitung von Mausklickereignissen. </font><font style="vertical-align: inherit;">Und beginnen Sie mit dem Öffnen der Zellen. </font><font style="vertical-align: inherit;">Zellen sollten durch Drücken der linken Taste geöffnet werden. </font><font style="vertical-align: inherit;">Bevor wir mit dem Programmieren beginnen, wollen wir die Bedingungen formulieren, die erfüllt sein müssen:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie auf eine geschlossene Zelle klicken, sollte diese geöffnet werden </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn sich eine Mine in einer offenen Zelle befindet, ist das Spiel verloren </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Befinden sich in der offenen Zelle keine Minen oder Werte, befindet sich min nicht in den benachbarten Zellen. In diesem Fall müssen Sie alle benachbarten Zellen öffnen und fortfahren, bis der Wert in der offenen Zelle angezeigt wird </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie auf eine offene Zelle klicken, sollten Sie überprüfen, ob alle Flaggen richtig gesetzt sind. Wenn ja, beenden Sie das Spiel mit einem Sieg </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und jetzt, um das Verständnis der erforderlichen Funktionalität zu vereinfachen, übersetzen wir die obige Logik in Pseudocode: </font></font><br><br><pre> <code class="plaintext hljs">                         </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt verstehen wir, was programmiert werden muss. </font><font style="vertical-align: inherit;">Wir implementieren die Methode </font></font><code>_onFieldClickLeft</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... private _onFieldClickLeft(field: Field): void { if (field.closed) { //    field.open(); //   if (field.mined) { //    field.exploded = true; this._onGameOver(false); //   } else if (field.empty) { //    this._board.openClosestFields(field); //   } } else if (field.opened) { //    if (this._board.completed) { //       this._onGameOver(true); //   } } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und dann werden wir wie immer die Klassen fertigstellen </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Methoden implementieren, die wir im Handler aufrufen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir geben 3 mögliche Zustände der Zelle in der Aufzählung an </font></font><code>States</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, fügen ein Feld hinzu </font></font><code>_state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und implementieren einen Getter für jeden möglichen Zustand:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts enum States { Closed = 'closed', Opened = 'opened', Marked = 'flag' }; export class Field extends Phaser.Events.EventEmitter { private _state: string = States.Closed; //... public get marked(): boolean { return this._state === States.Marked; } public get closed(): boolean { return this._state === States.Closed; } public get opened(): boolean { return this._state === States.Opened; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir nun Zustände haben, die angeben, ob die Zelle geschlossen ist oder nicht, können wir eine Methode hinzufügen </font></font><code>open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die den Zustand ändert:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public open(): void { this._setState(States.Opened); } private _setState(state: string): void { if (this._state !== state) { this._state = state; this.emit('change'); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Änderung des Modellstatus sollte ein Ereignis auslösen, das dies meldet. </font><font style="vertical-align: inherit;">Daher führen wir eine zusätzliche private Methode ein, </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der die gesamte Logik des Zustandswechsels implementiert wird. </font><font style="vertical-align: inherit;">Diese Methode wird in allen öffentlichen Methoden des Modells aufgerufen, die ihren Status ändern sollen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie ein Boolesches Flag hinzu </font></font><code>_exploded</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um genau das Feldobjekt anzugeben, das in die Luft gesprengt wurde:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts private _exploded: boolean = false; //... public set exploded(exploded: boolean) { this._exploded = exploded; this.emit('change'); } public get exploded(): boolean { return this._exploded; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Öffnen Sie nun die Klasse </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und implementieren Sie die Methode darin </font></font><code>openClosestFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Methode ist rekursiv und hat die Aufgabe, alle leeren Nachbarfelder in Bezug auf die im Parameter akzeptierte Zelle zu öffnen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Algorithmus sieht wie folgt aus:</font></font><br><br><pre> <code class="plaintext hljs"> :                </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und dieses Mal haben wir bereits alle notwendigen Schnittstellen für die vollständige Implementierung dieser Methode: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public openClosestFields(field: Field): void { field.getClosestFields().forEach(item =&gt; {//     if (item.closed) {//    item.open();//   if (item.empty) {//    this.openClosestFields(item);//     } } }); } //...</span></span></code> </pre><br>   <code>completed</code>   <code>Board</code>       .        ?           . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public get completed(): boolean { return this._fields.filter(field =&gt; field.completed).length === this._bombs; } //...</span></span></code> </pre><br>     <code>_fields</code>   <code>completed</code> ,      .     (      ,     <code>completed</code>    <code>Field</code> )    <code>_bombs</code> (     ),   <code>true</code> ,  ,   . <br>          ,       .       <code>Board</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public open(): void { this._fields.forEach(field =&gt; field.open()); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Klasse selbst muss </font><font style="vertical-align: inherit;">noch ein Getter hinzugefügt werden </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In welchem ​​Fall wird das Feld als erfolgreich gelöscht betrachtet? </font><font style="vertical-align: inherit;">Wenn es abgebaut und markiert ist. </font><font style="vertical-align: inherit;">Beide notwendigen Getter sind bereits vorhanden und wir können diese Methode hinzufügen:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public get completed(): boolean { return this.marked &amp;&amp; this.mined; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Verarbeitung des linken Mausklicks abzuschließen, erstellen wir eine Methode, </font></font><code>_onGameOver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit der wir die Verfolgung von Board-Ereignissen deaktivieren und dem Spieler das gesamte Board anzeigen. </font><font style="vertical-align: inherit;">Später werden wir auch einen Rendering-Code des Statusabschlussberichts basierend auf dem Parameter hinzufügen </font></font><code>status</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... private _onGameOver(status: boolean) { this._board.off('left-click', this._onFieldClickLeft, this); this._board.off('right-click', this._onFieldClickRight, this); this._board.open(); } //...</span></span></code> </pre><br><a name="section-4-3"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3 Feldanzeige</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor Sie mit der Verarbeitung des Rechtsklicks beginnen, erfahren Sie, wie Sie die neu geöffneten Zellen neu zeichnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu Beginn der Klasse haben </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir eine Methode entwickelt </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die ein Ereignis auslöst, </font></font><code>change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn sich der Status des Modells ändert. Wir werden dies verwenden und in der Klasse werden wir </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses Ereignis verfolgen:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _init(): void { //... this._model.on('change', this._onStateChange, this); } private _onStateChange(): void { this._render(); } private _render(): void { this.setFrame(this._frameName); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben die intermediäre Methode speziell zu einem </font></font><code>_onStateChange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rückruf des Modelländerungsereignisses gemacht. </font><font style="vertical-align: inherit;">In Zukunft müssen wir überprüfen, wie das Modell geändert wurde, um zu verstehen, ob es durchgeführt werden muss </font></font><code>_render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das aktuelle Sprite einer Zelle in einem neuen Status anzuzeigen, müssen Sie den Frame ändern. </font><font style="vertical-align: inherit;">Da wir den Atlas als Assets geladen haben, können wir die Methode aufrufen </font></font><code>setFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um den aktuellen Frame in einen neuen zu ändern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Frame in eine Zeile zu bringen, haben wir geschickt den Getter verwendet </font></font><code>_frameName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der nun implementiert werden muss. </font><font style="vertical-align: inherit;">Zunächst beschreiben wir alle möglichen Werte, die ein Zellenrahmen annehmen kann.</font></font><br><div class="scrollable-table"><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rahmen </font></font></td><td>  Zustand </td></tr><tr><td> <code>closed</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Feld ist geschlossen </font></font><br></td></tr><tr><td> <code>flag</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Markiertes Feld </font></font><br></td></tr><tr><td> <code>empty</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Feld ist offen, nicht vermint oder mit Wert gefüllt </font></font><br></td></tr><tr><td> <code>exploded</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Feld ist offen, vermint und gesprengt </font></font><br></td></tr><tr><td> <code>mined</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Feld ist offen, vermint, aber nicht gesprengt </font></font><br></td></tr><tr><td> <code>1...9</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Feld ist geöffnet und zeigt einen Wert von 1 bis 9 an, der die Anzahl der Bomben neben diesem Feld angibt </font></font><br></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben eine Beschreibung aller Zustände erhalten und haben bereits alle Methoden des Modells, mit denen diese Zustände erhalten werden können. </font><font style="vertical-align: inherit;">Lassen Sie uns am Anfang der Datei eine kleine Konfiguration erstellen:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts const States = { 'closed': field =&gt; field.closed, 'flag': field =&gt; field.marked, 'empty': field =&gt; field.opened &amp;&amp; !field.mined &amp;&amp; !field.filled, 'exploded': field =&gt; field.opened &amp;&amp; field.mined &amp;&amp; field.exploded, 'mined': field =&gt; field.opened &amp;&amp; field.mined &amp;&amp; !field.exploded } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Schlüssel in diesem Objekt sind die Werte der Frames, und die Werte dieser Schlüssel sind die Rückrufe, die ein Boolesches Ergebnis zurückgeben. </font><font style="vertical-align: inherit;">Basierend auf dieser Konfiguration können wir eine Methode entwickeln, um den gewünschten Frame (dh den Schlüssel aus der Konfiguration) zu erhalten:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private get _frameName(): string { for (let key in States) { if (States[key](this._model)) { return key; } } return this._model.value.toString(); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch einfache Aufzählung in einer Schleife durchlaufen wir also alle Schlüssel des config-Objekts und rufen nacheinander jeden Rückruf auf. </font><font style="vertical-align: inherit;">Die Funktion, die uns zuerst zurückgibt, </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt an, dass der Schlüssel </font></font><code>key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bei der aktuellen Iteration der richtige Frame für den aktuellen Status des Modells ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn kein Schlüssel geeignet ist, betrachten wir als Standardstatus ein offenes Feld mit einem Wert </font></font><code>_value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da </font></font><code>States</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">diesen Status in der Konfiguration </font><font style="vertical-align: inherit;">nicht festgelegt haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir den Linksklick auf die Kartenfelder vollständig testen und überprüfen, wie sich die Zellen öffnen und was nach dem Öffnen angezeigt wird.</font></font><br><br><a name="section-4-4"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4 Rechtsklickverarbeitung</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie beim Erstellen des Linksklick-Handlers definieren wir zunächst die erwartete Funktionalität eindeutig. </font><font style="vertical-align: inherit;">Mit einem Rechtsklick markieren wir die ausgewählte Zelle mit einem Flag. </font><font style="vertical-align: inherit;">Aber es gibt bestimmte Bedingungen.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nur ein geschlossenes Feld, das derzeit nicht markiert ist, kann markiert werden </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn das Feld markiert ist, sollte ein erneuter Rechtsklick die Markierung aus dem Feld entfernen </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beim Setzen / Entfernen eines Flags muss die Anzahl der verfügbaren Flags auf der Ebene aktualisiert und der Text mit der aktuellen Nummer angezeigt werden </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir diese Bedingungen in Pseudocode übersetzen, erhalten wir die folgenden Kommentarzeilen: </font></font><br><br><pre> <code class="plaintext hljs">                              </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt können wir diesen Algorithmus in Aufrufe der benötigten Methoden übersetzen, auch wenn diese noch nicht entwickelt wurden: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts private _flags: number = 0; //... private _onFieldClickRight(field: Field): void { if (field.closed &amp;&amp; this._flags &gt; 0) { //        field.addFlag(); //     } else if (field.marked) { //     field.removeFlag(); //   } this._flags = Bombs - this._board.countMarked; } //... public create(): void { this._flags = Bombs; //... } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier haben wir auch ein neues Feld gestartet </font></font><code>_flags</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das zu Beginn des Spiels der Anzahl der Bomben auf dem Brett entspricht, da zu Beginn des Spiels keine einzige Flagge gesetzt wurde. </font><font style="vertical-align: inherit;">Dieses Feld muss mit jedem Rechtsklick aktualisiert werden, da in diesem Fall die Flagge entweder hinzugefügt oder von der Tafel entfernt wird. </font><font style="vertical-align: inherit;">Fügen Sie der Klasse einen </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getter hinzu </font></font><code>countMarked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public get countMarked(): number { return this._fields.filter(field =&gt; field.marked).length; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Setzen und Entfernen des Flags ändert den Status des Modells </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Daher implementieren wir diese Methoden in der entsprechenden Klasse ähnlich der Methode </font></font><code>open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public addFlag(): void { this._setState(States.Marked); } public removeFlag(): void { this._setState(States.Closed); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich möchte Sie daran erinnern, dass dadurch </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Ereignis ausgelöst </font></font><code>change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird, das in der Ansicht nachverfolgt wird. Daher wird das Sprite dieses Mal automatisch neu gezeichnet, wenn sich das Modell ändert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Testen der entwickelten Funktionalität werden Sie mit Sicherheit feststellen, dass jedes Mal, wenn Sie mit der rechten Maustaste klicken, ein Kontextmenü geöffnet wird. </font><font style="vertical-align: inherit;">Fügen Sie dem Konstruktor der Spielszene den Code hinzu, der dieses Verhalten deaktiviert:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... constructor() { super('Game'); //        document.querySelector("canvas").oncontextmenu = e =&gt; e.preventDefault(); } //...</span></span></code> </pre><br><a name="section-4-5"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5 GameSceneView-Objekt</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Benutzeroberfläche in der Spielszene anzuzeigen, erstellen wir eine Klasse </font></font><code>GameSceneView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und platzieren sie in </font></font><code>src/scripts/views/GameSceneView.ts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verhalten </font><font style="vertical-align: inherit;">wir uns anders als die Schöpfung </font><font style="vertical-align: inherit;">und machen diese Klasse nicht zum Fertighaus und Erben </font></font><code>GameObjects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall müssen die folgenden Elemente aus der Szenenansicht ausgegeben werden:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Text in der Anzahl der Flags </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exit-Taste </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spielabschluss-Statusmeldung (Gewinn / Verlust) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Machen wir aus jedem UI-Element ein separates Feld in der Klasse </font></font><code>GameSceneView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden einen Stummel vorbereiten.</font></font><br><br><pre> <code class="javascript hljs">enum Styles { Color = <span class="hljs-string"><span class="hljs-string">'#008080'</span></span>, Font = <span class="hljs-string"><span class="hljs-string">'Arial'</span></span> } enum Texts { Flags = <span class="hljs-string"><span class="hljs-string">'FLAGS: '</span></span>, Exit = <span class="hljs-string"><span class="hljs-string">'EXIT'</span></span>, Success = <span class="hljs-string"><span class="hljs-string">'YOU WIN!'</span></span>, Failure = <span class="hljs-string"><span class="hljs-string">'YOU LOOSE'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameSceneView</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _style: {<span class="hljs-attr"><span class="hljs-attr">font</span></span>: string, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: string}; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._style = {<span class="hljs-attr"><span class="hljs-attr">font</span></span>: <span class="hljs-string"><span class="hljs-string">`28px </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${Styles.Font}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: Styles.Color}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._create(); } private _create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } public render() { } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fügen Sie Text mit der Anzahl der Flags hinzu. </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _txtFlags: Phaser.GameObjects.Text = null; //... private _createTxtFlags(): void { this._txtFlags = this._scene.add.text( 50, 50, Texts.Flags, this._style ).setOrigin(0, 1); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit diesem Code wird der benötigte Text von oben und links um 50 Pixel eingerückt und auf den angegebenen Stil eingestellt. </font><font style="vertical-align: inherit;">Zusätzlich setzt die Methode </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Drehpunkt des Textes auf die Koordinaten (0, 1). </font><font style="vertical-align: inherit;">Dies bedeutet, dass der Text am linken Rand ausgerichtet wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie eine Statusmeldung hinzu.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _txtStatus: Phaser.GameObjects.Text = null; //... private _createTxtStatus(): void { this._txtStatus = this._scene.add.text( this._scene.cameras.main.centerX, 50, Texts.Success, this._style ).setOrigin(0.5, 1); this._txtStatus.visible = false; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir platzieren den Statustext in der Mitte des Bildschirms und richten ihn an der Mitte der Linie aus, indem wir </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit Parameter 0.5 für die x-Koordinate </font><font style="vertical-align: inherit;">aufrufen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Außerdem muss dieser Text standardmäßig ausgeblendet sein, da er erst nach Abschluss des Spiels angezeigt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie eine Exit-Schaltfläche, die im Wesentlichen auch ein Textobjekt ist.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _btnExit: Phaser.GameObjects.Text = null; //... private _createBtnExit(): void { this._btnExit = this._scene.add.text( this._scene.cameras.main.width - 50, 50, Texts.Exit, this._style ).setOrigin(1); this._btnExit.setInteractive(); this._btnExit.once('pointerdown', () =&gt; { this._scene.scene.start('Start'); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir platzieren die Schaltfläche in der oberen rechten Ecke des Bildschirms und verwenden sie erneut </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um den Text dieses Mal an der rechten Kante auszurichten. </font><font style="vertical-align: inherit;">Wir machen die Schaltfläche interaktiv und fügen dem Klickereignis einen Rückruf hinzu, der den Spieler zur Startszene schickt. </font><font style="vertical-align: inherit;">Somit geben wir dem Spieler die Möglichkeit, das Level jederzeit zu verlassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es bleibt noch eine Methode zu entwickeln, mit der </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alle Elemente der Benutzeroberfläche korrekt aktualisiert und alle in erstellten Methoden aufgerufen werden können </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _create(): void { this._createTxtFlags(); this._createTxtStatus(); this._createBtnExit(); } public render(data: {flags?: number, status?: boolean}) { if (typeof data.flags !== 'undefined') { this._txtFlags.text = Texts.Flags + data.flags.toString(); } if (typeof data.status !== 'undefined') { this._txtStatus.text = data.status ? Texts.Success : Texts.Failure; this._txtStatus.visible = true; } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abhängig von der im Parameter übergebenen Eigenschaft aktualisieren wir die Benutzeroberfläche und zeigen die erforderlichen Änderungen an. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie in der GameScene-Klasse eine Darstellung in der Spielszene und schreiben Sie den Aufruf an die Methode _render, wo immer dies aus Gründen der Bedeutung erforderlich ist:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... import { GameSceneView } from "../views/GameSceneView"; //... export class GameScene extends Phaser.Scene { private _view: GameSceneView = null; //... private _onGameOver(status: boolean) { //... this._view.render({status}); } //... private _onFieldClickRight(field: Field): void { //... this._flags = Bombs - this._board.countMarked; this._view.render({flags: this._flags}); } //... public create(): void { //... this._view = new GameSceneView(this); this._view.render({flags: this._flags}); } //... }</span></span></code> </pre><br><a name="section-5"></a><h2> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Animationen</font></font></font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was für ein Fan von einem Spiel, auch wenn es so einfach ist wie das unsere, wenn es keine Animationen enthält ?! </font><font style="vertical-align: inherit;">Darüber hinaus sollten wir uns, seit wir anfingen, Phaser zu studieren, mit den grundlegendsten Funktionen von Animationen vertraut machen und die Funktionalität von Zwillingen betrachten. </font><font style="vertical-align: inherit;">Zwillinge werden im Framework selbst implementiert und es sind keine Bibliotheken von Drittanbietern erforderlich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie dem Spiel 2 Animationen hinzu: Füllen Sie das Spielfeld am Anfang mit Zellen und drehen Sie die Zelle an der Öffnung um. </font><font style="vertical-align: inherit;">Beginnen wir mit dem ersten.</font></font><br><br><a name="section-5-1"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1 Animation zum Füllen von Brettern</font></font></font> </h3><br><img src="https://habrastorage.org/webt/7r/uu/1v/7ruu1vtppaw26sp-fapxbahgm9q.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir stellen sicher, dass alle Zellen des Boards vom oberen linken Bildschirmrand an ihren Platz fliegen. </font><font style="vertical-align: inherit;">Wenn Sie das Spiellevel starten, müssen Sie alle Zellen in die obere linke Ecke des Bildschirms verschieben und für jede Zelle die Animation der Bewegung auf die entsprechenden Koordinaten starten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie in der Klasse </font></font><code>FiledView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufruf </font><font style="vertical-align: inherit;">am Ende der Methoden hinzu </font></font><code>_animateShow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _create(): void { //... this._animateShow(); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B Wir implementieren die neue Methode, die wir brauchen. </font><font style="vertical-align: inherit;">Darin müssen, wie oben vereinbart, zwei Dinge ausgeführt werden:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschieben Sie die Zelle hinter die linke obere Ecke, sodass sie auf dem Bildschirm nicht sichtbar ist </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Starten Sie die Doppelbewegung zu den gewünschten Koordinaten mit der richtigen Verzögerung </font></font></li></ol><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _animateShow(): Promise&lt;void&gt; { this.x = -this.width; this.y = -this.height; const delay = this._model.row * 50 + this._model.col * 10; return this._moveTo(this._position, delay); } //...</span></span></code> </pre><br>         (0, 0),      ,       ,           .       . <br><br>       <code>_moveTo</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _moveTo(position: Vec2, delay: number): Promise&lt;void&gt; { return new Promise(resolve =&gt; { this.scene.tweens.add({ targets: this, x: position.x, y: position.y, duration: 600, ease: 'Elastic', easeParams: [1, 1], delay, onComplete: () =&gt; { resolve(); } }); }); } //...</span></span></code> </pre><br>        <code>tweens</code> .    <code>add</code>      : <br><br><ul><li>  <code>targets</code>         ,      .      <code>this</code>   ,      . </li><li>         . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Eigenschaft </font></font><code>duration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist verantwortlich für die Dauer der Animation, in unserem Fall - 600ms.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter </font></font><code>ease</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>easeParams</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stellen Sie die Beschleunigungsfunktion ein.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Feld Verzögerung ersetzen wir den Wert aus dem zweiten Argument, das für jede einzelne Zelle unter Berücksichtigung ihrer Position auf der Platine generiert wird. </font><font style="vertical-align: inherit;">Dies geschieht, damit die Zellen nicht gleichzeitig herausfliegen. </font><font style="vertical-align: inherit;">Stattdessen wird jede Zelle mit einer geringen Verzögerung gegenüber der vorherigen Zelle angezeigt.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schließlich </font></font><code>onComplete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fügen wir einen Rückruf </font><font style="vertical-align: inherit;">in die Eigenschaft ein </font><font style="vertical-align: inherit;">, der am Ende der Tween-Aktion aufgerufen wird.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist vernünftig, den Zwilling in ein Versprechen zu hüllen, damit er in Zukunft verschiedene Animationen auf wunderbare Weise andocken kann. Daher platzieren wir einen Funktionsaufruf im Rückruf </font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der die erfolgreiche Ausführung der Animation anzeigt.</font></font><br><br><a name="section-5-2"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2 Animationen der Zellumdrehung</font></font></font> </h3><br><img src="https://habrastorage.org/webt/uc/d-/yw/ucd-yw-nq6a4veixb-npp0mdyqy.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist großartig, wenn beim Öffnen der Zelle der Effekt ihrer Umkehrung reproduziert wurde. Wie können wir das erreichen? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Öffnen einer Zelle erfolgt derzeit durch Ändern des Frames, wenn die Methode </font></font><code>_render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Ansicht </font><font style="vertical-align: inherit;">aufgerufen wird </font><font style="vertical-align: inherit;">. Wenn wir bei dieser Methode den Status des Modells überprüfen, sehen wir, ob die Zelle geöffnet war. Wenn die Zelle geöffnet war, starten Sie die Animation, anstatt sofort einen neuen Umkehrrahmen anzuzeigen.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _onStateChange(): void { if (this._model.opened) { this._animateFlip(); } else { this._render(); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den gewünschten Effekt zu erzielen, verwenden wir die Transformation des Sprites durch die Eigenschaft </font></font><code>scale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn wir das Sprite entlang der Achse </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit der </font><font style="vertical-align: inherit;">Zeit </font><font style="vertical-align: inherit;">auf Null </font><font style="vertical-align: inherit;">skalieren </font><font style="vertical-align: inherit;">, schrumpft es schließlich und verbindet die linke und rechte Seite. </font><font style="vertical-align: inherit;">Und umgekehrt, wenn Sie das Sprite entlang der Achse </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von Null auf seine volle Breite </font><font style="vertical-align: inherit;">skalieren </font><font style="vertical-align: inherit;">, dehnen wir es auf seine volle Größe. </font><font style="vertical-align: inherit;">Wir implementieren diese Logik in die Methode </font></font><code>_animateFlip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _animateFlip(): void { this._scaleXTo(0).then(() =&gt; { this._render(); this._scaleXTo(1); }) } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Analogie zur Methode </font></font><code>_moveTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementieren </font><font style="vertical-align: inherit;">wir </font></font><code>_scaleTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _scaleXTo(scaleX: number): Promise&lt;void&gt; { return new Promise(resolve =&gt; { this.scene.tweens.add({ targets: this, scaleX, ease: 'Elastic.easeInOut', easeParams: [1, 1], duration: 150, onComplete: () =&gt; { resolve() } }); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei dieser Methode nehmen wir als Parameter den Wert der Skala, mit dem wir die Größe des Sprites in beide Richtungen ändern und übergeben ihn als zweiten Parameter an das Animationskonfigurationsobjekt. </font><font style="vertical-align: inherit;">Alle anderen Konfigurationsparameter sind uns bereits aus der vorherigen Animation bekannt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt werden wir das Projekt zum Testen starten und nach dem Debuggen sehen wir unser Spiel als abgeschlossen an und die Testaufgabe ist abgeschlossen!</font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich danke allen von Herzen, dass sie diesen Moment mit mir erreicht haben! </font></font><br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kolleginnen und Kollegen, ich freue mich sehr, wenn Ihnen das im Artikel vorgestellte Material von Nutzen ist und Sie diese oder jene beschriebenen Ansätze in Ihren eigenen Projekten anwenden können. Sie können sich jederzeit an mich wenden, wenn Sie Fragen zu diesem Artikel, zur Phaser-Programmierung oder zur Arbeit in Gamedev im Allgemeinen haben. Ich begrüße die Kommunikation und freue mich auf neue Bekanntschaften und Erfahrungsaustausch! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und ich habe gerade eine Frage an Sie. Da ich Video-Tutorials zur Spieleentwicklung erstelle, habe ich natürlich ein Dutzend dieser kleinen Spiele angesammelt. Jedes Spiel öffnet das Framework auf seine Weise. Zum Beispiel haben wir in diesem Spiel das Thema Zwillinge angesprochen, aber es gibt viele andere Funktionen, wie Physik, Tilemap, Wirbelsäule usw.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Zusammenhang stellt sich die Frage, ob Ihnen dieser Artikel gefallen hat und ob Sie daran interessiert sind, weiterhin Artikel wie diesen zu lesen, aber über andere kleine klassische Spiele? </font><font style="vertical-align: inherit;">Wenn die Antwort ja ist, übersetze ich die Materialien meiner Video-Tutorials gerne in Textform und veröffentliche im Laufe der Zeit weiterhin neue Handbücher, aber für andere Spiele. </font><font style="vertical-align: inherit;">Ich bringe die entsprechende Umfrage mit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielen Dank für Ihre Aufmerksamkeit! </font><font style="vertical-align: inherit;">Ich freue mich auf Feedback und bis bald!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476682/">https://habr.com/ru/post/de476682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476670/index.html">CAD-Übersicht auf dem geometrischen Kern C3D-2</a></li>
<li><a href="../de476674/index.html">ReportPortal-Schnellbereitstellung zum Einarbeiten</a></li>
<li><a href="../de476676/index.html">48 Open-Source-Ressourcen für JavaScript (2019)</a></li>
<li><a href="../de476678/index.html">API für asynchrones Remote-Abrufen mit Apple Combine</a></li>
<li><a href="../de476680/index.html">Rodovs kontinuierliches Produktionsplanungssystem ist das sowjetische 1961 Lean / MRP. Start, Sonnenuntergang und Neugeburt</a></li>
<li><a href="../de476686/index.html">Entwicklung eines IoT-Gateways auf Basis von Raspberry CM3 +</a></li>
<li><a href="../de476688/index.html">Neuer Kurs von OTUS. “IOS-Entwickler. Aufbaukurs V 2.0 »</a></li>
<li><a href="../de476692/index.html">Content-Marketing-Grundsätze</a></li>
<li><a href="../de476694/index.html">Über die Geschäftsrobotisierung mit Farida Roslovets und Direktor der RPA-Firma electroNeek</a></li>
<li><a href="../de476696/index.html">Erstellen und Bereitstellen einer Full-Stack-React-Anwendung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>