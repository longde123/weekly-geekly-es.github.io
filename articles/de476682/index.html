<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöí üë®üèæ‚Äçüî¨ üí® So schreiben Sie einen Pionier in Phaser und f√ºhren eine HTML5-Entwicklertestaufgabe aus üé∂ üö∂ üçú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag, liebe Kollegen! 

 Mein Name ist Alexander, ich bin Entwickler von HTML5-Spielen. 

 In einem der Unternehmen, an das ich meinen Lebenslauf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So schreiben Sie einen Pionier in Phaser und f√ºhren eine HTML5-Entwicklertestaufgabe aus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476682/"> Guten Tag, liebe Kollegen! <br><br>  Mein Name ist Alexander, ich bin Entwickler von HTML5-Spielen. <br><br>  In einem der Unternehmen, an das ich meinen Lebenslauf gesendet habe, wurde ich gebeten, eine Testaufgabe abzuschlie√üen.  Ich habe zugestimmt und nach 1 Tag als Ergebnis das Spiel gesendet, das gem√§√ü TOR HTML5 entwickelt wurde. <br><br><img src="https://habrastorage.org/webt/4t/ng/dn/4tngdnvlxq3izqrpk2nykww2dvs.png"><br><br>  Da ich eine Ausbildung in Spielprogrammierung absolviere und meinen Code effizienter nutzen m√∂chte, habe ich mich dazu entschlossen, einen Schulungsartikel √ºber das abgeschlossene Projekt zu verfassen.  Und da der abgeschlossene Test eine positive Bewertung erhielt und zu einer Einladung zu einem Vorstellungsgespr√§ch f√ºhrte, hat meine Entscheidung wahrscheinlich das Recht zu existieren und wird m√∂glicherweise in Zukunft jemandem helfen. <br><br>  Dieser Artikel gibt einen √úberblick √ºber den Arbeitsaufwand, der ausreicht, um die durchschnittliche Testaufgabe f√ºr die HTML5-Position des Entwicklers erfolgreich abzuschlie√üen.  Das Material kann auch f√ºr jeden von Interesse sein, der sich mit dem Phaser-Framework vertraut machen m√∂chte.  Wenn Sie bereits mit Phaser arbeiten und in JS schreiben, erfahren Sie, wie Sie ein Projekt in TypeScript entwickeln. <br><br>  Unter cat gibt es also viel TypeScript-Code! <br><a name="habracut"></a><br><h2>  Einleitung </h2><br>  Wir geben eine kurze Erkl√§rung des Problems. <br><br><ol><li>  Wir werden ein einfaches HTML5-Spiel entwickeln - einen klassischen Pionier. </li><li>  Als Haupttools werden wir Phaser 3, Typoscript und Webpack verwenden. </li><li>  Das Spiel wird f√ºr den Desktop entworfen und im Browser ausgef√ºhrt. </li></ol><br>  Wir bieten Links zum endg√ºltigen Projekt. <br><br><div class="spoiler">  <b class="spoiler_title">Links zur Demo und Quelle</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spielbare Demo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub-Quellcode</a> <br></div></div><br>  Und erinnere dich an die Mechanik des Pioniers, wenn pl√∂tzlich jemand die Spielregeln vergessen hat.  Da dies jedoch unwahrscheinlich ist, werden die Regeln unter den Spoiler gestellt :) <br><br><div class="spoiler">  <b class="spoiler_title">Sapper-Regeln</b> <div class="spoiler_text">  Das Spielfeld besteht aus Zellen, die in einer Tabelle angeordnet sind.  Standardm√§√üig sind beim Start des Spiels alle Zellen geschlossen.  In einigen Zellen sind Bomben platziert. <br><br>  Wenn Sie mit der linken Maustaste auf eine geschlossene Zelle klicken, wird diese ge√∂ffnet.  Wenn sich eine Bombe in einer offenen Zelle befand, endet das Spiel mit einer Niederlage. <br><br>  Wenn sich keine Bombe in der Zelle befand, wird eine Zahl darin angezeigt, die die Anzahl der Bomben angibt, die sich in benachbarten Zellen befinden, bezogen auf die derzeit ge√∂ffnete Bombe.  Wenn keine Bomben in der N√§he sind, sieht die Zelle leer aus. <br><br>  Ein Rechtsklick auf eine geschlossene Zelle setzt ein Flag darauf.  Der Spieler hat die Aufgabe, alle ihm zur Verf√ºgung stehenden Flaggen so anzuordnen, dass sie alle verminteten Zellen markieren.  Nachdem alle Flaggen platziert wurden, dr√ºckt der Spieler die linke Maustaste auf eine der offenen Zellen, um zu √ºberpr√ºfen, ob er gewonnen hat. <br></div></div><br>  Als n√§chstes gehen wir direkt zum Handbuch.  Das gesamte Material ist in kleine Schritte unterteilt, von denen jeder die Implementierung einer bestimmten Aufgabe in kurzer Zeit beschreibt.  Wenn wir also Schritt f√ºr Schritt kleine Ziele erreichen, werden wir am Ende ein vollst√§ndiges Spiel erstellen.  Verwenden Sie das Inhaltsverzeichnis, wenn Sie schnell zu einem bestimmten Schritt √ºbergehen m√∂chten. <br><br><div class="spoiler">  <b class="spoiler_title">Inhaltsverzeichnis</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1. Vorbereitung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.1 Projektvorlage</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.2 Build-Konfiguration</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.3 Module installieren</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.4 Verm√∂gensvorbereitung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2. Szenen erstellen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.1 Einstiegspunkt</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2 Startszene</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.3 Texte der Startszene</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.4 √úbergang in die Spielebene</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2,5 Level Szene</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.6 Szenen am Einstiegspunkt einstellen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3. Spielobjekte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.1 Spielbrett</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.2 Zellenmodell</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.3 Zellenansicht</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.4 Erstellen eines Sprites in einer Ansichtsklasse</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.5 Sprite-Positionierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.6 Erstellen einer Instanz von FieldView</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.7 Anzeigetafelfelder.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.8 Bomben bauen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.9 Werte einstellen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4. Behandlung von Eingabeereignissen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.1 Verfolgen von Mausklickereignissen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linksklickverarbeitung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.4 Rechtsklickverarbeitung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.5 GameSceneView-Objekt</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5. Animationen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5.1 Animation zum F√ºllen von Brettern</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5.2 Animationen zum Umbl√§ttern von Zellen</a> <br></div></div><br><a name="section-1"></a><h2>  <font color="#008080">1. Vorbereitung</font> </h2><br><a name="section-1-1"></a><h3>  <font color="#008080">1.1 Projektvorlage</font> </h3><br>  Laden Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standard-Phaser-Projektvorlage</a> herunter.  Dies ist die empfohlene Vorlage des Autors des Frameworks und bietet uns die folgende Verzeichnisstruktur: <br><div class="scrollable-table"><table><tbody><tr><td>  index.html </td><td colspan="2">  HTML-Seite, die das Spiel startet </td></tr><tr><td rowspan="2">  Webpack / </td><td>  base.js </td><td>  build config f√ºr die Testumgebung </td></tr><tr><td>  prod.js </td><td>  build config f√ºr die Produktion </td></tr><tr><td rowspan="2">  src / </td><td>  Verm√∂genswerte / </td><td>  Spiele-Assets (Sprites, Sounds, Schriften) </td></tr><tr><td>  index.js </td><td>  Einstiegspunkt </td></tr></tbody></table></div> F√ºr unser Projekt ben√∂tigen wir die aktuelle Datei <code>index.js</code> nicht. L√∂schen Sie sie daher.  Erstellen Sie dann das Verzeichnis <code>/src/scripts/</code> und platzieren Sie die leere Datei <code>index.ts</code> darin.  Wir werden alle unsere Skripte zu diesem Ordner hinzuf√ºgen. <br>  Beachten Sie auch, dass beim Erstellen eines Projekts f√ºr die Produktion im Stammverzeichnis ein <code>dist</code> Verzeichnis erstellt wird, in dem der Release-Build abgelegt wird. <br><br><a name="section-1-2"></a><h3>  <font color="#008080">1.2 Build-Konfiguration</font> </h3><br>  Wir werden das Webpack f√ºr die Montage verwenden.  Da unsere Vorlage urspr√ºnglich f√ºr die Arbeit mit JavaScript vorbereitet war und wir in TypeScript schreiben, m√ºssen wir kleine √Ñnderungen an der Konfiguration des Kollektors vornehmen. <br><br>  <code>webpack/base.js</code> den <code>webpack/base.js</code> hinzu, der den Einstiegspunkt beim <code>webpack/base.js</code> unseres Projekts angibt, sowie die Konfiguration von <code>ts-loader</code> , die die Regeln f√ºr das <code>webpack/base.js</code> TS-Skripten beschreibt: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// webpack/base.js //... module.exports = { entry: './src/scripts/index.ts', // ... resolve: { extensions: [ '.ts', '.tsx', '.js' ] }, module: { rules: [{ test: /\.tsx?$/, use: 'ts-loader', exclude: /node_modules/ }, //...</span></span></code> </pre><br>  Wir m√ºssen auch die Datei tsconfig.json im Projektstamm erstellen.  F√ºr mich hat es folgenden Inhalt: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"compilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"module"</span></span>: <span class="hljs-string"><span class="hljs-string">"commonjs"</span></span>, <span class="hljs-string"><span class="hljs-string">"lib"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"dom"</span></span>, <span class="hljs-string"><span class="hljs-string">"es5"</span></span>, <span class="hljs-string"><span class="hljs-string">"es6"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2015"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2017"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2015.promise"</span></span> ], <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-string"><span class="hljs-string">"es5"</span></span>, <span class="hljs-string"><span class="hljs-string">"skipLibCheck"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"exclude"</span></span>: [<span class="hljs-string"><span class="hljs-string">"node_modules"</span></span>, <span class="hljs-string"><span class="hljs-string">"dist"</span></span>] }</code> </pre> <br><a name="section-1-3"></a><h3>  <font color="#008080">1.3 Module installieren</font> </h3><br>  Installieren Sie alle Abh√§ngigkeiten von package.json und f√ºgen Sie die typescript- und ts-loader-Module hinzu: <br><br><pre> <code class="plaintext hljs">npm i npm i typescript --save-dev npm i ts-loader --save-dev</code> </pre><br>  Jetzt kann das Projekt mit der Entwicklung beginnen.  Wir verf√ºgen √ºber 2 Befehle, die bereits in der Eigenschaft <code>scripts</code> in der Datei <code>package.json</code> definiert sind. <br><br><ol><li>  Erstellen Sie ein Projekt zum Debuggen und √∂ffnen Sie es in einem Browser √ºber einen lokalen Server <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> </li><li>  F√ºhren Sie den Build for Sale aus und legen Sie den Release-Build im Ordner dist / ab <br><br><pre> <code class="plaintext hljs">npm run build</code> </pre> </li></ol><br><a name="section-1-4"></a><h3>  <font color="#008080">1.4 Verm√∂gensvorbereitung</font> </h3><br>  Alle Assets f√ºr dieses Spiel werden ehrlich von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenGameArt</a> (Version 61x61) heruntergeladen und haben die freundlichste der Lizenzen namens <i>Feel free to use</i> , die uns auf der Seite mit dem Paket sorgf√§ltig mitgeteilt wird.  Der Code im Artikel hat √ºbrigens die gleiche Lizenz!  ;) <br><br>  Ich habe das Uhrbild aus dem heruntergeladenen Satz gel√∂scht und den Rest der Dateien umbenannt, um einfach zu verwendende Frame-Namen zu erhalten.  Die Liste der Namen und der entsprechenden Dateien wird auf dem Bildschirm unten angezeigt. <br><br>  Aus den resultierenden Sprites erstellen wir einen <code>Phaser JSONArray</code> im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TexturePacker-</a> Programm (es gibt mehr als genug kostenlose Versionen, ich habe noch keine Arbeit erhalten) und legen die generierten Dateien <code>spritesheet.png</code> und <code>spritesheet.json</code> im Projektverzeichnis <code>src/assets/</code> . <br><br><img src="https://habrastorage.org/webt/ms/ki/z9/mskiz9zmuidbxk8hhcbksfmny4k.png"><br><br><a name="section-2"></a><h2>  <font color="#008080">2. Szenen erstellen</font> </h2><br><a name="section-2-1"></a><h3>  <font color="#008080">2.1 Einstiegspunkt</font> </h3><br>  Wir beginnen die Entwicklung mit der Erstellung des Einstiegspunkts, der in der Webpack-Konfiguration beschrieben ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// src/scripts/index.ts import * as Phaser from "phaser"; new Phaser.Game({ type: Phaser.AUTO, parent: "minesweeper", width: window.innerWidth, height: window.innerHeight, backgroundColor: "#F0FFFF", scene: [] });</span></span></code> </pre><br>  Da das Spiel f√ºr den Desktop entwickelt wurde und den gesamten Bildschirm ausf√ºllt, verwenden wir mutig die gesamte Breite und H√∂he des Browsers f√ºr die Felder <code>width</code> und <code>height</code> . <br>  Das <code>scene</code> ist momentan ein leeres Array und wir werden es reparieren! <br><br><a name="section-2-2"></a><h3>  <font color="#008080">2.2 Startszene</font> </h3><br>  Erstellen Sie die Klasse der ersten Szene in der <code>src/scripts/scenes/StartScene.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartScene</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scene</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">'Start'</span></span>); } public preload(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } public create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  F√ºr eine g√ºltige Vererbung <code>Phaser.Scene</code> den <code>Phaser.Scene</code> als Parameter an den Konstruktor der √ºbergeordneten Klasse. <br><br>  Diese Szene kombiniert die Funktionalit√§t des Vorladens von Ressourcen und des Startbildschirms und l√§dt den Benutzer zum Spiel ein. <br><br>  Normalerweise durchl√§uft ein Spieler in meinen Projekten zwei Szenen, bevor er zur Startszene gelangt, und zwar in dieser Reihenfolge: <br><br><pre> <code class="plaintext hljs">Boot =&gt; Preload =&gt; Start</code> </pre><br>  Aber in diesem Fall ist das Spiel so einfach und es gibt so wenige Assets, dass es keinen Grund gibt, das Preload in eine separate Szene zu stellen, und noch mehr den anf√§nglichen separaten Bootloader. <br><br>  Wir werden alle Assets in der <code>preload</code> Methode laden.  Um in Zukunft mit dem erstellten Atlas arbeiten zu k√∂nnen, m√ºssen wir zwei Schritte ausf√ºhren: <br><br><ol><li>  <code>png</code> sich sowohl <code>png</code> als auch <code>json</code> Atlas-Dateien mit <code>require</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.ts const spritesheetPng = require("./../../assets/spritesheet.png"); const spritesheetJson = require("./../../assets/spritesheet.json"); // ...</span></span></code> </pre><br></li><li>  Laden Sie sie in die <code>preload</code> Methode der Startszene: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.ts // ... public preload(): void { this.load.atlas("spritesheet", spritesheetPng, spritesheetJson); } // ...</span></span></code> </pre><br></li></ol><br><a name="section-2-3"></a><h3>  <font color="#008080">2.3 Texte der Startszene</font> </h3><br>  In der Startszene sind noch 2 Dinge zu tun: <br><br><ol><li>  Sagen Sie dem Spieler, wie er das Spiel starten soll </li><li>  starte das Spiel auf Initiative des Spielers </li></ol><br>  Um den ersten Punkt zu erf√ºllen, erstellen wir zun√§chst zwei Aufz√§hlungen am Anfang der Szenendatei, um die Texte und ihre Stile zu beschreiben: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js enum Texts { Title = 'Minesweeper HTML5', Message = 'Click anywhere to start' } enum Styles { Color = '#008080', Font = 'Arial' } //...</span></span></code> </pre><br>  Und erstellen Sie dann beide Texte als Objekte in der Methode <code>create</code> .  Lassen Sie mich daran erinnern, dass die <code>create</code> von Szenen in <code>Phaser</code> erst aufgerufen wird, nachdem alle Ressourcen in der <code>preload</code> Methode <code>preload</code> , und dies ist f√ºr uns durchaus geeignet. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js //... public create(): void { this.add.text( this.cameras.main.centerX, this.cameras.main.centerY - 100, Texts.Title, {font: `52px ${Styles.Font}`, fill: Styles.Color}) .setOrigin(0.5); this.add.text( this.cameras.main.centerX, this.cameras.main.centerY + 100, Texts.Message, {font: `28px ${Styles.Font}`, fill: Styles.Color}) .setOrigin(0.5); } //...</span></span></code> </pre><br>  In einem anderen gr√∂√üeren Projekt k√∂nnten wir die Texte und Stile entweder in JSON-Locale-Dateien oder in separate Konfigurationsdateien aufnehmen. Da wir jetzt nur noch zwei Zeilen haben, halte ich diesen Schritt f√ºr √ºberfl√ºssig und schlage in diesem Fall vor, unser Leben nicht zu verkomplizieren. Beschr√§nken wir uns auf Listen am Anfang der Szenendatei. <br><br><a name="section-2-4"></a><h3>  <font color="#008080">2.4 √úbergang in die Spielebene</font> </h3><br>  Das Letzte, was wir in dieser Szene tun werden, bevor wir weitermachen, ist das Verfolgen des Mausklick-Ereignisses, um den Spieler in das Spiel zu starten: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js //... public create(): void { //... this.input.once('pointerdown', () =&gt; { this.scene.start('Game'); }); } //...</span></span></code> </pre> <br><a name="section-2-5"></a><h3>  <font color="#008080">2,5 Level Szene</font> </h3><br>  <code>this.scene.start</code> Parameters <code>"Game"</code> , der an die Methode <code>this.scene.start</code> Sie bereits vermutet, dass es an der Zeit ist, eine zweite Szene zu erstellen, die die Hauptspiellogik verarbeitet.  Erstelle die <code>src/scripts/scenes/GameScene.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameScene</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scene</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">'Game'</span></span>); } public create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  In dieser Szene ben√∂tigen wir die Methode <code>preload</code> , weil  In der vorherigen Szene haben wir bereits alle erforderlichen Ressourcen geladen. <br><br><a name="section-2-6"></a><h3>  <font color="#008080">2.6 Szenen am Einstiegspunkt einstellen</font> </h3><br>  Nachdem beide Szenen erstellt wurden, f√ºgen Sie sie unserem Einstiegspunkt hinzu <br>  <code>src/scripts/index.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//... import { StartScene } from "./scenes/StartScene"; import { GameScene } from "./scenes/GameScene"; //... new Phaser.Game({ // ... scene: [StartScene, GameScene] });</span></span></code> </pre><br><a name="section-3"></a><h2>  <font color="#008080">3. Spielobjekte</font> </h2><br>  Die <code>GameScene</code> Klasse implementiert also die Logik auf Spielebene.  Und was erwarten wir vom Sapper-Level?  Visuell erwarten wir ein Spielfeld mit geschlossenen Zellen.  Wir wissen, dass das Feld eine Tabelle ist, was bedeutet, dass es eine bestimmte Anzahl von Zeilen und Spalten hat, in denen mehrere Bomben bequem platziert sind.  Somit verf√ºgen wir √ºber gen√ºgend Informationen, um eine separate Entit√§t zu erstellen, die das Spielfeld beschreibt. <br><br><a name="section-3-1"></a><h3>  <font color="#008080">3.1 Spielbrett</font> </h3><br>  Erstellen Sie die <code>src/scripts/models/Board.ts</code> in die wir die <code>Board</code> Klasse <code>src/scripts/models/Board.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Field"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Board</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Events</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _rows: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _cols: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _bombs: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _fields: Field[] = []; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, rows: number, cols: number, bombs: number) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rows = rows; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cols = cols; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bombs = bombs; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._fields = []; } public get cols(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cols; } public get rows(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rows; } }</code> </pre> <br>  Machen wir die Klasse zum Nachfolger von Phaser.Events.EventEmitter, um auf die Schnittstelle zum Registrieren und Aufrufen von Ereignissen zuzugreifen, die wir in Zukunft ben√∂tigen werden. <br><br>  Ein Array von Objekten der <code>Field</code> Klasse wird in der Privateigenschaft <code>_fields</code> gespeichert.  Wir werden dieses Modell sp√§ter implementieren. <br><br>  Wir richten private numerische Eigenschaften <code>_rows</code> und <code>_cols</code> , um die Anzahl der Zeilen und Spalten des Spielfelds anzugeben.  Erstellen Sie √∂ffentliche Getter zum Lesen von <code>_rows</code> und <code>_cols</code> . <br><br>  Das Feld <code>_bombs</code> die Anzahl der Bomben an, die f√ºr das Level generiert werden m√ºssen.  Und im Parameter <code>_scene</code> wir einen Verweis auf das Objekt der <code>GameScene</code> -Spielszene, in dem wir eine Instanz der <code>Board</code> Klasse erstellen. <br><br>  Es ist erw√§hnenswert, dass wir das Szenenobjekt nur zur weiteren √úbertragung in die Ansichten auf das Modell √ºbertragen, wo wir es nur zum Anzeigen der Ansicht verwenden.  Tatsache ist, dass Phaser das Szenenobjekt direkt zum Rendern von Sprites verwendet und uns daher verpflichtet, einen Link zur aktuellen Szene bereitzustellen, wenn Prefabs f√ºr Sprites erstellt werden, die wir in Zukunft entwickeln werden.  Wir erkl√§ren uns damit einverstanden, dass wir den Link zur Szene nur zur weiteren Verwendung als Display-Engine √ºbertragen und die benutzerdefinierten Methoden der Szene in Modellen und Ansichten nicht direkt aufrufen. <br><br>  Nachdem wir uns f√ºr die <code>GameScene</code> entschieden haben, schlage ich vor, diese in der <code>GameScene</code> zu initialisieren und die <code>GameScene</code> Klasse <code>GameScene</code> : <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// GameScene.ts import { Board } from "../models/Board"; const Rows = 8; const Cols = 8; const Bombs = 8; export class GameScene extends Phaser.Scene { private _board: Board = null; //... public create(): void { this._board = new Board(this, Rows, Cols, Bombs); } }</span></span></code> </pre> <br>  Wir nehmen die Board-Parameter zu Konstanten am Anfang der Szenendatei und √ºbergeben sie an den <code>Board</code> Konstruktor, wenn wir eine Instanz dieser Klasse erstellen. <br><br><a name="section-3-2"></a><h3>  <font color="#008080">3.2 Zellenmodell</font> </h3><br>  Die Tafel besteht aus Zellen, die Sie auf dem Bildschirm anzeigen m√∂chten.  Jede Zelle muss an der entsprechenden Position platziert werden, die durch die Zeile und Spalte bestimmt wird. <br><br>  Zellen werden auch als separate Einheit ausgew√§hlt.  Erstellen Sie die <code>src/scripts/models/Field.ts</code> in der die Klasse platziert wird, die die Zelle beschreibt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Board } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Board"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Field</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Events</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _board: Board = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _row: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _col: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, board: Board, row: number, col: number) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._init(scene, board, row, col); } public get col(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._col; } public get row(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._row; } public get board(): Board { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._board; } private _init(scene: Phaser.Scene, <span class="hljs-attr"><span class="hljs-attr">board</span></span>: Board, <span class="hljs-attr"><span class="hljs-attr">row</span></span>: number, <span class="hljs-attr"><span class="hljs-attr">col</span></span>: number): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._board = board; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._row = row; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._col = col; } }</code> </pre><br>  Jede Zelle sollte √ºber Zeilen- und Spaltenmetriken verf√ºgen, in denen sie sich befindet.  Wir richten die Parameter <code>_board</code> und <code>_scene</code> um Verkn√ºpfungen zu Objekten der Platine und der Szene <code>_scene</code> .  Wir implementieren Getter zum Lesen der <code>_row</code> , <code>_col</code> und <code>_board</code> . <br><br><a name="section-3-3"></a><h3>  <font color="#008080">3.3 Zellenansicht</font> </h3><br>  Die abstrakte Zelle wird erstellt und nun m√∂chten wir sie visualisieren.  Um eine Zelle auf dem Bildschirm anzuzeigen, m√ºssen Sie ihre Ansicht erstellen.  Erstellen Sie die <code>src/scripts/views/FieldView.ts</code> und <code>src/scripts/views/FieldView.ts</code> die Ansichtsklasse ein: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../models/Field"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameObjects</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sprite</span></span></span><span class="hljs-class"> </span></span>{ private _model: Field = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, model: Field) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(scene, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'spritesheet'</span></span>, <span class="hljs-string"><span class="hljs-string">'closed'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._model = model; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._init(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._create(); } private _init(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } private _create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  Bitte beachten Sie, dass wir diese Klasse zum Nachkommen von <code>Phaser.GameObjects.Sprite</code> .  In Phaser-Begriffen ist diese Klasse zu einem Sprite-Fertighaus geworden.  Das hei√üt, ich habe die Funktionalit√§t des Spielobjekts des Sprites, das wir mit unseren eigenen Methoden weiter ausbauen werden. <br><br>  Schauen wir uns den Konstruktor dieser Klasse an.  Hier m√ºssen wir zun√§chst den Konstruktor der √ºbergeordneten Klasse mit den folgenden Parameters√§tzen aufrufen: <br><br><ul><li>  Verkn√ºpfen mit dem Szenenobjekt (wie ich in Abschnitt 3.1 gewarnt habe: Phaser erfordert, dass wir eine Verkn√ºpfung mit der aktuellen Szene herstellen, um Sprites zu rendern.) </li><li>  <code>x</code> und <code>y</code> Koordinaten auf Leinwand </li><li>  der String-Schl√ºssel, f√ºr den der Atlas verf√ºgbar ist, den wir in der <code>preload</code> Methode der <code>preload</code> geladen haben </li><li>  Geben Sie den Schl√ºssel f√ºr die Frame-Zeichenfolge in diesem Atlas ein, den Sie ausw√§hlen m√∂chten, um das Sprite anzuzeigen </li></ul><br>  <code>_model</code> in der Eigenschaft private <code>_model</code> einen Verweis auf das Modell ( <code>_model</code> eine Instanz der <code>Field</code> Klasse) <code>_model</code> . <br><br>  Wir haben auch vorsichtig 2 derzeit leere <code>_init</code> und <code>_create</code> , die wir etwas sp√§ter implementieren werden. <br><br><a name="section-3-4"></a><h3>  <font color="#008080">3.4 Erstellen eines Sprites in einer Ansichtsklasse</font> </h3><br>  So wurde die Ansicht erstellt, aber sie wei√ü immer noch nicht, wie man ein Sprite zeichnet.  Um das Sprite mit dem von uns ben√∂tigten Rahmen auf der <code>_create</code> , m√ºssen Sie unsere eigene private <code>_create</code> Methode <code>_create</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.js //... private _create(): void { this.scene.add.existing(this); //      this.setOrigin(0.5); //  pivot point    } //...</span></span></code> </pre><br><a name="section-3-5"></a><h3>  <font color="#008080">3.5 Sprite-Positionierung</font> </h3><br>  Im Moment werden alle erstellten Sprites in den Koordinaten (0, 0) der Zeichenfl√§che platziert.  Wir m√ºssen auch jede Zelle an der entsprechenden Position auf dem Brett platzieren.  Das hei√üt, an die Stelle, die der Zeile und Spalte dieser Zelle entspricht.  Dazu m√ºssen wir einen Code zur Berechnung der Koordinaten jeder Instanz der <code>FieldView</code> Klasse <code>FieldView</code> . <br><br>  F√ºgen <code>_position</code> der Klasse die Eigenschaft <code>_position</code> , die f√ºr die endg√ºltigen Koordinaten der Zelle auf dem Spielfeld verantwortlich ist: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... interface Vec2 {x: number, y: number}; export class FieldView extends Phaser.GameObjects.Sprite { private _position: Vec2 = {x: 0, y: 0}; //...</span></span></code> </pre><br>  Da wir die <code>_offset</code> und dementsprechend die Zellen in ihr relativ zur Mitte des Bildschirms ausrichten m√∂chten, ben√∂tigen wir auch die Eigenschaft <code>_offset</code> , die den Versatz dieser bestimmten Zelle relativ zum linken und oberen Rand des Bildschirms angibt.  F√ºge es mit einem privaten Getter hinzu: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private get _offset(): Vec2 { return { x: (this.scene.cameras.main.width - this._model.board.cols * this.width) / 2, y: (this.scene.cameras.main.height - this._model.board.rows * this.height) / 2 }; } //...</span></span></code> </pre><br>  So haben wir: <br><br><ol><li>  <code>this._scene.cameras.main.width</code> die gesamte Bildschirmbreite in <code>this._scene.cameras.main.width</code> . </li><li>  Wir erhalten die Gesamtbreite der <code>this._board.cols * this.width</code> indem wir die Anzahl der Zellen mit der Breite einer Zelle <code>this._board.cols * this.width</code> : <code>this._board.cols * this.width</code> . </li><li>  Indem wir die Breite der Tafel von der Breite des Bildschirms entfernen, erhalten wir einen Platz auf dem Bildschirm, der nicht von der Tafel belegt ist. </li><li>  Teilen Sie die resultierende Zahl durch 2 und Sie erhalten den Einr√ºckungswert links und rechts von der Tafel. </li><li>  Indem wir jede Zelle um den Wert dieser Einr√ºckung verschieben, garantieren wir die Ausrichtung der gesamten Platine entlang der <code>x</code> Achse. </li></ol><br>  Wir f√ºhren absolut √§hnliche Aktionen durch, um eine vertikale Verschiebung zu erhalten. <br><br>  In der <code>_init</code> Methode muss noch der erforderliche Code <code>_init</code> werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts // ... private _init(): void { const offset = this._offset; this.x = this._position.x = offset.x + this.width * this._model.col + this.width / 2; this.y = this._position.y = offset.y + this.height * this._model.row + this.height / 2; } // ...</span></span></code> </pre><br>  Die hier angegebenen Eigenschaften <code>this.x</code> , <code>this.y</code> , <code>this.width</code> und <code>this.height</code> sind die geerbten Eigenschaften der √ºbergeordneten Klasse <code>Phaser.GameObjects.Sprite</code> .  Das √Ñndern der Eigenschaften von <code>this.x</code> und <code>this.y</code> f√ºhrt zur korrekten Positionierung des Sprites auf der Leinwand. <br><br><a name="section-3-6"></a><h3>  <font color="#008080">3.6 Erstellen einer Instanz von FieldView</font> </h3><br>  Erstellen Sie eine Ansicht in der <code>Field</code> Klasse: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts // ... private _view: FieldView = null; public get view(): FieldView { return this._view; } private _init(scene: Phaser.Scene, board: Board, row: number, col: number): void { //... this._view = new FieldView(this._scene, this); } // ...</span></span></code> </pre><br><a name="section-3-7"></a><h3>  <font color="#008080">3.7 Anzeigetafelfelder.</font> </h3><br>  Kehren wir zur <code>Board</code> Klasse zur√ºck, die im Wesentlichen eine Sammlung von <code>Field</code> Objekten ist und Zellen erstellt. <br><br>  Wir werden den Board-Erstellungscode in eine separate <code>_create</code> Methode aufnehmen und diese Methode vom Konstruktor aus aufrufen.  Da wir wissen, dass wir in der <code>_create</code> Methode nicht nur Zellen erstellen, sondern auch den Code zum Erstellen von Zellen in einer separaten <code>_createFields</code> Methode <code>_createFields</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts constructor(scene: Phaser.Scene, rows: number, cols: number, bombs: number) { // ... this._create(); } private _create(): void { this._createFields(); } private _createFields(): void { }</span></span></code> </pre><br>  In dieser Methode erstellen wir die gew√ºnschte Anzahl von Zellen in einer verschachtelten Schleife: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts // ... private _createFields(): void { for (let row = 0; row &lt; this._rows; row++) { for (let col = 0; col &lt; this._cols; col++) { this._fields.push(new Field(this._scene, this, row, col)); } } } //...</span></span></code> </pre><br>  Es ist Zeit, die Assembly zum Debuggen zum ersten Mal mit dem Befehl auszuf√ºhren <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br>  Stellen Sie sicher, dass in der Mitte des Bildschirms 64 Zellen in 8 Zeilen angezeigt werden. <br><br><a name="section-3-8"></a><h3>  <font color="#008080">3.8 Bomben bauen</font> </h3><br>  Fr√ºher habe ich berichtet, dass in der <code>_create</code> Methode der <code>Board</code> Klasse nicht nur Felder erstellt werden.  Was noch  Es werden auch Bomben erzeugt und die erzeugten Zellen auf die Anzahl benachbarter Bomben eingestellt.  Beginnen wir mit den Bomben. <br><br>  Wir m√ºssen N Bomben in zuf√§lligen Zellen auf dem Brett platzieren.  Wir beschreiben den Prozess der Herstellung von Bomben mit einem ungef√§hren Algorithmus: <br><br><pre> <code class="plaintext hljs">                        </code> </pre><br>  Bei jeder Iteration der Schleife erhalten wir eine zuf√§llige Zelle aus der Eigenschaft <code>this._fields</code> bis wir so viele Bomben erstellt haben, wie im Feld <code>this._bombs</code> sind.  Wenn die empfangene Zelle leer ist, installieren wir eine Bombe und aktualisieren den Z√§hler der Bomben, die f√ºr die Erzeugung erforderlich sind. <br><br>  Um eine Zufallszahl zu generieren, verwenden wir die statische Methode <code>Phaser.Math.Between</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createBombs(): void { let count = this._bombs; //      while (count &gt; 0) { //       let field = this._fields[Phaser.Math.Between(0, this._fields.length - 1)]; //    if (field.empty) { //     field.setBomb(); //     --count; //    } } }</span></span></code> </pre><br>  Vergessen Sie nicht, den Aufruf von <code>this._createBombs();</code> in die Datei <code>Board.ts</code> zu schreiben <code>this._createBombs();</code>  am Ende der <code>_create</code> Methode <br><br>  Wie Sie bereits bemerkt haben, m√ºssen Sie die <code>Field</code> Klasse verfeinern, indem Sie den <code>empty</code> Getter und die <code>setBomb</code> Methode hinzuf√ºgen, damit dieser Code ordnungsgem√§√ü <code>setBomb</code> . <br><br>  F√ºgen <code>_value</code> der Field- <code>_value</code> ein privates <code>_value</code> Feld hinzu, das den Inhalt der Zelle regelt.  Wir akzeptieren die folgenden Vereinbarungen. <br><div class="scrollable-table"><table><tbody><tr><td>  <code>_value</code> === 0 </td><td>  Die Zelle ist leer und enth√§lt keine Minen oder Werte </td></tr><tr><td>  <code>_value</code> === -1 </td><td>  In der Zelle ist eine Mine </td></tr><tr><td>  <code>_value</code> &gt; 0 </td><td>  In der Zelle befindet sich die Anzahl der Minen neben der aktuellen Zelle </td></tr></tbody></table></div><br>  Nach diesen Regeln entwickeln wir Methoden in der <code>Field</code> Klasse, die mit der <code>_value</code> Eigenschaft arbeiten: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts // ... private _value: number = 0; // ... public get value(): number { return this._value; } public set value(value) { this._value = value; } public get empty(): boolean { return this._value === 0; } public get mined(): boolean { return this._value === -1; } public get filled(): boolean { return this._value &gt; 0; } public setBomb(): void { this._value = -1; } // ...</span></span></code> </pre><br><a name="section-3-9"></a><h3>  <font color="#008080">3.9 Werte einstellen</font> </h3><br>  Die Bomben sind angeordnet und jetzt haben wir alle Daten, um die numerischen Werte in allen Zellen festzulegen, die sie ben√∂tigen. <br><br>  Lassen Sie mich daran erinnern, dass die Zelle nach den Regeln des Pioniers die Nummer haben muss, die der Anzahl der Bomben entspricht, die sich neben dieser Zelle befinden.  Basierend auf dieser Regel schreiben wir den entsprechenden Pseudocode. <br><br><pre> <code class="plaintext hljs">                  </code> </pre><br>  Erstellen Sie in der <code>Board</code> Klasse eine neue Methode und √ºbersetzen Sie den angegebenen Pseudocode in echten Code: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createValues() { //      this._fields.forEach(field =&gt; { //      if (field.mined) { //     field.getClosestFields().forEach(item =&gt; { //      if (item.value &gt;= 0) { ++item.value; } }); } }); } //...</span></span></code> </pre><br>  Mal sehen, welche der von uns verwendeten Schnittstellen nicht implementiert sind.  Sie m√ºssen die <code>getClosestFields</code> Methode hinzuf√ºgen, um die benachbarten Zellen <code>getClosestFields</code> . <br><br>  Wie erkennt man benachbarte Zellen? <br><br>  Betrachten Sie beispielsweise eine beliebige Zelle der Platine, die sich nicht am Rand befindet, dh nicht in der √§u√üersten Reihe und nicht in der √§u√üersten Spalte.  Solche Zellen haben eine maximale Anzahl von Nachbarn: 1 oben, 1 unten, 3 links und 3 rechts (einschlie√ülich der diagonalen Zellen). <br><br>  Daher unterscheiden sich die Indikatoren <code>_row</code> und <code>_col</code> in jeder der benachbarten Zellen nicht um mehr als 1. Dies bedeutet, dass wir die Differenz zwischen den Parametern <code>_row</code> und <code>_col</code> im Voraus mit dem aktuellen Feld angeben k√∂nnen.  F√ºgen Sie der Klassenbeschreibung eine Konstante am Anfang der Datei hinzu: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts const Positions = [ {row : 0, col : 1}, //  {row : 0, col : -1}, //  {row : 1, col : 0}, //  {row : 1, col : 1}, //   {row : 1, col : -1}, //   {row : -1, col : 0}, //  {row : -1, col : 1}, //   {row : -1, col : -1} //   ]; //...</span></span></code> </pre><br>  Und jetzt k√∂nnen wir die fehlende Methode hinzuf√ºgen, in der wir dieses Array durchlaufen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public getClosestFields(): Field[] { let results = []; //      Positions.forEach(position =&gt; { //      let field = this._board.getField(this._row + position.row, this._col + position.col); //       if (field) { //     results.push(field); } }); return results; }; //...</span></span></code> </pre><br>  Vergessen Sie nicht, die Feldvariable bei jeder Iteration zu √ºberpr√ºfen, da nicht alle Zellen auf der Karte 8 Nachbarn haben.  Beispielsweise hat die obere linke Zelle keine Nachbarn links von ihr und so weiter. <br><br>  Es bleibt die Methode <code>getField</code> zu implementieren und der Methode <code>_create</code> in der Klasse <code>Board</code> alle erforderlichen Aufrufe hinzuzuf√ºgen <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public getField(row: number, col: number): Field { return this._fields.find(field =&gt; field.row === row &amp;&amp; field.col === col); } //... private _create(): void { this._createFields(); this._createBombs(); this._createValues(); } //...</span></span></code> </pre><br><a name="section-4"></a><h2> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Behandlung von Eingabeereignissen</font></font></font> </h2><br><a name="section-4-1"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1 Verfolgen von Mausklickereignissen</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Moment ist das Board vollst√§ndig initialisiert, es enth√§lt Bomben und es gibt Zellen mit Zahlen, aber alle sind derzeit geschlossen und es gibt keine M√∂glichkeit, sie zu √∂ffnen. </font><font style="vertical-align: inherit;">Wir werden dies korrigieren und das √ñffnen von Zellen durch Klicken mit der linken Maustaste implementieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst m√ºssen wir genau diesen Klick verfolgen. </font><font style="vertical-align: inherit;">F√ºgen Sie in der Klasse </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">folgenden Code </font><font style="vertical-align: inherit;">ganz am Ende der Methode hinzu </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FielView.ts //... private _create(): void { // ... this.setInteractive(); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Phaser k√∂nnen Sie Objekte aus dem Namespace f√ºr verschiedene Ereignisse abonnieren </font></font><code>Phaser.GameObjects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Insbesondere abonnieren wir das click-Ereignis ( </font></font><code>pointerdown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) als Prefab des Sprites selbst, dh als Objekt einer Klasse, von der es </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geerbt wurde </font></font><code>Phaser.GameObjects.Sprite</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuvor m√ºssen wir jedoch explizit darauf hinweisen, dass das Sprite m√∂glicherweise interaktiv ist, dh, Sie m√ºssen im Allgemeinen die Benutzereingaben abh√∂ren. Sie m√ºssen dies tun, indem Sie die Methode </font></font><code>setInteractive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ohne Parameter f√ºr das Sprite selbst </font><font style="vertical-align: inherit;">aufrufen </font><font style="vertical-align: inherit;">, wie wir es im obigen Beispiel getan haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem das Sprite interaktiv geworden ist, kehren wir zu der Klasse zur√ºck, </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der neue Modellobjekte erstellt wurden </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, n√§mlich die Methode, </font></font><code>_createFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und registrieren den R√ºckruf f√ºr die Eingabeereignisse f√ºr die Ansicht:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createFields(): void { for (let row = 0; row &lt; this._rows; row++) { for (let col = 0; col &lt; this._cols; col++) { const field = new Field(this._scene, this, row, col) field.view.on('pointerdown', this._onFieldClick.bind(this, field)); this._fields.push(field); } } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobald wir festgestellt haben, dass wir die Methode ausf√ºhren m√∂chten, indem wir auf das Sprite klicken </font></font><code>_onFieldClick</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, m√ºssen wir sie implementieren. Wir werden jedoch die Logik der Verarbeitung des Klicks aus der Klasse entfernen </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es wird angenommen, dass es besser ist, das Modell in Abh√§ngigkeit von der Eingabe zu verarbeiten und seine Daten entsprechend in einem separaten Controller zu √§ndern, dessen √Ñhnlichkeit die Klasse der Spielszene ist </font></font><code>GameScene</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Daher m√ºssen wir das Klickereignis weiterleiten, von der Klasse </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bis zur Szene. Also machen wir:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _onFieldClick(field: Field, pointer: Phaser.Input.Pointer): void { if (pointer.leftButtonDown()) { this.emit(`left-click`, field); } else if (pointer.rightButtonDown()) { this.emit(`right-click`, field); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier werfen wir nicht nur das Klickereignis so wie es war, sondern spezifizieren auch, welches Klickereignis es war. </font><font style="vertical-align: inherit;">Dies wird in Zukunft n√ºtzlich sein, wenn wir in der Szenenklasse jede Option anders verarbeiten. </font><font style="vertical-align: inherit;">Nat√ºrlich w√§re es m√∂glich, das Klick-Ereignis so zu senden, wie es ist, aber wir werden den Szenencode vereinfachen und einen Teil der Logik bez√ºglich des Ereignisses selbst in der Klasse belassen </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kehren wir nun zur Klasse der Spielszene zur√ºck </font></font><code>GameScene</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und f√ºgen am Ende der Methode einen </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code hinzu, </font><font style="vertical-align: inherit;">der </font><font style="vertical-align: inherit;">Ereignisse eines Klickens auf Zellen aufzeichnet:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... import { Field } from "../models/Field"; //... public create(): void { this._board = new Board(this, Rows, Cols, Bombs); this._board.on('left-click', this._onFieldClickLeft, this); this._board.on('right-click', this._onFieldClickRight, this); } private _onFieldClickLeft(field: Field): void { } private _onFieldClickRight(field: Field): void { } //...</span></span></code> </pre><br><a name="section-4-2"></a><h3>  <font color="#008080">4.2.</font> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linksklickverarbeitung</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir implementieren nun die Verarbeitung von Mausklickereignissen. </font><font style="vertical-align: inherit;">Und beginnen Sie mit dem √ñffnen der Zellen. </font><font style="vertical-align: inherit;">Zellen sollten durch Dr√ºcken der linken Taste ge√∂ffnet werden. </font><font style="vertical-align: inherit;">Bevor wir mit dem Programmieren beginnen, wollen wir die Bedingungen formulieren, die erf√ºllt sein m√ºssen:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie auf eine geschlossene Zelle klicken, sollte diese ge√∂ffnet werden </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn sich eine Mine in einer offenen Zelle befindet, ist das Spiel verloren </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Befinden sich in der offenen Zelle keine Minen oder Werte, befindet sich min nicht in den benachbarten Zellen. In diesem Fall m√ºssen Sie alle benachbarten Zellen √∂ffnen und fortfahren, bis der Wert in der offenen Zelle angezeigt wird </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie auf eine offene Zelle klicken, sollten Sie √ºberpr√ºfen, ob alle Flaggen richtig gesetzt sind. Wenn ja, beenden Sie das Spiel mit einem Sieg </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und jetzt, um das Verst√§ndnis der erforderlichen Funktionalit√§t zu vereinfachen, √ºbersetzen wir die obige Logik in Pseudocode: </font></font><br><br><pre> <code class="plaintext hljs">                         </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt verstehen wir, was programmiert werden muss. </font><font style="vertical-align: inherit;">Wir implementieren die Methode </font></font><code>_onFieldClickLeft</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... private _onFieldClickLeft(field: Field): void { if (field.closed) { //    field.open(); //   if (field.mined) { //    field.exploded = true; this._onGameOver(false); //   } else if (field.empty) { //    this._board.openClosestFields(field); //   } } else if (field.opened) { //    if (this._board.completed) { //       this._onGameOver(true); //   } } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und dann werden wir wie immer die Klassen fertigstellen </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Methoden implementieren, die wir im Handler aufrufen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir geben 3 m√∂gliche Zust√§nde der Zelle in der Aufz√§hlung an </font></font><code>States</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, f√ºgen ein Feld hinzu </font></font><code>_state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und implementieren einen Getter f√ºr jeden m√∂glichen Zustand:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts enum States { Closed = 'closed', Opened = 'opened', Marked = 'flag' }; export class Field extends Phaser.Events.EventEmitter { private _state: string = States.Closed; //... public get marked(): boolean { return this._state === States.Marked; } public get closed(): boolean { return this._state === States.Closed; } public get opened(): boolean { return this._state === States.Opened; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir nun Zust√§nde haben, die angeben, ob die Zelle geschlossen ist oder nicht, k√∂nnen wir eine Methode hinzuf√ºgen </font></font><code>open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die den Zustand √§ndert:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public open(): void { this._setState(States.Opened); } private _setState(state: string): void { if (this._state !== state) { this._state = state; this.emit('change'); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede √Ñnderung des Modellstatus sollte ein Ereignis ausl√∂sen, das dies meldet. </font><font style="vertical-align: inherit;">Daher f√ºhren wir eine zus√§tzliche private Methode ein, </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der die gesamte Logik des Zustandswechsels implementiert wird. </font><font style="vertical-align: inherit;">Diese Methode wird in allen √∂ffentlichen Methoden des Modells aufgerufen, die ihren Status √§ndern sollen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie ein Boolesches Flag hinzu </font></font><code>_exploded</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um genau das Feldobjekt anzugeben, das in die Luft gesprengt wurde:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts private _exploded: boolean = false; //... public set exploded(exploded: boolean) { this._exploded = exploded; this.emit('change'); } public get exploded(): boolean { return this._exploded; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ñffnen Sie nun die Klasse </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und implementieren Sie die Methode darin </font></font><code>openClosestFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Methode ist rekursiv und hat die Aufgabe, alle leeren Nachbarfelder in Bezug auf die im Parameter akzeptierte Zelle zu √∂ffnen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Algorithmus sieht wie folgt aus:</font></font><br><br><pre> <code class="plaintext hljs"> :                </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und dieses Mal haben wir bereits alle notwendigen Schnittstellen f√ºr die vollst√§ndige Implementierung dieser Methode: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public openClosestFields(field: Field): void { field.getClosestFields().forEach(item =&gt; {//     if (item.closed) {//    item.open();//   if (item.empty) {//    this.openClosestFields(item);//     } } }); } //...</span></span></code> </pre><br>   <code>completed</code>   <code>Board</code>       .        ?           . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public get completed(): boolean { return this._fields.filter(field =&gt; field.completed).length === this._bombs; } //...</span></span></code> </pre><br>     <code>_fields</code>   <code>completed</code> ,      .     (      ,     <code>completed</code>    <code>Field</code> )    <code>_bombs</code> (     ),   <code>true</code> ,  ,   . <br>          ,       .       <code>Board</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public open(): void { this._fields.forEach(field =&gt; field.open()); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Klasse selbst muss </font><font style="vertical-align: inherit;">noch ein Getter hinzugef√ºgt werden </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In welchem ‚Äã‚ÄãFall wird das Feld als erfolgreich gel√∂scht betrachtet? </font><font style="vertical-align: inherit;">Wenn es abgebaut und markiert ist. </font><font style="vertical-align: inherit;">Beide notwendigen Getter sind bereits vorhanden und wir k√∂nnen diese Methode hinzuf√ºgen:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public get completed(): boolean { return this.marked &amp;&amp; this.mined; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Verarbeitung des linken Mausklicks abzuschlie√üen, erstellen wir eine Methode, </font></font><code>_onGameOver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit der wir die Verfolgung von Board-Ereignissen deaktivieren und dem Spieler das gesamte Board anzeigen. </font><font style="vertical-align: inherit;">Sp√§ter werden wir auch einen Rendering-Code des Statusabschlussberichts basierend auf dem Parameter hinzuf√ºgen </font></font><code>status</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... private _onGameOver(status: boolean) { this._board.off('left-click', this._onFieldClickLeft, this); this._board.off('right-click', this._onFieldClickRight, this); this._board.open(); } //...</span></span></code> </pre><br><a name="section-4-3"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3 Feldanzeige</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor Sie mit der Verarbeitung des Rechtsklicks beginnen, erfahren Sie, wie Sie die neu ge√∂ffneten Zellen neu zeichnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu Beginn der Klasse haben </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir eine Methode entwickelt </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die ein Ereignis ausl√∂st, </font></font><code>change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn sich der Status des Modells √§ndert. Wir werden dies verwenden und in der Klasse werden wir </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses Ereignis verfolgen:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _init(): void { //... this._model.on('change', this._onStateChange, this); } private _onStateChange(): void { this._render(); } private _render(): void { this.setFrame(this._frameName); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben die intermedi√§re Methode speziell zu einem </font></font><code>_onStateChange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√ºckruf des Modell√§nderungsereignisses gemacht. </font><font style="vertical-align: inherit;">In Zukunft m√ºssen wir √ºberpr√ºfen, wie das Modell ge√§ndert wurde, um zu verstehen, ob es durchgef√ºhrt werden muss </font></font><code>_render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das aktuelle Sprite einer Zelle in einem neuen Status anzuzeigen, m√ºssen Sie den Frame √§ndern. </font><font style="vertical-align: inherit;">Da wir den Atlas als Assets geladen haben, k√∂nnen wir die Methode aufrufen </font></font><code>setFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um den aktuellen Frame in einen neuen zu √§ndern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den Frame in eine Zeile zu bringen, haben wir geschickt den Getter verwendet </font></font><code>_frameName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der nun implementiert werden muss. </font><font style="vertical-align: inherit;">Zun√§chst beschreiben wir alle m√∂glichen Werte, die ein Zellenrahmen annehmen kann.</font></font><br><div class="scrollable-table"><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rahmen </font></font></td><td>  Zustand </td></tr><tr><td> <code>closed</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Feld ist geschlossen </font></font><br></td></tr><tr><td> <code>flag</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Markiertes Feld </font></font><br></td></tr><tr><td> <code>empty</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Feld ist offen, nicht vermint oder mit Wert gef√ºllt </font></font><br></td></tr><tr><td> <code>exploded</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Feld ist offen, vermint und gesprengt </font></font><br></td></tr><tr><td> <code>mined</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Feld ist offen, vermint, aber nicht gesprengt </font></font><br></td></tr><tr><td> <code>1...9</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Feld ist ge√∂ffnet und zeigt einen Wert von 1 bis 9 an, der die Anzahl der Bomben neben diesem Feld angibt </font></font><br></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben eine Beschreibung aller Zust√§nde erhalten und haben bereits alle Methoden des Modells, mit denen diese Zust√§nde erhalten werden k√∂nnen. </font><font style="vertical-align: inherit;">Lassen Sie uns am Anfang der Datei eine kleine Konfiguration erstellen:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts const States = { 'closed': field =&gt; field.closed, 'flag': field =&gt; field.marked, 'empty': field =&gt; field.opened &amp;&amp; !field.mined &amp;&amp; !field.filled, 'exploded': field =&gt; field.opened &amp;&amp; field.mined &amp;&amp; field.exploded, 'mined': field =&gt; field.opened &amp;&amp; field.mined &amp;&amp; !field.exploded } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Schl√ºssel in diesem Objekt sind die Werte der Frames, und die Werte dieser Schl√ºssel sind die R√ºckrufe, die ein Boolesches Ergebnis zur√ºckgeben. </font><font style="vertical-align: inherit;">Basierend auf dieser Konfiguration k√∂nnen wir eine Methode entwickeln, um den gew√ºnschten Frame (dh den Schl√ºssel aus der Konfiguration) zu erhalten:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private get _frameName(): string { for (let key in States) { if (States[key](this._model)) { return key; } } return this._model.value.toString(); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch einfache Aufz√§hlung in einer Schleife durchlaufen wir also alle Schl√ºssel des config-Objekts und rufen nacheinander jeden R√ºckruf auf. </font><font style="vertical-align: inherit;">Die Funktion, die uns zuerst zur√ºckgibt, </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt an, dass der Schl√ºssel </font></font><code>key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bei der aktuellen Iteration der richtige Frame f√ºr den aktuellen Status des Modells ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn kein Schl√ºssel geeignet ist, betrachten wir als Standardstatus ein offenes Feld mit einem Wert </font></font><code>_value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da </font></font><code>States</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">diesen Status in der Konfiguration </font><font style="vertical-align: inherit;">nicht festgelegt haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir den Linksklick auf die Kartenfelder vollst√§ndig testen und √ºberpr√ºfen, wie sich die Zellen √∂ffnen und was nach dem √ñffnen angezeigt wird.</font></font><br><br><a name="section-4-4"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4 Rechtsklickverarbeitung</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie beim Erstellen des Linksklick-Handlers definieren wir zun√§chst die erwartete Funktionalit√§t eindeutig. </font><font style="vertical-align: inherit;">Mit einem Rechtsklick markieren wir die ausgew√§hlte Zelle mit einem Flag. </font><font style="vertical-align: inherit;">Aber es gibt bestimmte Bedingungen.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nur ein geschlossenes Feld, das derzeit nicht markiert ist, kann markiert werden </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn das Feld markiert ist, sollte ein erneuter Rechtsklick die Markierung aus dem Feld entfernen </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beim Setzen / Entfernen eines Flags muss die Anzahl der verf√ºgbaren Flags auf der Ebene aktualisiert und der Text mit der aktuellen Nummer angezeigt werden </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir diese Bedingungen in Pseudocode √ºbersetzen, erhalten wir die folgenden Kommentarzeilen: </font></font><br><br><pre> <code class="plaintext hljs">                              </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt k√∂nnen wir diesen Algorithmus in Aufrufe der ben√∂tigten Methoden √ºbersetzen, auch wenn diese noch nicht entwickelt wurden: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts private _flags: number = 0; //... private _onFieldClickRight(field: Field): void { if (field.closed &amp;&amp; this._flags &gt; 0) { //        field.addFlag(); //     } else if (field.marked) { //     field.removeFlag(); //   } this._flags = Bombs - this._board.countMarked; } //... public create(): void { this._flags = Bombs; //... } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier haben wir auch ein neues Feld gestartet </font></font><code>_flags</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das zu Beginn des Spiels der Anzahl der Bomben auf dem Brett entspricht, da zu Beginn des Spiels keine einzige Flagge gesetzt wurde. </font><font style="vertical-align: inherit;">Dieses Feld muss mit jedem Rechtsklick aktualisiert werden, da in diesem Fall die Flagge entweder hinzugef√ºgt oder von der Tafel entfernt wird. </font><font style="vertical-align: inherit;">F√ºgen Sie der Klasse einen </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getter hinzu </font></font><code>countMarked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public get countMarked(): number { return this._fields.filter(field =&gt; field.marked).length; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Setzen und Entfernen des Flags √§ndert den Status des Modells </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Daher implementieren wir diese Methoden in der entsprechenden Klasse √§hnlich der Methode </font></font><code>open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public addFlag(): void { this._setState(States.Marked); } public removeFlag(): void { this._setState(States.Closed); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich m√∂chte Sie daran erinnern, dass dadurch </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Ereignis ausgel√∂st </font></font><code>change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird, das in der Ansicht nachverfolgt wird. Daher wird das Sprite dieses Mal automatisch neu gezeichnet, wenn sich das Modell √§ndert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Testen der entwickelten Funktionalit√§t werden Sie mit Sicherheit feststellen, dass jedes Mal, wenn Sie mit der rechten Maustaste klicken, ein Kontextmen√º ge√∂ffnet wird. </font><font style="vertical-align: inherit;">F√ºgen Sie dem Konstruktor der Spielszene den Code hinzu, der dieses Verhalten deaktiviert:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... constructor() { super('Game'); //        document.querySelector("canvas").oncontextmenu = e =&gt; e.preventDefault(); } //...</span></span></code> </pre><br><a name="section-4-5"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5 GameSceneView-Objekt</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Benutzeroberfl√§che in der Spielszene anzuzeigen, erstellen wir eine Klasse </font></font><code>GameSceneView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und platzieren sie in </font></font><code>src/scripts/views/GameSceneView.ts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verhalten </font><font style="vertical-align: inherit;">wir uns anders als die Sch√∂pfung </font><font style="vertical-align: inherit;">und machen diese Klasse nicht zum Fertighaus und Erben </font></font><code>GameObjects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall m√ºssen die folgenden Elemente aus der Szenenansicht ausgegeben werden:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Text in der Anzahl der Flags </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exit-Taste </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spielabschluss-Statusmeldung (Gewinn / Verlust) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Machen wir aus jedem UI-Element ein separates Feld in der Klasse </font></font><code>GameSceneView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden einen Stummel vorbereiten.</font></font><br><br><pre> <code class="javascript hljs">enum Styles { Color = <span class="hljs-string"><span class="hljs-string">'#008080'</span></span>, Font = <span class="hljs-string"><span class="hljs-string">'Arial'</span></span> } enum Texts { Flags = <span class="hljs-string"><span class="hljs-string">'FLAGS: '</span></span>, Exit = <span class="hljs-string"><span class="hljs-string">'EXIT'</span></span>, Success = <span class="hljs-string"><span class="hljs-string">'YOU WIN!'</span></span>, Failure = <span class="hljs-string"><span class="hljs-string">'YOU LOOSE'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameSceneView</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _style: {<span class="hljs-attr"><span class="hljs-attr">font</span></span>: string, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: string}; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._style = {<span class="hljs-attr"><span class="hljs-attr">font</span></span>: <span class="hljs-string"><span class="hljs-string">`28px </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${Styles.Font}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: Styles.Color}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._create(); } private _create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } public render() { } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºgen Sie Text mit der Anzahl der Flags hinzu. </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _txtFlags: Phaser.GameObjects.Text = null; //... private _createTxtFlags(): void { this._txtFlags = this._scene.add.text( 50, 50, Texts.Flags, this._style ).setOrigin(0, 1); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit diesem Code wird der ben√∂tigte Text von oben und links um 50 Pixel einger√ºckt und auf den angegebenen Stil eingestellt. </font><font style="vertical-align: inherit;">Zus√§tzlich setzt die Methode </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Drehpunkt des Textes auf die Koordinaten (0, 1). </font><font style="vertical-align: inherit;">Dies bedeutet, dass der Text am linken Rand ausgerichtet wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie eine Statusmeldung hinzu.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _txtStatus: Phaser.GameObjects.Text = null; //... private _createTxtStatus(): void { this._txtStatus = this._scene.add.text( this._scene.cameras.main.centerX, 50, Texts.Success, this._style ).setOrigin(0.5, 1); this._txtStatus.visible = false; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir platzieren den Statustext in der Mitte des Bildschirms und richten ihn an der Mitte der Linie aus, indem wir </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit Parameter 0.5 f√ºr die x-Koordinate </font><font style="vertical-align: inherit;">aufrufen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au√üerdem muss dieser Text standardm√§√üig ausgeblendet sein, da er erst nach Abschluss des Spiels angezeigt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie eine Exit-Schaltfl√§che, die im Wesentlichen auch ein Textobjekt ist.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _btnExit: Phaser.GameObjects.Text = null; //... private _createBtnExit(): void { this._btnExit = this._scene.add.text( this._scene.cameras.main.width - 50, 50, Texts.Exit, this._style ).setOrigin(1); this._btnExit.setInteractive(); this._btnExit.once('pointerdown', () =&gt; { this._scene.scene.start('Start'); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir platzieren die Schaltfl√§che in der oberen rechten Ecke des Bildschirms und verwenden sie erneut </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um den Text dieses Mal an der rechten Kante auszurichten. </font><font style="vertical-align: inherit;">Wir machen die Schaltfl√§che interaktiv und f√ºgen dem Klickereignis einen R√ºckruf hinzu, der den Spieler zur Startszene schickt. </font><font style="vertical-align: inherit;">Somit geben wir dem Spieler die M√∂glichkeit, das Level jederzeit zu verlassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es bleibt noch eine Methode zu entwickeln, mit der </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alle Elemente der Benutzeroberfl√§che korrekt aktualisiert und alle in erstellten Methoden aufgerufen werden k√∂nnen </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _create(): void { this._createTxtFlags(); this._createTxtStatus(); this._createBtnExit(); } public render(data: {flags?: number, status?: boolean}) { if (typeof data.flags !== 'undefined') { this._txtFlags.text = Texts.Flags + data.flags.toString(); } if (typeof data.status !== 'undefined') { this._txtStatus.text = data.status ? Texts.Success : Texts.Failure; this._txtStatus.visible = true; } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abh√§ngig von der im Parameter √ºbergebenen Eigenschaft aktualisieren wir die Benutzeroberfl√§che und zeigen die erforderlichen √Ñnderungen an. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie in der GameScene-Klasse eine Darstellung in der Spielszene und schreiben Sie den Aufruf an die Methode _render, wo immer dies aus Gr√ºnden der Bedeutung erforderlich ist:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... import { GameSceneView } from "../views/GameSceneView"; //... export class GameScene extends Phaser.Scene { private _view: GameSceneView = null; //... private _onGameOver(status: boolean) { //... this._view.render({status}); } //... private _onFieldClickRight(field: Field): void { //... this._flags = Bombs - this._board.countMarked; this._view.render({flags: this._flags}); } //... public create(): void { //... this._view = new GameSceneView(this); this._view.render({flags: this._flags}); } //... }</span></span></code> </pre><br><a name="section-5"></a><h2> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Animationen</font></font></font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was f√ºr ein Fan von einem Spiel, auch wenn es so einfach ist wie das unsere, wenn es keine Animationen enth√§lt ?! </font><font style="vertical-align: inherit;">Dar√ºber hinaus sollten wir uns, seit wir anfingen, Phaser zu studieren, mit den grundlegendsten Funktionen von Animationen vertraut machen und die Funktionalit√§t von Zwillingen betrachten. </font><font style="vertical-align: inherit;">Zwillinge werden im Framework selbst implementiert und es sind keine Bibliotheken von Drittanbietern erforderlich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie dem Spiel 2 Animationen hinzu: F√ºllen Sie das Spielfeld am Anfang mit Zellen und drehen Sie die Zelle an der √ñffnung um. </font><font style="vertical-align: inherit;">Beginnen wir mit dem ersten.</font></font><br><br><a name="section-5-1"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1 Animation zum F√ºllen von Brettern</font></font></font> </h3><br><img src="https://habrastorage.org/webt/7r/uu/1v/7ruu1vtppaw26sp-fapxbahgm9q.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir stellen sicher, dass alle Zellen des Boards vom oberen linken Bildschirmrand an ihren Platz fliegen. </font><font style="vertical-align: inherit;">Wenn Sie das Spiellevel starten, m√ºssen Sie alle Zellen in die obere linke Ecke des Bildschirms verschieben und f√ºr jede Zelle die Animation der Bewegung auf die entsprechenden Koordinaten starten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie in der Klasse </font></font><code>FiledView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufruf </font><font style="vertical-align: inherit;">am Ende der Methoden hinzu </font></font><code>_animateShow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _create(): void { //... this._animateShow(); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B Wir implementieren die neue Methode, die wir brauchen. </font><font style="vertical-align: inherit;">Darin m√ºssen, wie oben vereinbart, zwei Dinge ausgef√ºhrt werden:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschieben Sie die Zelle hinter die linke obere Ecke, sodass sie auf dem Bildschirm nicht sichtbar ist </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Starten Sie die Doppelbewegung zu den gew√ºnschten Koordinaten mit der richtigen Verz√∂gerung </font></font></li></ol><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _animateShow(): Promise&lt;void&gt; { this.x = -this.width; this.y = -this.height; const delay = this._model.row * 50 + this._model.col * 10; return this._moveTo(this._position, delay); } //...</span></span></code> </pre><br>         (0, 0),      ,       ,           .       . <br><br>       <code>_moveTo</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _moveTo(position: Vec2, delay: number): Promise&lt;void&gt; { return new Promise(resolve =&gt; { this.scene.tweens.add({ targets: this, x: position.x, y: position.y, duration: 600, ease: 'Elastic', easeParams: [1, 1], delay, onComplete: () =&gt; { resolve(); } }); }); } //...</span></span></code> </pre><br>        <code>tweens</code> .    <code>add</code>      : <br><br><ul><li>  <code>targets</code>         ,      .      <code>this</code>   ,      . </li><li>         . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Eigenschaft </font></font><code>duration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist verantwortlich f√ºr die Dauer der Animation, in unserem Fall - 600ms.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter </font></font><code>ease</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>easeParams</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stellen Sie die Beschleunigungsfunktion ein.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Feld Verz√∂gerung ersetzen wir den Wert aus dem zweiten Argument, das f√ºr jede einzelne Zelle unter Ber√ºcksichtigung ihrer Position auf der Platine generiert wird. </font><font style="vertical-align: inherit;">Dies geschieht, damit die Zellen nicht gleichzeitig herausfliegen. </font><font style="vertical-align: inherit;">Stattdessen wird jede Zelle mit einer geringen Verz√∂gerung gegen√ºber der vorherigen Zelle angezeigt.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich </font></font><code>onComplete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºgen wir einen R√ºckruf </font><font style="vertical-align: inherit;">in die Eigenschaft ein </font><font style="vertical-align: inherit;">, der am Ende der Tween-Aktion aufgerufen wird.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist vern√ºnftig, den Zwilling in ein Versprechen zu h√ºllen, damit er in Zukunft verschiedene Animationen auf wunderbare Weise andocken kann. Daher platzieren wir einen Funktionsaufruf im R√ºckruf </font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der die erfolgreiche Ausf√ºhrung der Animation anzeigt.</font></font><br><br><a name="section-5-2"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2 Animationen der Zellumdrehung</font></font></font> </h3><br><img src="https://habrastorage.org/webt/uc/d-/yw/ucd-yw-nq6a4veixb-npp0mdyqy.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist gro√üartig, wenn beim √ñffnen der Zelle der Effekt ihrer Umkehrung reproduziert wurde. Wie k√∂nnen wir das erreichen? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das √ñffnen einer Zelle erfolgt derzeit durch √Ñndern des Frames, wenn die Methode </font></font><code>_render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Ansicht </font><font style="vertical-align: inherit;">aufgerufen wird </font><font style="vertical-align: inherit;">. Wenn wir bei dieser Methode den Status des Modells √ºberpr√ºfen, sehen wir, ob die Zelle ge√∂ffnet war. Wenn die Zelle ge√∂ffnet war, starten Sie die Animation, anstatt sofort einen neuen Umkehrrahmen anzuzeigen.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _onStateChange(): void { if (this._model.opened) { this._animateFlip(); } else { this._render(); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den gew√ºnschten Effekt zu erzielen, verwenden wir die Transformation des Sprites durch die Eigenschaft </font></font><code>scale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn wir das Sprite entlang der Achse </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit der </font><font style="vertical-align: inherit;">Zeit </font><font style="vertical-align: inherit;">auf Null </font><font style="vertical-align: inherit;">skalieren </font><font style="vertical-align: inherit;">, schrumpft es schlie√ülich und verbindet die linke und rechte Seite. </font><font style="vertical-align: inherit;">Und umgekehrt, wenn Sie das Sprite entlang der Achse </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von Null auf seine volle Breite </font><font style="vertical-align: inherit;">skalieren </font><font style="vertical-align: inherit;">, dehnen wir es auf seine volle Gr√∂√üe. </font><font style="vertical-align: inherit;">Wir implementieren diese Logik in die Methode </font></font><code>_animateFlip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _animateFlip(): void { this._scaleXTo(0).then(() =&gt; { this._render(); this._scaleXTo(1); }) } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Analogie zur Methode </font></font><code>_moveTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementieren </font><font style="vertical-align: inherit;">wir </font></font><code>_scaleTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _scaleXTo(scaleX: number): Promise&lt;void&gt; { return new Promise(resolve =&gt; { this.scene.tweens.add({ targets: this, scaleX, ease: 'Elastic.easeInOut', easeParams: [1, 1], duration: 150, onComplete: () =&gt; { resolve() } }); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei dieser Methode nehmen wir als Parameter den Wert der Skala, mit dem wir die Gr√∂√üe des Sprites in beide Richtungen √§ndern und √ºbergeben ihn als zweiten Parameter an das Animationskonfigurationsobjekt. </font><font style="vertical-align: inherit;">Alle anderen Konfigurationsparameter sind uns bereits aus der vorherigen Animation bekannt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt werden wir das Projekt zum Testen starten und nach dem Debuggen sehen wir unser Spiel als abgeschlossen an und die Testaufgabe ist abgeschlossen!</font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich danke allen von Herzen, dass sie diesen Moment mit mir erreicht haben! </font></font><br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kolleginnen und Kollegen, ich freue mich sehr, wenn Ihnen das im Artikel vorgestellte Material von Nutzen ist und Sie diese oder jene beschriebenen Ans√§tze in Ihren eigenen Projekten anwenden k√∂nnen. Sie k√∂nnen sich jederzeit an mich wenden, wenn Sie Fragen zu diesem Artikel, zur Phaser-Programmierung oder zur Arbeit in Gamedev im Allgemeinen haben. Ich begr√º√üe die Kommunikation und freue mich auf neue Bekanntschaften und Erfahrungsaustausch! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und ich habe gerade eine Frage an Sie. Da ich Video-Tutorials zur Spieleentwicklung erstelle, habe ich nat√ºrlich ein Dutzend dieser kleinen Spiele angesammelt. Jedes Spiel √∂ffnet das Framework auf seine Weise. Zum Beispiel haben wir in diesem Spiel das Thema Zwillinge angesprochen, aber es gibt viele andere Funktionen, wie Physik, Tilemap, Wirbels√§ule usw.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Zusammenhang stellt sich die Frage, ob Ihnen dieser Artikel gefallen hat und ob Sie daran interessiert sind, weiterhin Artikel wie diesen zu lesen, aber √ºber andere kleine klassische Spiele? </font><font style="vertical-align: inherit;">Wenn die Antwort ja ist, √ºbersetze ich die Materialien meiner Video-Tutorials gerne in Textform und ver√∂ffentliche im Laufe der Zeit weiterhin neue Handb√ºcher, aber f√ºr andere Spiele. </font><font style="vertical-align: inherit;">Ich bringe die entsprechende Umfrage mit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielen Dank f√ºr Ihre Aufmerksamkeit! </font><font style="vertical-align: inherit;">Ich freue mich auf Feedback und bis bald!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476682/">https://habr.com/ru/post/de476682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476670/index.html">CAD-√úbersicht auf dem geometrischen Kern C3D-2</a></li>
<li><a href="../de476674/index.html">ReportPortal-Schnellbereitstellung zum Einarbeiten</a></li>
<li><a href="../de476676/index.html">48 Open-Source-Ressourcen f√ºr JavaScript (2019)</a></li>
<li><a href="../de476678/index.html">API f√ºr asynchrones Remote-Abrufen mit Apple Combine</a></li>
<li><a href="../de476680/index.html">Rodovs kontinuierliches Produktionsplanungssystem ist das sowjetische 1961 Lean / MRP. Start, Sonnenuntergang und Neugeburt</a></li>
<li><a href="../de476686/index.html">Entwicklung eines IoT-Gateways auf Basis von Raspberry CM3 +</a></li>
<li><a href="../de476688/index.html">Neuer Kurs von OTUS. ‚ÄúIOS-Entwickler. Aufbaukurs V 2.0 ¬ª</a></li>
<li><a href="../de476692/index.html">Content-Marketing-Grunds√§tze</a></li>
<li><a href="../de476694/index.html">√úber die Gesch√§ftsrobotisierung mit Farida Roslovets und Direktor der RPA-Firma electroNeek</a></li>
<li><a href="../de476696/index.html">Erstellen und Bereitstellen einer Full-Stack-React-Anwendung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>