<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚁 ⏬ 🚺 Comment nous avons construit un référentiel rapide et fiable de vues d'annonces 👩‍👩‍👦 👩‍👧 💆🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'une des fonctions discrètes mais importantes de nos sites publicitaires est d'enregistrer et d'afficher le nombre de leurs vues. Nos sites regardent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment nous avons construit un référentiel rapide et fiable de vues d'annonces</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/kolesa/blog/431902/"> L'une des fonctions discrètes mais importantes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nos sites publicitaires</a> est d'enregistrer et d'afficher le nombre de leurs vues.  Nos sites regardent les annonces depuis plus de 10 ans.  L'implémentation technique de la fonctionnalité a réussi à changer plusieurs fois pendant ce temps, et maintenant c'est un (micro) service sur Go, travaillant avec Redis comme cache et file d'attente de tâches, et avec MongoDB comme stockage persistant.  Il y a quelques années, il a appris à travailler non seulement avec la somme des vues d'annonces, mais aussi avec les statistiques de chaque jour.  Mais il a appris à faire tout cela très rapidement et de manière fiable tout récemment. <br><br><img src="https://habrastorage.org/webt/ee/nn/jp/eennjposwyrztis3a7s6cbkhq2e.png" alt="image"><br><br>  Au total, le service traite ~ 300 000 requêtes de lecture et ~ 9 000 requêtes d'écriture par minute, dont 99% sont exécutées jusqu'à 5 ms.  Ce ne sont bien sûr pas des indicateurs astronomiques et non le lancement de fusées sur Mars - mais ce n'est pas non plus une tâche aussi banale qu'un simple stockage de nombres pourrait sembler.  Il s'est avéré que faire tout cela, assurer un stockage de données sans perte et lire des valeurs cohérentes et pertinentes, nécessite un certain effort, dont nous discuterons ci-dessous. <br><a name="habracut"></a><br><h3>  Tâches et vue d'ensemble du projet </h3><br>  Bien que les compteurs de vues ne soient pas aussi critiques pour les entreprises que, par exemple, le traitement des paiements ou des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">demandes de prêt</a> , ils sont tout d'abord importants pour nos utilisateurs.  Les gens sont fascinés par le suivi de la popularité de leurs annonces: certains appellent même le support lorsqu'ils remarquent des informations de visualisation inexactes (cela s'est produit avec l'une des implémentations de service précédentes).  De plus, nous stockons et affichons des statistiques détaillées dans les comptes personnels des utilisateurs (par exemple, pour évaluer l'efficacité de l'utilisation des services payants).  Tout cela nous fait prendre soin de sauvegarder chaque événement de visualisation et d'afficher les valeurs les plus pertinentes. <br><br>  En général, la fonctionnalité et les principes du projet ressemblent à ceci: <br><br><ul><li>  L'écran de la page Web ou de l'application fait une demande derrière les compteurs d'affichage des annonces (la demande est généralement asynchrone pour hiérarchiser la sortie des informations de base).  Et si la page de l'annonce elle-même est affichée, le client vous demandera plutôt d'augmenter et de renvoyer le nombre de vues mis à jour. </li><li>  En traitant les demandes de lecture, le service essaie d'obtenir des informations du cache Redis et complète l'inconnu en complétant une demande à MongoDB. </li><li>  Les demandes d'écriture sont envoyées à 2 structures dans le radis: la file d'attente de mise à jour incrémentielle (traitée en arrière-plan, de manière asynchrone) et le cache du nombre total de vues. </li><li>  Un processus d'arrière-plan du même service lit les éléments de la file d'attente, les accumule dans le tampon local et les écrit périodiquement dans MongoDB. </li></ul><br><h3>  Compteurs de vues d'enregistrement: pièges </h3><br>  Bien que les étapes décrites ci-dessus semblent assez simples, le problème ici est l'organisation de l'interaction entre la base de données et les instances de microservices afin que les données ne soient pas perdues, pas dupliquées et pas retardées. <br><br>  L'utilisation d'un seul référentiel (par exemple, seulement MongoDB) résoudrait certains de ces problèmes.  En fait, le service fonctionnait auparavant, jusqu'à ce que nous rencontrions des problèmes de mise à l'échelle, de stabilité et de vitesse. <br><br>  Une implémentation naïve du déplacement des données entre les stockages pourrait conduire, par exemple, à de telles anomalies: <br><br><ul><li>  Perte de données lors d'une écriture compétitive dans le cache: <br><ol><li>  Le processus <b>A</b> augmente le nombre de vues dans le cache Redis, mais découvre qu'il n'y a toujours pas de données pour cette entité (il peut s'agir d'une nouvelle déclaration ou d'une ancienne qui a été extrudée du cache), donc le processus doit d'abord obtenir cette valeur de MongoDB. <br></li><li>  Le processus <b>A</b> obtient le nombre de vues de MongoDB - par exemple, le nombre 5;  puis y ajoute 1 et va écrire dans Redis <b>6</b> . </li><li>  Le processus <b>B</b> (initié, par exemple, par un autre utilisateur du site qui a également entré la même annonce) fait de même simultanément. </li><li>  Le processus <b>A</b> écrit une valeur de <b>6</b> dans Redis. </li><li>  Le processus <b>B</b> écrit une valeur de <b>6</b> dans Redis. </li><li>  Par conséquent, une vue est perdue en raison de la course lors de l'enregistrement des données. <br>  <i>Le scénario n'est pas si improbable: par exemple, nous avons un service payant qui place une annonce sur la page principale du site.</i>  <i>Pour une nouvelle annonce, un tel déroulement des événements peut entraîner la perte de nombreuses vues à la fois en raison de leur afflux soudain.</i> </li></ol></li><li>  Un exemple d'un autre scénario est la perte de données lors du déplacement de vues de Redis vers MongoDb: <br><br><ol><li>  Le processus récupère une valeur en attente de Redis et la stocke en mémoire pour une écriture ultérieure dans MongoDB. </li><li>  Une demande d'écriture échoue (ou le processus se bloque avant d'être exécuté). </li><li>  Les données sont à nouveau perdues, ce qui deviendra apparent la prochaine fois que la valeur mise en cache sera poussée et remplacée par la valeur de la base de données. </li></ol><br></li></ul><br>  D'autres erreurs peuvent se produire, dont les raisons résident également dans la nature non atomique des opérations entre les bases de données, par exemple, un conflit lors de la suppression et de l'augmentation des vues de la même entité. <br><br><h3>  Enregistrement du nombre de vues: solution </h3><br>  Notre approche du stockage et du traitement des données dans ce projet est basée sur l'hypothèse qu'à tout moment, MongoDB peut échouer plus probablement que Redis.  Bien sûr, ce n'est pas une <i>règle</i> absolue - du moins pas pour chaque projet - mais dans notre environnement, nous sommes vraiment habitués à observer des délais d'expiration périodiques pour les requêtes dans MongoDB causés par la performance des opérations sur disque, ce qui était auparavant l'une des raisons de la perte de certains événements. <br><br>  Pour éviter bon nombre des problèmes mentionnés ci-dessus, nous utilisons des files d'attente de tâches pour l'enregistrement différé et des lua-scripts, qui permettent de modifier atomiquement les données dans plusieurs structures de radis à la fois.  Dans cet esprit, les détails de l'enregistrement des vues sont les suivants: <br><br><ol><li>  Lorsqu'une demande d'écriture tombe dans le microservice, elle exécute le script lua <b>IncrementIfExists</b> pour augmenter le compteur uniquement s'il existe déjà dans le cache.  Le script renvoie immédiatement <b>-1</b> s'il n'y a pas de données pour l'entité visualisée dans le radis;  sinon, il augmente la valeur des vues dans le cache via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HINCRBY</a> , ajoute l'événement à la file d'attente pour un stockage ultérieur dans MongoDB (appelé <i>file d'attente en attente par</i> nous) via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LPUSH</a> , et renvoie la quantité de vues mise à jour. <br></li><li>  Si IncrementIfExists renvoie un nombre positif, cette valeur est renvoyée au client et la demande se termine. <br><br>  Sinon, le microservice récupère le compteur de vues de MongoDb, l'incrémente de 1 et l'envoie au radis. <br></li><li>  L'écriture sur le radis se fait via un autre lua-script - <b>Upsert</b> - qui enregistre la quantité de vues dans le cache s'il est encore vide, ou les augmente de 1 si quelqu'un d'autre a réussi à remplir le cache entre les étapes 1 et 3. <br></li><li>  Upsert ajoute également un événement d'affichage à la file d'attente en attente et renvoie un montant mis à jour, qui est ensuite envoyé au client. <br></li></ol><br>  Du fait que les scripts lua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sont exécutés de manière atomique</a> , nous évitons de nombreux problèmes potentiels qui pourraient être causés par une écriture compétitive. <br><br>  Un autre détail important est d'assurer le transfert sécurisé des mises à jour de la file d'attente en attente vers MongoDB.  Pour ce faire, nous avons utilisé le modèle de «file d'attente fiable» décrit dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation Redis</a> , qui réduit considérablement les risques de perte de données en créant une copie des éléments traités dans une autre file d'attente jusqu'à ce qu'ils soient finalement stockés dans un stockage persistant. <br><br>  Pour mieux comprendre l'ensemble des étapes du processus, nous avons préparé une petite visualisation.  Tout d'abord, regardons un scénario normal et réussi (les étapes sont numérotées dans le coin supérieur droit et sont décrites en détail ci-dessous): <br><br><img src="https://habrastorage.org/webt/0v/al/bq/0valbqz3kj6du62z0foxfcb6bay.gif" alt="image"><br><br><ol><li>  Le microservice reçoit une demande d'écriture </li><li>  Le gestionnaire de requêtes la transmet à un lua-script qui écrit la recherche dans le cache (la rendant immédiatement lisible) et dans la file d'attente pour un traitement ultérieur. </li><li>  Le goroutine d'arrière-plan effectue (périodiquement) l'opération <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BRPopLPush</a> , qui déplace atomiquement un élément d'une file d'attente à une autre (nous l'appelons «file d'attente de traitement» - une file d'attente avec des éléments actuellement traités).  Le même élément est ensuite stocké dans un tampon de la mémoire de processus. <br></li><li>  Une autre demande d'écriture arrive et est en cours de traitement, ce qui nous laisse 2 éléments dans le tampon et 2 éléments dans la file d'attente de traitement. </li><li>  Après un certain délai, le processus d'arrière-plan décide de vider le tampon dans MongoDB.  L'écriture de plusieurs valeurs à partir du tampon est effectuée par une seule demande, ce qui affecte positivement le débit.  De plus, avant l'enregistrement, le processus essaie de combiner plusieurs vues en une seule, en résumant leurs valeurs pour les mêmes annonces. <br>  <i>Sur chacun de nos projets, 3 instances de microservices sont utilisées, chacune avec son propre tampon, qui est enregistré dans la base de données toutes les 2 secondes.</i>  <i>Pendant ce temps, environ 100 éléments sont accumulés dans un seul tampon.</i> <i><br></i> </li><li>  Après une écriture réussie, le processus supprime les éléments de la file d'attente de traitement, signalant que le traitement s'est terminé avec succès. <br></li></ol><br>  Lorsque tous les sous-systèmes sont en ordre, certaines de ces étapes peuvent sembler redondantes.  Et le lecteur attentif peut également avoir une question sur ce que fait le gopher dormant dans le coin inférieur gauche. <br>  Tout est expliqué lorsque l'on considère le scénario où MongoDB n'est pas disponible: <br><br><img src="https://habrastorage.org/webt/hl/jd/bs/hljdbsmwzxn6i2k5xfgj2mm02em.gif" alt="Un exemple de service lorsque MongoDB plante"><br><br><ol><li>  La première étape est identique aux événements du scénario précédent: le service reçoit 2 demandes d'enregistrement des vues et les traite. <br></li><li>  Le processus perd la connexion avec MongoDB (le processus lui-même, bien sûr, ne le sait pas encore). <br>  Le gestionnaire Gorutin, comme précédemment, essaie de vider son tampon dans la base de données - mais cette fois sans succès.  Elle revient à attendre la prochaine itération. <br></li><li>  Un autre goroutine d'arrière-plan se réveille et vérifie la file d'attente de traitement.  Elle découvre que les éléments lui ont été ajoutés il y a longtemps;  concluant que leur traitement a échoué, elle les replace dans la file d'attente. <br></li><li>  Après un certain temps, la connexion avec MongoDB est rétablie. <br></li><li>  Le premier goroutine d'arrière-plan essaie à nouveau d'effectuer une opération d'écriture - cette fois avec succès - et supprime définitivement les éléments de la file d'attente de traitement. <br></li></ol><br>  Dans ce schéma, il existe plusieurs délais d'attente et heuristiques importants dérivés des tests et du bon sens: par exemple, les éléments sont déplacés de la file d'attente de traitement vers la file d'attente en attente après 15 minutes d'inactivité.  De plus, le goroutine responsable de cette tâche effectue un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">verrouillage</a> avant l'exécution afin que plusieurs instances du microservice n'essaient pas de restaurer les vues «figées» en même temps. <br><br>  À strictement parler, même ces mesures n'offrent pas de garanties théoriquement justifiées (par exemple, nous ignorons des scénarios comme le processus se bloque pendant 15 minutes) - mais en pratique, cela fonctionne de manière assez fiable. <br><br>  De plus, dans ce schéma, il y a au moins 2 autres vulnérabilités connues que nous devons connaître: <br><br><ul><li>  Si le microservice est tombé en panne immédiatement après avoir enregistré avec succès dans MongoDb, mais avant d'effacer la liste de files d'attente de traitement, ces données seront considérées comme non enregistrées - et après 15 minutes seront à nouveau enregistrées. <br>  <i>Pour réduire la probabilité d'un tel scénario, nous avons fourni des tentatives répétées de suppression de la file d'attente de traitement en cas d'erreurs.</i>  <i>En réalité, nous n'avons pas encore observé de tels cas en production.</i> <br></li><li>  Lorsque vous redémarrez, le radis peut perdre non seulement le cache, mais également certaines vues non enregistrées des files d'attente, car il est configuré pour enregistrer périodiquement des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instantanés RDB</a> toutes les quelques minutes. <br>  <i>Bien qu'en théorie cela puisse être un problème sérieux (surtout si le projet traite de données vraiment critiques), en pratique les nœuds sont extrêmement rarement redémarrés.</i>  <i>Dans le même temps, selon la surveillance, les éléments passent dans les files d'attente pendant moins de 3 secondes, c'est-à-dire que le montant possible des pertes est très limité.</i> <br></li></ul><br>  Il peut sembler qu'il y a plus de problèmes que nous ne le souhaiterions.  Cependant, en fait, il s'avère que le scénario que nous avons initialement défendu - l'échec de MongoDB - est en effet une menace bien plus réelle, et le nouveau schéma de traitement des données garantit avec succès la disponibilité du service et évite les pertes. <br><br>  Un exemple frappant de cela était lorsque l'instance MongoDB à l'un des projets était absurdement indisponible toute la nuit.  Pendant tout ce temps, le nombre de vues accumulées et tournées dans un radis d'une file d'attente à une autre, jusqu'à ce qu'elles soient finalement enregistrées dans la base de données après la résolution de l'incident;  la plupart des utilisateurs n'ont même pas remarqué l'échec. <br><br><h3>  Lecture en lecture compte </h3><br>  Les demandes de lecture sont beaucoup plus simples que les demandes d'écriture: le microservice vérifie d'abord le cache dans le radis;  tout ce qui ne se trouve pas dans le cache est rempli avec des données de MongoDb et retourné au client. <br><br>  Il n'y a pas d'écriture de bout en bout dans le cache pendant les opérations de lecture pour éviter la surcharge de protection contre les écritures concurrentes.  Le taux de réussite du cache reste bon, car le plus souvent, il sera déjà réchauffé grâce à d'autres demandes d'écriture. <br><br>  Les statistiques de vue quotidiennes sont lues directement à partir de MongoDB, car elles sont demandées beaucoup moins souvent et la mise en cache est plus difficile.  Cela signifie également que lorsque la base de données n'est pas disponible, la lecture des statistiques cesse de fonctionner;  mais cela n'affecte qu'une petite partie des utilisateurs. <br><br><h3>  Schéma de stockage des données MongoDB </h3><br>  Le schéma de collecte MongoDB pour le projet est basé sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ces recommandations des développeurs de bases de données eux</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mêmes</a> et ressemble à ceci: <br><br><ul><li>  Les vues sont enregistrées dans 2 collections: dans l'une il y a leur montant total, dans l'autre - les statistiques par jour. <br></li><li>  Les données de la collecte de statistiques sont organisées sur la base d' <b>un document par annonce et par mois</b> .  Pour les nouvelles annonces, un document rempli de trente et un zéro pour le mois en cours est inséré dans la collection;  Selon l'article mentionné ci-dessus, cela vous permet d'allouer immédiatement suffisamment d'espace pour un document sur le disque afin que la base de données n'ait pas à le déplacer lors de l'ajout de données. <br>  <i>Cet élément rend le processus de lecture des statistiques un peu délicat (les demandes doivent être générées par mois du côté du microservice), mais dans l'ensemble, le schéma reste assez intuitif.</i> <br></li><li>  L'opération <b>upsert</b> est utilisée pour l'enregistrement, afin de mettre à jour et, si nécessaire, de créer un document pour l'entité souhaitée dans la même requête. <br></li></ul><br>  Nous n'utilisons pas les capacités transactionnelles de MongoDb pour mettre à jour plusieurs collections en même temps, ce qui signifie que nous risquons que les données puissent être écrites dans une seule collection.  Pour le moment, nous nous connectons simplement à de tels cas;  il y en a peu, et jusqu'à présent, cela ne présente pas le même problème important que d'autres scénarios. <br><br><h3>  Test </h3><br>  Je ne ferais pas confiance à mes propres mots que les scénarios décrits fonctionnent vraiment s'ils n'étaient pas couverts par des tests. <br><br>  Étant donné que la plupart du code du projet fonctionne en étroite collaboration avec les radis et MongoDb, la plupart des tests qu'il contient sont des tests d'intégration.  L'environnement de test est pris en charge par docker-compose, ce qui signifie qu'il peut être déployé rapidement, offre une reproductibilité en réinitialisant et en restaurant l'état à chaque démarrage, et permet d'expérimenter sans affecter les bases de données d'autres personnes. <br><br>  Dans ce projet, il existe 3 principaux domaines de test: <br><br><ol><li>  Validation de la logique métier dans des scénarios typiques, les soi-disant  chemin heureux.  Ces tests répondent à la question - lorsque tous les sous-systèmes sont en ordre, le service fonctionne-t-il conformément aux exigences fonctionnelles? </li><li>  Vérification des scénarios négatifs dans lesquels le service devrait poursuivre son travail.  Par exemple, le service ne perd-il vraiment pas de données lorsque MongoDb plante? <br>  Sommes-nous sûrs que les informations restent cohérentes avec les délais d'expiration périodiques, les blocages et les opérations d'enregistrement concurrentielles? </li><li>  Vérification des scénarios négatifs dans lesquels nous ne nous attendons pas à ce que le service continue, mais un niveau minimum de fonctionnalité doit toujours être fourni.  Par exemple, il n'y a aucune chance que le service continue d'enregistrer et de renvoyer des données lorsque ni radis ni mongo ne sont disponibles - mais nous voulons être sûrs que, dans de tels cas, il ne se bloque pas, mais attend la récupération du système, puis revient au travail. </li></ol><br>  Pour vérifier les scénarios infructueux, le code de logique métier de service fonctionne avec les interfaces client de base de données, qui dans les tests nécessaires sont remplacées par des implémentations qui renvoient des erreurs et / ou simulent des retards réseau.  Nous simulons également le fonctionnement parallèle de plusieurs instances de service en utilisant le modèle " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">objet environnement</a> ".  Il s'agit d'une variante de l'approche bien connue «d'inversion de contrôle», où les fonctions n'accèdent pas aux dépendances elles-mêmes, mais les reçoivent via l'objet d'environnement passé dans les arguments.  Entre autres avantages, l'approche vous permet de simuler plusieurs copies indépendantes du service en un seul test, chacune ayant son propre pool de connexions à la base de données et reproduisant plus ou moins efficacement l'environnement de production.  Certains tests exécutent chacune de ces instances en parallèle et s'assurent qu'ils voient tous les mêmes données, et il n'y a pas de conditions de concurrence. <br><br>  Nous avons également effectué un test de résistance rudimentaire, mais toujours très utile, basé sur <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">siège</a> , qui a permis d'estimer approximativement la charge admissible et la vitesse de réponse du service. <br><br><h3>  À propos des performances </h3><br>  Pour 90% des demandes, le temps de traitement est très court et, surtout, stable;  Voici un exemple de mesures sur l'un des projets sur plusieurs jours: <br><br><img src="https://habrastorage.org/webt/ln/bk/zy/lnbkzy7-wnykbaelv4vzsd8b53q.png" alt="image"><br><br>  Fait intéressant, un enregistrement (qui est en fait une opération d'écriture + lecture, car il renvoie des valeurs mises à jour) est légèrement plus rapide que la lecture (mais uniquement du point de vue d'un client qui n'observe pas l'écriture en attente réelle). <br>  Une augmentation régulière des retards le matin est un effet secondaire du travail de notre équipe d'analyse, qui recueille quotidiennement ses propres statistiques sur la base des données du service, créant pour nous une «surcharge artificielle». <br><br>      :           (          —          MongoDB),       (      ),     : <br><br><img src="https://habrastorage.org/webt/6f/pz/v9/6fpzv9b8lmswdsjhmrn4gk_qugw.png" alt="image"><br><br><h3>  Conclusion </h3><br> ,  -  , ,   Redis                . <br><br>       , 95%    ,     .      ,                .           5. <br><br>        Go, Redis  MongoDB             .                 ,       .         ,      —      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431902/">https://habr.com/ru/post/fr431902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431888/index.html">«Je pense que les idées d'équipe sont les plus importantes lors du développement d'un produit.»</a></li>
<li><a href="../fr431890/index.html">Comment passer une commande sur la bourse indépendante</a></li>
<li><a href="../fr431892/index.html">Nous utilisons Veeam Backup & Replication pour tester de nouveaux systèmes et applications avant la mise à niveau</a></li>
<li><a href="../fr431894/index.html">En décembre, ils décideront de l'enregistrement obligatoire des stations de base LPWAN</a></li>
<li><a href="../fr431898/index.html">Il s'agit d'Agile - 2: Fonctionnalités d'implémentation Agile</a></li>
<li><a href="../fr431904/index.html">Comment nous avons déchargé les spécialistes RH: informations pour l'émission des feuilles de paiement</a></li>
<li><a href="../fr431906/index.html">PIFR - une méthode pour générer un masque 3D, quel que soit l'angle de rotation du visage</a></li>
<li><a href="../fr431908/index.html">Configuration de l'API Tinkoff Bank. Comment est votre intuition ....? Ou une chanson sur Oauth 2.0</a></li>
<li><a href="../fr431910/index.html">PSEFABRIC - une nouvelle approche de la gestion et de l'automatisation des réseaux. Pas à l'idéal</a></li>
<li><a href="../fr431912/index.html">Le plus gros bot-no a été arrêté aux États-Unis: qu'est-ce que cela signifie pour la communauté numérique?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>