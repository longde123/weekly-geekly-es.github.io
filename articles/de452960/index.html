<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍒 🆙 🧑 Sie werden für alles antworten! Verbrauchergesteuerte Verträge mit den Augen des Entwicklers 🏇🏾 👩🏿‍🤝‍👩🏽 🤘🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden wir über die Probleme sprechen, die durch Consumer Driven Contracts gelöst werden, und am Beispiel von Pact with Node.js und ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sie werden für alles antworten! Verbrauchergesteuerte Verträge mit den Augen des Entwicklers</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/452960/">  In diesem Artikel werden wir über die Probleme sprechen, die durch Consumer Driven Contracts gelöst werden, und am Beispiel von Pact with Node.js und Spring Boot zeigen, wie diese angewendet werden.  Und sprechen Sie über die Grenzen dieses Ansatzes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gu/vg/za/guvgzadja02vflw5bi8mgh_wbbo.png"></div><br><h2>  Problem </h2><br>  Beim Testen von Produkten werden häufig Szenariotests verwendet, bei denen die Integration verschiedener Systemkomponenten in eine speziell ausgewählte Umgebung überprüft wird.  Solche Tests auf Live-Diensten liefern das zuverlässigste Ergebnis (ohne Tests im Kampf).  Gleichzeitig gehören sie zu den teuersten. <br><a name="habracut"></a><br><ul><li>  Es wird oft fälschlicherweise angenommen, dass die Integrationsumgebung nicht fehlertolerant sein sollte.  SLA, Garantien für solche Umgebungen werden selten ausgesprochen, aber wenn sie nicht verfügbar sind, müssen die Teams entweder die Veröffentlichung verzögern oder auf das Beste hoffen und ohne Tests in den Kampf ziehen.  Obwohl jeder weiß, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hoffnung keine Strategie ist</a> .  Und neue Infrastrukturtechnologien erschweren nur die Arbeit mit Integrationsumgebungen. </li><li>  <b>Ein weiterer Schmerz ist die Arbeit mit Testdaten</b> .  Viele Szenarien erfordern einen bestimmten Status des Systems, Fixtures.  Wie nah sollten sie an der Bekämpfung von Daten sein?  Wie kann man sie vor dem Test auf den neuesten Stand bringen und nach Abschluss reinigen? </li><li> <b>Tests sind zu instabil</b> .  Und das nicht nur wegen der Infrastruktur, die wir im ersten Absatz erwähnt haben.  Der Test kann fehlschlagen, weil ein benachbartes Team eigene Überprüfungen gestartet hat, die den erwarteten Status des Systems verletzt haben!  Viele falsch negative Schecks, schuppige Tests beenden ihr Leben bei <code>@Ignored</code> .  Außerdem können verschiedene Teile der Integration von verschiedenen Teams unterstützt werden.  Sie haben einen neuen Release-Kandidaten mit Fehlern eingeführt - sie haben alle Verbraucher gebrochen.  Jemand löst dieses Problem mit dedizierten Testschleifen.  Aber auf Kosten der Multiplikation der Supportkosten. </li><li>  <b>Solche Tests nehmen viel Zeit in Anspruch</b> .  Selbst mit Blick auf die Automatisierung können Ergebnisse für Stunden erwartet werden. </li><li>  Und um das Ganze abzurunden, wenn der Test wirklich richtig war, ist es bei weitem nicht immer möglich, die Ursache des Problems sofort zu finden.  Es kann sich tief hinter Integrationsebenen verstecken.  Oder es kann das Ergebnis einer unerwarteten Kombination von Zuständen vieler Systemkomponenten sein. </li></ul><br>  Stabile Tests in einer Integrationsumgebung erfordern ernsthafte Investitionen von QS, Entwicklern und sogar Ops.  Kein Wunder, dass sie ganz oben auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testpyramide stehen</a> .  Solche Tests sind nützlich, aber die Ressourcenökonomie erlaubt es ihnen nicht, alles zu überprüfen.  Die Hauptquelle ihres Wertes ist die Umwelt. <br><br>  Unterhalb derselben Pyramide befinden sich weitere Tests, bei denen wir das Vertrauen gegen kleinere Unterstützungskopfschmerzen austauschen - unter Verwendung von Isolationsprüfungen.  Je körniger, desto kleiner der Maßstab des Tests, desto geringer ist die Abhängigkeit von der äußeren Umgebung.  Ganz unten in der Pyramide befinden sich Unit-Tests.  Wir überprüfen einzelne Funktionen, Klassen, arbeiten weniger mit Geschäftssemantik als vielmehr mit Konstruktionen einer bestimmten Implementierung.  Diese Tests geben schnelles Feedback. <br><br>  Aber sobald wir die Pyramide hinuntergehen, müssen wir die Umwelt durch etwas ersetzen.  Stubs erscheinen - als ganze Dienste und einzelne Entitäten der Programmiersprache.  Mit Hilfe von Steckern können wir Komponenten isoliert testen.  Sie verringern aber auch die Gültigkeit der Prüfungen.  Wie kann sichergestellt werden, dass der Stub die richtigen Daten zurückgibt?  Wie kann man seine Qualität sicherstellen? <br><br>  <b>Die Lösung kann eine umfassende Dokumentation sein</b> , die verschiedene Szenarien und mögliche Zustände von Systemkomponenten beschreibt.  Formulierungen lassen jedoch immer noch Interpretationsfreiheit.  Daher ist eine gute Dokumentation ein lebendiges Artefakt, das sich ständig verbessert, wenn das Team den Problembereich versteht.  Wie kann dann die Einhaltung der Dokumentationsstubs sichergestellt werden? <br><br>  Bei vielen Projekten können Sie eine Situation beobachten, in der die Stubs von denselben Leuten geschrieben wurden, die das Testartefakt entwickelt haben.  Beispielsweise erstellen Entwickler mobiler Anwendungen selbst Stubs für ihre Tests.  Infolgedessen können Programmierer die Dokumentation auf ihre eigene Weise verstehen (was völlig normal ist), sie machen den Stub mit dem falsch erwarteten Verhalten, schreiben den Code entsprechend (mit grünen Tests) und Fehler treten während der realen Integration auf. <br><br>  Darüber hinaus wird die Dokumentation normalerweise nachgeschaltet - Clients verwenden Dienstspezifikationen (in diesem Fall kann ein anderer Dienst ein Client des Dienstes sein).  Es wird nicht ausgedrückt, <strong>wie</strong> Verbraucher Daten verwenden, welche Daten überhaupt benötigt werden und welche Annahmen sie für diese Daten treffen.  Die Folge dieser Unwissenheit ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gesetz von Hyrum</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ek/bh/ho/ekbhhofe0ox95w50drdg8tybsbi.png" width="300"></div><br><br>  Hyrum Wright hat lange Zeit öffentliche Tools in Google entwickelt und beobachtet, wie kleinste Änderungen zu Störungen bei Kunden führen können, die die impliziten (undokumentierten) Funktionen seiner Bibliotheken verwendet haben.  Eine solche versteckte Konnektivität erschwert die Entwicklung der API. <br><br>  Diese Probleme können bis zu einem gewissen Grad mithilfe von Verbraucherverträgen gelöst werden.  Wie jeder Ansatz und jedes Tool weist es eine Reihe von Anwendbarkeit und Kosten auf, die wir ebenfalls berücksichtigen werden.  Die Umsetzung dieses Ansatzes hat einen ausreichenden Reifegrad erreicht, um ihre Projekte auszuprobieren. <br><br><h2>  Was ist eine CDC? </h2><br>  Drei Schlüsselelemente: <br><br><ul><li>  <b>Der Vertrag</b> .  Beschrieben mit etwas DSL, implementierungsabhängig.  Es enthält eine Beschreibung der API in Form von Interaktionsszenarien: Wenn eine bestimmte Anforderung eingeht, sollte der Client eine bestimmte Antwort erhalten. </li><li>  <b>Kundentests</b> .  Darüber hinaus verwenden sie einen Stub, der automatisch aus dem Vertrag generiert wird. </li><li>  <b>Tests für die API</b> .  Sie werden auch aus dem Vertrag generiert. </li></ul><br>  Somit ist der Vertrag ausführbar.  Das Hauptmerkmal des Ansatzes besteht darin, dass die Anforderungen für das Verhalten der API vom Client zum Server <b>vorgelagert</b> werden. <br><br>  Der Vertrag konzentriert sich auf das Verhalten, <strong>das</strong> für den Verbraucher <strong>wirklich</strong> wichtig ist.  Macht seine Annahmen über die API explizit. <br><br>  Das Hauptziel der CDC ist es, ihren Entwicklern und den Entwicklern ihrer Kunden ein Verständnis des API-Verhaltens zu vermitteln.  Dieser Ansatz lässt sich gut mit BDD kombinieren. Bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Besprechungen mit drei Amigo können</a> Sie die Lücken für den Vertrag skizzieren.  Letztendlich dient dieser Vertrag auch zur Verbesserung der Kommunikation;  ein gemeinsames Verständnis des Problembereichs zu teilen und die Lösung innerhalb und zwischen Teams umzusetzen. <br><br><h2>  Pakt </h2><br>  Betrachten Sie die Verwendung von CDC als Beispiel aus Pact, einer seiner Implementierungen.  Angenommen, wir erstellen eine Webanwendung für Konferenzteilnehmer.  In der nächsten Iteration entwickelt das Team einen Präsentationsplan - bisher ohne Geschichten wie Abstimmungen oder Notizen, nur die Ausgabe des Berichtsrasters.  Der Quellcode für das Beispiel ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Bei einem Treffen von <s>drei</s> vier Amigo treffen sich ein Produkt, ein Tester, Entwickler des Backends und eine mobile Anwendung.  Das sagen sie <br><br><ul><li>  In der Benutzeroberfläche wird eine Liste mit dem Text angezeigt: Berichtstitel + Sprecher + Datum und Uhrzeit. </li><li>  Dazu muss das Backend Daten wie im folgenden Beispiel zurückgeben. </li></ul><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"talks"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>:<span class="hljs-string"><span class="hljs-string">"      "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"speakers"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">" "</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"time"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-05-27T12:00:00+03:00"</span></span> } ] }</code> </pre> <br>  Danach schreibt der Frontend-Entwickler den Client-Code (Backend für Frontend).  Er installiert eine Paktvertragsbibliothek im Projekt: <br><br><pre> <code class="bash hljs">yarn add --dev @pact-foundation/pact</code> </pre> <br>  Und beginnt einen Test zu schreiben.  Es konfiguriert den lokalen Stub-Server, der den Dienst mit Berichtszeitplänen simuliert: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> provider = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pact({ <span class="hljs-comment"><span class="hljs-comment">//      consumer: "schedule-consumer", provider: "schedule-producer", // ,     port: pactServerPort, //  pact     log: path.resolve(process.cwd(), "logs", "pact.log"), // ,     dir: path.resolve(process.cwd(), "pacts"), logLevel: "WARN", //  DSL  spec: 2 });</span></span></code> </pre> <br>  Der Vertrag ist eine JSON-Datei, die die Szenarien beschreibt, in denen der Client mit dem Service interagiert.  Sie müssen es jedoch nicht manuell beschreiben, da es aus den Einstellungen des Stubs im Code gebildet wird.  Der Entwickler vor dem Test beschreibt das folgende Verhalten. <br><br><pre> <code class="javascript hljs">provider.setup().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> provider .addInteraction({ <span class="hljs-attr"><span class="hljs-attr">uponReceiving</span></span>: <span class="hljs-string"><span class="hljs-string">"a request for schedule"</span></span>, <span class="hljs-attr"><span class="hljs-attr">withRequest</span></span>: { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">"/schedule"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">willRespondWith</span></span>: { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">headers</span></span>: { <span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json;charset=UTF-8"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { <span class="hljs-attr"><span class="hljs-attr">talks</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">"      "</span></span>, <span class="hljs-attr"><span class="hljs-attr">speakers</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">time</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-05-27T12:00:00+03:00"</span></span> } ] } } }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> done()) );</code> </pre> <br>  In diesem Beispiel haben wir die spezifische erwartete Serviceanforderung angegeben, aber pact-js unterstützt auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verschiedene Methoden zum Ermitteln von Übereinstimmungen</a> . <br><br>  Schließlich schreibt der Programmierer einen Test des Teils des Codes, der diesen Stub verwendet.  Im folgenden Beispiel werden wir es der Einfachheit halber direkt nennen. <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"fetches schedule"</span></span>, done =&gt; { fetch(<span class="hljs-string"><span class="hljs-string">`http://localhost:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${pactServerPort}</span></span></span><span class="hljs-string">/schedule`</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> response.json()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">json</span></span></span><span class="hljs-function"> =&gt;</span></span> expect(json).toStrictEqual({ <span class="hljs-attr"><span class="hljs-attr">talks</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">"      "</span></span>, <span class="hljs-attr"><span class="hljs-attr">speakers</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">time</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-05-27T12:00:00+03:00"</span></span> } ] })) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> done()); });</code> </pre> <br>  In einem realen Projekt kann dies entweder ein schneller Komponententest einer separaten Antwortinterpretationsfunktion oder ein langsamer UI-Test zum Anzeigen von Daten sein, die von einem Dienst empfangen wurden. <br><br>  Während des Testlaufs überprüft pact, ob der Stub die in den Tests angegebene Anforderung erhalten hat.  Die Abweichungen können in der Datei pact.log als unterschiedlich angesehen werden. <br><br><pre> <code class="plaintext hljs">E, [2019-05-21T01:01:55.810194 #78394] ERROR -- : Diff with interaction: "a request for schedule" Diff -------------------------------------- Key: - is expected + is actual Matching keys and values are not shown { "headers": { - "Accept": "application/json" + "Accept": "*/*" } } Description of differences -------------------------------------- * Expected "application/json" but got "*/*" at $.headers.Accept</code> </pre> <br><br>  Wenn der Test erfolgreich ist, wird ein Vertrag im JSON-Format generiert.  Es beschreibt das erwartete Verhalten der API. <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"consumer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"schedule-consumer"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"provider"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"schedule-producer"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"interactions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"a request for schedule"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"request"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"/schedule"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"headers"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Accept"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"status"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">"headers"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json;charset=UTF-8"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"body"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"talks"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>:<span class="hljs-string"><span class="hljs-string">"      "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"speakers"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">" "</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"time"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-05-27T12:00:00+03:00"</span></span> } ] }}} ], <span class="hljs-attr"><span class="hljs-attr">"metadata"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"pactSpecification"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"2.0.0"</span></span> } } }</code> </pre> <br>  Er gibt diesen Vertrag an den Backend-Entwickler.  Angenommen, die API befindet sich im Spring Boot.  Pact verfügt über eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pact-jvm-provider-spring-</a> Bibliothek, die mit MockMVC zusammenarbeiten kann.  Aber wir werden uns den Spring Cloud-Vertrag ansehen, der CDC im Spring-Ökosystem implementiert.  Es verwendet ein eigenes Vertragsformat, verfügt jedoch auch über einen Erweiterungspunkt zum Verbinden von Konvertern aus anderen Formaten.  Das native Vertragsformat wird nur vom Spring Cloud-Vertrag selbst unterstützt - im Gegensatz zu Pact, das Bibliotheken für JVM, Ruby, JS, Go, Python usw. enthält. <br><br>  Angenommen, in unserem Beispiel verwendet der Backend-Entwickler Gradle, um den Service zu erstellen.  Es verbindet die folgenden Abhängigkeiten: <br><br><pre> <code class="plaintext hljs">buildscript { // ... dependencies { classpath "org.springframework.cloud:spring-cloud-contract-pact:2.1.1.RELEASE" } } plugins { id "org.springframework.cloud.contract" version "2.1.1.RELEASE" // ... } // ... dependencies { // ... testImplementation 'org.springframework.cloud:spring-cloud-starter-contract-verifier' }</code> </pre> <br>  Und es legt den vom Frotender erhaltenen Paktvertrag in das Verzeichnis <code>src/test/resources/contracts</code> . <br><br>  Standardmäßig subtrahiert das Spring-Cloud-Vertrags-Plugin Verträge davon.  Während der Montage wird die Gradle-Task generateContractTests ausgeführt, die den folgenden Test im Verzeichnis build / generate-test-sources generiert. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractVerifierTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractsBaseTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate_aggregator_client_aggregator_service</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// given: MockMvcRequestSpecification request = given() .header("Accept", "application/json"); // when: ResponseOptions response = given().spec(request) .get("/scheduler"); // then: assertThat(response.statusCode()).isEqualTo(200); assertThat(response.header("Content-Type")).isEqualTo("application/json;charset=UTF-8"); // and: DocumentContext parsedJson = JsonPath.parse(response.getBody().asString()); assertThatJson(parsedJson).array("['talks']").array("['speakers']").contains("['name']").isEqualTo( /*...*/ ); assertThatJson(parsedJson).array("['talks']").contains("['time']").isEqualTo( /*...*/ ); assertThatJson(parsedJson).array("['talks']").contains("['title']").isEqualTo( /*...*/ ); } }</span></span></code> </pre> <br><br>  Beim Starten dieses Tests wird ein Fehler angezeigt: <br><br><pre> <code class="plaintext hljs">java.lang.IllegalStateException: You haven't configured a MockMVC instance. You can do this statically</code> </pre> <br>  Da wir verschiedene Tools zum Testen verwenden können, müssen wir dem Plug-In mitteilen, welches wir konfiguriert haben.  Dies erfolgt über die Basisklasse, die die aus den Verträgen generierten Tests erbt. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractsBaseTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ScheduleController scheduleController = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ScheduleController(); <span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ RestAssuredMockMvc.standaloneSetup(scheduleController); } }</code> </pre> <br><br>  Um diese Basisklasse während der Generierung zu verwenden, müssen Sie das Spring-Cloud-Contract-Gradle-Plugin konfigurieren. <br><br><pre> <code class="plaintext hljs">contracts { baseClassForTests = 'ru.example.schedule.ContractsBaseTest' }</code> </pre> <br><br>  Jetzt haben wir folgenden Test generiert: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractVerifierTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractsBaseTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate_aggregator_client_aggregator_service</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br>  Der Test wird erfolgreich gestartet, schlägt jedoch mit einem Überprüfungsfehler fehl. Der Entwickler hat die Implementierung des Dienstes noch nicht geschrieben.  Aber jetzt kann er es auf der Grundlage eines Vertrags tun.  Er kann sicherstellen, dass er die Anfrage des Kunden bearbeiten und die erwartete Antwort zurückgeben kann. <br><br>  Der Serviceentwickler weiß durch den Vertrag, was er tun muss und welches Verhalten er implementieren muss. <br><br>  Der Pakt kann tiefer in den Entwicklungsprozess integriert werden.  Sie können einen Pact-Broker bereitstellen, der solche Verträge aggregiert, deren Versionierung unterstützt und ein Abhängigkeitsdiagramm anzeigt. <br><br><img src="https://habrastorage.org/webt/dq/pd/v0/dqpdv0c4qk89kboewjxrafys1iq.png"><br><br>  Das Hochladen eines neu generierten Vertrags auf den Broker kann in Schritt CI beim Erstellen des Clients erfolgen.  Und geben Sie im Servercode das dynamische Laden des Vertrags per URL an.  Spring Cloud Contract unterstützt dies ebenfalls. <br><br><h2>  CDC-Anwendbarkeit </h2><br>  Was sind die Einschränkungen von Verbraucherverträgen? <br><br>  Für diesen Ansatz müssen <b>Sie mit zusätzlichen Tools</b> wie Pakt <b>bezahlen</b> .  Verträge an sich sind ein zusätzliches Artefakt, eine weitere Abstraktion, die sorgfältig gepflegt und bewusst auf technische Praktiken angewendet werden muss. <br><br>  <b>Sie ersetzen keine e2e-Tests</b> , da Stubs immer noch Stubs bleiben - Modelle realer Systemkomponenten, die zwar ein wenig sind, aber nicht der Realität entsprechen.  Durch sie können komplexe Szenarien nicht verifiziert werden. <br><br>  <b>CDCs ersetzen auch keine API-Funktionstests</b> .  Ihre Unterstützung ist teurer als bei einfachen alten Komponententests.  Paktentwickler empfehlen die Verwendung der folgenden Heuristiken: Wenn Sie den Vertrag entfernen und dies keine Fehler oder Fehlinterpretationen durch den Kunden verursacht, ist dies nicht erforderlich.  Beispielsweise ist es nicht erforderlich, absolut alle API-Fehlercodes durch einen Vertrag zu beschreiben, wenn der Client sie auf die gleiche Weise verarbeitet.  Mit anderen Worten, der Vertrag beschreibt für die Dienstleistung <strong>nur das, was für den Kunden wichtig ist</strong> .  Nicht mehr, aber nicht weniger. <br><br>  Zu viele Verträge erschweren auch die Entwicklung der API.  <b>Jeder zusätzliche Vertrag ist Anlass für rote Tests</b> .  Es ist notwendig, eine CDC so zu gestalten, dass jeder Fehlertest eine nützliche semantische Last trägt, die die Kosten ihrer Unterstützung überwiegt.  Wenn der Vertrag beispielsweise die Mindestlänge eines bestimmten Textfelds <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">festlegt</a> , die für den Verbraucher gleichgültig ist (er verwendet die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Toleran Reader-</a> Technik), wird jede Änderung dieses Mindestwerts den Vertrag und die Nerven seiner Umgebung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zerstören</a> .  Eine solche Prüfung muss auf die Ebene der API selbst übertragen und abhängig von der Quelle der Einschränkungen implementiert werden. <br><br><h2>  Fazit </h2><br>  CDC verbessert die Produktqualität durch explizite Beschreibung des Integrationsverhaltens.  Es hilft Kunden und Serviceentwicklern, ein gemeinsames Verständnis zu erreichen, und ermöglicht es Ihnen, über Code zu sprechen.  Dies geht jedoch zu Lasten des Hinzufügens von Tools, der Einführung neuer Abstraktionen und zusätzlicher Aktionen von Teammitgliedern. <br><br>  Gleichzeitig werden CDC-Tools und Frameworks aktiv entwickelt und sind bereits ausgereift, um Ihre Projekte zu testen.  Test :) <br><br><blockquote>  Auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">QualityConf-</a> Konferenz vom 27. bis 28. Mai wird Andrei Markelov über Testtechniken für Produkte sprechen, und Arthur Khineltsev wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">über die Überwachung eines</a> hoch geladenen Frontends sprechen, wenn der Preis für selbst einen kleinen Fehler Zehntausende trauriger Benutzer beträgt. <br><br>  Kommen Sie und chatten Sie für Qualität! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452960/">https://habr.com/ru/post/de452960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452946/index.html">Lou Greenaws „Windows 95 / NT-Programmierphilosophie“ erneut lesen</a></li>
<li><a href="../de452952/index.html">JetBrains Tag der offenen Tür in St. Petersburg</a></li>
<li><a href="../de452954/index.html">Aufbau von Zeit, Netzwerkgeschwindigkeit und Routing: Wie wir unser Mesh-Netzwerk verbessert haben und ein bisschen über neuronale Netzwerke</a></li>
<li><a href="../de452956/index.html">Benchmark für den CPU-Verbrauch für Istio und Linkerd</a></li>
<li><a href="../de452958/index.html">JMAP - Ein offenes Protokoll ersetzt IMAP beim Austausch von E-Mails</a></li>
<li><a href="../de452962/index.html">Die Hauptursache für Unfälle in Rechenzentren ist das Verlegen zwischen Computer und Stuhl</a></li>
<li><a href="../de452964/index.html">Eine erschwingliche Erklärung der Riemannschen Hypothese</a></li>
<li><a href="../de452966/index.html">Der Mythos der Achtsamkeit: eine „neurozentrische“ Sicht der Meditation</a></li>
<li><a href="../de452968/index.html">Indizes in PostgreSQL - 10 (Bloom)</a></li>
<li><a href="../de452974/index.html">Asynchrone Programmierung (vollständiger Kurs)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>