<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😿 👨🏾‍🍳 ♌️ Segurança de aplicativos clientes: dicas práticas para um desenvolvedor front-end 👨‍👨‍👧‍👧 👩🏽‍🌾 🌀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como você sabe, a maioria dos ataques de hackers do BlackHat visa comprometer os dados do servidor de aplicativos e serviços da web. Ao mesmo tempo, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Segurança de aplicativos clientes: dicas práticas para um desenvolvedor front-end</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445932/"><p>  Como você sabe, a maioria dos ataques de hackers do BlackHat visa comprometer os dados do servidor de aplicativos e serviços da web.  Ao mesmo tempo, a parte do cliente é atacada pelo menos hoje.  De acordo com a definição seca, qualquer ataque é um conjunto de medidas por parte de um hacker direcionado à rede e transferência de dados, dados e sua substituição, infraestrutura e recursos técnicos da implementação do aplicativo da web.  Portanto, empresas internacionais exigem que os engenheiros de desenvolvimento adotem uma abordagem mais responsável e completa da segurança dos aplicativos clientes. </p><br><p> No exemplo do meu projeto, falarei sobre como os aplicativos clientes estão atacando hoje e como você pode evitar essas ameaças. </p><a name="habracut"></a><br><img alt="As 10 principais ameaças de 2013 a 2017" src="https://habrastorage.org/webt/ys/zg/d7/yszgd7tqw75npl5bx9pliitikte.jpeg"><br>  <i>As 10 principais ameaças para 2013 - 2017.</i> <br><br><p>  Como você pode ver, entre as principais ameaças, injeção, acionamento de erros, desvio de autenticação e dados confidenciais inseguros estão em primeiro lugar.  A ameaça de usar componentes com vulnerabilidades conhecidas ainda é relevante.  Novas ameaças também apareceram: invasão do mecanismo de controle de acesso, desserialização e serialização inseguras de dados, registro e monitoramento insuficientemente detalhados. </p><br><p>  Em 2001, Mark Curfy e Dennis Groves fundaram o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OWASP</a> (Open Web Application Security Project).  Este é um projeto internacional de código aberto para troca de experiências no combate a vulnerabilidades em aplicativos clientes, no qual um grande número de engenheiros de segurança de aplicativos participa.  A comunidade da OWASP enche o portal de vários artigos com informações sobre vulnerabilidades, materiais de treinamento, ferramentas para testar e repelir ataques.  Ataques reais são descritos, seus aspectos são revelados e o que precisa ser feito para evitar ameaças é descrito. </p><br><p>  Para entender quais ameaças são perigosas para um projeto, você precisa testá-lo completamente.  Para fazer isso, a rede possui aplicativos, estruturas e serviços online que identificam automaticamente certas vulnerabilidades.  Para testes locais, recomendo o uso de aplicativos e estruturas e, para testar projetos em operação, é muito útil adicionar serviços online também. </p><br><img src="https://habrastorage.org/webt/zh/c7/ll/zhc7lln_b43msp-lkz7ah0iapmw.jpeg"><br><br><p>  Mas mesmo que as ferramentas de teste não tenham informado nos relatórios sobre vulnerabilidades significativas (o que é improvável), ainda assim, preste atenção ao armazenamento de dados confidenciais no sistema de controle de versão, construindo o aplicativo, mecanismo de autenticação, algoritmo de hash de senha, criptografia de dados confidenciais e sistemas de registro e monitorar todo o aplicativo da web.  Nesse caso, é melhor jogar com segurança e não confiar na automação cega. </p><br><h2>  Git </h2><br><p>  Primeiro, vamos falar sobre dados confidenciais no Git.  Idealmente, um repositório separado de segredos é alocado para armazenar dados confidenciais.  A partir dele, durante a montagem para comissionamento, dados confidenciais são puxados e costurados no aplicativo.  Hoje, Hashicorp Vault, Keywhiz, segredos do Docker, Azure Key Vault e vários outros são populares. </p><br><p>  Mas e se você não tiver esse armazenamento?  Você pode usar ferramentas para codificar e ocultar arquivos com segredos que expandirão os recursos dos sistemas de controle de versão. </p><br><p> A primeira coisa que vem à mente é a solução universal BlackBox.  Pode ser usado com qualquer sistema de controle de versão, por exemplo, Mercurial, Git, etc.  Além disso, existem duas extensões para o Git: git-crypt e git-secret.  Eu recomendo usar o segundo, porque me pareceu o mais conveniente de usar e mais compreensível em termos de descrição na documentação oficial.  Após instalar o git-secret, você precisa inicializá-lo no repositório Git.  Lembre-se de especificar a extensão a ser usada no arquivo <b>.gitattributes</b> .  Em seguida, configure a acessibilidade dos segredos: identifique os usuários aos quais você deseja fornecer acesso a dados confidenciais.  Em seguida, adicione arquivos com dados confidenciais e <code>git-secret-hide</code> os através do <code>git-secret-hide</code> .  Você pode obter arquivos ocultos através do <code>git-secret-reveal.</code> </p><br> <code>brew install git-secret              //  <br> git secret init                      //  <br> git secret tell your@gpg.email       &amp;nbsp//   <br> git secret add &lt;files...&gt;             //   <br> git secret hide                      &amp;nbsp//   <br> git secret reveal                    &amp;nbsp//    <br></code> <br><h2>  Webpack </h2><br><p>  Outra maneira de eliminar ameaças é configurar o webpack corretamente.  Para se proteger contra ataques XSS, XEE e similares, considere aderir às políticas CORS (compartilhamento de recursos de origem cruzada) e CSP (Política de segurança de conteúdo).  Nos dois casos, é importante seguir os cabeçalhos para verificar a autenticidade de certos scripts usados ​​no projeto.  Os navegadores têm mecanismos para verificar a confiabilidade de uma fonte específica, por exemplo, o Safari emitirá avisos a cada etapa se o CORS e o CSP estiverem configurados incorretamente. </p><br><p>  Existem duas maneiras de cumprir o CORS e o CSP.  O primeiro é configurar os cabeçalhos para responder às solicitações no lado do servidor.  O segundo é registrar as duas políticas por meio de metatags e atributos.  O último método é recomendado se você tiver desenvolvedores de back-end preguiçosos, eles sempre estão ocupados e não estão interessados ​​em políticas de segurança.  As meta tags podem ser registradas imediatamente ao criar o aplicativo.  Plug-ins como html-webpack-plugin, html-webpack-exclude-assets-plugin, script-ext-html-webpack-plugin, csp-html-webpack-plugin e crypto nos ajudarão com isso.  Além disso, se você tiver recursos de terceiros em seu projeto (por exemplo, links para fontes externas usadas em CSS; recursos carregados da CDN e assim por diante), recomendo usar também o webpack-subresource-integridade-plugin.  Assim, você informará ao navegador que os recursos carregados no script são confiáveis, não há injeções neles, são inteiros e intocados.  E mesmo que alguém tenha injetado dados maliciosos no recurso e você o tenha carregado, você deve estar preparado para isso e proteger seu projeto contra essas ameaças. </p><br><p>  Quero prestar <b>especial atenção</b> à ordem em que as instâncias de classe para os plug-ins são criadas.  A ordem deve ser assim: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SHA256 = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) =&gt;</span></span> CRYPTO.createHash(<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>).update( str, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>).digest(<span class="hljs-string"><span class="hljs-string">'base64'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sha256Str = SHA256( <span class="hljs-string"><span class="hljs-string">''</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() ); […] <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HtmlWebpackPlugin({   <span class="hljs-attr"><span class="hljs-attr">filename</span></span>: <span class="hljs-string"><span class="hljs-string">'index.html'</span></span>,   <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">'public/index.html'</span></span> }), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ScriptExtHtmlWebpackPlugin({    <span class="hljs-attr"><span class="hljs-attr">custom</span></span>: [{           <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.js$/</span></span>,           <span class="hljs-attr"><span class="hljs-attr">attribute</span></span>: <span class="hljs-string"><span class="hljs-string">'nonce'</span></span>,           <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'nonce-'</span></span> + sha256Str    }] }), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HtmlWebpackExcludeAssetsPlugin(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CspHtmlWebpackPlugin({    <span class="hljs-string"><span class="hljs-string">'base-uri'</span></span>: <span class="hljs-string"><span class="hljs-string">'\'self\''</span></span>,    <span class="hljs-string"><span class="hljs-string">'object-src'</span></span>: <span class="hljs-string"><span class="hljs-string">'\'none\''</span></span>,    <span class="hljs-string"><span class="hljs-string">'script-src'</span></span>: [<span class="hljs-string"><span class="hljs-string">'\'self\''</span></span>, <span class="hljs-string"><span class="hljs-string">'\'unsafe-eval\''</span></span>, <span class="hljs-string"><span class="hljs-string">'\'nonce-'</span></span> + sha256Str + <span class="hljs-string"><span class="hljs-string">'\''</span></span>],    <span class="hljs-string"><span class="hljs-string">'style-src'</span></span>: [<span class="hljs-string"><span class="hljs-string">'\'unsafe-inline\''</span></span>, <span class="hljs-string"><span class="hljs-string">'\'self\''</span></span>] }, {    <span class="hljs-attr"><span class="hljs-attr">devAllowUnsafe</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,    <span class="hljs-attr"><span class="hljs-attr">enabled</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,    <span class="hljs-attr"><span class="hljs-attr">hashingMethod</span></span>: <span class="hljs-string"><span class="hljs-string">'sha256'</span></span> }), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SriPlugin({    <span class="hljs-attr"><span class="hljs-attr">hashFuncNames</span></span>: [<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>, <span class="hljs-string"><span class="hljs-string">'sha384'</span></span>],    <span class="hljs-attr"><span class="hljs-attr">enabled</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }), […]</code> </pre><br><p>  Em seguida, durante a montagem, a <code>&lt;hed&gt;</code> exibirá a <code>&lt;hed&gt;</code> <code>http-equiv=content-security-policy</code> .  As diretivas serão escritas no atributo <code>content</code> , que indica quais scripts e recursos podem ser confiáveis. </p><br><p>  A diretiva <code>base-uri</code> mostra qual URL base é usado para carregar scripts, CSS, imagens e muito mais. </p><br><p>  Os objetos geralmente não são carregados, portanto, defina <code>none</code> na diretiva <code>object-sr</code> c. </p><br><p>  A diretiva <code>script-src</code> se aplica aos scripts JS. </p><br><p>  Não se esqueça de registrar um atributo do tipo uma <code>nnce-&lt;hshVlue&gt;</code> cada vez.  Além disso, o hash deve ser calculado usando o algoritmo SHA256 ou SHA512. </p><br><p>  Quanto à diretiva <code>style-src</code> , nosso projeto tem uma peculiaridade: usamos componentes estilizados para escrever CSS para cada componente e isolá-los um do outro.  E, portanto, é necessário especificar que em nós o <code>style-src</code> <code>unsafe-inline</code> e o <code>self</code> são usados ​​no <code>style-src</code> , caso contrário, os componentes estilizados cairão. </p><br><br><img src="https://habrastorage.org/webt/9x/di/ny/9xdinyh5msrmdszkkdayka1tqya.jpeg"><br><br><p>  A tag de <code>script</code> será automaticamente definida como não <code>nnce-&lt;hshVlue&gt;</code> , <code>integrity</code> e <code>cross-origin</code> .  Eles informam ao navegador que os recursos estão sendo extraídos de fontes confiáveis.  Caso contrário, se o navegador perceber que o recurso não corresponde ao CSP ou ao CORS, ele simplesmente não carregará esse script ou arquivo CSS e escreverá algo no console como: <i>"Preste atenção neste script, nesta linha na qual você inicializa ele.</i>  <i>Olha, você tem algo errado!</i>  . </p><br><p>  A documentação <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MDN</a> , OWASP e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">W3C</a> fornece diretrizes para impor políticas CSP e CORS.  Além disso, quaisquer ferramentas de teste de penetração reportarão a conformidade com as regras CORS e CSP no projeto.  Qualquer estrutura ou ferramenta que realize testes automáticos de um projeto apontará falhas. </p><br><h2>  Autenticação de usuário </h2><br><p>  Usamos o OpenID Connect e o protocolo Kerberos.  Um padrão OpenID bastante comum é usado para autenticar usuários externos. </p><br><p>  O Kerberos é mais adequado para a rede interna, no banco é usado para autenticação automática de funcionários.  Suponha que exista uma máquina local na qual um funcionário da organização trabalhe.  Ele se autenticou uma vez nesta máquina e não precisará digitar o login e a senha novamente em nenhum lugar: o funcionário efetua login em qualquer aplicativo e o sistema a autentica imediatamente.  O Kerberos possui configurações sutis para a máquina local, e isso é difícil porque precisa ser configurado para <b>cada computador e cada navegador.</b>  Se o Internet Explorer normalmente puxa as configurações padrão e o Chrome puxa as configurações do IE, o Firefox precisa configurá-lo separadamente.  O Safari no MacOS X encontrará as configurações em si, mas para o Safari no Windows você precisará especificá-las manualmente. </p><br><p>  Você precisa verificar seu aplicativo em todos os navegadores, independentemente de onde quer que funcione.  Por exemplo, se eu trabalho no Windows, instalo o Safari localmente e testo meu projeto, e se trabalho no Mac, levanto o Windows em uma máquina virtual para executar o aplicativo nas versões correspondentes dos navegadores. </p><br><p>  A autenticação pode ser implementada em aplicativos modernos usando o Passport.js e pacotes de sessão expressa, além do SDK do Auth0. </p><br><p>  Se você não conseguir desenvolver um serviço de autenticação por meio do OpenID Connect ou de qualquer outro protocolo, use uma camada proxy, como Auth0 e similares, para que a autenticação ocorra através de uma empresa terceirizada especializada em fornecer aos usuários acesso seguro aos recursos da Internet. </p><br><p>  Quando atualizamos alguns aplicativos para o Node.js, recomendamos o uso de pacotes Passport.js, sessão expressa etc. no servidor.  Para garantir a segurança no cliente, aumentamos independentemente o componente para autenticação.  Não se esqueça de especificar o atributo de preenchimento automático desativado no formulário de autenticação para excluir o preenchimento automático dos campos do formulário. </p><br><h2>  Hash de senha </h2><br><p>  O site da OWASP recomenda que você não use mecanismos de hash de senha embutidos no banco de dados.  Para isso, é melhor usar pacotes como Argon2, PBKDF2, ccrypt e bcrypt.  Na minha prática, eu uso o Argon2 - este é um invólucro para algoritmos GCC, PGP / GPG, etc., mas requer que você instale primeiro o pacote GCC.  Esquema de uso do Argon2: </p><br><br><pre> <code class="bash hljs">1.  GCC &gt;= 4.8 install $ brew install gcc</code> </pre> <br><pre> <code class="bash hljs">2.     - $ npm install -g node-gyp</code> </pre> <br><pre> <code class="bash hljs">3.   Argon2 $ npm install argon2</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">4.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ARGON <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'argon2'</span></span>; ARGON.generateSalt().then( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">salt: string</span></span></span><span class="hljs-function">) =&gt;</span></span> {  ARGON.hash(<span class="hljs-string"><span class="hljs-string">'some-user-password'</span></span>, salt)    .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">hash : string</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Successfully created Argon2 hash:'</span></span>, hash);       <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> store the hash in the user database  }); }); argon2.verify( 'previously-created-argon-hash-here', 'some-user-password').then(() =&gt; {  console.log('Successful password supplied!');  // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> log the user in }).catch(() =&gt; {  console.log('Invalid password supplied!'); });</span></span></code> </pre> <br><h2>  Ofuscação </h2><br><p>  A ofuscação permite modificar o código para que ele não possa ser analisado em componentes.  Afinal, os atacantes - e não apenas eles - costumam usar engenharia reversa: o programador pega um arquivo JS e começa a analisar as fontes.  Assim, ele pode aprender os métodos usados ​​ou entender o mecanismo de trabalho de um script específico para implementar código malicioso.  Ou use esses mecanismos para invadir um aplicativo da Web e realizar um ataque furtivo. </p><br><p>  Os hackers não se metem em problemas.  Primeiro, eles conduzem a exploração do recurso, determinam as vulnerabilidades e o vetor de ataque.  Por exemplo, eles manipulam dados ou exploram vulnerabilidades contidas em protocolos de transporte.  O vetor de ataque pode ter como objetivo as vulnerabilidades de um sistema operacional específico; existem muitas em qualquer sistema UNIX.  Porém, as vulnerabilidades só podem ser usadas se o administrador tiver configurado políticas de segurança mal configuradas, por exemplo, definir URLs incorretos que saem para fora. </p><br><p>  Assim, para o reconhecimento, a engenharia reversa é usada.  É impossível excluí-lo completamente, mas pode ser muito difícil.  Para isso, vários ofuscadores são usados, no meu caso - javascript-obfuscator.  Com base nele, é feito um plugin para o webpack - webpack-obfuscator.  Também para o webpack criado obfuscator-loader.  Este pacote possui configurações recomendadas para diferentes níveis de paranóico: baixo, médio e alto, eles podem ser encontrados no site oficial.  Se você usar esse ofuscador, lembre-se de que ele funciona muito mal com o mecanismo de minificação incorporado ao webpack.  Não use minificação e ofuscação juntos, caso contrário, o ofuscador pode quebrar completamente o código do script. </p><br><p>  Além disso, o ofuscador aumenta o volume do script e seu carregamento.  Aqui você precisa decidir por si mesmo: ou aprimora a segurança, estabilidade e confiabilidade, mas perde em conveniência e velocidade;  se preocupam com a velocidade, mas esquecem a segurança, seguem as orientações. </p><br><h2>  Registro e monitoramento de ameaças </h2><br><p>  Existe uma ameaça como o uso de pacotes com vulnerabilidades já conhecidas.  Analisadores de ameaças como auditoria npm, Snyk e LGTM ajudarão nessas situações.  A auditoria Npm é um utilitário padrão incorporado ao npm, mas você precisa chamar constantemente esse comando ou criar muletas.  Portanto, aconselho você a usar o Snyk.  Este projeto possui seu próprio banco de dados com vulnerabilidades.  Quando você inicia o teste, o Snyk acessa esse banco de dados e faz o upload confidencial do relatório no seu projeto do Snyk, que não é acessível a pessoas de fora.  É verdade que você pode verificar seu projeto gratuitamente apenas 300 vezes e, ao verificar cada pré-confirmação, essas 300 tentativas gratuitas terminam muito rapidamente.  Portanto, é melhor executar um teste para ganchos de pré-push ou pré-mesclagem. </p><br><p>  O homem é a vulnerabilidade mais importante de qualquer sistema.  Portanto, verifique o projeto antes de começar a criar o aplicativo, porque até o código-fonte pode conter algo malicioso.  É bom quando apenas uma pessoa tem acesso ao projeto, mas geralmente trabalhamos em equipe.  E se algum tipo de “bem-querido” aparecesse e decidisse deixar a empresa “lindamente” e deixar uma marca?  Isso também deve ser lembrado. </p><br><p>  Eu recomendo usar o pacote Snyk desde o início do projeto e iniciar a verificação no console.  Tudo é simples aqui: após a instalação, defina o login e a senha da conta, e o teste em si pode ser realizado assim: </p><br><ul><li>  Após instalar a dependência npm i snyk —D e especificar “snyk”: true no package.json, execute: </li></ul><br><pre> <code class="bash hljs">./node_modules/.bin/snyk wizard --dev</code> </pre> <br><ul><li>  No package.json, adicione scripts e configurações: </li></ul><br><pre> <code class="javascript hljs">{ ... <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: {  ...  <span class="hljs-string"><span class="hljs-string">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run test:snyk &amp;&amp; npm run test:jest"</span></span>,  ...  <span class="hljs-string"><span class="hljs-string">"test:snyk"</span></span>: <span class="hljs-string"><span class="hljs-string">"snyk test --dev"</span></span>,  ...  <span class="hljs-string"><span class="hljs-string">"prepare"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run prepare:snyk"</span></span>,  <span class="hljs-string"><span class="hljs-string">"prepare:snyk"</span></span>: <span class="hljs-string"><span class="hljs-string">"snyk protect"</span></span> }, <span class="hljs-string"><span class="hljs-string">"husky"</span></span>: {  <span class="hljs-string"><span class="hljs-string">"hooks"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"commit-msg"</span></span>: <span class="hljs-string"><span class="hljs-string">"commitlint -E HUSKY_GIT_PARAMS"</span></span>,   <span class="hljs-string"><span class="hljs-string">"pre-commit"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run test:snyk &amp;&amp; npm run lint &amp;&amp; npm run test:jest"</span></span>,   <span class="hljs-string"><span class="hljs-string">"pre-push"</span></span>: [    <span class="hljs-string"><span class="hljs-string">"npm run test:snyk"</span></span>,    <span class="hljs-string"><span class="hljs-string">"npm run lint"</span></span>,    <span class="hljs-string"><span class="hljs-string">"npm run test:jest"</span></span>,    <span class="hljs-string"><span class="hljs-string">"npm run build:production"</span></span>   ],   ...  } }, <span class="hljs-string"><span class="hljs-string">"snyk"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><p>  Acima, analisamos uma verificação local em busca de ameaças à segurança.  Para verificar os pacotes em busca de ameaças conhecidas, também recomendo o uso do LGTM.  Use este projeto em conjunto com o GitHub ou o Bitbucket (até você tentar, não era necessário), e o código será verificado imediatamente a cada push. </p><br><h2>  Monitoramento de aplicativos </h2><br><p>  Na esfera do Front-end, as ferramentas já estão bem estabelecidas; ferramentas para todos os gostos estão disponíveis para registrar e monitorar a parte do cliente.  Os mais famosos são Sentry, TrackJS e InsightOps.  O Sentry Server pode ser implantado em seus servidores físicos.  Por exemplo, em nossos dois projetos, usamos um servidor separado, que foi totalmente configurado para registrar a operação de aplicativos.  Fomos para o URL e largamos todos os logs lá.  Se ocorrer um erro no aplicativo, ele será agrupado em um bloco try catch e enviado ao servidor Sentry por meio dos métodos do pacote raven.  Tudo é simples e conveniente.  Se você vê URLs obscuros no Sentry que não registrou, se vê incorporamentos ou mensagens obscuras, eles estão tentando invadir você.  Na minha prática, isso acontecia regularmente.  Por exemplo, um dos projetos - um serviço para contornar bloqueadores de anúncios e antivírus - estava constantemente tentando neutralizar e quebrá-lo. </p><br><p>  Para o monitoramento, eu também recomendo o uso do Grafana.  É importante considerar um sistema de critérios e indicadores que serão monitorados pelo sistema.  Ativamos o tráfego, o retorno da publicidade, o grau de exibição de anúncios, o número de banners provenientes do Yandex etc.  (projetos no grupo Rambler).  Precisávamos entender como o Yandex trabalha com nossas solicitações, porque é um serviço de terceiros, o que significa que precisa ser monitorado, porque, se falhar, todo o projeto poderá entrar em colapso completamente. </p><br><p>  Se você monitorar toda a comunicação com serviços de terceiros, encontrará rapidamente qualquer erro.  A história é da minha prática: vimos que a partir do Yandex, as respostas de publicidade deixaram de aparecer.  Aconteceu que eles tiveram problemas técnicos e toda a rede de publicidade caiu completamente.  E não foi a Yandex quem nos informou primeiro, mas ligamos para eles e pedimos para ver o que estava acontecendo com seus serviços. </p><br><p>  Qual é a melhor maneira de monitorar?  Pegue uma URL pequena, escreva os parâmetros GET e envie uma solicitação GET para esta URL.  No lado do servidor, processe esse URL, grave o log no banco de dados e aumente o monitoramento para o Grafana.  Tudo é simples. </p><br><p>  Isso é tudo.  No futuro, tentarei continuar escrevendo sobre o tópico de proteger aplicativos da Web contra ameaças.  Para todos que leram até o fim - desejo segurança aos seus projetos))) </p><br><h3>  Lista de fontes para leitura sobre o tópico: </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.owasp.org/index.php/Main_Page</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tproger.ru/translations/webapp-security</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">S. Hawks.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aplicativo de página única ainda mais rápido: segurança</a> </p><br><p>  Seacord, Robert C. O padrão de codificação segura CERT C / Robert C. Seacord.  - 2008 </p><br><p>  Chetan Karande.  Protegendo aplicativos de nó - 2017 </p><br><p>  Steven Palmer.  Vulnerabilidades de aplicativos da Web detectam, exploram e impedem - 2011 </p><br><p>  Robert Shimonski, Sean-Philip Oriyano.  Ataques e defesa do cliente - 2012 </p><br><p>  Marcus Pinto, Dafydd Stuttard.  O manual do hacker de aplicativos da Web: Encontrando e explorando falhas de segurança, 2ª edição - 2011 </p><br><p>  Karl Duuna.  Proteja seu aplicativo da web Node.js. - 2015 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt445932/">https://habr.com/ru/post/pt445932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt445920/index.html">Live: como restringir o desenvolvimento do iOS em grandes equipes</a></li>
<li><a href="../pt445922/index.html">Por que assistir transmissões online, se você pode ler Habr</a></li>
<li><a href="../pt445924/index.html">TESOUROS: quando os relógios inteligentes ficam estranhos</a></li>
<li><a href="../pt445926/index.html">O Programa Secreto de OVNIs dos EUA também pesquisou buracos de minhoca e dimensões extras.</a></li>
<li><a href="../pt445928/index.html">Como aumentamos a produtividade do serviço em Tensorflow em 70%</a></li>
<li><a href="../pt445936/index.html">Desenvolvimento de eletrônicos. Sobre microcontroladores nos dedos</a></li>
<li><a href="../pt445940/index.html">AMA com Habr, v 7.0. Limão, Rosquinhas e Notícias</a></li>
<li><a href="../pt445946/index.html">MWC: instruções de uso</a></li>
<li><a href="../pt445948/index.html">Herança em C ++: iniciante, intermediário, avançado</a></li>
<li><a href="../pt445952/index.html">Um trilhão de pequenos singles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>