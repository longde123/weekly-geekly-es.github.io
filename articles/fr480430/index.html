<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüåæ üë®‚Äçüî¨ ‚òÆÔ∏è Fonctionnement du codec vid√©o. Partie 2. Quoi, pourquoi, comment üï∂Ô∏è üîÇ üê£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partie I: notions de base sur la vid√©o et l'image 

  

 Quoi? Un codec vid√©o est un logiciel / mat√©riel qui compresse et / ou d√©compresse la vid√©o nu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fonctionnement du codec vid√©o. Partie 2. Quoi, pourquoi, comment</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/480430/"><h3>  Partie I: <a href="https://habr.com/ru/company/edison/blog/481418/">notions de base sur la vid√©o et l'image</a> </h3><br><hr><br> <a href="https://habr.com/ru/company/edison/blog/480430/"><img src="https://habrastorage.org/webt/ta/r8/lt/tar8ltvwz2ubkwwudgcjws-sa9a.png" alt="L'histoire de Kodek"></a> <br><br>  <b>Quoi?</b>  Un codec vid√©o est un logiciel / mat√©riel qui compresse et / ou d√©compresse la vid√©o num√©rique. <br><br>  <b>Pour quoi?</b>  Malgr√© certaines limitations en termes de bande passante, <br>  et en termes d'espace de stockage, le march√© a besoin de plus en plus de vid√©o de haute qualit√©.  Rappelez-vous comment dans le dernier article, nous avons calcul√© le minimum n√©cessaire pour 30 images par seconde, 24 bits par pixel, avec une r√©solution de 480x240?  Re√ßu 82,944 Mbps sans compression.  La compression est le seul moyen de transf√©rer HD / FullHD / 4K vers les √©crans de t√©l√©vision et Internet.  Comment y parvient-on?  Nous allons maintenant examiner bri√®vement les principales m√©thodes. <a name="habracut"></a><blockquote> <a href="https://www.edsd.ru/" title="Logiciel EDISON - d√©veloppement web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Logiciel EDISON - d√©veloppement web"></a> <br clear="right">  La traduction a √©t√© r√©alis√©e avec le soutien d'EDISON Software. <br><br>  Nous sommes engag√©s dans l' <a href="https://www.edsd.ru/integratsiya-sistem-videonablyudeniya-axxon-next-i-sureview-immix">int√©gration de syst√®mes de vid√©osurveillance</a> , ainsi que dans le <a href="https://www.edsd.ru/prilozhenie-dlya-mikrotomografa">d√©veloppement d'un microtomographe</a> . </blockquote><h3>  Codec vs Container </h3><br>  Une erreur courante pour les novices est de confondre un codec vid√©o num√©rique et un conteneur vid√©o num√©rique.  Un conteneur est un certain format.  Un wrapper contenant des m√©tadonn√©es vid√©o (et √©ventuellement audio).  La vid√©o compress√©e peut √™tre consid√©r√©e comme une charge utile de conteneur. <br><br>  En r√®gle g√©n√©rale, une extension de fichier vid√©o indique un type de conteneur.  Par exemple, le fichier video.mp4 est tr√®s probablement un <i>conteneur MPEG-4 Part 14</i> , et le fichier nomm√© video.mkv est tr√®s probablement une <a href="https://ru.wikipedia.org/wiki/Matroska">poup√©e</a> russe.  Pour √™tre totalement s√ªr du codec et du format de conteneur, vous pouvez utiliser <a href="https://www.ffmpeg.org/">FFmpeg</a> ou <a href="https://mediaarea.net/ru/MediaInfo">MediaInfo</a> . <br><br><h3>  Un peu d'histoire </h3><br>  Avant d'arriver √† <b>Comment?</b>  , plongeons dans un peu d'histoire pour mieux comprendre certains anciens codecs. <br><br>  Le codec vid√©o <b>H.261</b> est apparu en 1990 (techniquement - en 1988) et a √©t√© cr√©√© pour fonctionner avec un taux de transfert de donn√©es de 64 Kbps.  Il a d√©j√† utilis√© des id√©es telles que le sous-√©chantillonnage des couleurs, les macroblocs, etc.  En 1995, la norme de codec vid√©o <b>H.263 a</b> √©t√© publi√©e, qui s'est d√©velopp√©e jusqu'en 2001. <br><br>  En 2003, la premi√®re version de <b>H.264 / AVC a</b> √©t√© achev√©e.  La m√™me ann√©e, TrueMotion a publi√© son codec vid√©o gratuit qui compresse la vid√©o avec perte appel√©e <b>VP3</b> .  En 2008, Google a achet√© cette soci√©t√©, lib√©rant <b>VP8</b> la m√™me ann√©e.  En d√©cembre 2012, Google a publi√© <b>VP9</b> , et il est pris en charge dans environ les ¬æ du march√© des navigateurs (y compris les appareils mobiles). <br><br>  <b>AV1</b> est un nouveau codec vid√©o open source gratuit d√©velopp√© <b>par l'Open Media Alliance</b> ( <b>AOMedia</b> ), qui comprend des soci√©t√©s bien connues telles que Google, Mozilla, Microsoft, Amazon, Netflix, AMD, ARM, NVidia, Intel et Cisco .  La premi√®re version du codec 0.1.0 a √©t√© publi√©e le 7 avril 2016. <br><br><h3>  Naissance d'AV1 </h3><br>  D√©but 2015, Google a travaill√© sur <b>VP10</b> , Xiph (qui appartient √† Mozilla) a travaill√© sur <b>Daala</b> , et Cisco a cr√©√© son codec vid√©o gratuit appel√© <b>Thor</b> . <br><br>  Ensuite, <b>MPEG LA a d'</b> abord annonc√© des limites annuelles pour <b>HEVC</b> ( <b>H.265</b> ) et des frais 8 fois plus √©lev√©s que pour H.264, mais ils ont bient√¥t chang√© les r√®gles √† nouveau: <br><br>  pas de limite annuelle, <br>  frais de contenu (0,5% du chiffre d'affaires) et <br>  les co√ªts unitaires sont environ 10 fois plus √©lev√©s que pour le H.264. <br><br>  <i>L'Open Media Alliance a</i> √©t√© cr√©√©e par des entreprises de divers domaines: fabricants d'√©quipements (Intel, AMD, ARM, Nvidia, Cisco), fournisseurs de contenu (Google, Netflix, Amazon), fabricants de navigateurs (Google, Mozilla) et autres. <br><br>  Les entreprises avaient un objectif commun: un codec vid√©o sans redevances.  Vient ensuite <b>AV1</b> avec une licence de brevet beaucoup plus simple.  Timothy B. Terriberry a fait une pr√©sentation √©tonnante, qui est devenue la source du concept actuel d'AV1 et de son mod√®le de licence. <br><br>  Vous serez surpris d'apprendre que vous pouvez analyser le codec AV1 via un navigateur (les personnes int√©ress√©es peuvent aller sur <a href="http://aomanalyzer.org/">aomanalyzer.org</a> ). <br><br><img src="https://habrastorage.org/webt/wa/zz/tv/wazztvoifpc4l11k2_8jzdmiffk.png" alt="image"><br><br><h3>  Codec universel </h3><br>  Analysons les m√©canismes de base qui sous-tendent le codec vid√©o universel.  La plupart de ces concepts sont utiles et utilis√©s dans les codecs modernes tels que <b>VP9</b> , <b>AV1</b> et <b>HEVC</b> .  Je vous pr√©viens que beaucoup de choses expliqu√©es seront simplifi√©es.  Des exemples concrets seront parfois utilis√©s (comme c'est le cas avec H.264) pour d√©montrer la technologie. <br><br><h3>  1√®re √©tape - fractionnement de l'image </h3><br>  La premi√®re √©tape consiste √† diviser le cadre en plusieurs sections, sous-sections, etc. <br><br><img width="420" height="238" src="https://habrastorage.org/webt/lo/ze/q1/lozeq18ppa9po16q2ykeiazibpk.png" alt="image"><br><br>  Pour quoi?  Il y a plusieurs raisons.  Lorsque nous divisons l'image, nous pouvons pr√©dire plus pr√©cis√©ment le vecteur de mouvement √† l'aide de petites sections pour les petites pi√®ces mobiles.  Alors que pour un arri√®re-plan statique, vous pouvez vous limiter √† des sections plus grandes. <br><br>  En r√®gle g√©n√©rale, les codecs organisent ces sections en sections (ou fragments), macroblocs (ou blocs d'une arborescence de codage) et de nombreuses sous-sections.  La taille maximale de ces partitions varie, HEVC d√©finit 64x64, tandis qu'AVC utilise 16x16, et les sous-sections peuvent √™tre divis√©es en 4x4. <br><br>  Rappelez-vous les vari√©t√©s de cadres du dernier article?!  La m√™me chose peut √™tre appliqu√©e aux blocs, nous pouvons donc avoir un fragment I, un bloc B, un macrobloc P, etc. <br><br>  Pour ceux qui veulent s'entra√Æner, regardez comment l'image sera divis√©e en sections et sous-sections.  Pour ce faire, vous pouvez utiliser <a href="https://software.intel.com/en-us/video-pro-analyzer">Intel Video Pro Analyzer</a> d√©j√† mentionn√© dans l'article pr√©c√©dent (celui qui est pay√©, mais avec une version d'essai gratuite, qui a une limite sur les 10 premi√®res images).  Les sections de <b>VP9</b> sont analys√©es ici: <br><br><img width="711" height="370" src="https://habrastorage.org/webt/ub/n1/yh/ubn1yh-_d5n68swbd0bgc-lxbha.png" alt="image"><br><br><h3>  2e √©tape - pr√©vision </h3><br>  D√®s que nous avons des sections, nous pouvons y faire des pr√©visions <s>astrologiques</s> .  Pour la <b>pr√©diction INTER,</b> il est n√©cessaire de transf√©rer <b>les vecteurs de mouvement</b> et le reste, et pour la pr√©diction INTRA, la <b>direction de la pr√©vision</b> et le reste sont transmis. <br><br><h3>  3e √©tape - conversion </h3><br>  Apr√®s avoir obtenu le bloc r√©siduel (la section pr√©dite ‚Üí la section r√©elle), il est possible de le transformer de mani√®re √† savoir quels pixels peuvent √™tre supprim√©s, tout en conservant la qualit√© globale.  Certaines transformations fournissent un comportement pr√©cis. <br><br>  Bien qu'il existe d'autres m√©thodes, consid√©rons plus en d√©tail la <b>transform√©e en cosinus discr√®te</b> ( <b>DCT</b> - √† partir <i>de la transform√©e en cosinus discr√®te</i> ).  Caract√©ristiques cl√©s de DCT: <br><br><ul><li>  Convertit des blocs de pixels en blocs de coefficients de fr√©quence de taille √©gale. </li><li>  Scelle l'alimentation, contribuant √† √©liminer la redondance spatiale. </li><li>  Assure la r√©versibilit√©. </li></ul><br>  2 f√©vrier 2017 Sintra R.J.  (Cintra, RJ) et Bayer F.M.  (Bayer FM) a publi√© un article sur la conversion de type DCT pour la compression d'image, ne n√©cessitant que 14 ajouts. <br><br>  Ne vous inqui√©tez pas si vous ne comprenez pas les avantages de chaque article.  Maintenant, avec des exemples concrets, nous allons v√©rifier leur valeur r√©elle. <br><br>  Prenons un bloc de 8x8 pixels comme celui-ci: <br><br><img width="354" height="139" src="https://habrastorage.org/webt/tf/di/up/tfdiuplow4tut1aww2lrfydamyi.png" alt="image"><br><br>  Ce bloc est rendu dans l'image suivante 8 par 8 pixels: <br><br><img width="362" height="380" src="https://habrastorage.org/webt/rq/gj/hj/rqgjhjuplvgdadziupv-ogpdazo.png" alt="image"><br><br>  Appliquez DCT √† ce bloc de pixels et obtenez un bloc de coefficients de taille 8x8: <br><br><img width="623" height="141" src="https://habrastorage.org/webt/3c/oh/i8/3cohi8vd2yjmxurbzrfhlabc_ni.png" alt="image"><br><br>  Et si nous rendons ce bloc de coefficients, nous obtenons l'image suivante: <br><br><img width="401" height="328" src="https://habrastorage.org/webt/np/b0/v2/npb0v2_58_1hxinqekagzf6phzi.png" alt="image"><br><br>  Comme vous pouvez le voir, cela ne ressemble pas √† l'image d'origine.  Vous remarquerez peut-√™tre que le premier coefficient est tr√®s diff√©rent de tous les autres.  Ce premier coefficient est connu sous le nom de coefficient DC repr√©sentant tous les √©chantillons du tableau d'entr√©e, quelque chose de similaire √† la valeur moyenne. <br><br>  Ce bloc de coefficients a une propri√©t√© int√©ressante: il s√©pare les composants haute fr√©quence de ceux basse fr√©quence. <br><br><img width="293" height="129" src="https://habrastorage.org/webt/n0/4u/1z/n04u1zqlixaeggiw_yfg3umocsy.jpeg" alt="image"><br><br>  Dans l'image, la majeure partie de la puissance est concentr√©e √† des fr√©quences plus basses.Par cons√©quent, si vous convertissez l'image en ses composantes de fr√©quence et supprimez les coefficients de fr√©quence plus √©lev√©s, vous pouvez r√©duire la quantit√© de donn√©es n√©cessaires pour d√©crire l'image sans sacrifier trop la qualit√© de l'image. <blockquote>  La fr√©quence signifie √† quelle vitesse le signal change. </blockquote>  Essayons d'appliquer les connaissances acquises dans l'exemple de test en convertissant l'image d'origine √† sa fr√©quence (bloc de coefficients) √† l'aide de DCT, puis en supprimant certains des coefficients les moins importants. <br><br>  Tout d'abord, convertissez-le dans le domaine fr√©quentiel. <br><br><img width="623" height="141" src="https://habrastorage.org/webt/3c/oh/i8/3cohi8vd2yjmxurbzrfhlabc_ni.png" alt="image"><br><br>  Ensuite, nous √©liminons une partie (67%) des coefficients, principalement le c√¥t√© inf√©rieur droit. <br><br><img width="624" height="139" src="https://habrastorage.org/webt/h5/dq/ww/h5dqwwheilwuuasgm7xxijdxmt8.png" alt="image"><br><br>  Enfin, nous restaurons l'image √† partir de ce bloc de coefficients rejet√© (rappelez-vous, elle doit √™tre r√©versible) et comparons avec l'original. <br><br><img src="https://habrastorage.org/webt/6j/c6/1z/6jc61zgpg5r-vxxh3j0dxjeatha.png" alt="image"><br><br>  Nous voyons qu'elle ressemble √† l'image d'origine, mais il existe de nombreuses diff√©rences par rapport √† l'original.  Nous avons lanc√© 67,1875% et avons toujours obtenu quelque chose qui ressemble √† la source d'origine.  Vous pouvez plus d√©lib√©r√©ment supprimer les coefficients pour obtenir une image de qualit√© encore meilleure, mais c'est le sujet suivant. <blockquote><h4>  Chaque coefficient est g√©n√©r√© en utilisant tous les pixels. </h4><br><br>  Important: chaque coefficient n'est pas directement affich√© sur un pixel, mais est une somme pond√©r√©e de tous les pixels.  Ce graphique √©tonnant montre comment les premier et deuxi√®me coefficients sont calcul√©s en utilisant des poids uniques √† chaque indice. <br><br><img width="381" height="550" src="https://habrastorage.org/webt/ix/uv/hw/ixuvhwvqvclyzq6astn1d5vsaac.jpeg" alt="image"><br><br>  Vous pouvez √©galement essayer de visualiser le DCT en regardant une imagerie simple bas√©e sur celui-ci.  Par exemple, voici le symbole A g√©n√©r√© en utilisant chaque poids de coefficient: <br><br><img width="241" height="81" src="https://habrastorage.org/webt/oq/ua/3t/oqua3tnacmh7nsucvodymeqzqa0.gif" alt="image"></blockquote><br><br><h3>  4√®me √©tape - quantification </h3><br>  Apr√®s avoir jet√© quelques coefficients √† l'√©tape pr√©c√©dente, √† la derni√®re √©tape (transformation), nous produisons une forme de quantification sp√©ciale.  √Ä ce stade, il est permis de perdre des informations.  Ou, plus simplement, nous quantifierons les coefficients pour r√©aliser la compression. <br><br>  Comment quantifier un bloc de coefficients?  L'une des m√©thodes les plus simples sera la quantification uniforme, lorsque nous prenons un bloc, le divisons par une valeur (par 10) et arrondissons ce qui s'est pass√©. <br><br><img width="770" height="168" src="https://habrastorage.org/webt/i8/1a/os/i81aosymefwhnp0jboibq0dd_4i.png" alt="image"><br><br>  Pouvons-nous inverser ce bloc de coefficients?  Oui, nous pouvons, en multipliant par la m√™me valeur que nous avons divis√©e par. <br><br><img width="770" height="168" src="https://habrastorage.org/webt/ys/vs/51/ysvs514v-u_hrteesekxdrkjp9c.png" alt="image"><br><br>  Cette approche n'est pas la meilleure, car elle ne prend pas en compte l'importance de chaque coefficient.  On pourrait utiliser la matrice de quantification au lieu d'une seule valeur, et cette matrice pourrait utiliser la propri√©t√© DCT, quantifiant la majeure partie du coin inf√©rieur droit et une minorit√© du coin sup√©rieur gauche. <br><br><h3>  5 √©tapes - codage entropique </h3><br>  Apr√®s avoir quantifi√© les donn√©es (blocs d'images, fragments, cadres), nous pouvons toujours les compresser sans perte.  Il existe de nombreuses m√©thodes algorithmiques pour compresser les donn√©es.  Nous allons bri√®vement vous familiariser avec certains d'entre eux, pour une compr√©hension plus approfondie, vous pouvez lire le livre " <a href="https://www.amazon.com/Understanding-Compression-Data-Modern-Developers/dp/1491961538/">Comprendre la compression: compression de donn√©es pour les d√©veloppeurs modernes</a> " (" <a href="https://www.amazon.com/Understanding-Compression-Data-Modern-Developers/dp/1491961538/">Comprendre la compression: compression de donn√©es pour les d√©veloppeurs modernes</a> "). <br><br><h3>  Encodage vid√©o avec VLC </h3><br>  Supposons que nous ayons un flux de caract√®res: <b>a</b> , <b>e</b> , <b>r</b> et <b>t</b> .  La probabilit√© (allant de 0 √† 1) de la fr√©quence √† laquelle chaque symbole appara√Æt dans le flux est pr√©sent√©e dans ce tableau. <div class="scrollable-table"><table><tbody><tr><th></th><th>  un </th><th>  e </th><th>  r </th><th>  t </th></tr><tr><th>  Probabilit√© </th><td align="center">  0,3 </td><td align="center">  0,3 </td><td align="center">  0,2 </td><td align="center">  0,2 </td></tr></tbody></table></div>  Nous pouvons attribuer des codes binaires uniques (de pr√©f√©rence petits) aux codes les plus probables, et les plus grands moins probables. <div class="scrollable-table"><table><tbody><tr><th></th><th>  un </th><th>  e </th><th>  r </th><th>  t </th></tr><tr><th>  Probabilit√© </th><td align="center">  0,3 </td><td align="center">  0,3 </td><td align="center">  0,2 </td><td align="center">  0,2 </td></tr><tr><th>  Code binaire </th><td align="center">  0 </td><td align="center">  10 </td><td align="center">  110 </td><td align="center">  1110 </td></tr></tbody></table></div>  Nous compressons le flux, en supposant qu'√† la fin nous d√©pensons 8 bits pour chaque caract√®re.  Sans compression sur un caract√®re, 24 bits seraient n√©cessaires.  Si chaque caract√®re est remplac√© par son code, nous r√©alisons des √©conomies! <br><br>  La premi√®re √©tape consiste √† coder le caract√®re <b>e</b> , qui est 10, et le deuxi√®me caract√®re est <b>a</b> , qui est ajout√© (pas math√©matiquement): [10] [0], et enfin, le troisi√®me caract√®re <b>t</b> , ce qui rend notre flux binaire compress√© final √©gal [10] [0] [1110] ou <b>1001110</b> , qui ne n√©cessite que 7 bits (3,4 fois moins d'espace que dans l'original). <br><br>  Veuillez noter que chaque code doit √™tre un code unique avec un pr√©fixe.  <a href="https://en.wikipedia.org/wiki/Huffman_coding">L'algorithme de Huffman vous</a> aidera √† trouver ces nombres.  Bien que cette m√©thode ne soit pas sans d√©fauts, il existe des codecs vid√©o qui offrent toujours cette m√©thode algorithmique de compression. <br><br>  L'encodeur et le d√©codeur doivent avoir acc√®s √† la table des symboles avec leurs codes binaires.  Par cons√©quent, il est √©galement n√©cessaire d'envoyer une table en entr√©e. <br><br><h3>  Codage arithm√©tique </h3><br>  Supposons que nous ayons un flux de caract√®res: <b>a</b> , <b>e</b> , <b>r</b> , <b>s</b> et <b>t</b> , et leur probabilit√© est repr√©sent√©e par ce tableau. <div class="scrollable-table"><table><tbody><tr><th></th><th>  un </th><th>  e </th><th>  r </th><th>  s </th><th>  t </th></tr><tr><th>  Probabilit√© </th><td align="center">  0,3 </td><td align="center">  0,3 </td><td align="center">  0,15 </td><td align="center">  0,05 </td><td align="center">  0,2 </td></tr></tbody></table></div>  Avec ce tableau, nous construisons des plages contenant tous les caract√®res possibles, tri√©es par le plus grand nombre. <br><br><img width="713" height="86" src="https://habrastorage.org/webt/v2/et/wv/v2etwv7gqr0imlymbanupu6k3fw.png" alt="image"><br><br>  Maintenant, codons un flux de trois caract√®res: <b>manger</b> . <br><br>  Tout d'abord, s√©lectionnez le premier caract√®re <b>e</b> , qui se situe dans la sous-plage de 0,3 √† 0,6 (non compris).  On reprend cette sous-gamme et on la divise √† nouveau dans les m√™mes proportions qu'avant, mais d√©j√† pour cette nouvelle gamme. <br><br><img width="731" height="86" src="https://habrastorage.org/webt/fv/ra/lx/fvralxpih4rt9d6zowmweah5r8m.png" alt="image"><br><br>  Continuons √† coder notre flux de <b>manger</b> .  Maintenant, nous prenons le deuxi√®me symbole <b>a</b> , qui est dans la nouvelle sous-gamme de 0,3 √† 0,39, puis nous prenons notre dernier symbole <b>t</b> et, en r√©p√©tant le m√™me processus √† nouveau, nous obtenons la derni√®re sous-gamme de 0,354 √† 0,372. <br><br><img width="735" height="388" src="https://habrastorage.org/webt/eh/bj/nz/ehbjnz3uckrkkfoei5bt2gqh1zk.png" alt="image"><br><br>  Nous avons juste besoin de s√©lectionner un nombre dans la derni√®re sous-plage de 0,354 √† 0,372.  Choisissons 0,36 (mais vous pouvez choisir n'importe quel autre nombre dans cette sous-plage).  Ce n'est qu'avec ce nombre que nous pouvons restaurer notre flux d'origine.  C'est comme si nous dessinions une ligne √† l'int√©rieur des plages pour encoder notre flux. <br><br><img width="712" height="231" src="https://habrastorage.org/webt/a2/y2/ye/a2y2yerdhz8bied1n-4o8pqfiic.png" alt="image"><br><br>  L'op√©ration inverse (c'est-√†-dire le <i>d√©codage</i> ) est tout aussi simple: avec notre nombre 0,36 et notre plage initiale, nous pouvons d√©marrer le m√™me processus.  Mais maintenant, en utilisant ce num√©ro, nous r√©v√©lons le flux encod√© en utilisant ce num√©ro. <br><br>  Avec la premi√®re plage, nous remarquons que notre nombre correspond √† une tranche, c'est donc notre premier caract√®re.  Encore une fois, nous partageons cette sous-bande, effectuant le m√™me processus que pr√©c√©demment.  Ici, vous pouvez voir que 0,36 correspond au caract√®re <b>a</b> , et apr√®s avoir r√©p√©t√© le processus, nous arrivons au dernier caract√®re <b>t</b> (formant notre flux cod√© d'origine <b>eat</b> ). <br><br>  Le codeur et le d√©codeur doivent tous deux avoir une table de probabilit√©s de symboles, il est donc n√©cessaire de l'envoyer dans les donn√©es d'entr√©e. <br><br>  Assez √©l√©gant, non?  Quelqu'un qui a trouv√© cette solution √©tait sacr√©ment intelligent.  Certains codecs vid√©o utilisent cette technique (ou, dans tous les cas, la proposent en option). <br><br>  L'id√©e est de compresser un train de bits quantifi√© sans perte.  Certes, dans cet article, il n'y a pas de tonnes de d√©tails, de raisons, de compromis, etc.  Mais vous, si vous √™tes d√©veloppeur, devez en savoir plus.  De nouveaux codecs essaient d'utiliser diff√©rents algorithmes de codage entropique, tels que <b>ANS</b> . <br><br><h3>  6 √©tapes - format bitstream </h3><br>  Apr√®s avoir fait tout cela, il reste √† d√©compresser les trames compress√©es dans le cadre des √©tapes franchies.  Le d√©codeur doit √™tre explicitement inform√© des d√©cisions prises par le codeur.  Le d√©codeur doit √™tre fourni avec toutes les informations n√©cessaires: profondeur de bits, espace colorim√©trique, r√©solution, informations sur les pr√©visions (vecteurs de mouvement, pr√©diction INTER directionnelle), profil, niveau, fr√©quence d'images, type de trame, num√©ro de trame et bien plus encore. <br><br>  Nous allons jeter un ≈ìil au flux binaire <b>H.264</b> .  Notre premi√®re √©tape consiste √† cr√©er un flux binaire H.264 minimum (FFmpeg ajoute par d√©faut tous les param√®tres d'encodage, tels que <b>SEI NAL</b> - un peu plus loin, nous d√©couvrirons ce que c'est).  Nous pouvons le faire en utilisant notre propre r√©f√©rentiel et FFmpeg. <br><br> <code>./s/ffmpeg -i /files/i/minimal.png -pix_fmt yuv420p /files/v/minimal_yuv420.h264</code> <br> <br>  Cette commande va g√©n√©rer un <b>train de</b> bits <b>H.264</b> brut avec une trame, r√©solution 64x64, avec l'espace colorim√©trique <b>YUV420</b> .  L'image suivante est utilis√©e comme cadre. <br><br><img width="64" height="64" src="https://habrastorage.org/webt/dk/94/2b/dk942bnujajisjouk6zpwy9p5i8.png" alt="image"><br><br><h3>  Flux binaire H.264 </h3><br>  La <b>norme AVC</b> ( <b>H.264</b> ) d√©finit que les informations seront envoy√©es dans des macro-trames (dans la compr√©hension du r√©seau) appel√©es <b>NAL</b> (c'est un tel niveau d'abstraction du r√©seau).  L'objectif principal de NAL est de fournir une pr√©sentation vid√©o ¬´conviviale¬ª.  Cette norme devrait fonctionner sur les t√©l√©viseurs (bas√©s sur les flux), sur Internet (bas√©s sur les packages). <br><br><img width="484" height="41" src="https://habrastorage.org/webt/rd/8r/ag/rd8rag_9adq5fnhkh3bp1l84ljw.png" alt="image"><br><br>  Il existe un marqueur de synchronisation pour d√©finir les limites des √©l√©ments NAL.  Chaque marqueur de synchronisation contient la valeur <nobr><b>0x00 0x00 0x01,</b></nobr> √† l'exception du tout premier, qui est <nobr><b>0x00 0x00 0x00 0x01.</b></nobr>  Si nous <b>ex√©cutons hexdump</b> pour le flux binaire H.264 g√©n√©r√©, nous identifierons au moins trois mod√®les NAL au d√©but du fichier. <br><br><img width="451" height="250" src="https://habrastorage.org/webt/ow/vk/uj/owvkujuxd9qw-yft0b2tecxp3oq.png" alt="image"><br><br>  Comme indiqu√©, le d√©codeur doit conna√Ætre non seulement les donn√©es d'image, mais aussi les d√©tails de la vid√©o, la trame, la couleur, les param√®tres utilis√©s et bien plus encore.  Le premier octet de chaque NAL d√©finit sa cat√©gorie et son type. <div class="scrollable-table"><table><tbody><tr><th>  Identificateur de type NAL </th><th>  La description </th></tr><tr><td align="center">  0 </td><td>  Type inconnu </td></tr><tr><td align="center">  1 </td><td>  Fragment d'image cod√© sans IDR </td></tr><tr><td align="center">  2 </td><td>  Section de donn√©es de la tranche cod√©e <b>A</b> </td></tr><tr><td align="center">  3 </td><td>  Section <b>B des</b> donn√©es sur les tranches cod√©es </td></tr><tr><td align="center">  4 </td><td>  Section de donn√©es de tranche cod√©e <b>C</b> </td></tr><tr><td align="center">  5 </td><td>  Fragment IDR cod√© d'une image IDR </td></tr><tr><td align="center">  6 </td><td>  Informations suppl√©mentaires sur l'extension SEI </td></tr><tr><td align="center">  7 </td><td>  Ensemble de param√®tres de s√©quence SPS </td></tr><tr><td align="center">  8 </td><td>  Ensemble de param√®tres d'image PPS </td></tr><tr><td align="center">  9 </td><td>  D√©limiteur d'acc√®s </td></tr><tr><td align="center">  10 </td><td>  Fin de s√©quence </td></tr><tr><td align="center">  11 </td><td>  Fin du flux </td></tr><tr><td align="center">  ... </td><td>  ... </td></tr></tbody></table></div>  Habituellement, le premier flux binaire NAL est <b>SPS</b> .  Ce type de NAL est charg√© de signaler les variables de codage courantes, telles que le profil, le niveau, la r√©solution, etc. <br><br>  Si nous sautons le premier jeton de synchronisation, nous pouvons d√©coder le premier octet pour savoir quel type de NAL est le premier. <br><br>  Par exemple, le premier octet apr√®s le marqueur de synchronisation est <i>01100111</i> , o√π le premier bit ( <i>0</i> ) est dans le champ f <i>orbidden_zero_bit</i> .  Les 2 bits suivants ( <i>11</i> ) nous <i>indiquent le</i> champ <i>nal_ref_idc,</i> qui indique si ce NAL est un champ de r√©f√©rence ou non.  Et les 5 bits restants ( <i>00111</i> ) nous <i>indiquent le</i> champ <i>nal_unit_type,</i> dans ce cas il s'agit d'un bloc NAL SPS ( <i>7</i> ). <br><br>  Le deuxi√®me octet ( <i>binaire</i> = <i>01100100</i> , <i>hex</i> = <i>0x64</i> , <i>dec</i> = <i>100</i> ) dans SPS NAL est le champ <i>profile_idc,</i> qui montre le profil utilis√© par l'encodeur.  Dans ce cas, un profil haut limit√© a √©t√© utilis√© (c'est-√†-dire un profil haut sans support pour un segment B bidirectionnel). <br><br><img src="https://habrastorage.org/webt/xo/zt/wl/xoztwl_amtveehtmceuijr3wdsm.png" alt="image"><br><br>  Si nous nous familiarisons avec la sp√©cification du flux binaire <b>H.264</b> pour SPS NAL, nous trouverons de nombreuses valeurs pour le nom, la cat√©gorie et la description du param√®tre.  Par exemple, regardons les <i>champs</i> <i>pic_width_in_mbs_minus_1</i> et <i>pic_height_in_map_units_minus_1</i> . <div class="scrollable-table"><table><tbody><tr><th>  Nom du param√®tre </th><th>  Cat√©gorie </th><th>  La description </th></tr><tr><td>  pic_width_in_mbs_minus_1 </td><td align="center">  0 </td><td align="center">  ue (v) </td></tr><tr><td>  pic_height_in_map_units_minus_1 </td><td align="center">  0 </td><td align="center">  ue (v) </td></tr></tbody></table></div>  Si nous effectuons des op√©rations math√©matiques avec les valeurs de ces champs, nous obtenons la permission.  Vous pouvez imaginer <nobr>1920 x 1080 en</nobr> utilisant <i>pic_width_in_mbs_minus_1</i> avec une valeur de <nobr>119 ((119 + 1) * macroblock_size = 120 * 16 = 1920)</nobr> .  Encore une fois, pour √©conomiser de l'espace, au lieu de coder 1920, ils l'ont fait avec 119. <br><br>  Si nous continuons √† v√©rifier notre vid√©o cr√©√©e sous forme binaire (par exemple: <nobr><i>xxd -b -c 11 v / minimal_yuv420.h264</i></nobr> ), alors nous pouvons passer au dernier NAL, qui est l'image elle-m√™me. <br><br><img src="https://habrastorage.org/webt/fc/wt/ru/fcwtruw1ol7zkpc4osveloks_ri.png" alt="image"><br><br>  Ici, nous voyons ses 6 premi√®res valeurs d'octets: <i>01100101 10001000 10000100 00000000 00100001 11111111</i> .  Comme il est connu que le premier octet indique le type de NAL, dans ce cas ( <i>00101</i> ), il s'agit d'un fragment IDR (5), et il sera alors possible de l'√©tudier davantage: <br><br><img width="604" height="458" src="https://habrastorage.org/webt/ip/67/gh/ip67gh7uuxizfnt_5oko5oowohk.png" alt="image"><br><br>  En utilisant les informations de sp√©cification, il sera possible de d√©coder le type de fragment ( <i>slice_type</i> ) et le num√©ro de trame ( <i>frame_num</i> ) parmi d'autres champs importants. <br><br>  Pour obtenir les valeurs de certains champs ( <i>ue</i> ( <i>v</i> ), <i>me</i> ( <i>v</i> ), <i>se</i> ( <i>v</i> ) ou <i>te</i> ( <i>v</i> )), nous devons d√©coder le fragment √† l'aide d'un d√©codeur sp√©cial bas√© sur le <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BA%25D1%2581%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25BE%25D0%25B4_%25D0%2593%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25BC%25D0%25B1%25D0%25B0">code exponentiel de Golomb</a> .  Cette m√©thode est tr√®s efficace pour coder des valeurs de variable, en particulier lorsqu'il existe de nombreuses valeurs par d√©faut. <br><br>  Les valeurs <i>slice_type</i> et <i>frame_num</i> de cette vid√©o sont 7 (I-fragment) et 0 (premi√®re image). <br><br>  Le bitstream peut √™tre consid√©r√© comme un protocole.  Si vous souhaitez en savoir plus sur le flux binaire, vous devez vous r√©f√©rer √† la sp√©cification <b>UIT H.264</b> .  Voici une macro montrant o√π se trouvent les donn√©es d'image ( <b>YUV</b> sous forme compress√©e). <br><br><img src="https://habrastorage.org/webt/sh/ka/sf/shkasfvpn80vva4jfeoxk2be1pe.png" alt="image"><br><br>  Vous pouvez explorer d'autres flux binaires, tels que <b>VP9</b> , <b>H.265</b> ( <b>HEVC</b> ), ou m√™me notre nouveau meilleur flux binaire <b>AV1</b> .  Sont-ils tous pareils?  Non, mais en avoir trait√© au moins un est beaucoup plus facile √† comprendre le reste. <blockquote><h4>  Envie de pratiquer?  Explorez le flux binaire H.264 </h4><br>  Vous pouvez g√©n√©rer une vid√©o √† image unique et utiliser MediaInfo pour examiner le flux binaire <b>H.264</b> .  En fait, rien ne vous emp√™che m√™me de regarder le code source qui analyse le flux binaire <b>H.264</b> ( <b>AVC</b> ). <br><br><img src="https://habrastorage.org/webt/b0/n5/7v/b0n57v_h_gb2l2m0evkrhkukr_s.png" alt="image"><br><br>  Pour vous entra√Æner, vous pouvez utiliser Intel Video Pro Analyzer (j'ai d√©j√† dit que le programme est payant, mais existe-t-il une version d'essai gratuite avec une limite de 10 images?). <br><br><img src="https://habrastorage.org/webt/l9/63/ni/l963nix2wqornscrgdpzechdjq8.png" alt="image"></blockquote><h3>  Revue </h3><br>  Notez que de nombreux codecs modernes utilisent le m√™me mod√®le qu'ils viennent d'apprendre.  Ici, jetons un coup d'≈ìil au diagramme du codec vid√©o <b>Thor</b> .  Il contient toutes les mesures que nous avons prises.  L'int√©r√™t de cet article est pour vous de mieux comprendre les innovations et la documentation dans ce domaine. <br><br><img width="574" height="507" src="https://habrastorage.org/webt/7q/go/1s/7qgo1so0_mld4wglqvhan3ttwei.png" alt="image"><br><br>  Auparavant, il √©tait estim√© que 139 Go d'espace disque seraient n√©cessaires pour stocker un fichier vid√©o d'une heure avec une qualit√© de 720p et 30 ips.  Si vous utilisez les m√©thodes qui ont √©t√© discut√©es dans cet article (pr√©visions inter-trames et internes, conversion, quantification, codage entropique, etc.), alors vous pouvez r√©aliser (en supposant que nous d√©pensons 0,031 bits par pixel), la vid√©o est de qualit√© assez satisfaisante, ce qui prend seulement 367,82 Mo, pas 139 Go de m√©moire. <br><br><h3>  Comment le H.265 atteint-il un meilleur taux de compression que le H.264? </h3><br>  Maintenant que vous en savez plus sur le fonctionnement des codecs, il est plus facile de comprendre comment les nouveaux codecs peuvent fournir une r√©solution plus √©lev√©e avec moins de bits. <br><br>  Lorsque vous comparez <b>AVC</b> et <b>HEVC</b> , vous ne devez pas oublier que c'est presque toujours un choix entre une charge CPU et un taux de compression plus √©lev√©s. <br><br>  <b>HEVC</b> a plus d'options pour les sections (et sous-sections) que <b>AVC</b> , plus de directions pour les pr√©visions internes, un codage entropique am√©lior√©, et bien plus encore.  Toutes ces am√©liorations ont rendu <b>H.265</b> capable de compresser 50% de plus que <b>H.264</b> . <br><br><img src="https://habrastorage.org/webt/m3/jj/x8/m3jjx88-ppzrakex1sjxlinwjx8.png" alt="image"><br><br><hr><br><h3>  Partie I: <a href="https://habr.com/ru/company/edison/blog/481418/">notions de base sur la vid√©o et l'image</a> </h3><br><br><hr><br> <a href="https://habr.com/ru/company/edison/blog/485460/"><img align="right" width="404" height="150" src="https://habrastorage.org/webt/2b/9i/gm/2b9igmgpbxunecpetjj6hhqsa9m.png"></a> <br clear="left"><h4>  Lisez aussi le blog <br>  Soci√©t√© EDISON: </h4><br>  <a href="https://habr.com/ru/company/edison/blog/485460/"><b>20 biblioth√®ques pour</b></a> <a href="https://habr.com/ru/company/edison/blog/485460/"><b><br></b></a>  <a href="https://habr.com/ru/company/edison/blog/485460/"><b>application iOS spectaculaire</b></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480430/">https://habr.com/ru/post/fr480430/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480414/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 393 (9-15 d√©cembre 2019)</a></li>
<li><a href="../fr480416/index.html">Maths g√©n√©riques dangereux en C #</a></li>
<li><a href="../fr480422/index.html">Google Style Guide en C ++. Partie 1</a></li>
<li><a href="../fr480424/index.html">Google Style Guide en C ++. Partie 9</a></li>
<li><a href="../fr480428/index.html">La m√©thode de raccourci le plus simple. Alphabet et police pour elle.</a></li>
<li><a href="../fr480432/index.html">Le probl√®me du premier visualiseur ou la difficile conversion des flux vid√©o WebRTC en HLS</a></li>
<li><a href="../fr480438/index.html">√âv√©nements num√©riques √† Moscou du 16 au 22 d√©cembre</a></li>
<li><a href="../fr480440/index.html">√âv√©nements num√©riques √† Saint-P√©tersbourg du 16 au 22 d√©cembre</a></li>
<li><a href="../fr480444/index.html">D√©tective Habra: 24 heures de la vie de 24 publications</a></li>
<li><a href="../fr480446/index.html">√âcriture du proxy inverse Grafana sur Go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>