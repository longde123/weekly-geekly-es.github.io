<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘± ğŸ¤¾ğŸ¿ ğŸ¥ Sistem yang fleksibel untuk menguji dan mengumpulkan metrik program menggunakan LLVM test-suite sebagai contoh â›“ï¸ ğŸ§’ğŸ¼ ğŸ‘‚ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Sebagian besar pengembang jelas telah mendengar tentang beberapa perkembangan open-source yang cukup signifikan seperti sistem LLVM dan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistem yang fleksibel untuk menguji dan mengumpulkan metrik program menggunakan LLVM test-suite sebagai contoh</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428421/"><h2>  Pendahuluan </h2><br>  Sebagian besar pengembang jelas telah mendengar tentang beberapa perkembangan open-source yang cukup signifikan seperti sistem LLVM dan compiler dentang.  Namun, LLVM sekarang tidak hanya sistem itu sendiri untuk membuat kompiler, tetapi juga ekosistem besar yang mencakup banyak proyek untuk menyelesaikan berbagai masalah yang muncul selama tahap pembuatan kompiler (biasanya setiap proyek tersebut memiliki repositori terpisah sendiri).  Bagian dari infrastruktur secara alami termasuk alat pengujian dan benchmarking, seperti  ketika mengembangkan kompiler, efektivitasnya adalah indikator yang sangat penting.  Salah satu proyek infrastruktur uji LLVM individual ini adalah test-suite ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi</a> ). <br><br><h2>  Suite uji LLVM </h2><br>  Sepintas pada repositori test-suite, tampaknya ini hanya seperangkat tolok ukur dalam C / C ++, tetapi ini tidak sepenuhnya benar.  Selain kode sumber program tempat pengukuran kinerja akan dilakukan, uji-suite mencakup infrastruktur yang fleksibel untuk membangun, menjalankan, dan mengumpulkan metrik.  Secara default, ia mengumpulkan metrik berikut: waktu kompilasi, waktu eksekusi, waktu tautan, ukuran kode (dalam bagian). <br><a name="habracut"></a><br>  Test-suite secara alami berguna untuk pengujian dan penyusun benchmarking, tetapi juga dapat digunakan untuk beberapa tugas penelitian lainnya di mana beberapa basis kode C / C ++ diperlukan.  Mereka yang pernah melakukan upaya untuk melakukan sesuatu di bidang analisis data, saya pikir, dihadapkan dengan masalah kekurangan dan fragmentasi sumber data.  Suite uji, meskipun tidak terdiri dari sejumlah besar aplikasi, tetapi memiliki mekanisme pengumpulan data terpadu.  Menambahkan aplikasi Anda sendiri ke koleksi, mengumpulkan metrik yang diperlukan untuk tugas khusus Anda sangat sederhana.  Oleh karena itu, menurut pendapat saya, test-suite (selain tugas-tugas utama pengujian dan benchmarking) adalah pilihan yang baik untuk proyek dasar, di mana Anda dapat membangun pengumpulan data untuk tugas-tugas di mana Anda perlu menganalisis beberapa fitur dari kode program atau beberapa karakteristik dari program. <br><br><h3>  Struktur suite uji LLVM </h3><br><pre><code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">test</span></span>-suite |----CMakeLists.txt //  CMake ,   ,  | //   .. | |---- cmake | |---- .modules //        , | //   API    | |---- litsupport //  Python,      <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>-suite, | //    lit (  LLVM) | |---- tools //   :    | //     (    | // ),    .. | | //     | |---- SingleSource //   ,       | // .        . | |---- MultiSource //   ,      | //  .        | //  . | |---- MicroBenchmarks // ,   google-benchmark.   | //  ,    ,  | //       | |---- External //    ,     <span class="hljs-keyword"><span class="hljs-keyword">test</span></span>-suite,  | // ,     (  ) | // -   </code> </pre> <br>  Strukturnya sederhana dan mudah. <br><br><h3>  Prinsip kerja </h3><br>  Seperti yang Anda lihat, CMake dan format uji lit khusus bertanggung jawab untuk semua pekerjaan mendeskripsikan perakitan, peluncuran, dan pengumpulan metrik. <br><br>  Jika kami mempertimbangkannya dengan cara yang sangat abstrak, jelas bahwa proses pembandingan menggunakan sistem ini terlihat sederhana dan sangat dapat diprediksi: <br><img src="https://habrastorage.org/webt/5p/ny/s8/5pnys8slvpcfavbmriofq4lymrs.jpeg"><br><br>  Bagaimana ini terlihat lebih detail?  Pada artikel ini, saya ingin membahas peran CMake dalam seluruh sistem dan apa satu-satunya file yang harus Anda tulis jika Anda ingin menambahkan sesuatu ke sistem ini. <br><br>  <b>1. Membangun aplikasi uji.</b> <br><br>  Sebagai sistem build, ini telah menjadi standar de facto untuk program C / C ++ CMake.  CMake mengkonfigurasi proyek dan menghasilkan file make, ninja, dll. Tergantung pada preferensi pengguna.  untuk konstruksi langsung. <br>  Namun, dalam test-suite CMake menghasilkan tidak hanya aturan tentang cara membangun aplikasi, tetapi juga mengkonfigurasi tes itu sendiri. <br><br>  Setelah memulai CMake, file lain (dengan ekstensi .test) akan ditulis ke direktori build dengan deskripsi bagaimana aplikasi harus dijalankan dan diperiksa kebenarannya. <br><br>  Contoh file .test paling standar <br><br><pre> <code class="cmake hljs">RUN: cd &lt;some_path_to_build_directory&gt;/MultiSource/Benchmarks/Prolangs-C/football ; &lt;some_path_to_build_directory&gt;/MultiSource/Benchmarks/Prolangs-C/football/football VERIFY: cd &lt;some_path_to_build_directory&gt;/MultiSource/Benchmarks/Prolangs-C/football ; &lt;some_path_to_build_directory&gt;/tools/fpcmp %o football.reference_output</code> </pre><br>  File dengan ekstensi .test dapat berisi bagian-bagian berikut: <br><br><ul><li>  SIAPKAN - menjelaskan tindakan apa pun yang harus dilakukan sebelum meluncurkan aplikasi, sangat mirip dengan metode Sebelum yang ada dalam kerangka kerja unit pengujian yang berbeda; </li><li>  RUN - menjelaskan cara menjalankan aplikasi; </li><li>  VERIFIKASI - menjelaskan cara memeriksa operasi aplikasi yang benar; </li><li>  METRIC - menjelaskan metrik yang perlu dikumpulkan tambahan dalam standar. </li></ul><br>  Bagian mana pun dari ini dapat dihilangkan. <br><br>  Tetapi karena file ini dihasilkan secara otomatis, file CMake untuk benchmark yang menjelaskan: cara mendapatkan file objek, cara merakitnya ke dalam aplikasi, dan kemudian apa yang harus dilakukan dengan aplikasi ini. <br><br>  Untuk pemahaman yang lebih baik tentang perilaku default dan bagaimana ini dijelaskan, pertimbangkan contoh beberapa CMakeLists.txt <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">list</span></span>(APPEND CFLAGS -DBREAK_HANDLER -DUNICODE-pthread) <span class="hljs-comment"><span class="hljs-comment">#      (         ..     CMak,       ) list(APPEND LDFLAGS -lstdc++ -pthread) #      </span></span></code> </pre><br>  Bendera dapat diatur tergantung pada platform, file DetectArchitecture disertakan dalam modul cmake suite-uji, yang menentukan platform target tempat benchmark dijalankan, sehingga Anda dapat menggunakan data yang sudah dikumpulkan.  Data lain juga tersedia: sistem operasi, urutan byte, dll. <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(TARGET_OS <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"Linux"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>(APPEND CPPFLAGS -DC_LINUX) <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> ARCH <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"ARM"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ENDIAN <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"little"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>(APPEND CPPFLAGS -DFPU_WORDS_BIGENDIAN=<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ENDIAN <span class="hljs-keyword"><span class="hljs-keyword">STREQUAL</span></span> <span class="hljs-string"><span class="hljs-string">"big"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>(APPEND CPPFLAGS -DFPU_WORDS_BIGENDIAN=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">endif</span></span>()</code> </pre><br>  Pada prinsipnya, bagian ini seharusnya tidak menjadi sesuatu yang baru bagi orang-orang yang setidaknya pernah melihat atau menulis file CMake sederhana.  Secara alami, Anda dapat menggunakan perpustakaan, membangunnya sendiri, secara umum, menggunakan segala cara yang disediakan oleh CMake untuk menggambarkan proses membangun aplikasi Anda. <br><br>  Dan kemudian Anda perlu menyediakan pembuatan file .test.  Alat apa yang disediakan antarmuka tets-suite untuk ini? <br><br>  Ada 2 makro dasar <b>llvm_multisource</b> dan <b>llvm_singlesource</b> , yang cukup untuk sebagian besar kasus sepele. <br><br><ul><li>  <b>llvm_multisource</b> digunakan jika aplikasi terdiri dari beberapa file.  Jika Anda tidak meneruskan file kode sumber sebagai parameter saat memanggil makro ini di CMake Anda, maka semua file kode sumber yang terletak di direktori saat ini akan digunakan sebagai dasar untuk membangun.  Bahkan, perubahan saat ini sedang terjadi di antarmuka makro ini di test-suite, dan metode yang dijelaskan untuk mentransfer file sumber sebagai parameter makro adalah versi saat ini yang terletak di cabang utama.  Sebelumnya, ada sistem lain: file dengan kode sumber harus ditulis ke variabel Sumber (seperti pada rilis 7.0), dan makro tidak menerima parameter apa pun.  Tetapi logika dasar implementasi tetap sama. </li><li>  <b>llvm_singlesource</b> menganggap bahwa setiap file .c / .cpp adalah patokan terpisah dan untuk masing-masing mengumpulkan file yang dapat dieksekusi terpisah. </li></ul><br>  Secara default, kedua makro yang dijelaskan di atas untuk meluncurkan aplikasi yang dibangun menghasilkan perintah yang hanya memanggil aplikasi ini.  Dan pemeriksaan kebenaran terjadi karena perbandingan dengan output yang diharapkan terletak di file dengan ekstensi .reference_output (juga dengan kemungkinan suffix .reference_output.little-endian, .reference_output.big-endian). <br><br>  Jika ini cocok untuk Anda, itu bagus, satu baris tambahan (memanggil llvm_multisource atau llvm_singlesource) sudah cukup bagi Anda untuk memulai aplikasi dan mendapatkan metrik berikut: ukuran kode (dalam beberapa bagian), waktu kompilasi, waktu tautan, waktu eksekusi. <br><br>  Tapi, tentu saja, itu jarang terjadi dengan lancar.  Anda mungkin perlu mengubah satu atau beberapa tahapan.  Dan ini juga dimungkinkan dengan bantuan tindakan sederhana.  Satu-satunya hal yang perlu Anda ingat adalah bahwa jika Anda mendefinisikan ulang beberapa tahap, Anda perlu menggambarkan semua yang lain (bahkan jika algoritma default dari pakaian kerja mereka, yang, tentu saja, sedikit mengecewakan). <br><br>  Ada makro di API untuk menjelaskan tindakan di setiap tahap. <br><br>  <b>Tidak</b> ada banyak yang harus ditulis tentang makro <b>llvm_test_prepare</b> untuk tahap persiapan, perintah yang perlu Anda jalankan hanya diteruskan ke sana sebagai parameter. <br><br>  Apa yang mungkin diperlukan di bagian peluncuran?  Kasus yang paling dapat diprediksi adalah bahwa aplikasi menerima beberapa argumen, memasukkan file.  Untuk ini, ada makro <b>llvm_test_run</b> , yang hanya menerima argumen startup aplikasi (tanpa nama file yang dapat dieksekusi) sebagai parameter. <br><br><pre> <code class="cmake hljs">llvm_test_run(--fixed <span class="hljs-number"><span class="hljs-number">400</span></span> --cpu <span class="hljs-number"><span class="hljs-number">1</span></span> --num <span class="hljs-number"><span class="hljs-number">200000</span></span> --seed <span class="hljs-number"><span class="hljs-number">1158818515</span></span> run.hmm)</code> </pre><br>  Untuk mengubah tindakan pada tahap validasi, makro <b>llvm_test_verify digunakan</b> , yang menerima perintah apa pun sebagai parameter.  Tentu saja, untuk memverifikasi kebenarannya, lebih baik menggunakan alat yang termasuk dalam folder alat.  Mereka memberikan peluang bagus untuk membandingkan output yang dihasilkan dengan yang diharapkan (ada proses terpisah untuk membandingkan bilangan real dengan beberapa kesalahan, dll.).  Tetapi Anda bisa di suatu tempat dan hanya memeriksa bahwa aplikasi selesai dengan sukses, dll. <br><br><pre> <code class="cmake hljs">llvm_test_verify(<span class="hljs-string"><span class="hljs-string">"cat %o | grep -q 'exit 0'"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># %o -   placeholder   ,   lit.          lit,    ,    .    lit (  ,   LLVM)      (   &lt;a href="https://llvm.org/docs/CommandGuide/lit.html"&gt; &lt;/a&gt;)</span></span></code> </pre><br>  Tetapi bagaimana jika ada kebutuhan untuk mengumpulkan beberapa metrik tambahan?  Ada makro <b>llvm_test_metric</b> untuk <b>ini</b> . <br><br><pre> <code class="cmake hljs">llvm_test_metric(METRIC &lt; &gt; &lt;,   &gt;)</code> </pre><br>  Misalnya, untuk dhrystone, metrik khusus untuknya dapat diperoleh. <br><br><pre> <code class="cmake hljs">llvm_test_metric(METRIC dhry_score grep 'Dhrystones per Second' %o | awk '{print $<span class="hljs-number"><span class="hljs-number">4</span></span>}')</code> </pre><br>  Tentu saja, jika Anda perlu mengumpulkan metrik tambahan untuk semua tes, metode ini agak tidak nyaman.  Anda harus menambahkan panggilan llvm_test_metric ke makro tingkat lebih tinggi yang disediakan oleh antarmuka, atau Anda dapat menggunakan TEST_SUITE_RUN_UNDER (variabel CMake) dan skrip khusus untuk mengumpulkan metrik.  Variabel TEST_SUITE_RUN_UNDER cukup berguna, dan dapat digunakan, misalnya, untuk berjalan di simulator, dll.  Bahkan, sebuah perintah ditulis ke dalamnya yang akan menerima aplikasi dengan argumennya sebagai input. <br><br>  Sebagai hasilnya, kami mendapatkan beberapa formulir CMakeLists.txt <br><br><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#       llvm_test_run(--fixed 400 --cpu 1 --num 200000 --seed 1158818515 run.hmm) llvm_test_verify("cat %o | grep -q 'exit 0'") llvm_test_metric(METRIC score grep 'Score' %o | awk '{print $4}') llvm_multisource() # llvm_multisource(my_application)   </span></span></code> </pre><br>  Integrasi tidak memerlukan upaya tambahan, jika aplikasi sudah dibangun menggunakan CMake, maka dalam CMakeList.txt dalam test-suite Anda dapat menyertakan CMake yang ada untuk perakitan dan menambahkan beberapa panggilan makro sederhana. <br><br>  <b>2. Menjalankan tes</b> <br><br>  Sebagai hasil dari kerjanya, CMake menghasilkan file tes khusus sesuai dengan deskripsi yang ditentukan.  Tetapi bagaimana file ini dijalankan? <br><br>  lit selalu menggunakan beberapa file konfigurasi lit.cfg, yang, sesuai dengan itu, ada di dalam test-suite.  Dalam file konfigurasi ini, berbagai pengaturan untuk menjalankan tes ditunjukkan, termasuk format tes yang dapat dieksekusi.  Test-suite menggunakan formatnya sendiri, yang terletak di folder litsupport. <br><br><pre> <code class="python hljs">config.test_format = litsupport.test.TestSuiteTest()</code> </pre> <br>  Format ini dideskripsikan sebagai kelas uji yang diwarisi dari uji standar menyala dan menimpa metode utama dari antarmuka eksekusi.  Juga komponen penting dari litsupport adalah kelas dengan deskripsi rencana eksekusi tes TestPlan, yang menyimpan semua perintah yang harus dieksekusi pada tahapan yang berbeda dan mengetahui urutan tahapan.  Untuk memberikan fleksibilitas yang diperlukan, modul juga diperkenalkan ke dalam arsitektur yang harus menyediakan metode mutatePlan, di mana mereka dapat mengubah rencana pengujian, hanya memperkenalkan deskripsi kumpulan metrik yang diperlukan, menambahkan perintah tambahan untuk mengukur waktu untuk meluncurkan aplikasi, dll.  Karena solusi ini, arsitekturnya berkembang dengan baik. <br><br><img src="https://habrastorage.org/webt/a_/s4/6y/a_s46ygow0ah-bmfzx9jkezdysg.png"><br><br>  Contoh dari operasi uji test-suite (dengan pengecualian rincian dalam bentuk kelas TestContext, berbagai konfigurasi yang menyala dan tes itu sendiri, dll.) Disajikan di bawah ini. <br><br><img src="https://habrastorage.org/webt/5b/k9/1a/5bk91asgtn8ivhsr4pehhczdgrw.png"><br><br>  Lit menyebabkan tipe tes yang ditentukan dalam file konfigurasi dieksekusi.  TestSuiteTest mem-parsing file uji CMake yang dihasilkan, menerima deskripsi tahapan utama.  Kemudian, semua modul yang ditemukan dipanggil untuk mengubah rencana pengujian saat ini, peluncurannya diinstrumentasi.  Kemudian rencana pengujian yang diterima dijalankan: semuanya dilakukan sesuai dengan tahapan persiapan, peluncuran, dan validasi.  Jika perlu, pembuatan profil dapat dilakukan (ditambahkan oleh salah satu modul, jika variabel diatur selama konfigurasi yang menunjukkan perlunya pembuatan profil).  Langkah berikutnya adalah mengumpulkan metrik, fungsi untuk mengumpulkan yang ditambahkan oleh modul standar di bidang metric_collectors di TestPlan, dan kemudian metrik tambahan yang dijelaskan oleh pengguna di CMake dikumpulkan. <br><br>  <b>3. Menjalankan test-suite</b> <br><br>  Ada dua cara untuk menjalankan test-suite: <br><br><ul><li>  Manual, mis.  doa perintah berurutan. <pre> <code class="bash hljs">cmake -DCMAKE_CXX_COMPILER:FILEPATH=clang++ -DCMAKE_C_COMPILER:FILEPATH=clang <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite <span class="hljs-comment"><span class="hljs-comment">#  make #   llvm-lit . -o &lt;output&gt; #  </span></span></code> </pre></li><li>  menggunakan LNT (sistem lain dari ekosistem LLVM yang memungkinkan Anda untuk menjalankan tolok ukur, menyimpan hasil ke database, menganalisis hasil di antarmuka web).  LNT, dalam tim uji coba, melakukan langkah yang sama seperti pada paragraf sebelumnya. <br><pre> <code class="bash hljs">lnt runtest <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite --sandbox SANDBOX --cc clang --cxx clang++ --<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite</code> </pre> </li></ul><br>  Hasil untuk setiap tes ditampilkan sebagai <br><br><pre> <code class="bash hljs">PASS: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite :: MultiSource/Benchmarks/Prolangs-C/football/football.test (m of n) ********** TEST <span class="hljs-string"><span class="hljs-string">'test-suite :: MultiSource/Benchmarks/Prolangs-C/football/football.test'</span></span> RESULTS ********** compile_time: 1.1120 exec_time: 0.0014 <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span>: <span class="hljs-string"><span class="hljs-string">"38254c7947642d1adb9d2f1200dbddf7"</span></span> link_time: 0.0240 size: 59784 size..bss: 99800 â€¦ size..text: 37778 **********</code> </pre><br>  Hasil dari peluncuran yang berbeda dapat dibandingkan tanpa LNT (meskipun kerangka kerja ini memberikan peluang besar untuk menganalisis informasi menggunakan alat yang berbeda, tetapi perlu ditinjau secara terpisah), menggunakan skrip yang disertakan dalam test-suite <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite/utils/compare.py results_a.json results_b.json</code> </pre> <br>  Contoh membandingkan ukuran kode satu dan tolok ukur yang sama dari dua peluncuran: dengan flag -O3 dan -Os <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite/utils/compare.py -m size SANDBOX1/build/O3.json SANDBOX/build/Os.json Tests: 1 Metric: size Program O3 Os diff <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-suite...langs-C/football/football.test 59784 47496 -20.6%</code> </pre><br><h2>  Kesimpulan </h2><br>  Infrastruktur untuk menggambarkan dan menjalankan tolok ukur yang diterapkan dalam test-suite mudah digunakan dan didukung, berskala dengan baik, dan pada prinsipnya, menurut saya, menggunakan solusi yang cukup elegan dalam arsitekturnya, yang, tentu saja, menjadikan test-suite alat yang sangat berguna bagi pengembang. kompiler, serta sistem ini dapat dimodifikasi untuk digunakan dalam beberapa tugas analisis data. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428421/">https://habr.com/ru/post/id428421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428411/index.html">Teknologi Radar: Daftar Bahasa, Alat, dan Platform yang Melewati Tangan Lamoda</a></li>
<li><a href="../id428413/index.html">Sistem pendingin di pusat data Selectel</a></li>
<li><a href="../id428415/index.html">Tinjauan umum tentang pengontrol cloud TP-Link Omada OC200</a></li>
<li><a href="../id428417/index.html">Pembelajaran Mesin di MatLab / Oktaf: Contoh Algoritma yang Didukung oleh Rumus</a></li>
<li><a href="../id428419/index.html">Seret dan Geser di RecyclerView. Bagian 2: pengontrol seret dan lepas, kisi, dan animasi khusus</a></li>
<li><a href="../id428423/index.html">Bagaimana kesepakatan $ 34 miliar antara IBM dan Red Hat akan mengubah pasar TI: para ahli dan analis</a></li>
<li><a href="../id428429/index.html">GOST R 34.10 tanda tangan elektronik dari dokumen PDF di office suite LibreOffice</a></li>
<li><a href="../id428431/index.html">Lebih dari lapisan konsentris</a></li>
<li><a href="../id428433/index.html">Pengacara Pengujian Pribadi</a></li>
<li><a href="../id428435/index.html">Apa yang harus dibaca dalam PHP dalam bahasa Rusia?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>