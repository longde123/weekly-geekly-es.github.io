<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëéüèº üßôüèæ üê° Bloqueios no PostgreSQL: 4. Bloqueios na mem√≥ria üïµÔ∏è ü§ú üàöÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Deixe-me lembr√°-lo de que j√° conversamos sobre bloqueios de relacionamento , bloqueios em n√≠vel de linha , bloqueios de outros objetos (incluindo pred...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bloqueios no PostgreSQL: 4. Bloqueios na mem√≥ria</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/466199/">  Deixe-me lembr√°-lo de que j√° conversamos sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bloqueios de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relacionamento</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">, bloqueios em n√≠vel de linha</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bloqueios de outros objetos</a> (incluindo predicados) e sobre o relacionamento entre diferentes tipos de bloqueios. <br><br>  Hoje encerro esta s√©rie com um artigo sobre <strong>bloqueios de mem√≥ria</strong> .  Falaremos sobre spinlocks, bloqueios leves e bloqueio de buffer, bem como ferramentas de monitoramento e amostragem de expectativas. <br><br><img src="https://habrastorage.org/webt/2y/vt/2g/2yvt2gpimbdqmnibpzaiuf8qu0q.png"><br><a name="habracut"></a><br><h1>  Bloqueio de rota√ß√£o </h1><br>  Diferentemente dos bloqueios comuns, ‚Äúpesados‚Äù, os bloqueios mais leves e mais baratos (em termos de sobrecarga) s√£o usados ‚Äã‚Äãpara proteger estruturas na RAM compartilhada. <br><br>  Os mais simples deles s√£o <em>bloqueios de rota√ß√£o</em> ou <em>spinlocks</em> .  Eles foram projetados para capturar por um per√≠odo muito curto (v√°rias instru√ß√µes do processador) e proteger se√ß√µes individuais da mem√≥ria contra altera√ß√µes simult√¢neas. <br><br>  Os bloqueios de rota√ß√£o s√£o implementados com base em instru√ß√µes at√¥micas do processador, como comparar e trocar.  Eles suportam um √∫nico modo exclusivo.  Se o bloqueio estiver ocupado, o processo de espera executar√° uma espera ativa - o comando se repete ("gira" no loop, da√≠ o nome) at√© que seja executado com √™xito.  Isso faz sentido, pois os bloqueios de rota√ß√£o s√£o usados ‚Äã‚Äãquando a probabilidade de conflito √© estimada como muito baixa. <br><br>  Os bloqueios de rota√ß√£o n√£o fornecem detec√ß√£o de conflitos (os desenvolvedores do PostgreSQL est√£o monitorando isso) e n√£o fornecem nenhuma ferramenta de monitoramento.  Em geral, a √∫nica coisa que podemos fazer com os bloqueios de rota√ß√£o √© saber sobre sua exist√™ncia. <br><br><h1>  Fechaduras leves </h1><br>  Em seguida, v√™m as chamadas <em>fechaduras de luz</em> (fechaduras leves, fechaduras). <br><br>  Eles s√£o capturados pelo curto per√≠odo de tempo necess√°rio para trabalhar com a estrutura de dados (por exemplo, uma tabela de hash ou uma lista de ponteiros).  Como regra, uma trava leve n√£o √© mantida por muito tempo, mas, em alguns casos, uma trava leve protege as opera√ß√µes de E / S; portanto, em princ√≠pio, o tempo pode se tornar significativo. <br><br>  Dois modos s√£o suportados: exclusivo (para altera√ß√£o de dados) e compartilhado (somente leitura).  Como tal, n√£o h√° fila de espera: se v√°rios processos estiverem aguardando a libera√ß√£o do bloqueio, um deles obter√° acesso mais ou menos aleatoriamente.  Em sistemas com um alto grau de paralelismo e carga pesada, isso pode levar a efeitos desagrad√°veis ‚Äã‚Äã(ver, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">discuss√£o</a> ). <br><br>  Um mecanismo para verificar conflitos n√£o √© fornecido, isso permanece na consci√™ncia dos desenvolvedores do kernel.  No entanto, os bloqueios de luz t√™m ferramentas de monitoramento; portanto, diferentemente dos bloqueios de rota√ß√£o, eles podem ser "vistos" (um pouco mais tarde mostrarei como). <br><br><h1>  Buffer de clipe </h1><br>  Outro tipo de bloqueio que j√° discutimos no artigo sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cache</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">buffer</a> √© a <em>fixa√ß√£o do buffer</em> . <br><br>  Com um buffer fixo, voc√™ pode executar v√°rias a√ß√µes, incluindo altera√ß√£o de dados, mas com a condi√ß√£o de que essas altera√ß√µes n√£o sejam vis√≠veis para outros processos devido ao multi-versioning.  Ou seja, por exemplo, voc√™ pode adicionar uma nova linha √† p√°gina, mas n√£o pode substituir a p√°gina no buffer por outra. <br><br>  Se o processo √© dificultado pela liga√ß√£o, geralmente apenas ignora esse buffer e seleciona outro.  Mas, em alguns casos, quando esse buffer espec√≠fico √© necess√°rio, o processo fica em fila e adormece - o sistema o ativa quando a fixa√ß√£o √© removida. <br><br>  As expectativas de consolida√ß√£o est√£o dispon√≠veis para monitoramento. <br><br><h1>  Exemplo: cache de buffer </h1><br><img src="https://habrastorage.org/webt/gt/z8/gy/gtz8gylhroqbvj7jmwemqbd4jys.png"><br><br>  Agora, para obter algumas informa√ß√µes (incompletas!) Sobre como e onde os bloqueios s√£o usados, considere um exemplo de cache de buffer. <br><br>  Para acessar uma tabela de hash contendo refer√™ncias a buffers, o processo deve capturar um bloqueio de mapeamento de buffer de luz no modo compartilhado e, se a tabela precisar ser alterada, ent√£o no modo excepcional.  Para reduzir a granularidade, esse bloqueio √© organizado como uma <em>parcela</em> , consistindo em 128 bloqueios separados, cada um dos quais protege sua pr√≥pria parte da tabela de hash. <br><br>  O processo obt√©m acesso ao cabe√ßalho do buffer usando o bloqueio de rota√ß√£o.  Opera√ß√µes individuais (como incrementar o contador) tamb√©m podem ser executadas sem bloqueios expl√≠citos usando instru√ß√µes at√¥micas do processador. <br><br>  Para ler o conte√∫do de um buffer, √© necess√°rio um bloqueio de conte√∫do do buffer.  Normalmente, ele √© capturado apenas pelo tempo necess√°rio para ler os ponteiros para a vers√£o das linhas e, em seguida, a prote√ß√£o fornecida pelo clipe de buffer √© suficiente.  Para modificar o conte√∫do do buffer, esse bloqueio deve ser capturado no modo excepcional. <br><br>  Ao ler um buffer do disco (ou gravar no disco), o bloqueio de E / S em andamento tamb√©m √© capturado, o que sinaliza outros processos que a p√°gina est√° lendo (ou gravando) - eles podem enfileirar-se se tamb√©m precisarem fazer algo com esta p√°gina. <br><br>  Os ponteiros para liberar buffers e para a pr√≥xima v√≠tima s√£o protegidos por um √∫nico bloqueio de rota√ß√£o de estrat√©gia de buffer. <br><br><h1>  Exemplo: Buffers de Log </h1><br><img src="https://habrastorage.org/webt/_f/mu/ub/_fmuubhon3hualbtorx4rmjgur4.png"><br>  Outro exemplo: buffers de log. <br><br>  Para o cache do di√°rio, tamb√©m √© usada uma tabela de hash que cont√©m o mapeamento de p√°ginas para buffers.  Diferentemente do cache do buffer, essa tabela de hash √© protegida pelo √∫nico bloqueio leve do WALBufMappingLock, j√° que o tamanho do cache do di√°rio √© menor (geralmente 1/32 do cache do buffer) e o acesso aos buffers √© mais simplificado. <br><br>  A grava√ß√£o de p√°ginas no disco √© protegida por um leve bloqueio WALWriteLock, para que apenas um processo possa executar esta opera√ß√£o por vez. <br><br>  Para criar uma entrada no di√°rio, o processo deve primeiro reservar um espa√ßo na p√°gina WAL.  Para fazer isso, ele captura a trava de posi√ß√£o da inser√ß√£o da trava girat√≥ria.  Depois que um local √© reservado, o processo copia o conte√∫do de seu registro para o local designado.  A c√≥pia pode ser executada por v√°rios processos ao mesmo tempo, para os quais o registro √© protegido por uma tranche de 8 bloqueios f√°ceis de inser√ß√£o de bloqueio (o processo deve capturar <em>qualquer um</em> deles). <br><br>  A figura n√£o mostra todos os bloqueios relacionados ao log de pr√©-registro, mas este e o exemplo anterior devem dar uma id√©ia sobre o uso de bloqueios na RAM. <br><br><h1>  Monitoramento de expectativas </h1><br>  A partir do PostgreSQL 9.6, as ferramentas de monitoramento de espera s√£o incorporadas √† exibi√ß√£o pg_stat_activity.  Quando um processo (sistema ou servi√ßo) n√£o pode fazer seu trabalho e est√° esperando por algo, essa expectativa pode ser vista na exibi√ß√£o: a coluna wait_event_type indica o tipo de expectativa e a coluna wait_event indica o nome de uma expectativa espec√≠fica. <br><br>  Lembre-se de que uma exibi√ß√£o mostra apenas as expectativas que s√£o tratadas adequadamente no c√≥digo-fonte.  Se a vis√£o n√£o mostra a expectativa, isso geralmente n√£o significa com uma probabilidade de 100% que o processo realmente n√£o espere nada. <br><br>  Infelizmente, a √∫nica informa√ß√£o dispon√≠vel sobre as expectativas √© <em>a</em> informa√ß√£o <em>atual</em> .  Nenhuma estat√≠stica √© mantida.  A √∫nica maneira de obter uma imagem das expectativas ao longo do tempo √© <em>amostrando o</em> estado da vista em um intervalo espec√≠fico.  N√£o h√° meios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">internos</a> para isso, mas voc√™ pode usar extens√µes, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pg_wait_sampling</a> . <br><br>  √â necess√°rio levar em considera√ß√£o a natureza probabil√≠stica da amostragem.  Para obter uma imagem mais ou menos confi√°vel, o n√∫mero de medi√ß√µes deve ser grande o suficiente.  A amostragem em baixa frequ√™ncia pode n√£o fornecer uma imagem confi√°vel e aumentar a frequ√™ncia levar√° a um aumento na sobrecarga.  Pelo mesmo motivo, a amostragem √© in√∫til para analisar sess√µes de curta dura√ß√£o. <br><br>  Todas as expectativas podem ser divididas em v√°rios tipos. <br><br>  As expectativas dos bloqueios considerados comp√µem uma grande categoria: <br><br><ul><li>  aguardando bloqueios de objetos (valor de bloqueio na coluna wait_event_type); </li><li>  aguardando bloqueios de luz (LWLock); </li><li>  aguardando um buffer fixado (BufferPin). </li></ul><br>  Mas os processos podem esperar outros eventos: <br><br><ul><li>  As expectativas de E / S (E / S) ocorrem quando um processo precisa gravar ou ler dados; </li><li>  o processo pode aguardar os dados necess√°rios para o trabalho do cliente (cliente) ou de outro processo (IPC); </li><li>  extens√µes podem registrar suas expectativas espec√≠ficas (extens√£o). </li></ul><br>  H√° situa√ß√µes em que um processo simplesmente n√£o faz um trabalho √∫til.  Esta categoria inclui: <br><br><ul><li>  aguardando processos em segundo plano em seu loop principal (Activity); </li><li>  aguardando um temporizador (Timeout). </li></ul><br>  Como regra, essas expectativas s√£o "normais" e n√£o falam de nenhum problema. <br><br>  O tipo de expectativa √© seguido pelo nome da expectativa espec√≠fica.  A tabela completa pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na documenta√ß√£o</a> . <br><br>  Se nenhum nome de espera for especificado, o processo n√£o estar√° no estado de espera.  Esse tempo deve ser considerado <em>inexplic√°vel</em> , uma vez que, na verdade, n√£o se sabe exatamente o que est√° acontecendo neste momento. <br><br>  No entanto, √© hora de olhar. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pid, backend_type, wait_event_type, wait_event <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity;</code> </pre> <pre> <code class="plaintext hljs"> pid | backend_type | wait_event_type | wait_event -------+------------------------------+-----------------+--------------------- 28739 | logical replication launcher | Activity | LogicalLauncherMain 28736 | autovacuum launcher | Activity | AutoVacuumMain 28963 | client backend | | 28734 | background writer | Activity | BgWriterMain 28733 | checkpointer | Activity | CheckpointerMain 28735 | walwriter | Activity | WalWriterMain (6 rows)</code> </pre><br>  Pode-se observar que todos os processos do servi√ßo em segundo plano est√£o "brincando". Os valores vazios em wait_event_type e wait_event indicam que o processo n√£o est√° esperando nada - no nosso caso, o processo de veicula√ß√£o est√° ocupado executando a solicita√ß√£o. <br><br><h2>  Amostragem </h2><br>  Para obter uma imagem mais ou menos completa das expectativas usando a amostragem, usamos a extens√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pg_wait_sampling</a> .  Ele deve ser compilado a partir do c√≥digo fonte;  Eu vou omitir esta parte.  Em seguida, registramos a biblioteca no par√¢metro <em>shared_preload_libraries</em> e reiniciamos o servidor. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'pg_wait_sampling'</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Agora instale a extens√£o no banco de dados. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_wait_sampling;</code> </pre><br>  A extens√£o permite visualizar o hist√≥rico de expectativas, armazenado em um buffer circular.  Mas o mais interessante √© ver o perfil das expectativas - as estat√≠sticas acumuladas para todo o tempo de trabalho. <br><br>  Aqui est√° o que veremos em alguns segundos: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile;</code> </pre><pre> <code class="plaintext hljs"> pid | event_type | event | queryid | count -------+------------+---------------------+---------+------- 29074 | Activity | LogicalLauncherMain | 0 | 220 29070 | Activity | WalWriterMain | 0 | 220 29071 | Activity | AutoVacuumMain | 0 | 219 29069 | Activity | BgWriterMain | 0 | 220 29111 | Client | ClientRead | 0 | 3 29068 | Activity | CheckpointerMain | 0 | 220 (6 rows)</code> </pre><br>  Como nada aconteceu desde o in√≠cio do servidor, as principais expectativas s√£o do tipo Atividade (processos de servi√ßo aguardam at√© que o trabalho apare√ßa) e Cliente (psql aguarda o usu√°rio enviar uma solicita√ß√£o). <br><br>  Com as configura√ß√µes padr√£o (par√¢metro <em>pg_wait_sampling.profile_period</em> ), o per√≠odo de amostragem √© de 10 milissegundos, ou seja, os valores s√£o salvos 100 vezes por segundo.  Portanto, para estimar a dura√ß√£o da espera em segundos, o valor da contagem deve ser dividido por 100. <br><br>  Para entender a que pertencem as expectativas do processo, adicionamos a visualiza√ß√£o pg_stat_activity √† solicita√ß√£o: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+------------------------------+------+------------+----------------------+------- 29068 | checkpointer | | Activity | CheckpointerMain | 222 29069 | background writer | | Activity | BgWriterMain | 222 29070 | walwriter | | Activity | WalWriterMain | 222 29071 | autovacuum launcher | | Activity | AutoVacuumMain | 221 29074 | logical replication launcher | | Activity | LogicalLauncherMain | 222 29111 | client backend | psql | Client | ClientRead | 4 29111 | client backend | psql | IPC | MessageQueueInternal | 1 (7 rows)</code> </pre><br>  Vamos carregar com o pgbench e ver como a imagem muda. <br><br><pre> <code class="plaintext hljs">student$ pgbench -i test</code> </pre><br>  Redefinimos o perfil coletado para zero e executamos o teste por 30 segundos em um processo separado. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_wait_sampling_reset_profile();</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><br>  A solicita√ß√£o deve ser conclu√≠da antes que o processo pgbench seja conclu√≠do: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> a.application_name = <span class="hljs-string"><span class="hljs-string">'pgbench'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+----------------+---------+------------+------------+------- 29148 | client backend | pgbench | IO | WALWrite | 8 29148 | client backend | pgbench | Client | ClientRead | 1 (2 rows)</code> </pre><br>  Obviamente, as expectativas do processo pgbench ser√£o ligeiramente diferentes, dependendo do sistema espec√≠fico.  No nosso caso, √© muito prov√°vel que a espera de uma entrada de log (IO / WALWrite) seja apresentada, mas na maioria das vezes o processo n√£o parou, mas fez algo presumivelmente √∫til. <br><br><h2>  Fechaduras leves </h2><br>  Voc√™ deve sempre lembrar que a aus√™ncia de qualquer expectativa na amostragem n√£o significa que n√£o havia expectativa.  Se fosse mais curto que o per√≠odo de amostragem (o cent√©simo de segundo em nosso exemplo), simplesmente n√£o poderia cair na amostra. <br><br>  Portanto, os bloqueios de luz n√£o apareceram no perfil - mas aparecer√£o se voc√™ coletar dados por um longo tempo.  Para garantir uma olhada nelas, voc√™ pode desacelerar artificialmente o sistema de arquivos, por exemplo, usar o projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">slowfs</a> criado no sistema de arquivos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FUSE</a> . <br><br>  √â o que podemos ver no mesmo teste se qualquer opera√ß√£o de E / S demorar 1/10 de segundo. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_wait_sampling_reset_profile();</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> a.application_name = <span class="hljs-string"><span class="hljs-string">'pgbench'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+----------------+---------+------------+----------------+------- 29240 | client backend | pgbench | IO | WALWrite | 1445 29240 | client backend | pgbench | LWLock | WALWriteLock | 803 29240 | client backend | pgbench | IO | DataFileExtend | 20 (3 rows)</code> </pre><br>  Agora, a principal expectativa do processo pgbench est√° relacionada √† E / S, ou melhor, a uma entrada de log executada no modo s√≠ncrono com cada confirma√ß√£o.  Como (como mostrado no exemplo acima), a grava√ß√£o de um log no disco √© protegida pelo bloqueio de luz WALWriteLock, esse bloqueio tamb√©m est√° presente no perfil - quer√≠amos ver isso. <br><br><h2>  Buffer de clipe </h2><br>  Para ver a fixa√ß√£o do buffer, aproveitamos o fato de os cursores abertos prenderem o pino, para que a leitura da pr√≥xima linha seja mais r√°pida. <br><br>  Iniciamos a transa√ß√£o, abrimos o cursor e selecionamos uma linha. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgbench_history; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> tid | bid | aid | delta | mtime | filler -----+-----+-------+-------+----------------------------+-------- 9 | 1 | 35092 | 477 | 2019-09-04 16:16:18.596564 | (1 row)</code> </pre><br>  Verifique se o buffer est√° fixado (pinning_backends): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'pgbench_history'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> relforknumber = <span class="hljs-number"><span class="hljs-number">0</span></span> \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+------ bufferid | 190 relfilenode | 47050 reltablespace | 1663 reldatabase | 16386 relforknumber | 0 relblocknumber | 0 isdirty | t usagecount | 1 pinning_backends | 1 &lt;--   1 </code> </pre><br>  Agora vamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">limpar a</a> mesa: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| pg_backend_pid | ---------------- | 29367 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> pgbench_history;</code> </pre><pre> <code class="plaintext hljs">| INFO: vacuuming "public.pgbench_history" | INFO: "pgbench_history": found 0 removable, 0 nonremovable row versions in 1 out of 1 pages | DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 732651 | There were 0 unused item pointers.</code> </pre><pre> <code class="plaintext hljs">| Skipped 1 page due to buffer pins, 0 frozen pages.</code> </pre><pre> <code class="plaintext hljs">| 0 pages are entirely empty. | CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. | VACUUM</code> </pre><br>  Como podemos ver, a p√°gina foi pulada (1 p√°gina pulada devido aos pinos do buffer).  De fato, a limpeza n√£o pode lidar com isso, porque √© proibido excluir fisicamente vers√µes de linha de uma p√°gina em um buffer fixado.  Mas a limpeza n√£o ir√° esperar - a p√°gina ser√° processada na pr√≥xima vez. <br><br>  E agora faremos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">limpeza com congelamento</a> : <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FREEZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> pgbench_history;</code> </pre><br>  Com um congelamento claramente solicitado, voc√™ n√£o pode pular uma √∫nica p√°gina que n√£o esteja marcada no mapa de congelamento - caso contr√°rio, √© imposs√≠vel reduzir a idade m√°xima das transa√ß√µes descongeladas em pg_class.relfrozenxid.  Portanto, a limpeza trava at√© o cursor fechar. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-string"><span class="hljs-string">'pgbench_history'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> age ----- 27 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; <span class="hljs-comment"><span class="hljs-comment">--   </span></span></code> </pre><br><pre> <code class="plaintext hljs">| INFO: aggressively vacuuming "public.pgbench_history" | INFO: "pgbench_history": found 0 removable, 26 nonremovable row versions in 1 out of 1 pages | DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 732651 | There were 0 unused item pointers.</code> </pre><pre> <code class="plaintext hljs">| Skipped 0 pages due to buffer pins, 0 frozen pages.</code> </pre><pre> <code class="plaintext hljs">| 0 pages are entirely empty. | CPU: user: 0.00 s, system: 0.00 s, elapsed: 3.01 s. | VACUUM</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-string"><span class="hljs-string">'pgbench_history'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> age ----- 0 (1 row)</code> </pre><br>  Bem, vejamos o perfil de expectativas da segunda sess√£o psql na qual os comandos VACUUM foram executados: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> p.pid, a.backend_type, a.application_name <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> app, p.event_type, p.event, p.count <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_wait_sampling_profile p <span class="hljs-keyword"><span class="hljs-keyword">LEFT JOIN</span></span> pg_stat_activity a <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.pid = a.pid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> p.pid = <span class="hljs-number"><span class="hljs-number">29367</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p.pid, p.count <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | backend_type | app | event_type | event | count -------+----------------+------+------------+------------+------- 29367 | client backend | psql | BufferPin | BufferPin | 294 29367 | client backend | psql | Client | ClientRead | 10 (2 rows)</code> </pre><br>  O tipo de espera BufferPin indica que a libera√ß√£o estava aguardando a libera√ß√£o do buffer. <br><br>  Sobre isso, assumiremos que conclu√≠mos os bloqueios.  Obrigado a todos por sua aten√ß√£o e coment√°rios! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466199/">https://habr.com/ru/post/pt466199/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466187/index.html">Editor de l√≥gica visual para Unity3d. Parte 2</a></li>
<li><a href="../pt466191/index.html">A principal coisa sobre a batalha pela neutralidade da rede nos EUA √© a cronologia dos eventos e o estado atual das coisas</a></li>
<li><a href="../pt466193/index.html">Feed autom√°tico personalizado do MailChimp a partir do feed RSS</a></li>
<li><a href="../pt466195/index.html">PVS-Studio 7.04</a></li>
<li><a href="../pt466197/index.html">PVS-Studio 7.04</a></li>
<li><a href="../pt466201/index.html">Como deixar a ci√™ncia em TI e se tornar um testador: a hist√≥ria de uma carreira</a></li>
<li><a href="../pt466203/index.html">Dia Techdir em S√£o Petersburgo. Cerveja, pizza, dois microfones</a></li>
<li><a href="../pt466211/index.html">Linha principal do projeto no Android 10</a></li>
<li><a href="../pt466213/index.html">4 etapas para criar um perfil de candidato</a></li>
<li><a href="../pt466215/index.html">Projeto orientado a modelo. Cria√ß√£o de um modelo confi√°vel, usando o exemplo de um trocador de calor para avia√ß√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>