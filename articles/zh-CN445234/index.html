<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👩‍👦 👨🏿‍⚖️ 💑 现在将Python异常视为反模式 👩🏿‍🚒 🙎 ‼️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="有什么例外？ 顾名思义，它们是在程序中发生异常时出现的。 您可能会问为什么异常是一种反模式，它们与输入有何关系？ 我试图弄清楚 ，现在我想和你一起讨论这个问题，harazhiteli。 

 例外问题 
 很难发现您每天面对的问题。 习惯和盲目性将错误变成功能，但是让我们尝试以开放的态度看待异常。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>现在将Python异常视为反模式</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/445234/"> 有什么例外？ 顾名思义，它们是在程序中发生异常时出现的。 您可能会问为什么异常是一种反模式，它们与输入有何关系？ 我试图<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">弄清楚</a> ，现在我想和你一起讨论这个问题，harazhiteli。 <br><br><h2> 例外问题 </h2><br> 很难发现您每天面对的问题。 习惯和盲目性将错误变成功能，但是让我们尝试以开放的态度看待异常。 <br><br><h3> 很难发现例外 </h3><br> 异常有两种类型：“显式”是通过在您正在阅读的代码中直接调用<code>raise</code>来创建的；  “隐藏”隐藏在使用的函数，类，方法中。 <br><br> 问题在于，“隐藏”异常确实很难注意到。 让我向您展示一个纯函数的示例： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: float, second: float)</span></span></span><span class="hljs-function"> -&gt; float:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first / second</code> </pre><br> 该函数简单地将一个数除以另一个，返回<code>float</code> 。 检查类型，然后您可以运行以下命令： <br><br><pre> <code class="python hljs">result = divide(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) print(<span class="hljs-string"><span class="hljs-string">'x / y = '</span></span>, result)</code> </pre><br> 你注意到了吗？ 实际上，该程序的执行将永远无法实现<code>print</code> ，因为将1除以0是不可能的操作，它将引发<code>ZeroDivisionError</code> 。 是的，这样的代码是类型安全的，但是无论如何都不能使用。 <br><a name="habracut"></a><br> 为了即使在这种简单易读的代码中也要注意潜在的问题，需要经验。  Python中的任何内容都可以停止使用不同类型的异常：除法，函数调用， <code>int</code> ， <code>str</code> ，生成器，循环中的迭代器，对属性或键的访问。 甚至<code>raise something()</code>也可能导致崩溃。 而且，我什至没有提到输入和输出操作。 并且在不久的将来<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将不再支持检查的异常</a> 。 <br><br><h3> 无法恢复正常行为 </h3><br> 但恰恰在这种情况下，我们有例外。 让我们只处理<code>ZeroDivisionError</code> ，代码将变为类型安全。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: float, second: float)</span></span></span><span class="hljs-function"> -&gt; float:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first / second <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ZeroDivisionError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span></code> </pre><br> 现在一切都很好。 但是为什么我们返回0？ 为什么不选择1或<code>None</code> ？ 当然，在大多数情况下，获取<code>None</code>几乎和异常一样糟（如果不是更糟），但是使用该功能仍然需要依靠业务逻辑和选项。 <br><br> 我们到底分享了什么？ 任意数字，任何特定单位或金额？ 并非每个选项都易于预见和恢复。 可能会导致您下次使用一个功能时，您需要使用不同的恢复逻辑。 <br><br><blockquote> 可悲的结论是：每个问题的解决方案都是个别的，具体取决于使用的具体情况。 </blockquote><br> 没有一劳永逸地解决<code>ZeroDivisionError</code> 。 而且，我们并不是在讨论带有重复请求和超时的复杂I / O的可能性。 <br><br> 也许没有必要精确地处理异常发生的地方？ 也许只是将其放入代码执行过程中-稍后有人会弄清楚。 然后我们被迫回到目前的局势。 <br><br><h3> 执行过程不清楚 </h3><br> 好吧，让我们希望其他人能够捕获并处理该异常。 例如，系统可能要求用户更改输入的值，因为它不能被0 <code>divide</code>并且<code>divide</code>功能不应明确负责从错误中恢复。 <br><br> 在这种情况下，您需要检查我们在哪里捕获到异常。 顺便说一句，如何确定确切的处理位置？ 是否可以在代码中找到正确的位置？ 事实证明，不， <strong>这是不可能的</strong> 。 <br><br> 无法确定引发异常后将执行哪一行代码。 可以使用<code>except</code>选项<code>except</code>选项处理不同类型的异常，并且可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">忽略</a>某些异常。 而且，您可以在其他模块中抛出其他异常，这些异常将更早执行，并且通常会破坏所有逻辑。 <br><br> 假设应用程序中有两个独立的线程：从上到下运行的常规线程，以及根据需要运行的异常线程。 如何阅读和理解此代码？ <br><br> 仅在“捕获所有异常”模式下打开调试器。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8k/bn/do/8kbndolwukkaluarfk3vpexws2w.png"></div><br> 像臭名昭著的<code>goto</code>类的异常会破坏程序结构。 <br><br><h3> 异常不是唯一的 </h3><br> 让我们看另一个示例：通常的远程HTTP API访问代码： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_user_profile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user_id: int)</span></span></span><span class="hljs-function"> -&gt; 'UserProfile':</span></span> <span class="hljs-string"><span class="hljs-string">"""Fetches UserProfile dict from foreign API."""</span></span> response = requests.get(<span class="hljs-string"><span class="hljs-string">'/api/users/{0}'</span></span>.format(user_id)) response.raise_for_status() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.json()</code> </pre><br> 在此示例中，实际上一切都可能出错。 以下是部分可能的错误列表： <br><br><ul><li> 网络可能不可用，该请求将根本不会执行。 </li><li> 服务器可能无法正常工作。 </li><li> 服务器可能太忙，将发生超时。 </li><li> 服务器可能需要身份验证。 </li><li>  API可能没有这样的URL。 </li><li> 可能存在不存在的用户。 </li><li> 可能没有足够的权利。 </li><li> 处理您的请求时，服务器可能由于内部错误而崩溃 </li><li> 服务器可能返回无效或损坏的响应。 </li><li> 服务器可能会返回无法解析的无效JSON。 </li></ul><br> 清单不胜枚举，不幸的三行代码中有许多潜在的问题。 我们可以说，它通常只能靠幸运的机会才能发挥作用，而且很有可能会出现例外情况。 <br><br><h2> 如何保护自己？ </h2><br> 既然我们已经确定了异常可能对代码有害，那么让我们找出如何消除它们。 要无例外地编写代码，有不同的模式。 <br><br><ul><li>  <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">except Exception: pass</a></code>地方都写。 死胡同。  <strong>不要这样做。</strong> </li><li> 不返回<code>None</code> 。 太邪恶了。 结果， <code>if something is not None:</code> ，您将不得不几乎以每行开始<code>if something is not None:</code>并且所有逻辑将在清理检查的垃圾后面丢失，否则您将一直遭受<code>TypeError</code>困扰。 不是一个好选择。 </li><li> 为特殊用例编写类。 例如，具有子类的<code>User</code>基类具有<code>UserNotFound</code>和<code>MissingUser</code>类的错误。 可以在某些特定情况下使用此方法，例如Django中的<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AnonymousUser</a></code> ，但是将所有可能的错误包装在类中是不现实的。 这将需要太多的工作，并且域模型将变得难以想象的复杂。 </li><li> 使用容器将结果变量或错误值包装在包装器中，然后继续使用容器值。 这就是为什么我们创建<code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@dry-python/return</a></code>项目的原因。 这样该函数将返回有意义，类型化和安全的内容。 </li></ul><br> 让我们回到除法示例，该示例在发生错误时返回0，是否可以明确表明函数不返回特定数值就不会成功？ <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> returns.result <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Result, Success, Failure <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: float, second: float)</span></span></span><span class="hljs-function"> -&gt; Result[float, ZeroDivisionError]:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Success(first / second) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ZeroDivisionError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> exc: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Failure(exc)</code> </pre><br> 我们将值包含在两个包装器之一中： <code>Success</code>或<code>Failure</code> 。 这些类是从<code>Result</code>基类继承的。 可以使用返回的函数在批注中指定打包值的类型，例如， <code>Result[float, ZeroDivisionError]</code>返回<code>Success[float]</code>或<code>Failure[ZeroDivisionError]</code> 。 <br><br> 这给了我们什么？ 更多的<strong>例外并非例外，但这是预期的问题</strong> 。 另外，将异常包装在“ <code>Failure</code>解决了第二个问题：识别潜在异常的复杂性。 <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> + divide(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment"># =&gt; mypy error: Unsupported operand types for + ("int" and "Result[float, ZeroDivisionError]")</span></span></code> </pre><br> 现在，它们很容易发现。 如果您在代码中看到<code>Result</code> ，则该函数可能会引发异常。 您甚至可以提前知道他的类型。 <br><br> 此外，该库是完全类型化的，并且<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">与PEP561兼容</a> 。 也就是说，如果您尝试返回与声明的类型不匹配的内容，mypy将警告您。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> returns.result <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Result, Success, Failure <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: float, second: float)</span></span></span><span class="hljs-function"> -&gt; Result[float, ZeroDivisionError]:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Success(<span class="hljs-string"><span class="hljs-string">'Done'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># =&gt; error: incompatible type "str"; expected "float" except ZeroDivisionError as exc: return Failure(0) # =&gt; error: incompatible type "int"; expected "ZeroDivisionError"</span></span></code> </pre><br><h3> 如何使用容器？ </h3><br> 有两种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">方法</a> ： <br><br><ul><li>  <code>map</code>返回正常值的函数； </li><li>  <code>bind</code>返回其他容器的函数。 </li></ul><br><pre> <code class="python hljs">Success(<span class="hljs-number"><span class="hljs-number">4</span></span>).bind(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> number: Success(number / <span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># =&gt; Success(2) Success(4).map(lambda number: number + 1) # =&gt; Success(5)</span></span></code> </pre><br> 这样做的好处是，此代码将保护您免受失败的脚本的攻击，因为<code>.bind</code>和<code>.map</code>不会对具有<code>Failure</code>容器执行： <br><br><pre> <code class="python hljs">Failure(<span class="hljs-number"><span class="hljs-number">4</span></span>).bind(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> number: Success(number / <span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># =&gt; Failure(4) Failure(4).map(lambda number: number / 2) # =&gt; Failure(4)</span></span></code> </pre><br> 现在，您可以专注于正确的执行过程，并确保错误的状态不会在意外的地方中断程序。 而且总是有机会<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">确定错误的状态，进行更正</a> ，然后返回到流程的构想路径。 <br><br><pre> <code class="python hljs">Failure(<span class="hljs-number"><span class="hljs-number">4</span></span>).rescue(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> number: Success(number + <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># =&gt; Success(5) Failure(4).fix(lambda number: number / 2) # =&gt; Success(2)</span></span></code> </pre><br> 在我们的方法中，“所有问题都是单独解决的”，“执行过程现在是透明的”。 享受编程的乐趣！ <br><br><h3> 但是如何从容器中扩展价值呢？ </h3><br> 确实，如果您使用对容器一无所知的函数，那么您本身就需要这些值。 然后，您可以使用<code>.unwrap()</code>或<code>.value_or()</code>方法： <br><br><pre> <code class="python hljs">Success(<span class="hljs-number"><span class="hljs-number">1</span></span>).unwrap() <span class="hljs-comment"><span class="hljs-comment"># =&gt; 1 Success(0).value_or(None) # =&gt; 0 Failure(0).value_or(None) # =&gt; None Failure(1).unwrap() # =&gt; Raises UnwrapFailedError()</span></span></code> </pre><br> 等等，我们不得不摆脱异常，现在事实证明，所有<code>.unwrap()</code>调用都可能导致另一个异常？ <br><br><h3> 如何不考虑UnwrapFailedErrors？ </h3><br> 好的，让我们看看如何使用新的异常。 考虑以下示例：您需要检查用户输入并在数据库中创建两个模型。 每个步骤都可能以异常结束，这就是为什么所有方法都包装在<code>Result</code> ： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> returns.result <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Result, Success, Failure <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateAccountAndUser</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Creates new Account-User pair."""</span></span> <span class="hljs-comment"><span class="hljs-comment"># </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> we need to create a pipeline of these methods somehow... def _validate_user( self, username: str, email: str, ) -&gt; Result['UserSchema', str]: """Returns an UserSchema for valid input, otherwise a Failure.""" def _create_account( self, user_schema: 'UserSchema', ) -&gt; Result['Account', str]: """Creates an Account for valid UserSchema's. Or returns a Failure.""" def _create_user( self, account: 'Account', ) -&gt; Result['User', str]: """Create an User instance. If user already exists returns Failure."""</span></span></code> </pre><br> 首先，您根本不必在自己的业务逻辑中扩展价值： <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateAccountAndUser</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Creates new Account-User pair."""</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, username: str, email: str)</span></span></span><span class="hljs-function"> -&gt; Result['User', str]:</span></span> <span class="hljs-string"><span class="hljs-string">"""Can return a Success(user) or Failure(str_reason)."""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._validate_user( username, email, ).bind( self._create_account, ).bind( self._create_user, ) <span class="hljs-comment"><span class="hljs-comment"># ...</span></span></code> </pre><br> 一切都会正常进行，不会<code>.unwrap()</code>任何异常，因为不使用<code>.unwrap()</code> 。 但是阅读这样的代码容易吗？ 不行 还有什么选择？  <code>@pipeline</code> ： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> result.functions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pipeline <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateAccountAndUser</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Creates new Account-User pair."""</span></span> @pipeline <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, username: str, email: str)</span></span></span><span class="hljs-function"> -&gt; Result['User', str]:</span></span> <span class="hljs-string"><span class="hljs-string">"""Can return a Success(user) or Failure(str_reason)."""</span></span> user_schema = self._validate_user(username, email).unwrap() account = self._create_account(user_schema).unwrap() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._create_user(account) <span class="hljs-comment"><span class="hljs-comment"># ...</span></span></code> </pre><br> 现在，这段代码已经很好地阅读了。 这是<code>.unwrap()</code>和<code>@pipeline</code>一起工作的方式：每当<code>.unwrap()</code>方法失败和<code>Failure[str]</code> ， <code>@pipeline</code>装饰器将其捕获并返回<code>Failure[str]</code>作为结果值。 这就是我建议从代码中删除所有异常并使之真正安全和键入的方式。 <br><br><h2> 全部包裹在一起 </h2><br> 好的，现在我们将应用新工具，例如，对HTTP API的请求。 还记得每行都可以抛出异常吗？ 而且没有办法让他们用<code>Result</code>返回容器。 但是您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@safe装饰器</a>来包装不安全的函数并使它们安全。 以下是两个执行相同操作的代码选项： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> returns.functions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> safe @safe <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: float, second: float)</span></span></span><span class="hljs-function"> -&gt; float:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first / second <span class="hljs-comment"><span class="hljs-comment"># is the same as: def divide(first: float, second: float) -&gt; Result[float, ZeroDivisionError]: try: return Success(first / second) except ZeroDivisionError as exc: return Failure(exc)</span></span></code> </pre><br> 第一个使用<code>@safe</code> ，更易于阅读。 <br><br>  API请求示例中的最后一件事是添加<code>@safe</code>装饰器。 结果是以下代码： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> returns.functions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pipeline, safe <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> returns.result <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Result <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FetchUserProfile</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Single responsibility callable object that fetches user profile."""</span></span> <span class="hljs-comment"><span class="hljs-comment">#: You can later use dependency injection to replace `requests` #: with any other http library (or even a custom service). _http = requests @pipeline def __call__(self, user_id: int) -&gt; Result['UserProfile', Exception]: """Fetches UserProfile dict from foreign API.""" response = self._make_request(user_id).unwrap() return self._parse_json(response) @safe def _make_request(self, user_id: int) -&gt; requests.Response: response = self._http.get('/api/users/{0}'.format(user_id)) response.raise_for_status() return response @safe def _parse_json(self, response: requests.Response) -&gt; 'UserProfile': return response.json()</span></span></code> </pre><br>  <strong>总结如何摆脱异常并保护代码</strong> ： <br><br><ul><li> 对可能引发异常的所有方法使用<code>@safe</code>包装器。 它将函数的返回类型更改为<code>Result[OldReturnType, Exception]</code> 。 </li><li> 使用<code>Result</code>作为容器，可以将值和错误转换为简单的抽象。 </li><li> 使用<code>.unwrap()</code>扩展容器中的值。 </li><li> 使用<code>@pipeline</code>使<code>.unwrap</code>调用<code>.unwrap</code>更易于阅读。 </li></ul><br> 通过遵守这些规则，我们可以做完全相同的事情-只有安全且易于阅读。 解决了所有与异常有关的问题： <br><br><ul><li>  <strong>“很难发现例外</strong> 。 <strong>”</strong> 现在，将它们包装在一个类型化的<code>Result</code>容器中，这使它们完全透明。 </li><li>  <strong>恢复正常行为是不可能的</strong> 。 <strong>”</strong> 现在，您可以安全地将恢复过程委托给调用方。 对于这种情况，有<code>.fix()</code>和<code>.rescue()</code> 。 </li><li>  <strong>“执行的顺序尚不清楚</strong> 。 <strong>”</strong> 现在，它们是具有通常业务流程的一种。 从头到尾。 </li><li>  <strong>“例外并不例外</strong> 。 <strong>”</strong> 我们知道！ 并且我们希望某些事情会出错并且为任何事情做好准备。 </li></ul><br><h3> 用例和限制 </h3><br> 显然，您不能在所有代码中都使用这种方法。 对于大多数日常情况而言，它<strong>太安全了</strong> ，并且与其他库或框架不兼容。 但是，您必须完全按照我的说明编写业务逻辑中最重要的部分，以确保系统正确运行并促进将来的支持。 <br><br><blockquote> 这个话题会让您思考甚至看起来像霍利瓦尔尼吗？  4月5日来到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">莫斯科Python Conf ++</a> ，我们将进行讨论！ 除了我之外，干Python项目的创始人和Django Channels的核心开发人员Artyom Malyshev也将在那里。 他<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将</a>更多地讨论干Python和业务逻辑。 </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN445234/">https://habr.com/ru/post/zh-CN445234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN445220/index.html">AMD Radeon VII：高端芯片（第3部分）</a></li>
<li><a href="../zh-CN445222/index.html">在宇宙航行日的1天之内给后端团队一个报价</a></li>
<li><a href="../zh-CN445226/index.html">研制能够到达月球的火箭将耗资俄罗斯7,400亿卢布</a></li>
<li><a href="../zh-CN445228/index.html">Java中的密码学。 Mac类</a></li>
<li><a href="../zh-CN445230/index.html">开始为初学者SMARTRHINO-2019举行的II IT会议的注册</a></li>
<li><a href="../zh-CN445236/index.html">“ NOW至尊论坛2019”：注册开放</a></li>
<li><a href="../zh-CN445238/index.html">成长：Mobius 2018莫斯科的十大报道</a></li>
<li><a href="../zh-CN445240/index.html">如何廉价，快速地移动，上传和集成非常大的数据？ 下推式优化是什么？</a></li>
<li><a href="../zh-CN445242/index.html">协程和改造2的经验</a></li>
<li><a href="../zh-CN445244/index.html">“区块链之外的金钱游戏必须消亡”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>