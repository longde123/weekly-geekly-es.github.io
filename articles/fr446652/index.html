<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕🏼 🤟🏽 👩🏼‍🚀 MVCC-4. Instantanés de données ✊🏽 👨🏿‍🚀 🔣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Après avoir examiné les problèmes liés à l' isolement et fait une digression sur l' organisation des données à un bas niveau , la dernière fois que no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-4. Instantanés de données</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/446652/">  Après avoir examiné les problèmes liés à l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">isolement</a> et fait une digression sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">organisation des données à un bas niveau</a> , la dernière fois que nous avons parlé en détail des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">versions de ligne</a> et tracé comment les informations de service dans l'en-tête de version ont changé au cours de diverses opérations. <br><br>  Aujourd'hui, nous examinons comment des versions cohérentes des données sont obtenues à partir des versions de ligne. <br><br><h1>  Qu'est-ce qu'un instantané de données </h1><br>  Physiquement, les pages de données peuvent contenir plusieurs versions de la même ligne.  De plus, chaque transaction ne devrait voir qu'une seule (ou pas une seule) version de chaque ligne afin qu'elles forment ensemble une image cohérente avec ACID des données à un certain moment. <br><br>  L'isolement dans PostgreSQL est construit sur la base d'instantanés: chaque transaction fonctionne avec son propre instantané de données, qui "contient" les données qui ont été enregistrées avant la création de l'instantané et ne "contient" pas les données non encore fixées à ce moment.  Nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">avons déjà vu</a> que l'isolement dans ce cas est plus rigoureux que ne l'exige la norme, mais pas sans anomalies. <br><a name="habracut"></a><br>  Au niveau d'isolement de Read Committed, un instantané est créé au début de chaque instruction de transaction.  Un tel instantané est actif pendant l'exécution de l'instruction.  Sur la figure, le moment de la création de l'instantané (qui, comme nous le rappelons, est déterminé par le numéro de transaction) est indiqué en bleu. <br><br><img src="https://habrastorage.org/webt/5g/nz/nj/5gnznjhyp869w4ls01o0wy5kxlo.png"><br><br>  Aux niveaux de lecture répétable et de sérialisation, un instantané est créé une fois au début de la première instruction de transaction.  Un tel instantané reste actif jusqu'à la fin de la transaction. <br><br><img src="https://habrastorage.org/webt/ff/dp/17/ffdp17xhiqemal2dj8k6a21ql38.png"><br><br><h1>  Visibilité des versions de ligne dans l'instantané </h1><br><h2>  Règles de visibilité </h2><br>  Bien sûr, un instantané n'est pas une copie physique de toutes les versions de ligne requises.  En fait, un instantané est spécifié par plusieurs nombres et la visibilité des versions de ligne dans l'instantané est déterminée par les règles. <br><br>  La visibilité ou non de cette version de la ligne dans l'instantané dépend des deux champs de son en-tête - xmin et xmax - c'est-à-dire du nombre de transactions qui les ont créées et supprimées.  Ces intervalles ne se croisent pas, par conséquent, une ligne est représentée dans une image par un maximum de l'une de ses versions. <br><br>  Les règles exactes de visibilité sont assez complexes et prennent en compte de nombreuses situations différentes et des cas extrêmes. <br><blockquote>  Cela peut être facilement vérifié en consultant src / backend / utils / time / tqual.c (dans la version 12, la vérification a été déplacée vers src / backend / access / heap / heapam_visibility.c). <br></blockquote><br>  Pour simplifier, nous pouvons dire que la version de la ligne est visible lorsque les modifications apportées par la transaction xmin sont visibles dans l'image, et les modifications apportées par la transaction xmax ne sont pas visibles (en d'autres termes, il est déjà visible que la version de la ligne est apparue, mais il n'est pas encore visible qu'elle a été supprimée). <br><br>  À leur tour, les modifications de transaction sont visibles dans l'instantané, si c'est la même transaction qui a créé l'instantané (elle voit ses propres modifications), ou la transaction a été validée avant la création de l'instantané. <br><br>  Il est possible de représenter graphiquement les transactions sous forme de segments (du début au moment de la validation): <br><br><img src="https://habrastorage.org/webt/w2/cq/yr/w2cqyrzhqwmzzenek8ski3mhbzo.png"><br><br>  Ici: <br><br><ul><li>  les modifications apportées à la transaction 2 seront visibles, car elles se sont terminées avant la création de l'instantané, </li><li>  les modifications apportées à la transaction 1 ne seront pas visibles car elle était active au moment de la prise de l'instantané, </li><li>  les modifications apportées à la transaction 3 ne seront pas visibles car elles ont commencé après la prise de l'instantané (peu importe si elle s'est terminée ou non). </li></ul><br>  Malheureusement, le moment de la validation des transactions est inconnu du système.  Seul le moment de son début est connu (il est déterminé par le numéro de transaction et est indiqué par une ligne pointillée sur les figures ci-dessus), mais le fait de l'achèvement n'est enregistré nulle part. <br><br>  Tout ce que nous pouvons faire est de connaître l'état <em>actuel</em> des transactions lors de la création d'un instantané.  Ces informations se trouvent dans la mémoire partagée du serveur dans la structure ProcArray, qui contient une liste de toutes les sessions actives et de leurs transactions. <br><br>  Et après coup, nous ne pourrons plus comprendre si une transaction était active au moment de l'instantané ou non.  Par conséquent, la liste de toutes les transactions actuellement actives doit être mémorisée dans l'image. <br><br>  Il découle de ce qui précède que dans PostgreSQL, vous ne pouvez pas créer un instantané montrant des données cohérentes à une date arbitraire, <em>même si</em> toutes les versions nécessaires des lignes existent dans les pages du tableau.  On entend souvent la question de savoir pourquoi il n'y a pas de requêtes rétrospectives (ou temporelles; dans Oracle, cela s'appelle une requête flashback) dans PostgreSQL - c'est l'une des raisons. <br><blockquote>  C'est drôle qu'au départ, il y avait une telle fonctionnalité, mais plus tard, elle a été supprimée du SGBD.  Vous pouvez lire à ce sujet dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article de Joseph Hellerstein</a> . <br></blockquote>  Ainsi, un instantané de données est déterminé par plusieurs paramètres: <br><br><ul><li>  le moment de la création de l'instantané, à savoir le numéro de la prochaine transaction qui n'existe pas dans le système ( <strong>snapshot.xmax</strong> ); </li><li>  une liste des transactions actives au moment de la prise de l'instantané ( <strong>snapshot.xip</strong> ). </li></ul><br>  Pour plus de commodité et d'optimisation, le numéro de la première transaction active ( <strong>snapshot.xmin</strong> ) est également stocké séparément.  Cette valeur a une signification importante, que nous discuterons ci-dessous. <br><br>  De plus, quelques paramètres supplémentaires sont enregistrés dans l'image, mais ils ne sont pas importants pour nous. <br><br><img src="https://habrastorage.org/webt/-r/8v/aa/-r8vaa6fvrltfpd4tjjnv_zxnk4.png"><br><br><h2>  Exemple </h2><br>  Pour voir comment la visibilité est déterminée par l'instantané, nous reproduisons la situation avec les trois transactions décrites ci-dessus.  Le tableau comportera trois lignes, avec: <br><br><ul><li>  le premier a été ajouté par une transaction qui a commencé avant la création de l'instantané, mais s'est terminée plus tard, </li><li>  le second est ajouté par une transaction qui a commencé et s'est terminée avant la création de l'instantané, </li><li>  le troisième a été ajouté après avoir pris la photo. </li></ul><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts;</code> </pre> <br>  Première transaction (pas encore terminée): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">=&gt; SELECT txid_current(); txid_current -------------- 3695 (1 row)</code> </pre><br>  La deuxième transaction (terminée avant la création de l'instantané): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3696 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Créez un instantané dans une transaction dans une autre session. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  Nous terminons la première transaction après la création de l'instantané: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Et la troisième transaction (apparue plus tard sur l'instantané): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3697 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  De toute évidence, une ligne est toujours visible dans notre image: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br>  La question est de savoir comment PostgreSQL comprend cela. <br><br>  Tout est déterminé par l'image.  Regardons ça: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_snapshot();</code> </pre><pre> <code class="plaintext hljs">|| txid_current_snapshot || ----------------------- || 3695:3697:3695 || (1 row)</code> </pre><br>  Ici, les deux points répertorient snapshot.xmin, snapshot.xmax et snapshot.xip (dans ce cas, un numéro, mais en général - une liste). <br><br>  Selon les règles énoncées ci-dessus, l'image doit montrer les modifications apportées par les transactions avec les nombres snapshot.xmin &lt;= xid &lt;snapshot.xmax, à l'exception de snapshot.xip.  Regardons toutes les lignes du tableau (dans une nouvelle image): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | number | client | amount ------+------+----+--------+--------+--------- 3695 | 0 | 1 | 1001 | alice | 1000.00 3696 | 0 | 2 | 2001 | bob | 100.00 3697 | 0 | 3 | 2002 | bob | 900.00 (3 rows)</code> </pre><br>  La première ligne n'est pas visible - elle a été créée par une transaction, qui est incluse dans la liste des actifs (xip). <br>  La deuxième ligne est visible - elle est créée par une transaction qui se situe dans la plage de l'image. <br>  La troisième ligne n'est pas visible - elle a été créée par une transaction qui n'est pas dans la plage de l'instantané. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Propres changements </h1><br>  Un peu complique l'image est le cas de déterminer la visibilité de vos propres changements de transaction.  Ici, vous devrez peut-être voir uniquement une partie de ces modifications.  Par exemple, un curseur ouvert à un moment particulier ne devrait pas voir les modifications apportées après ce moment à n'importe quel niveau d'isolement. <br><br>  Pour ce faire, dans l'en-tête de la version de ligne, il y a un champ spécial (qui est affiché dans les pseudo-colonnes cmin et cmax), montrant le numéro de séquence de l'opération à l'intérieur de la transaction.  Cmin représente le nombre à insérer, cmax représente le nombre à supprimer, mais pour économiser de l'espace dans l'en-tête de ligne, il s'agit en fait d'un champ, pas de deux différents.  On pense que l'insertion et la suppression de la même ligne dans une seule transaction est rare. <br><br>  Si cela se produit toujours, un numéro spécial "combo" est inséré dans le même champ, à propos duquel le processus de service se souvient des cmin et cmax réels.  Mais c'est complètement exotique. <br><br>  Un exemple simple.  Nous commençons la transaction et ajoutons la ligne au tableau: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3698 (1 row)</code> </pre><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3001</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>);</code> </pre><br>  Nous afficherons le contenu du tableau avec le champ cmin (mais uniquement pour les lignes ajoutées par notre transaction - pour d'autres cela n'a pas de sens): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  Ouvrez maintenant le curseur de la requête qui renvoie le nombre de lignes de la table. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><br>  Et après cela, ajoutez une autre ligne: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3002</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">200.00</span></span>);</code> </pre><br>  La demande renverra 4 - la ligne ajoutée après l'ouverture du curseur ne tombera pas dans l'instantané des données: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> count ------- 4 (1 row)</code> </pre><br>  Pourquoi?  Parce que dans l'instantané, seules les versions de ligne avec cmin &lt;1 sont prises en compte. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 3698 | 1 | 5 | 3002 | charlie | 200.00 (5 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h1>  Horizon de l'événement </h1><br>  Le numéro de la première transaction active (snapshot.xmin) a une signification importante - il définit «l'horizon des événements» de la transaction.  A savoir, au-delà de son horizon, une transaction ne voit toujours que les versions actuelles des lignes. <br><br>  En effet, une version non pertinente n'a besoin d'être vue que si la version actuelle a été créée par une transaction qui n'a pas encore été finalisée et n'est donc pas encore visible.  Mais au-delà de «l'horizon», toutes les transactions sont déjà garanties d'être réalisées. <br><br><img src="https://habrastorage.org/webt/8z/vp/oo/8zvpoocv891hhtnv9lcs6j7g4ry.png"><br><br>  L'horizon des événements de la transaction est visible dans le répertoire système: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  Vous pouvez également définir un «horizon d'événement» au niveau de la base de données.  Pour ce faire, prenez tous les instantanés actifs et trouvez parmi eux le xmin le plus ancien.  Il déterminera l'horizon au-delà duquel les versions non pertinentes des lignes de cette base de données ne seront jamais visibles pour aucune transaction.  <em>De telles versions de chaînes peuvent être effacées</em> - c'est pourquoi le concept d'horizon est si important d'un point de vue pratique. <br><br>  Si une transaction contient un instantané pendant une longue période, elle contiendra également l'horizon des événements de la base de données.  De plus, une transaction inachevée tiendra l'horizon par le fait même de son existence, même si aucun instantané n'y figure. <br><br>  Et cela signifie que les versions non pertinentes des lignes de cette base de données ne peuvent pas être effacées.  Dans le même temps, une transaction «longue durée» peut ne pas chevaucher d'autres transactions dans les données - ce n'est absolument pas important, l'horizon de la base de données est le même pour tout le monde. <br><br>  Si maintenant, pas une transaction, mais les instantanés (de snapshot.xmin à snapshot.xmax) sont représentés comme un segment, alors la situation peut être imaginée comme suit: <br><br><img src="https://habrastorage.org/webt/nd/ve/wi/ndvewikoeiljposax85zp7mmmn8.png"><br><br>  Dans cette figure, l'instantané le plus bas se réfère à une transaction incomplète et dans les instantanés snapshot.xmin restants ne peut pas être supérieur à son nombre. <br><br>  Dans notre exemple, une transaction avec le niveau d'isolement Read Committed a été démarrée.  Même s'il ne contient aucun instantané de données actif, il continue de tenir l'horizon: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">1.00</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br>  Et seulement une fois la transaction terminée, l'horizon avance, vous permettant d'effacer les versions non pertinentes des lignes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3700 (1 row)</code> </pre><br>  Si la situation décrite crée vraiment des problèmes et qu'il n'y a aucun moyen de l'éviter au niveau de l'application, alors, à partir de la version 9.6, deux options sont disponibles: <br><br><ul><li>  <em>old_snapshot_threshold</em> définit la durée de vie maximale d'un instantané.  Passé ce délai, le serveur obtient le droit de supprimer les versions non pertinentes des lignes, et s'il a besoin d'une transaction «longue durée», mais il recevra un instantané d'une erreur trop ancienne. </li><li>  <em>idle_in_transaction_session_timeout</em> définit la durée de vie maximale d'une transaction inactive.  Passé ce délai, la transaction est abandonnée. </li></ul><br><h1>  Exporter un instantané de données </h1><br>  Il existe des situations où plusieurs transactions simultanées doivent être garanties pour voir la même image de données.  Par exemple, nous pouvons utiliser l'utilitaire pg_dump, qui peut fonctionner en mode parallèle: tous les processus de travail doivent voir la base de données dans le même état afin que la copie de sauvegarde soit cohérente. <br><br>  Bien sûr, vous ne pouvez pas vous fier au fait que les modèles de données coïncident simplement parce que les transactions sont lancées «simultanément».  Il existe un mécanisme pour exporter et importer un instantané pour cela. <br><br>  La fonction pg_export_snapshot renvoie l'identifiant d'un instantané qui peut être transféré (par des moyens externes au SGBD) vers une autre transaction. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; <span class="hljs-comment"><span class="hljs-comment">--  </span></span></code> </pre><pre> <code class="plaintext hljs"> count ------- 3 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_export_snapshot();</code> </pre><pre> <code class="plaintext hljs"> pg_export_snapshot --------------------- 00000004-00000E7B-1 (1 row)</code> </pre><br>  Une autre transaction peut importer l'instantané à l'aide de la commande SET TRANSACTION SNAPSHOT avant d'y exécuter la première demande.  Vous devez d'abord définir le niveau d'isolement comme Lecture répétable ou Sérialisable, car au niveau de lecture validée, les opérateurs utiliseront leurs propres instantanés. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SNAPSHOT</span></span> <span class="hljs-string"><span class="hljs-string">'00000004-00000E7B-1'</span></span>;</code> </pre><br>  Maintenant, la deuxième transaction fonctionnera avec un instantané de la première et, en conséquence, affichera trois lignes (et non zéro): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 3 | (1 row)</code> </pre><br>  La durée de vie de l'instantané exporté est la durée de vie de la transaction d'exportation. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">À suivre</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr446652/">https://habr.com/ru/post/fr446652/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr446640/index.html">20 projets, 20 langues, date limite hier. 2e partie</a></li>
<li><a href="../fr446642/index.html">Liste de contrôle pour la création et la publication d'applications Web</a></li>
<li><a href="../fr446646/index.html">InterSystems IRIS 2019.1 Release</a></li>
<li><a href="../fr446648/index.html">Développement d'opérateurs Kubernetes avec Operator Framework</a></li>
<li><a href="../fr446650/index.html">Combien coûtent les testeurs et de quoi dépendent leurs salaires? Construire le portrait d'un spécialiste en AQ performant</a></li>
<li><a href="../fr446656/index.html">Codage de la parole à 1600 bits / s avec vocodeur neuronal LPCNet</a></li>
<li><a href="../fr446658/index.html">Entretien avec Andrei Stankevich sur la programmation sportive</a></li>
<li><a href="../fr446662/index.html">Transactions et mécanismes de contrôle</a></li>
<li><a href="../fr446666/index.html">Tirez le meilleur parti des calculatrices graphiques: jeux sur la TI-83</a></li>
<li><a href="../fr446668/index.html">Python pour le web: ce qu'un junior doit savoir pour travailler et grandir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>