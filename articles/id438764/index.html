<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ» ğŸ”’ ğŸ‘©ğŸ»â€ğŸ³ Tes Chromium Keenam, Kata Penutup ğŸ¤˜ğŸ½ ğŸ® ğŸ‘©ğŸ½â€ğŸ”§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada awal 2018, serangkaian artikel muncul di blog kami yang didedikasikan untuk verifikasi keenam kode sumber proyek Chromium. Siklus mencakup 8 arti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tes Chromium Keenam, Kata Penutup</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/438764/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3e/0f3/36b/e3e0f336b600672c601b8849d274d251.png" alt="unicorn yang ketat"></div><br>  Pada awal 2018, serangkaian artikel muncul di blog kami yang didedikasikan untuk verifikasi keenam kode sumber proyek Chromium.  Siklus mencakup 8 artikel yang ditujukan untuk kesalahan dan rekomendasi untuk pencegahannya.  Dua artikel telah menyebabkan diskusi panas, dan sejauh ini saya jarang menerima komentar tentang topik yang dibahas di dalamnya.  Mungkin, beberapa penjelasan tambahan harus diberikan dan, seperti kata mereka, beri tanda titik pada i. <br><a name="habracut"></a><br>  Setahun telah berlalu sejak penulisan serangkaian artikel yang ditujukan untuk verifikasi kode sumber proyek Chromium berikutnya: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chromium: cek proyek keenam dan 250 bug</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chromium yang indah dan memset yang kikuk</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">istirahat dan gagal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chromium: kebocoran memori</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Salah ketik Chromium</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chromium: Menggunakan Data yang Tidak Akurat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengapa penting untuk memeriksa apa fungsi malloc dikembalikan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chromium: kesalahan lain</a> </li></ol><br>  Artikel tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memset</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">malloc telah</a> menyebabkan, dan terus menyebabkan, diskusi yang terasa aneh bagi saya.  Rupanya, ada beberapa kesalahpahaman karena fakta bahwa saya tidak merumuskan pikiran saya dengan jelas.  Saya memutuskan untuk kembali ke artikel ini dan membuat beberapa klarifikasi. <br><br><h2>  memset </h2><br>  Mari kita mulai dengan artikel tentang <i>memset</i> , karena semuanya sederhana di sini.  Ada kontroversi mengenai cara terbaik untuk menginisialisasi struktur.  Cukup banyak programmer menulis bahwa lebih baik memberikan rekomendasi untuk tidak menulis: <br><br><pre><code class="cpp hljs">HDHITTESTINFO hhti = {};</code> </pre> <br>  Jadi: <br><br><pre> <code class="cpp hljs">HDHITTESTINFO hhti = { <span class="hljs-number"><span class="hljs-number">0</span></span> };</code> </pre> <br>  Argumen: <br><br><ol><li>  Konstruk {0} lebih mudah dilihat ketika membaca kode daripada {}. </li><li>  Konstruk {0} lebih intuitif daripada {}.  Yaitu, 0 menunjukkan bahwa struktur diisi dengan nol. </li></ol><br>  Oleh karena itu, saya ditawari untuk mengubah contoh inisialisasi ini dalam artikel.  Saya tidak setuju dengan argumen dan tidak berencana untuk mengubah artikel.  Sekarang saya membenarkan posisi saya. <br><br>  Tentang visibilitas.  Saya pikir ini masalah selera dan kebiasaan.  Saya tidak berpikir bahwa keberadaan 0 di dalam kurung kurawal secara fundamental mengubah situasi. <br><br>  Tetapi dengan argumen kedua saya tidak setuju sama sekali.  Catatan seperti {0} memberikan alasan untuk salah mengerti kode.  Misalnya, Anda dapat menghitung bahwa jika Anda mengganti 0 dengan 1, semua bidang akan diinisialisasi ke unit.  Karena itu, gaya penulisan ini lebih berbahaya daripada berguna. <br><br>  Alat analisa PVS-Studio bahkan memiliki diagnosis terkait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V1009</a> pada topik ini, deskripsi yang sekarang akan saya berikan. <br><br>  <b>V1009.</b>  <b>Periksa inisialisasi array.</b>  <b>Hanya elemen pertama yang diinisialisasi secara eksplisit.</b> <br><br>  Analyzer mendeteksi kemungkinan kesalahan karena fakta bahwa ketika mendeklarasikan array, nilainya ditentukan hanya untuk satu elemen.  Dengan demikian, sisa elemen akan diinisialisasi secara implisit ke nol atau konstruktor default. <br><br>  Pertimbangkan contoh kode yang mencurigakan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {<span class="hljs-number"><span class="hljs-number">1</span></span>};</code> </pre> <br>  Mungkin programmer diharapkan <i>arr</i> terdiri dari satu unit, tetapi ini tidak demikian.  Array akan terdiri dari nilai 1, 0, 0. <br><br>  Kode yang benar adalah: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>};</code> </pre> <br>  Kebingungan tersebut dapat terjadi karena kesamaan dengan konstruk <i>arr = {0}</i> , yang menginisialisasi seluruh array menjadi nol. <br><br>  Jika desain yang serupa digunakan secara aktif dalam proyek Anda, Anda dapat menonaktifkan diagnostik ini. <br><br>  Juga tidak disarankan untuk mengabaikan visibilitas kode. <br><br>  Misalnya, kode untuk pengkodean nilai warna ditulis sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> White[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Black[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Green[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span> };</code> </pre> <br>  Berkat inisialisasi implisit, semua warna diatur dengan benar, tetapi lebih baik untuk menulis ulang kode lebih jelas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> White[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Black[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Green[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span> };</code> </pre> <br><h2>  malloc </h2><br>  Sebelum membaca lebih lanjut, saya meminta Anda untuk me-refresh konten artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengapa penting untuk memeriksa apa fungsi malloc dikembalikan</a> ".  Artikel ini telah menghasilkan banyak diskusi dan kritik.  Inilah beberapa diskusi: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">reddit.com/r/cpp</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">reddit.com/r/C_Programming</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com</a> .  Kadang-kadang mereka menulis kepada saya tentang artikel ini melalui pos sekarang. <br><br>  Artikel ini dikritik oleh pembaca tentang hal-hal berikut: <br><br>  <b>1. Jika</b> <b><i>malloc</i></b> <b>mengembalikan</b> <b><i>NULL</i></b> <b>, maka lebih baik untuk segera keluar dari program daripada menulis</b> <b><i>seandainya</i></b> <b>dan mencoba untuk entah bagaimana menangani kekurangan memori, karena itu seringkali tidak mungkin untuk menjalankan program itu.</b> <br><br>  Saya sama sekali tidak menelepon sampai yang terakhir untuk berurusan dengan konsekuensi kehabisan memori, melemparkan kesalahan lebih tinggi dan lebih tinggi.  Jika diizinkan untuk aplikasi dimatikan tanpa peringatan, maka jadilah itu.  Untuk melakukan ini, hanya satu pemeriksaan diperlukan segera setelah <i>malloc</i> atau menggunakan <i>xmalloc</i> (lihat paragraf berikutnya). <br><br>  Saya keberatan dan memperingatkan tentang tidak adanya cek, karena itu program terus bekerja "seolah-olah tidak ada yang terjadi."  Ini sangat berbeda.  Ini berbahaya karena mengarah pada perilaku yang tidak terdefinisi, korupsi data, dan sebagainya. <br><br>  <b>2. Tidak membicarakan solusi, yang terdiri dari penulisan fungsi-pembungkus untuk mengalokasikan memori dengan verifikasi selanjutnya atau menggunakan fungsi yang ada, seperti</b> <b><i>xmalloc</i></b> <b>.</b> <br><br>  Saya setuju, saya melewatkan momen ini.  Saat menulis artikel, saya hanya tidak memikirkan bagaimana cara memperbaiki situasi.  Lebih penting bagi saya untuk menyampaikan kepada pembaca tentang bahaya kurangnya verifikasi.  Cara memperbaiki kesalahan sudah menjadi masalah selera dan detail implementasi. <br><br>  Fungsi <i>xmalloc</i> bukan bagian dari pustaka standar C (lihat " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa perbedaan antara xmalloc dan malloc?</a> ").  Namun, fungsi ini dapat dideklarasikan di pustaka lain, misalnya, di pustaka GNU utils ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GNU libiberty</a> ). <br><br>  Inti dari fungsi ini adalah bahwa program berakhir jika alokasi memori gagal.  Implementasi fungsi ini mungkin terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xmalloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"fatal: out of memory (xmalloc(%zu)).\n"</span></span>, s); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(EXIT_FAILURE); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; }</code> </pre> <br>  Dengan demikian, dengan memanggil fungsi <i>xmalloc di mana-mana</i> alih-alih <i>malloc,</i> Anda dapat yakin bahwa program tidak akan memiliki perilaku yang tidak terdefinisi karena penggunaan pointer nol. <br><br>  Sayangnya, <i>xmalloc</i> juga bukan obat mujarab untuk semua penyakit.  Harus diingat bahwa penggunaan <i>xmalloc tidak</i> dapat diterima ketika menulis kode pustaka.  Saya akan membicarakannya nanti. <br><br>  <b>3. Sebagian besar komentar adalah sebagai berikut: "dalam praktiknya,</b> <b><i>malloc</i></b> <b>tidak pernah mengembalikan</b> <b><i>NULL</i></b> <b>."</b> <br><br>  Untungnya, saya tidak sendiri mengerti bahwa ini adalah pendekatan yang salah.  Saya sangat menyukai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komentar</a> ini dalam dukungan saya: <br><br>  <i>Dari pengalaman mendiskusikan topik semacam itu, orang merasa bahwa ada dua sekte di Internet.</i>  <i>Penganut yang pertama sangat yakin bahwa di Linux, malloc tidak pernah mengembalikan NULL.</i>  <i>Penganut yang kedua sangat yakin bahwa jika memori dalam program tidak dapat dialokasikan, tetapi tidak ada yang dapat dilakukan pada prinsipnya, Anda hanya perlu jatuh.</i>  <i>Anda tidak dapat meyakinkan mereka dengan cara apa pun.</i>  <i>Terutama ketika kedua sekte ini bersinggungan.</i>  <i>Anda hanya bisa menerima begitu saja.</i>  <i>Dan tidak masalah sumber daya profil tempat diskusi itu berlangsung.</i> <br><br>  Saya berpikir dan memutuskan untuk mengikuti saran dan saya tidak akan mencoba untuk membujuk :).  Mari berharap tim pengembangan ini hanya menulis program yang tidak penting.  Jika, misalnya, beberapa data memburuk dalam game atau game crash, itu bukan masalah besar. <br><br>  Satu-satunya hal yang penting adalah pengembang perpustakaan, database, dll. Tidak melakukan ini. <br><br><h2>  Panggilan ke perpustakaan dan pengembang kode yang bertanggung jawab </h2><br>  Jika Anda sedang mengembangkan perpustakaan atau kode yang bertanggung jawab lainnya, selalu periksa nilai pointer yang dikembalikan oleh fungsi <i>malloc / realloc</i> , dan kembalikan kode kesalahan di luar jika memori tidak dapat dialokasikan. <br><br>  Di perpustakaan, Anda tidak dapat memanggil fungsi <i>keluar</i> jika Anda tidak dapat mengalokasikan memori.  Untuk alasan yang sama, Anda tidak dapat menggunakan <i>xmalloc</i> .  Untuk banyak aplikasi, tidak dapat diterima hanya mengambil dan menghentikannya.  Karena itu, misalnya, basis data mungkin rusak.  Data yang telah dihitung berjam-jam mungkin hilang.  Karena itu, program ini mungkin rentan terhadap penolakan kerentanan layanan, ketika alih-alih menangani dengan benar beban yang bertambah, aplikasi multithreaded berakhir begitu saja. <br><br>  Tidak dapat diasumsikan bagaimana dan dalam proyek apa perpustakaan akan digunakan.  Oleh karena itu, harus diasumsikan bahwa aplikasi dapat menyelesaikan tugas yang sangat penting.  Dan hanya "membunuhnya" dengan memanggil <i>keluar</i> tidak baik.  Kemungkinan besar, program semacam itu ditulis dengan mempertimbangkan kemungkinan kehabisan memori dan dapat melakukan sesuatu dalam kasus ini.  Sebagai contoh, beberapa sistem CAD, karena fragmentasi memori yang kuat, tidak dapat mengalokasikan buffer memori yang cukup untuk operasi selanjutnya.  Tapi ini bukan alasan baginya untuk berakhir dalam mode darurat dengan kehilangan data.  Suatu program dapat memungkinkan untuk menyimpan proyek dan memulai kembali dengan sendirinya dalam mode normal. <br><br>  Dalam kasus apa pun Anda tidak dapat mengandalkan fakta bahwa <i>malloc</i> selalu dapat mengalokasikan memori.  Tidak diketahui pada platform apa dan bagaimana perpustakaan akan digunakan.  Jika pada satu platform kekurangan memori adalah eksotis, maka di platform lain itu bisa menjadi situasi yang sangat umum. <br><br>  Tidak dapat diharapkan bahwa jika <i>malloc</i> mengembalikan <i>NULL</i> , maka program akan macet.  Apa pun bisa terjadi.  Seperti yang saya jelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> , sebuah program dapat menulis data pada alamat yang tidak nol sama sekali.  Akibatnya, beberapa data mungkin rusak, yang mengarah pada konsekuensi yang tidak terduga.  Bahkan <i>memset itu</i> berbahaya.  Jika data diisi dengan urutan terbalik, maka pada awalnya beberapa data rusak, dan hanya kemudian program akan crash.  Tetapi musim gugur bisa terjadi terlambat.  Jika data yang rusak digunakan dalam utas paralel pada saat fungsi <i>memset</i> , maka konsekuensinya bisa fatal.  Anda bisa mendapatkan transaksi yang rusak di database atau mengirim perintah untuk menghapus file yang "tidak perlu".  Apa pun bisa terjadi dalam waktu.  Saya menyarankan pembaca untuk membayangkan secara mandiri apa yang dapat menyebabkan penggunaan sampah dalam memori. <br><br>  Dengan demikian, perpustakaan hanya memiliki satu opsi yang benar untuk bekerja dengan fungsi <i>malloc</i> .  Anda perlu SEGERA memeriksa bahwa fungsi kembali, dan jika itu NULL, maka kembalikan status kesalahan. <br><br><h2>  Tautan situs </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penanganan OOM</a> . </li><li>  Bersenang-senang dengan pointer NULL: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 2</a> . </li><li>  Yang Harus Diketahui Setiap Pemrogram C Tentang Perilaku Tidak Terdefinisi: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 3</a> . </li></ol><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Periksa Chromium Keenam, Kata Penutup</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438764/">https://habr.com/ru/post/id438764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438752/index.html">Akuntansi langsung di bank: cara membuat pengusaha individu bahagia</a></li>
<li><a href="../id438754/index.html">Bagaimana kami melakukan pemantauan jaringan untuk 14.000 objek</a></li>
<li><a href="../id438756/index.html">Periksa Chromium Keenam, Kata Penutup</a></li>
<li><a href="../id438758/index.html">Mengapa Google mengubah antarmuka URL standar di browser</a></li>
<li><a href="../id438762/index.html">DBX: upaya untuk menyingkirkan kompilasi permintaan MySQL</a></li>
<li><a href="../id438766/index.html">DNA ekstraseluler sebagai biomarker penuaan dan berbagai patologi</a></li>
<li><a href="../id438768/index.html">Betapa saya membantu Alice untuk tidak menanggapi nama-nama lain. Magang Yandex</a></li>
<li><a href="../id438770/index.html">Menangani penekanan tombol alias pintasan dan debugging</a></li>
<li><a href="../id438772/index.html">HX711 ADC dari 3.3V - jangan percaya dokumentasi China dan tidak hanya</a></li>
<li><a href="../id438774/index.html">Semua yang terbaik sekaligus. Artikel yang paling jelas dari blog LANIT di HabrÃ© - 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>