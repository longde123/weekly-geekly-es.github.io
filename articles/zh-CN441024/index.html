<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📦 👨‍👩‍👦 👨🏿‍✈️ 我们为一个或两个1.0编写一个爬虫 🎖️ 👃🏽 🧚🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="网络搜寻器 （或网络蜘蛛）是搜索引擎的重要组成部分，用于搜寻网页，以便将有关它们的信息输入数据库，主要是为了进一步索引。 搜索引擎（Google，Yandex，Bing）以及SEO产品（SEMrush，MOZ，ahrefs）不仅具有这种功能。 这件事很有趣：无论是在潜力和用例方面，还是在技术实施方面...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们为一个或两个1.0编写一个爬虫</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/semrush/blog/441024/"> 网络搜寻<b>器</b> （或网络蜘蛛）是搜索引擎的重要组成部分，用于搜寻网页，以便将有关它们的信息输入数据库，主要是为了进一步索引。 搜索引擎（Google，Yandex，Bing）以及SEO产品（SEMrush，MOZ，ahrefs）不仅具有这种功能。 这件事很有趣：无论是在潜力和用例方面，还是在技术实施方面。 <br><br><img src="https://habrastorage.org/webt/vw/pi/-9/vwpi-9jp8-dypdtmlh58qqa1nm0.jpeg"><br><br> 通过本文，我们将开始<b>迭代地</b>创建您的履带式<s>自行车</s> ，分析许多功能并遇到陷阱。 从简单的递归功能到可扩展和可扩展的服务。 一定很有趣！ <br><a name="habracut"></a><br><h3> 前言 </h3><br> 反复进行-这意味着在每个发行版本的末尾，都应具有可商定的限制，功能和界面的“产品”的即用型版本。 <br><br> 选择<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Node.js</a>和<b>JavaScript</b>作为平台和语言，因为它简单且异步。 当然，对于工业发展而言，技术基础的选择应基于业务需求，期望和资源。 作为演示和原型，此平台完全无效（IMHO）。 <br><br><blockquote> 这是我的履带。 有很多这样的履带，但这是我的。 <br> 我的履带是我最好的朋友。 <br></blockquote><br> 实施搜寻器是一项相当受欢迎的任务，即使在技术采访中也可以找到。 确实有很多现成的（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apache Nutch</a> ）和自写的解决方案可以针对不同的条件和多种语言。 因此，任何来自个人开发或使用经验的评论都将受到欢迎，并且将很有趣。 <br><br><h3> 问题陈述 </h3><br>  <s>tyap-blooper搜寻</s>器的第一个（初始）实现的任务如下： <br><br><blockquote>  <b>一拖二爬行者1.0</b> <br> 编写一个爬网程序脚本，绕过一个小型（最多100页）网站的内部<i>&lt;a href /&gt;</i>链接。 结果，提供具有所接收代码的页面URL列表以及它们的链接图。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">robots.txt</a>规则和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">rel = nofollow</a>链接属性将被忽略。 </blockquote><br>  <b>注意！</b> 由于明显的原因，忽略<i>robots.txt</i>规则是一个坏主意。 我们将在将来弥补这一遗漏。 同时，添加限制参数以限制要爬网的页面数，以免停止DoS并尝试实验站点（最好使用自己的“仓鼠站点”进行实验）。 <br><br><h3> 实作 </h3><br> 对于不耐烦的人， <a href="">这是</a>此解决方案<a href="">的来源</a> 。 <br><br><ol><li>  HTTP（S）客户端 </li><li> 答案选项 </li><li> 链接提取 </li><li> 链接准备和过滤 </li><li>  URL规范化 </li><li> 主要功能算法 </li><li> 返回结果 </li></ol><br><h4>  1. HTTP（S）客户端 </h4><br> 实际上，我们需要做的第一件事是通过HTTP和HTTPS发送请求和接收响应。 在node.js中，有两个匹配的客户端。 当然，您可以接受<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现成的客户端请求</a> ，但是对于我们的任务来说，这是非常多余的：我们只需要发送GET请求并获取带有正文和标头的响应即可。 <br><br> 我们需要的两个客户端的API都相同，我们将创建一个地图： <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clients = { <span class="hljs-string"><span class="hljs-string">'http:'</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'http'</span></span>), <span class="hljs-string"><span class="hljs-string">'https:'</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'https'</span></span>) };</code> </pre> <br> 我们声明一个简单的函数<i>fetch</i> ，其唯一参数将是所需Web资源字符串的<b>绝对</b> URL。 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">url模块，</a>我们会将结果字符串解析为URL对象。 该对象具有一个带有协议的字段（带有冒号），我们将通过该字段选择适当的客户端： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'url'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dst</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dstURL = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(dst); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> client = clients[dstURL.protocol]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!client) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Could not select a client for '</span></span> + dstURL.protocol); } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br> 接下来，使用选定的客户端并将<i>fetch</i>函数的结果包装在promise中： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dst</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... let req = client.get(dstURL.href, res =&gt; { // do something with the response }); req.on('error', err =&gt; reject('Failed on the request: ' + err.message)); req.end(); }); }</span></span></code> </pre><br><br> 现在我们可以异步接收响应，但是目前我们还没有做任何事情。 <br><br><h4>  2.答案选项 </h4><br> 要抓取该站点，只需处理3个答案选项即可： <br><br><ol><li>  OK-收到2xx状态代码。 有必要保存响应主体作为进一步处理的结果-提取新链接。 </li><li>  <b>重定向</b> -收到3xx状态代码。 这是重定向到另一个页面。 在这种情况下，我们将需要<i>位置</i>响应标头，从那里我们将获得一个“传出”链接。 </li><li>  <b>NO_DATA-</b>所有其他情况：4xx / 5xx和3xx，而没有<i>Location</i>标头。 我们的爬虫无处可走。 </li></ol><br>  <i>提取</i>功能将解析处理后的响应，指示其类型： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ft = { <span class="hljs-string"><span class="hljs-string">'OK'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">// code (2xx), content 'REDIRECT': 2, // code (3xx), location 'NO_DATA': 3 // code };</span></span></code> </pre><br> 按照<i>if-else</i>的最佳传统实施产生结果的策略： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> code = res.statusCode; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> codeGroup = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(code / <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-comment"><span class="hljs-comment">// OK if (codeGroup === 2) { let body = []; res.setEncoding('utf8'); res.on('data', chunk =&gt; body.push(chunk)); res.on('end', () =&gt; resolve({ code, content: body.join(''), type: ft.OK })); } // REDIRECT else if (codeGroup === 3 &amp;&amp; res.headers.location) { resolve({ code, location: res.headers.location, type: ft.REDIRECT }); } // NO_DATA (others) else { resolve({ code, type: ft.NO_DATA }); }</span></span></code> </pre><br> 准备使用<i>提取</i>功能： <a href="">完整的功能代码</a> 。 <br><br><h4>  3.提取链接 </h4><br> 现在，根据收到的答案的变体，您需要能够从<i>访存</i>的结果数据中提取链接以进行进一步的爬网。 为此，我们定义了<i>extract</i>函数，该函数将结果对象作为输入并返回新链接的数组。 <br><br> 如果结果类型为REDIRECT，则该函数将返回一个包含<i>位置</i>字段中单个引用的数组。 如果为NO_DATA，则为空数组。 如果确定，那么我们需要连接解析器以显示所显示的文本<i>内容</i>以进行搜索。 <br><br> 对于搜索任务<i>&lt;a href /&gt;，</i>您还可以编写正则表达式。 但是此解决方案根本无法扩展，因为将来我们至少会关注链接的其他属性（ <i>rel</i> ），最大程度地，我们将考虑<i>img</i> ， <i>链接</i> ， <i>脚本</i> ， <i>音频/视频</i> （ <i>源</i> ）和其他资源。 解析文档的文本并构建其节点的树以绕过常规选择器，这是非常有前途且更加方便的。 <br><br> 我们将使用流行的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JSDOM</a>库在node.js中使用DOM： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { JSDOM } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'jsdom'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">document</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JSDOM(fetched.content).window.document; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> elements = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'A'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(elements) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el.getAttribute(<span class="hljs-string"><span class="hljs-string">'href'</span></span>)) .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">href</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> href === <span class="hljs-string"><span class="hljs-string">'string'</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">href</span></span></span><span class="hljs-function"> =&gt;</span></span> href.trim()) .filter(<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>);</code> </pre><br> 我们从文档中获取所有<i>A</i>元素，然后获取<i>href</i>属性的所有过滤值（如果不是空行）。 <br><br><h4>  4.链接的准备和过滤 </h4><br> 提取程序的结果是，我们有一组链接（URL）和两个问题：1）URL可能是相对的； 2）URL可能导致外部资源（我们现在只需要内部资源）。 <br><br> 第一个问题将通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">url.resolve</a>函数得到帮助，该函数可相对于源页面的URL解析登录页面的URL。 <br><br> 为了解决第二个问题，我们在<i>inScope</i>中编写了一个简单的实用程序函数，该函数将登录页面的主机与当前爬网的基本URL的主机进行检查： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLowerHost</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dst</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(dst)).hostname.toLowerCase(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inScope</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dst, base</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dstHost = getLowerHost(dst); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> baseHost = getLowerHost(base); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = dstHost.indexOf(baseHost); <span class="hljs-comment"><span class="hljs-comment">// the same domain or has subdomains return i === 0 || dstHost[i - 1] === '.'; }</span></span></code> </pre><br> 该函数搜索子字符串（ <i>baseHost</i> ），并检查是否找到了该子字符串：因为<i>wwwexample.com</i>和<i>example.com</i>是不同的域。 因此，我们不会离开给定的域，而是绕过其子域。 <br><br> 我们通过添加“绝对化”并过滤生成的链接来优化<i>提取</i>功能： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fetched, src, base</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> extractRaw(fetched) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">href</span></span></span><span class="hljs-function"> =&gt;</span></span> url.resolve(src, href)) .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dst</span></span></span><span class="hljs-function"> =&gt;</span></span> /^https?\:\/\<span class="hljs-comment"><span class="hljs-comment">//i.test(dst)) .filter(dst =&gt; inScope(dst, base)); }</span></span></code> </pre><br> 此处<i>获取</i>是<i>获取</i>功能的结果， <i>src</i>是源页面的URL， <i>base</i>是爬网的基本URL。 在输出中，我们获得了已经是绝对内部链接（URL）的列表，以进行进一步处理。 整个功能代码可以在<a href="">这里看到</a> 。 <br><br><h4>  5. URL规范化 </h4><br> 重新遇到任何URL，您不需要发送对资源的另一个请求，因为已经接收到数据（或者另一个连接仍处于打开状态并等待响应）。 但是，比较两个URL的字符串来理解这一点并不总是足够的。 规范化是确定语法上不同的URL的等效性所必需的过程。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">规范化</a>过程是应用于源URL及其组件的整套转换。 这里只是其中一些： <br><br><ul><li> 方案和主机不区分大小写，因此应将其转换为较低的值。 </li><li> 所有百分比（例如“％3A”）必须为大写。 </li><li> 可以删除默认端口（HTTP为80）。 </li><li> 该片段（ <i>＃</i> ）对服务器是永远不可见的，也可以删除。 </li></ul><br> 您可以随时使用现成的东西（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">normalize-url</a> ），也可以编写自己的简单函数来涵盖最重要和最常见的情况： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dst</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dstUrl = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(dst); <span class="hljs-comment"><span class="hljs-comment">// ignore userinfo (auth property) let origin = dstUrl.protocol + '//' + dstUrl.hostname; // ignore http(s) standart ports if (dstUrl.port &amp;&amp; (!/^https?\:/i.test(dstUrl.protocol) || ![80, 8080, 443].includes(+dstUrl.port))) { origin += ':' + dstUrl.port; } // ignore fragment (hash property) let path = dstUrl.pathname + dstUrl.search; // convert origin to lower case return origin.toLowerCase() // and capitalize letters in escape sequences + path.replace(/%([0-9a-f]{2})/ig, (_, es) =&gt; '%' + es.toUpperCase()); }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">以防万一，URL对象的格式</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/zs/te/jr/zstejr_mjpparhgrr4aar6ma7nq.png"><br></div></div><br> 是的，没有排序查询参数，忽略utm标签，处理<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">_escaped_fragment_</a>以及其他（绝对）不需要的东西。 <br><br> 接下来，我们将创建Crawl框架请求的标准化URL的本地缓存。 在发送下一个请求之前，我们将接收到的URL规范化，如果它不在缓存中，则添加它，然后才发送新请求。 <br><br><h4>  6.主要功能的算法 </h4><br> 解决方案的关键组件（原始）已经准备就绪，是时候开始将所有内容收集在一起了。 首先，让我们确定<i>爬网</i>函数的签名：在输入处，开始URL和页面限制。 该函数返回一个promise，其分辨率提供累积的结果； 将其写入<i>输出</i>文件： <br><br><pre> <code class="javascript hljs">crawl(start, limit).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> { fs.writeFile(output, <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(result), <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, err =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; }); });</code> </pre><br> 爬网功能最简单的递归工作流可以在以下步骤中进行描述： <br><br><blockquote>  1.初始化缓存和结果对象 <br>  2.如果登录页面网址（通过<b>normalize</b> ）不在缓存中，则 <br>  -2.1。 如果达到<i>限制</i> ，则END（等待结果） <br>  -2.2。 将URL添加到缓存 <br>  -2.3。 在结果中保存源页面和目标页面之间的链接 <br>  -2.4。 每页发送异步请求（ <b>提取</b> ） <br>  -2.5。 如果请求成功，则 <br>  --2.5.1。 从结果中提取新链接（ <b>extract</b> ） <br>  --2.5.2。 对于每个新链接，执行算法2-3 <br>  -2.6。  ELSE将该页面标记为错误 <br>  -2.7。 保存页面数据到结果 <br>  -2.8。 如果这是最后一页，则带来结果 <br>  3. ELSE将源和登录页面之间的链接保存在结果中 <br></blockquote><br>  <b>是的，该算法将来会发生重大变化。</b> 现在，在额头上特意使用了递归解决方案，以便以后最好“感觉”实现上的差异。 实现该功能的工件如下所示： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crawl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start, limit = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// initialize cache &amp; result return new Promise((resolve, reject) =&gt; { function curl(src, dst) { // check dst in the cache &amp; pages limit // save the link (src -&gt; dst) to the result fetch(dst).then(fetched =&gt; { extract(fetched, dst, start).forEach(ln =&gt; curl(dst, ln)); }).finally(() =&gt; { // save the page's data to the result // check completion and resolve the result }); } curl(null, start); }); }</span></span></code> </pre><br> 通过一个简单的请求计数器检查是否达到页数限制。 第二个计数器（一次活动请求的数量）将用作测试是否准备好给出结果的（当值变为零时）。 如果<i>获取</i>功能无法获取下一页，则将其状态代码设置为null。 <br><br> 您可以（可选） <a href="">在此处熟悉</a>实现代码，但是在<a href="">此</a>之前，您应该考虑返回结果的格式。 <br><br><h4>  7.返回结果 </h4><br> 我们将为轮询的页面引入一个唯一的<i>ID</i>标识符，并以简单的增量递增： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> id = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cache = {}; <span class="hljs-comment"><span class="hljs-comment">// ... let dstNorm = normalize(dst); if (dstNorm in cache === false) { cache[dstNorm] = ++id; // ... }</span></span></code> </pre><br> 为了获得结果，让我们创建一个<i>页面</i>数组，在其中我们将在页面上添加包含数据的对象： <i>id</i> {number}， <i>url</i> {string}和<i>代码</i> {number | null}（现在足够了）。 我们还为对象之间的页面之间的<i>链接</i>创建了一个<i>链接</i>数组： <i>从</i> （源页面的<i>ID</i> ） <i>到</i> （登陆页面的<i>ID</i> ）。 <br><br> 出于参考目的，在解决结果之前，我们以<i>id的</i>升序对页面列表进行排序（毕竟，答案将以任何顺序出现），在结果中添加扫描的<i>计数</i>页面<i>数</i>和达到指定的<i>fin</i>限制的标志： <br><br><pre> <code class="javascript hljs">resolve({ <span class="hljs-attr"><span class="hljs-attr">pages</span></span>: pages.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p1, p2</span></span></span><span class="hljs-function">) =&gt;</span></span> p1.id - p2.id), <span class="hljs-attr"><span class="hljs-attr">links</span></span>: links.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">l1, l2</span></span></span><span class="hljs-function">) =&gt;</span></span> l1.from - l2.from || l1.to - l2.to), count, <span class="hljs-attr"><span class="hljs-attr">fin</span></span>: count &lt; limit });</code> </pre><br><h3> 使用范例 </h3><br> 完成的搜寻器脚本具有以下概要： <br><br><pre> <code class="plaintext hljs">node crawl-cli.js --start="&lt;URL&gt;" [--output="&lt;filename&gt;"] [--limit=&lt;int&gt;]</code> </pre><br> 补充过程关键点的日志记录，我们将在启动时看到这样的画面： <br><br><pre> <code class="plaintext hljs">$ node crawl-cli.js --start="https://google.com" --limit=20 [2019-02-26T19:32:10.087Z] Start crawl "https://google.com" with limit 20 [2019-02-26T19:32:10.089Z] Request (#1) "https://google.com/" [2019-02-26T19:32:10.721Z] Fetched (#1) "https://google.com/" with code 301 [2019-02-26T19:32:10.727Z] Request (#2) "https://www.google.com/" [2019-02-26T19:32:11.583Z] Fetched (#2) "https://www.google.com/" with code 200 [2019-02-26T19:32:11.720Z] Request (#3) "https://play.google.com/?hl=ru&amp;tab=w8" [2019-02-26T19:32:11.721Z] Request (#4) "https://mail.google.com/mail/?tab=wm" [2019-02-26T19:32:11.721Z] Request (#5) "https://drive.google.com/?tab=wo" ... [2019-02-26T19:32:12.929Z] Fetched (#11) "https://www.google.com/advanced_search?hl=ru&amp;authuser=0" with code 200 [2019-02-26T19:32:13.382Z] Fetched (#19) "https://translate.google.com/" with code 200 [2019-02-26T19:32:13.782Z] Fetched (#14) "https://plus.google.com/108954345031389568444" with code 200 [2019-02-26T19:32:14.087Z] Finish crawl "https://google.com" on count 20 [2019-02-26T19:32:14.087Z] Save the result in "result.json"</code> </pre><br> 这是JSON格式的结果： <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"pages"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://google.com/"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">301</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://www.google.com/"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://play.google.com/?hl=ru&amp;tab=w8"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">302</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://mail.google.com/mail/?tab=wm"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">302</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://drive.google.com/?tab=wo"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">302</span></span> }, // ... { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">19</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://translate.google.com/"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://calendar.google.com/calendar?tab=wc"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">302</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> }, // ... { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-number"><span class="hljs-number">19</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-number"><span class="hljs-number">19</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"count"</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fin"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br><br> 已经可以做什么呢？ 至少，页面列表可以找到站点的所有损坏页面。 有了有关内部链接的信息，您可以检测重定向的长链（和闭环）或按参考质量查找最重要的页面。 <br><br><h3> 公告2.0 </h3><br> 我们获得了最简单的控制台搜寻器的一种变体，它绕过了一个站点的页面。 源代码<a href="">在这里</a> 。 还有一些功能的示例和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">单元测试</a> 。 <br><br> 现在，这是一个不礼貌的请求发送者，下一步的合理步骤是教他良好的举止。 这将涉及<i>用户代理</i>标头， <i>robots.txt</i>规则， <i>抓取延迟</i>指令等。 从实现的角度来看，这首先是对消息进行排队，然后为更大的负载提供服务。  <i>如果这种材料当然很有趣！</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN441024/">https://habr.com/ru/post/zh-CN441024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN441012/index.html">有关中国登月计划和the娥四号太空飞行任务历史的有趣事实</a></li>
<li><a href="../zh-CN441014/index.html">几行代码（立体图，立体浮雕，立体镜）的低成本预算立体渲染</a></li>
<li><a href="../zh-CN441018/index.html">NanoCAD Mechanics程序开发和规范工具</a></li>
<li><a href="../zh-CN441020/index.html">VTB是如何形成单一知识的</a></li>
<li><a href="../zh-CN441022/index.html">铁路和航空旅客的常见错误</a></li>
<li><a href="../zh-CN441026/index.html">最小的VMware NSX。 第2部分。配置防火墙和NAT</a></li>
<li><a href="../zh-CN441028/index.html">研究人员如何发现开放的MongoDB和Elasticsearch数据库</a></li>
<li><a href="../zh-CN441030/index.html">使用Seq2Seq自动编码器检测Web攻击</a></li>
<li><a href="../zh-CN441032/index.html">基比 从头开始制作自己的USB键盘</a></li>
<li><a href="../zh-CN441034/index.html">6点转化率增长或如何使用网站上的电话提高信心</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>