<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé∫ üíÇüèº üìô Mausgesteuerte Widgets. Ziehen und Ablegen innerhalb des Fensters ‚úãüèø üö¨ üíÖüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das √ºbliche Verst√§ndnis von Drag & Drop (D & D) setzt voraus, dass beispielsweise ein Link zu einer Datei von einem Widget genommen und mit der Maus i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mausgesteuerte Widgets. Ziehen und Ablegen innerhalb des Fensters</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473716/"><p> Das √ºbliche Verst√§ndnis von Drag &amp; Drop (D &amp; D) setzt voraus, dass beispielsweise ein Link zu einer Datei von einem Widget genommen und mit der Maus in ein anderes Fenster oder Widget verschoben wird.  Als n√§chstes werden wir nicht √ºber die Bibliotheksfunktionen von D &amp; D sprechen, sondern √ºber unsere eigene Implementierung des Verschiebens des Widgets innerhalb des Fensters und die damit verbundenen Funktionen.  Der Code ist mehr als eine konkrete praktische Anwendung, die im C-Stil mit Klassen geschrieben ist.  Der Editor ist CodeBlocks 17.12, der unter Ubuntu x64 im Vergleich zur 16. Version nicht mehr abst√ºrzt. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/e1/2g/ve/e12gvery3tvo4tlu5z_2mrdkppy.png" alt="Bild"></div><a name="habracut"></a><br><p>  Es gibt einen Widget-Container GtkFixed, in dem andere Widgets an bestimmten Koordinaten gespeichert werden k√∂nnen. Das klassische Konzept zum Erstellen von Anwendungen in GTK umfasst die Verwendung von Widget-Containern GtkBox (und anderen), um das Fenster korrekt zu dehnen und den Raum zu f√ºllen.  Der Container wird entweder auf die Gr√∂√üe des Fensters (und auf die R√§nder anderer Widgets) gestreckt oder in der Regel auf die Gr√∂√üe des untergeordneten Widgets reduziert. <br></p><p>  Der Code ist in main.cpp, main.hpp, movable_widgets.hpp unterteilt.  Ich habe die Implementierungsdatei nicht separat ausgew√§hlt.  Der Inhalt von main.cpp ist ziemlich typisch: <br><br></p><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"movable_widgets.hpp"</span></span></span><span class="hljs-meta"> void builder_init(gpointer user_data) { appdata *data=(appdata*) user_data; GError *</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> = NULL; GtkBuilder *builder = gtk_builder_new(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!gtk_builder_add_from_file (builder, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"window.glade"</span></span></span><span class="hljs-meta">, &amp;</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta">)) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     g_critical ("   : %s", error-&gt;message); g_error_free (error); } data-&gt;win=GTK_WIDGET(gtk_builder_get_object(builder, "window1")); data-&gt;notebook=GTK_NOTEBOOK(gtk_builder_get_object(builder, "notebook1")); gtk_notebook_remove_page(data-&gt;notebook,0); ///    gtk_builder_connect_signals (builder,data); g_clear_object(&amp;builder); } void application_activate(GtkApplication *application, gpointer user_data) { appdata *data=(appdata*) user_data; builder_init(data); gtk_widget_set_size_request(data-&gt;win,320,240); gtk_application_add_window(data-&gt;app,GTK_WINDOW(data-&gt;win)); page_body *page=new page_body(data, G_OBJECT(data-&gt;notebook)); const gchar *text ="&lt;span foreground=\"blue\" size=\"x-large\"&gt;Blue text&lt;/span&gt;" ; GtkWidget *label = gtk_label_new (NULL); gtk_label_set_markup (GTK_LABEL (label), text); GtkWidget *image=gtk_image_new_from_file("opennet2.gif"); GtkWidget *image2=gtk_image_new_from_file("n_temp.png"); page-&gt;add_widget(label,label_t,10,10); page-&gt;add_widget(image,image_t,20,20); page-&gt;add_widget(image2,image_t,40,40); gtk_widget_show_all(data-&gt;win); } void application_shutdown(const GtkApplication *application, gpointer user_data) {} int main (int argc, char *argv[]) { appdata data; gtk_init (&amp;argc, &amp;argv); gint res; data.app = gtk_application_new("gtk3.org", G_APPLICATION_FLAGS_NONE); g_signal_connect(data.app, "activate", G_CALLBACK(application_activate), &amp;data); g_signal_connect(data.app, "shutdown", G_CALLBACK(application_shutdown), &amp;data); res = g_application_run(G_APPLICATION(data.app), 0, NULL); return 0; }</span></span></span></span></code> </pre> <br><p>  Einige Widgets werden aus einer XML-Beschreibung (Funktion builder_init) erstellt, ein anderer Teil programmgesteuert (page-&gt; add_widget).  Gtk_widget_show_all Funktion (Daten-&gt; Win);  wird f√ºr die rekursive Anzeige von Widgets und deren Inhalten ben√∂tigt.  GTK l√∂scht unabh√§ngig den Inhalt von Widgets, wenn diese gel√∂scht werden, insbesondere von anderen untergeordneten Widgets.  Zum Zeitpunkt der Ausf√ºhrung der R√ºckruffunktion application_shutdown sind das Hauptfenster und alle Inhalts-Widgets bereits gel√∂scht. <br></p><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;gtk/gtk.h&gt; #include &lt;stdbool.h&gt; #include &lt;stdlib.h&gt; #define restrict __restrict__ class appdata { public: char *glade_name=(char*)"window.glade"; GtkApplication *restrict app; GtkWidget *restrict win; GtkNotebook *restrict notebook; GArray *restrict pages; }; #endif</span></span></span></span></code> </pre><br>  Das Seitenfeld ist ein Array von Zeigern auf Klassen mit dem Inhalt der Seiten. In diesem Beispiel wird es nicht verwendet, da nur eine Registerkarte verwendet wird.  Verwenden von Restrict ist ein Amateur.  Theoretisch ergibt sich eine gewisse Leistungssteigerung.  In diesem Fall besteht keine Notwendigkeit zur Verwendung. <br><br><p>  Das eingef√ºgte Widget selbst wird in einem Container vom Typ GtkEventBox abgelegt.  Er sammelt Ereignisse <br>  Knopfdruck.  Auch ein optionaler Container vom Typ GtkFrame zum Anzeigen eines Widgets in einem Frame beim Klicken mit der linken Maustaste.  Der Containerwechsel ist schnell genug.  Die Registerkarte selbst, in die Widgets eingef√ºgt werden, weist die folgende Hierarchie von Anh√§ngen auf: GtkScrolledWindow-&gt; GtkViewport-&gt; GtkFixed.  Anfangs sind Widgets vom Typ GtkWidget, das von Makros in die Typen GtkViewport, GtkFixed konvertiert wird.  Ich w√ºrde betonen <br>  Aufmerksamkeit auf die Makroansicht <br>  InsertedWidgetWithProperty * widget_with_property = &amp; g_array_index (Widgets, InsertedWidgetWithProperty, i); <br>  da es am einfachsten ist, hier einen Fehler zu machen.  Parameter x_correction, y_correction - Koordinaten des Mausklicks relativ zum eingef√ºgten Widget GtkEvent.  Das Flag button_not_pressed wird verwendet, um den Frame-Container korrekt anzuzeigen.  Unter Logik versteht es sich, dass eine der Maustasten, die auf das eingef√ºgte Widget geklickt wird, in einem Rahmen platziert werden sollte.  Das hei√üt, die Buttonclick- und Buttonrelease-Ereignisse sind im Gegensatz zu den Enter-Notify-Event- und Leave-Notify-Event-Ereignissen, die mit einer √Ñnderung der Cursorform verbunden sind, nicht gepaart.  Wenn die Parameter x_correction, button_not_pressed Dienstparameter sind, dh sie sollten im privaten Bereich platziert werden, wird das Flag click_order verwendet, um das aktuelle Widget √ºber dem Rest anzuzeigen. <br><br></p><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> GtkWidget *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> widget_ptr; GtkWidget *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> eventbox; GtkWidget *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> frame; <span class="hljs-comment"><span class="hljs-comment">//   GtkWidget *restrict pmenu; widget_type type; bool button_not_pressed; } InsertedWidgetWithProperty; class page_body { public: GtkWidget *restrict scrolledwindow; GtkWidget *restrict viewport; GtkWidget *restrict fixed; GArray *restrict widgets=g_array_new(FALSE, TRUE, sizeof(InsertedWidgetWithProperty)); GtkAdjustment *restrict h_adj; GtkAdjustment *restrict v_adj; int num_of_current_widget=0; double x_correction=0; double y_correction=0; GtkWidget *restrict window; ///      int widget_count=0; bool click_order=FALSE; //TRUE -  page_body(appdata *data, GObject *container) { window=data-&gt;win; h_adj=gtk_adjustment_new(0.0,4.0,900.0,1.0,5.0,10.0); v_adj=gtk_adjustment_new(0.0,4.0,900.0,1.0,5.0,10.0); scrolledwindow=gtk_scrolled_window_new(h_adj, v_adj); viewport=gtk_viewport_new(h_adj, v_adj); fixed=gtk_fixed_new(); gtk_container_add(GTK_CONTAINER(scrolledwindow),GTK_WIDGET(viewport)); gtk_container_add(GTK_CONTAINER(viewport),GTK_WIDGET(fixed)); if(GTK_IS_NOTEBOOK(container)) { gtk_notebook_append_page ((GtkNotebook*)container,scrolledwindow,NULL); } else if(GTK_IS_WIDGET(container)) { gtk_container_add(GTK_CONTAINER(container),scrolledwindow); } g_signal_connect(fixed,"motion-notify-event",G_CALLBACK(fixed_motion_notify), this); g_signal_connect(scrolledwindow,"destroy",G_CALLBACK(scrolled_window_destroy_cb), this); } ~page_body() { int i=widgets-&gt;len; if(widget_count&gt;0) { for(i; i&gt;=0; i--) { InsertedWidgetWithProperty *widget_with_property; widget_with_property=&amp;g_array_index(widgets,InsertedWidgetWithProperty,i); } } g_array_free(widgets,TRUE); } void add_widget(GtkWidget *widget, widget_type type, int x, int y) { ++widget_count; InsertedWidgetWithProperty *widget_with_property=(InsertedWidgetWithProperty*) g_malloc0(sizeof(InsertedWidgetWithProperty)); widget_with_property-&gt;eventbox=gtk_event_box_new(); widget_with_property-&gt;type=type; widget_with_property-&gt;widget_ptr=widget; gtk_container_add(GTK_CONTAINER(widget_with_property-&gt;eventbox),widget); gtk_fixed_put(GTK_FIXED(fixed),widget_with_property-&gt;eventbox,x,y); widget_with_property-&gt;pmenu=gtk_menu_new(); GtkWidget *menu_items = gtk_menu_item_new_with_label (""); gtk_widget_show(menu_items); gtk_menu_shell_append (GTK_MENU_SHELL (widget_with_property-&gt;pmenu), menu_items); g_signal_connect(widget_with_property-&gt;eventbox,"button-press-event",G_CALLBACK(eventbox_press_cb),this); g_signal_connect(widget_with_property-&gt;eventbox,"button-release-event",G_CALLBACK(eventbox_release_cb),this); g_signal_connect(menu_items,"activate",G_CALLBACK(menu_delete_activate),this); g_signal_connect(widget_with_property-&gt;eventbox,"leave-notify-event",G_CALLBACK(eventbox_leave_cb),this); g_signal_connect(widget_with_property-&gt;eventbox,"enter-notify-event",G_CALLBACK(eventbox_enter_cb),this); gtk_widget_set_events(widget_with_property-&gt;eventbox,GDK_LEAVE_NOTIFY_MASK|GDK_ENTER_NOTIFY_MASK|GDK_STRUCTURE_MASK); g_array_append_val(widgets, *widget_with_property); } inline void change_cursor(char *cursor_name) { GdkDisplay *display; GdkCursor *cursor; display = gtk_widget_get_display (window); if(cursor_name) cursor = gdk_cursor_new_from_name (display, cursor_name); else cursor = gdk_cursor_new_from_name (display, "default"); GdkWindow *gdkwindow=gtk_widget_get_window (window); gdk_window_set_cursor (gdkwindow, cursor); } inline void delete_widget(int i) { InsertedWidgetWithProperty *widget_with_property= &amp;g_array_index(this-&gt;widgets,InsertedWidgetWithProperty,i); GtkWidget *eventbox=widget_with_property-&gt;eventbox; g_object_ref(eventbox); gtk_container_remove(GTK_CONTAINER(this-&gt;fixed),eventbox); if(widget_with_property-&gt;frame!=NULL) { gtk_widget_destroy(widget_with_property-&gt;frame); } gtk_widget_destroy(widget_with_property-&gt;eventbox); this-&gt;widgets=g_array_remove_index_fast(this-&gt;widgets,i); --this-&gt;widget_count; } };</span></span></code> </pre><br>  Die Formel zum Berechnen der Koordinaten des Widgets, damit es sich beim Klicken mit der Maus nicht in eine Richtung bewegt.  Es beinhaltet die Koordinaten des Klicks relativ zum Widget, <br>  GtkFixed-Koordinaten relativ zum Anwendungsfenster, Fensterkoordinaten relativ zum Bildschirm. <br>  Der Korrekturfaktor +25 verwirrt mich etwas, aber ich wei√ü nicht, wie einfach das Schreiben ist.  Ich habe die Arbeit in Versionen von Ubuntu 15.10, 16.04, 18.04 √ºberpr√ºft.  Der Vergleich mit 0 und -1 wird durchgef√ºhrt, damit das eingef√ºgte Widget nicht aus dem scrollbaren Bereich entfernt wird.  Das Scrollen selbst wird vom GtkScrolledWindow-Widget bereitgestellt. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fixed_motion_notify</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, GdkEvent *event, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ page_body *page=(page_body*) user_data; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x_win, y_win, x_fixed, y_fixed; gtk_window_get_position(GTK_WINDOW(page-&gt;window),&amp;x_win,&amp;y_win); gtk_widget_translate_coordinates(page-&gt;window,page-&gt;fixed,x_win,y_win,&amp;x_fixed,&amp;y_fixed); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> correction_y=(-y_fixed+y_win)*<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> correction_x=(-x_fixed+x_win); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x_corr=page-&gt;x_correction; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y_corr=page-&gt;y_correction; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> position_x=event-&gt;motion.x_root-x_corr-x_win-correction_x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> position_y=event-&gt;motion.y_root-y_corr-y_fixed-correction_y; InsertedWidgetWithProperty *widget_with_property=&amp;g_array_index(page-&gt;widgets,InsertedWidgetWithProperty,page-&gt;num_of_current_widget); GtkWidget *fixed=page-&gt;fixed; GtkWidget *eventbox=widget_with_property-&gt;eventbox; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(position_x&lt;<span class="hljs-number"><span class="hljs-number">-1</span></span>) position_x=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(position_y&lt;<span class="hljs-number"><span class="hljs-number">-1</span></span>) position_y=<span class="hljs-number"><span class="hljs-number">0</span></span>; gtk_fixed_move(GTK_FIXED(fixed), eventbox, position_x, position_y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; }</code> </pre><br>  Der Rest der R√ºckruffunktionen.  Das Entfernen einzelner Widgets √ºber das Kontextmen√º mit der rechten Maustaste wurde implementiert.  Das Entfernen der page_body-Klasse wird vom L√∂schereignis GtkScrolledWindow angehalten. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scrolled_window_destroy_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *object, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ page_body *page=(page_body*) user_data; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> page; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">menu_delete_activate</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkMenuItem *menuitem, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ page_body *page=(page_body*) user_data; page-&gt;delete_widget(page-&gt;num_of_current_widget); } <span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eventbox_leave_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, GdkEvent *event, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ page_body *page=(page_body*) user_data; page-&gt;change_cursor(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); } <span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eventbox_enter_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, GdkEvent *event, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ page_body *page=(page_body*) user_data; page-&gt;change_cursor(<span class="hljs-string"><span class="hljs-string">"pointer"</span></span>); } <span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eventbox_press_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, GdkEvent *event, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ page_body *page=(page_body*) user_data; page-&gt;x_correction=event-&gt;button.x; page-&gt;y_correction=event-&gt;button.y; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; InsertedWidgetWithProperty *widget_compare; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i; i&lt;=page-&gt;widgets-&gt;len; i++) { widget_compare=(InsertedWidgetWithProperty*) page-&gt;widgets-&gt;data+i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(widget==widget_compare-&gt;eventbox) { page-&gt;num_of_current_widget=i; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(widget_compare-&gt;button_not_pressed==FALSE) { GtkWidget *eventbox=widget_compare-&gt;eventbox; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(page-&gt;click_order) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; gtk_widget_translate_coordinates(page-&gt;fixed, eventbox,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,&amp;x, &amp;y); gtk_container_remove(GTK_CONTAINER(page-&gt;fixed),eventbox); gtk_fixed_put(GTK_FIXED(page-&gt;fixed),eventbox,-x,-y); } g_object_ref(widget_compare-&gt;widget_ptr); gtk_container_remove(GTK_CONTAINER(eventbox),widget_compare-&gt;widget_ptr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(widget_compare-&gt;frame==<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) widget_compare-&gt;frame=gtk_frame_new(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); gtk_container_add(GTK_CONTAINER(widget_compare-&gt;frame),widget_compare-&gt;widget_ptr); gtk_container_add(GTK_CONTAINER(eventbox),widget_compare-&gt;frame); gtk_widget_show_all(eventbox); widget_compare-&gt;button_not_pressed=TRUE; } <span class="hljs-comment"><span class="hljs-comment">///   const gint RIGHT_CLICK = 3; if (event-&gt;type == GDK_BUTTON_PRESS) { GdkEventButton *bevent = (GdkEventButton *) event; if (bevent-&gt;button == RIGHT_CLICK) { gtk_menu_popup(GTK_MENU(widget_compare-&gt;pmenu), NULL, NULL, NULL, NULL, bevent-&gt;button, bevent-&gt;time); } } return FALSE; } gboolean eventbox_release_cb (GtkWidget *eventbox, GdkEvent *event, gpointer user_data) { page_body *page=(page_body*) user_data; InsertedWidgetWithProperty *widget_with_property= &amp;g_array_index(page-&gt;widgets,InsertedWidgetWithProperty,page-&gt;num_of_current_widget); ///      ,    if(widget_with_property-&gt;button_not_pressed==TRUE) { widget_with_property-&gt;frame=(GtkWidget*) g_object_ref(widget_with_property-&gt;frame); widget_with_property-&gt;widget_ptr=(GtkWidget*) g_object_ref(widget_with_property-&gt;widget_ptr); GtkWidget *frame=widget_with_property-&gt;frame; GtkWidget *widget=widget_with_property-&gt;widget_ptr; gtk_container_remove(GTK_CONTAINER(eventbox), frame); gtk_container_remove(GTK_CONTAINER(frame), widget); gtk_container_add(GTK_CONTAINER(eventbox), widget); widget_with_property-&gt;button_not_pressed=FALSE; } }</span></span></code> </pre><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/SanyaZ7/movable_widgets_on_GtkFixed-</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de473716/">https://habr.com/ru/post/de473716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de473704/index.html">Bro vs. nicht bro</a></li>
<li><a href="../de473706/index.html">Zoia: Leichtes reaktives CMS f√ºr die schnelle Entwicklung von Websites</a></li>
<li><a href="../de473708/index.html">Selbstgemachtes Elektroauto - alles ist nicht so, wie Sie denken</a></li>
<li><a href="../de473710/index.html">Die Prinzipien der Dokumentation und Lokalisierung oder wie man eine gute Lokalisierung bei minimalen Kosten erzielt</a></li>
<li><a href="../de473714/index.html">Wie ich zur formalen Spezifikation eines RISC-V-Prozessors in F # kam</a></li>
<li><a href="../de473718/index.html">So f√ºgen Sie NoVerify Schecks hinzu, ohne eine einzige Zeile Go-Code zu schreiben</a></li>
<li><a href="../de473720/index.html">Zwei M√∂glichkeiten, um zuverl√§ssige Komponententests durchzuf√ºhren</a></li>
<li><a href="../de473722/index.html">Fernisolation, Angst und Depression</a></li>
<li><a href="../de473726/index.html">Es reicht nicht aus zu wissen, was Mutex, Semaphore und Async / Warten sind. Sie m√ºssen alles von Quanten wissen</a></li>
<li><a href="../de473728/index.html">Typische Implementierung der √úberwachung. Nikolay Sivko</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>