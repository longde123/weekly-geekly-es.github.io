<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüé® üîÅ üòó Multimodularit√§t und Dolch 2. Yandex-Vorlesung ü§≤ üöú üò¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Ihre Anwendung auf einer Architektur mit mehreren Modulen basiert, m√ºssen Sie viel Zeit darauf verwenden, sicherzustellen, dass die gesamte Kommu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Multimodularit√§t und Dolch 2. Yandex-Vorlesung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/419295/">  Wenn Ihre Anwendung auf einer Architektur mit mehreren Modulen basiert, m√ºssen Sie viel Zeit darauf verwenden, sicherzustellen, dass die gesamte Kommunikation zwischen den Modulen korrekt in den Code geschrieben ist.  Die H√§lfte dieser Arbeit kann dem Dagger 2-Framework anvertraut werden. Der Leiter der Yandex.Map-Gruppe f√ºr Android Vladimir Tagakov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Noxa</a> sprach √ºber die Vor- und Nachteile der Multimodularit√§t und der bequemen Organisation von DI in Modulen mit Dagger 2. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/pMEAD6jjbaI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Mein Name ist Vladimir, ich entwickle Yandex.Maps und heute werde ich Ihnen von der Modularit√§t und dem zweiten Dolch erz√§hlen. <a name="habracut"></a><br><br>  Ich habe den l√§ngsten Teil verstanden, als ich ihn selbst studiert habe, den schnellsten.  Den zweiten Teil, √ºber den ich mehrere Wochen gesessen habe, werde ich Ihnen sehr schnell und pr√§zise erz√§hlen. <br><br><img src="https://habrastorage.org/webt/t5/2r/s5/t52rs5gcestw_7jvexuardxaaus.jpeg"><br><br>  Warum haben wir einen schwierigen Prozess der Aufteilung in Module in Maps gestartet?  Wir wollten nur die Build-Geschwindigkeit erh√∂hen, jeder wei√ü davon. <br><br>  Der zweite Punkt des Ziels besteht darin, das Code-Hooking zu reduzieren.  Ich habe die Ausr√ºstung von Wikipedia genommen.  Dies bedeutet, dass wir die Verbindungen zwischen den Modulen reduzieren wollten, damit die Module getrennt sind und au√üerhalb der Anwendung verwendet werden k√∂nnen.  Erste Erkl√§rung des Problems: Andere Yandex-Projekte sollten in der Lage sein, einen Teil der Funktionalit√§t von Maps genau wie wir zu nutzen.  Und um diese Funktionalit√§t zu entwickeln, sind wir an der Entwicklung des Projekts beteiligt. <br><br>  Ich m√∂chte einen brennenden Pantoffel in Richtung [k] apt werfen, was die Montagegeschwindigkeit verlangsamt.  Ich hasse ihn nicht sehr, aber ich liebe ihn sehr.  Er l√§sst mich Dolch benutzen. <br><br><img src="https://habrastorage.org/webt/9c/bz/iv/9cbzivba2osslltalebrdwqfsre.jpeg"><br><br>  Der Hauptnachteil des Modultrennungsprozesses ist paradoxerweise die Verlangsamung der Montagegeschwindigkeit.  Besonders zu Beginn, wenn Sie die ersten beiden Module Common und einige Ihrer Funktionen herausnehmen, sinkt die allgemeine Erstellungsgeschwindigkeit des Projekts, unabh√§ngig davon, wie Sie es versuchen.  Am Ende erh√∂ht sich die Erstellungsgeschwindigkeit, da weniger Code in Ihrem Hauptmodul verbleibt.  Und das bedeutet nicht, dass alles sehr schlecht ist. Es gibt M√∂glichkeiten, dies zu umgehen und sogar vom ersten Modul zu profitieren. <br><br>  Der zweite Nachteil ist, dass es schwierig ist, den Code in Module zu unterteilen.  Wer es versucht hat, wei√ü, dass Sie anfangen, Abh√§ngigkeiten und Klassiker zu ziehen, und am Ende haben Sie Ihr gesamtes Hauptmodul in ein anderes Modul kopiert und von vorne begonnen.  Daher m√ºssen Sie den Moment klar verstehen, in dem Sie die Verbindung mithilfe einer Art Abstraktion stoppen und trennen m√ºssen.  Der Nachteil sind mehr Abstraktionen.  Mehr Abstraktionen - komplexeres Design - mehr Abstraktionen. <br><br>  Es ist schwierig, neue Gradle-Module hinzuzuf√ºgen.  Warum?  Zum Beispiel kommt ein Entwickler, nimmt eine neue Funktion in die Entwicklung auf, macht sofort gut, macht ein separates Modul.  Was ist das Problem?  Er muss sich den gesamten verf√ºgbaren Code im Hauptmodul merken, damit er gegebenenfalls wiederverwendet und in Common abgelegt werden kann.  Weil der Prozess des Herausnehmens eines Moduls in Common konstant ist, bis sich Ihr Haupt-App-Modul in eine d√ºnne Schicht verwandelt. <br><br>  Module, Module, Module ... Gradle-Module, Dolchmodule, Schnittstellenmodule sind schrecklich. <br><br><img src="https://habrastorage.org/webt/2b/nj/x2/2bnjx25ooi8xw2exdinm5yfmmys.jpeg"><br><br>  Der Bericht wird aus drei Teilen bestehen: klein, gro√ü und komplex.  Erstens der Unterschied zwischen der Implementierung und der API in AGP.  Android Gradle Plugin 3.0 ist vor relativ kurzer Zeit erschienen.  Wie war alles vor ihm? <br><br><img src="https://habrastorage.org/webt/qc/oa/fw/qcoafwzux6royjdv11tr0sqvmug.jpeg"><br><br>  Hier ist ein typisches Projekt eines gesunden Entwicklers, das aus drei Modulen besteht: Das Hauptmodul der App wird in der Anwendung zusammengestellt und installiert, sowie zwei Funktionsmodule. <br><br>  Sprechen Sie sofort √ºber die Pfeile.  Dies ist ein gro√üer Schmerz, jeder zeichnet in die Richtung, in die es f√ºr ihn bequem ist, zu zeichnen.  Bei mir bedeutet das, dass es von Core aus einen Pfeil zu Feature gibt.  Feature kennt sich also mit Core aus und kann Klassen von Core verwenden.  Wie Sie sehen k√∂nnen, gibt es keinen Pfeil zwischen dem Core und der App, was bedeutet, dass die App anscheinend keinen Core verwendet.  Core ist kein allgemeines Modul, es ist, jeder h√§ngt davon ab, es ist separat, es enth√§lt wenig Code.  Wir werden es zwar nicht ber√ºcksichtigen. <br><br>  Unser Kernmodul hat sich ge√§ndert, wir m√ºssen es irgendwie wiederholen.  Wir √§ndern den Code darin.  Gelbe Farbe - Code√§nderung. <br><br><img src="https://habrastorage.org/webt/l4/b1/5w/l4b15wdqsgukdttudzee9vbxne0.jpeg"><br><br>  Nach dem Zusammenbau des Projekts.  Es ist klar, dass ein Modul nach dem √Ñndern neu erstellt und kompiliert werden muss.  Okay <br><br><img src="https://habrastorage.org/webt/_q/jo/mh/_qjomhp4-vkpioy_0ai112zuam0.jpeg"><br><br>  Nachdem das Feature-Modul ebenfalls zusammengebaut ist, h√§ngt das davon ab.  Es ist auch klar, dass sich seine Abh√§ngigkeit wieder zusammengesetzt hat und Sie sich selbst aktualisieren m√ºssen.  Wer wei√ü, was sich dort ge√§ndert hat. <br><br>  Und hier passiert das Unangenehmste.  Das App-Modul l√§uft, obwohl nicht klar ist, warum.  Ich wei√ü mit Sicherheit, dass ich Core in keiner Weise verwende und warum die App neu erstellt wird, ist unklar.  Und er ist sehr gro√ü, denn ganz am Anfang des Weges, und das ist ein sehr gro√üer Schmerz. <br><br><img src="https://habrastorage.org/webt/hu/j8/la/huj8larhnqmhr6dq7qhp2etnkc8.jpeg"><br><br>  Wenn mehrere Funktionen, viele Module von Core abh√§ngen, wird die ganze Welt wieder zusammengesetzt, was sehr lange dauert. <br><br>  Lassen Sie uns auf die neue Version von AGP aktualisieren und, wie im Handbuch angegeben, alle Kompilierungen mit der API und nicht mit der Implementierung ersetzen, wie Sie dachten.  Nichts √§ndert sich.  Die Schemata sind identisch.  Was ist die neue Methode zum Festlegen von Implementierungsabh√§ngigkeiten?  Stellen Sie sich dasselbe Schema vor, das nur dieses Schl√ºsselwort ohne API verwendet?  Es wird so aussehen. <br><br><img src="https://habrastorage.org/webt/nj/ns/fg/njnsfgghg9om12lpwlu5yh21hmu.jpeg"><br><br>  Hier in der Implementierung ist deutlich zu sehen, dass eine Verbindung zwischen Core und App besteht.  Hier k√∂nnen wir klar verstehen, dass wir es nicht brauchen, wir wollen es loswerden, also entfernen Sie es einfach.  Alles wird einfacher. <br><br><img src="https://habrastorage.org/webt/rp/lx/xr/rplxxrfrsee28vucqevngre8xq4.jpeg"><br><br>  Jetzt ist fast alles gut, sogar mehr als.  Wenn wir eine API in Core √§ndern, eine neue Klasse, eine neue √∂ffentliche oder eine private Paketmethode hinzuf√ºgen, werden Core und Feature neu erstellt.  Wenn Sie die Implementierung innerhalb der Methode √§ndern oder eine private Methode hinzuf√ºgen, sollte das Feature theoretisch √ºberhaupt nicht neu erstellt werden, da sich nichts ge√§ndert hat. <br><br><img src="https://habrastorage.org/webt/mk/ub/1e/mkub1ect0enydqitlermncinoyk.jpeg"><br><br>  Gehen wir weiter.  So kam es, dass viele von unserem Kern abh√§ngen.  Kern ist wahrscheinlich eine Art Netzwerk- oder Benutzerdatenverarbeitung.  Da dies Netzwerk ist, √§ndert sich alles ziemlich oft, alles wird neu aufgebaut und wir haben den gleichen Schmerz, vor dem wir vorsichtig weggelaufen sind. <br>  Schauen wir uns zwei M√∂glichkeiten an, um damit umzugehen. <br><br><img src="https://habrastorage.org/webt/um/_d/c-/um_dc-9rumfh-vyvlqdavr6zvgg.jpeg"><br><br>  Wir k√∂nnen die APIs nur von unserem Kernmodul auf ein separates Modul √ºbertragen, dessen API wir verwenden.  Und in einem separaten Modul k√∂nnen wir die Implementierung dieser Schnittstellen √ºbernehmen. <br><br><img src="https://habrastorage.org/webt/eu/o8/0-/euo80-48enzm_rvppcwmb1qbjca.jpeg"><br><br>  Sie k√∂nnen die Verbindung auf dem Bildschirm anzeigen.  Core Impl ist f√ºr Funktionen nicht verf√ºgbar.  Das hei√üt, es besteht keine Verbindung zwischen den Funktionen und der Core-Implementierung.  Und das gelb hervorgehobene Modul bietet nur Fabriken, die eine Implementierung Ihrer Schnittstellen erm√∂glichen, die niemandem bekannt ist. <br><br>  Nach einer solchen Konvertierung m√∂chte ich darauf hinweisen, dass die Core-API aufgrund der Tatsache, dass das API-Schl√ºsselwort steht, f√ºr alle Funktionen transitiv verf√ºgbar sein wird. <br><br><img src="https://habrastorage.org/webt/7a/lq/iu/7alqiukvhfpie8_olsuekuczfgi.jpeg"><br><br>  Nach diesen Transformationen √§ndern wir etwas an der Implementierung, die Sie am h√§ufigsten ausf√ºhren, und nur das Modul mit den Fabriken wird neu erstellt. Es ist sehr leicht, klein und Sie m√ºssen nicht einmal √ºberlegen, wie lange es dauert. <br><br><img src="https://habrastorage.org/webt/8p/ri/ah/8priahixb3prj9of3cqpzqjxaeg.jpeg"><br><br>  Eine andere Option funktioniert nicht immer.  Wenn dies beispielsweise eine Art Netzwerk ist, kann ich mir kaum vorstellen, wie dies geschehen kann, aber wenn dies eine Art Benutzeranmeldebildschirm ist, kann dies durchaus der Fall sein. <br><br><img src="https://habrastorage.org/webt/eu/rf/cs/eurfcs3tlrk9jasm6fqphr5lb4y.jpeg"><br><br>  Wir k√∂nnen Sample, das gleiche vollwertige Root-Modul wie App, erstellen und nur eine Funktion darin sammeln. Es wird sehr schnell sein und es kann schnell iterativ entwickelt werden.  Am Ende der Pr√§sentation zeige ich Ihnen, wie lange es dauert, ein Beispiel zu erstellen. <br><br>  Mit dem ersten Teil fertig.  Welche Module gibt es? <br><br><img src="https://habrastorage.org/webt/sv/jm/xk/svjmxkqxazeydcsinvypfuh_-24.jpeg"><br><br>  Es gibt drei Arten von Modulen.  Common sollte nat√ºrlich so leicht wie m√∂glich sein und keine Funktionen enthalten, sondern nur die Funktionen, die von allen verwendet werden.  F√ºr uns in unserem Team ist dies besonders wichtig.  Wenn wir unsere Feature-Module anderen Anwendungen zur Verf√ºgung stellen, werden wir sie auf jeden Fall zwingen, Common zu ziehen.  Wenn er sehr fett ist, wird uns niemand lieben. <br><br><img src="https://habrastorage.org/webt/bd/n-/1s/bdn-1si0fx1fxre86gldhgepx34.jpeg"><br><br>  Wenn Sie ein kleineres Projekt haben, k√∂nnen Sie sich mit Common entspannter f√ºhlen, und Sie m√ºssen auch nicht sehr eifrig sein. <br><br><img src="https://habrastorage.org/webt/ah/jj/fi/ahjjfiyfzltnadyswlalhsoeh-u.jpeg"><br><br>  Der n√§chste Modultyp ist Standalone.  Das gebr√§uchlichste und intuitivste Modul, das eine bestimmte Funktion enth√§lt: eine Art Bildschirm, eine Art Benutzerskript und so weiter.  Es sollte so unabh√§ngig wie m√∂glich sein, und daf√ºr k√∂nnen Sie meistens eine Beispiel-App erstellen und darin entwickeln.  Die Beispiel-App ist zu Beginn des Aufteilungsprozesses sehr wichtig, da sich alles noch langsam aufbaut und Sie so schnell wie m√∂glich Gewinn erzielen m√∂chten.  Am Ende, wenn alles in Module zerlegt ist, k√∂nnen Sie alles neu erstellen, es wird schnell sein.  Weil es nicht wieder aufgebaut wird. <br><br><img src="https://habrastorage.org/webt/sz/la/p5/szlap5ot3jnjdtvsj5roegwlboy.jpeg"><br><br>  Promi-Module.  Ich selbst habe mir das Wort ausgedacht.  Der Punkt ist, dass er f√ºr alle sehr ber√ºhmt ist und viele von ihm abh√§ngen.  Das gleiche Netzwerk.  Ich habe bereits gesagt, wenn Sie es oft wieder zusammenbauen, wie k√∂nnen Sie die Tatsache vermeiden, dass alles von Ihnen wieder zusammengesetzt wird.  Es gibt einen anderen Weg, der f√ºr kleine Projekte verwendet werden kann, f√ºr die es nicht das Ziel wert ist, alles als separate Sucht, als separates Artefakt auszugeben. <br><br><img src="https://habrastorage.org/webt/pk/yq/u8/pkyqu8xflbfu40ufwly3wr4rgzi.jpeg"><br><br>  Wie sieht es aus?  Wir wiederholen, dass Sie die API aus Celebrity herausnehmen, ihre Implementierung herausnehmen und jetzt Ihre H√§nde beobachten und auf die Pfeile von Feature zu Celebrity achten.  Das passiert gerade.  Die API Ihres Moduls fiel in Common, die Implementierung blieb darin und die Factory, die die Implementierung dieser API bereitstellt, wurde in Ihrem Hauptmodul angezeigt.  Wenn jemand Mobius beobachtete, dann sprach Denis Neklyudov dar√ºber.  Sehr √§hnliches Schema. <br><br>  Wir verwenden Dagger im Projekt, es gef√§llt uns und wir wollten diesen Vorteil im Kontext verschiedener Module optimal nutzen. <br><br><img src="https://habrastorage.org/webt/kr/ak/xu/krakxunqnjjjoinel9yk0sfbemc.jpeg"><br><br>  Wir wollten, dass jedes Modul einen unabh√§ngigen Abh√§ngigkeitsgraphen hat, eine bestimmte Stammkomponente, von der aus Sie alles tun k√∂nnen. Wir wollten unseren eigenen generierten Code f√ºr jedes Gradle-Modul.  Wir wollten nicht, dass sich der generierte Code in den Hauptcode einschleicht.  Wir wollten so viel Validierung zur Kompilierungszeit wie m√∂glich.  Wir leiden unter [k] apt, zumindest sollten wir etwas Profit von dem bekommen, was Dolch gibt.  Und mit all dem wollten wir niemanden zwingen, Dolch zu benutzen.  Weder derjenige, der das neue Funktionsmodul separat implementiert, noch derjenige, der es dann verwendet, sind unsere Kollegen, die nach einigen Funktionen f√ºr sich selbst fragen. <br><br>  Wie organisiere ich ein separates Abh√§ngigkeitsdiagramm in unserem Funktionsmodul? <br><br><img src="https://habrastorage.org/webt/9p/-u/im/9p-uimpq3hakpiwmedw-kinrsai.jpeg"><br><br>  Sie k√∂nnen versuchen, Subcomponent zu verwenden, und es wird sogar funktionieren.  Dies hat jedoch einige M√§ngel.  Sie k√∂nnen sehen, dass in Subcomponent nicht klar ist, welche Abh√§ngigkeiten von Component verwendet werden.  Um dies zu verstehen, m√ºssen Sie das Projekt lange und schmerzhaft wieder zusammensetzen, sich ansehen, was Dagger schw√∂rt, und es hinzuf√ºgen. <br>  Dar√ºber hinaus sind die Unterkomponenten so angeordnet, dass sie andere zur Verwendung von Dolch zwingen, und es wird f√ºr Ihre Kunden und sich selbst nicht einfach, wenn Sie sich entscheiden, in einem Modul abzulehnen. <br><br><img src="https://habrastorage.org/webt/d3/wz/vj/d3wzvj5_hjyy31e9rl-6hlo36ck.jpeg"><br><br>  Eines der ekelhaftesten Dinge ist, dass bei Verwendung von Subcomponent alle Abh√§ngigkeiten in das Hauptmodul gezogen werden.  Dolch ist so konzipiert, dass Unterkomponenten von einer eingebetteten Klasse ihrer Rahmenkomponenten, dem √ºbergeordneten Element, generiert werden.  Vielleicht hat sich jemand den generierten Code und seine Gr√∂√üe f√ºr die generierten Komponenten angesehen?  Wir haben 20.000 Zeilen darin.  Da Unterkomponenten immer verschachtelte Klassen f√ºr Komponenten sind, stellt sich heraus, dass Unterkomponenten von Unterkomponenten ebenfalls verschachtelt sind und der gesamte generierte Code in das Hauptmodul f√§llt, diese zwanzigzeilige Datei, die kompiliert und √ºberarbeitet werden muss. Studio beginnt sich zu verlangsamen - Schmerz. <br><br>  Aber es gibt eine L√∂sung.  Sie k√∂nnen nur Component verwenden. <br><br><img src="https://habrastorage.org/webt/dr/1b/lc/dr1blc8pj2qzzhxs3pnnu7lbqui.jpeg"><br><br>  In Dagger kann eine Komponente Abh√§ngigkeiten angeben.  Dies wird im Code und im Bild gezeigt.  Abh√§ngigkeiten, in denen Sie Bereitstellungsmethoden angeben, Factory-Methoden, die anzeigen, von welchen Entit√§ten Ihre Komponente abh√§ngt.  Er will sie zum Zeitpunkt der Sch√∂pfung. <br>  Fr√ºher habe ich immer gedacht, dass in diesen Abh√§ngigkeiten nur andere Komponenten angegeben werden k√∂nnen, und deshalb - so hei√üt es in der Dokumentation. <br><br><img src="https://habrastorage.org/webt/gk/us/45/gkus45n1uhs0jhqjojmciaa3y48.jpeg"><br><br>  Jetzt verstehe ich, was es bedeutet, eine Komponentenschnittstelle zu verwenden, aber bevor ich dachte, es sei nur eine Komponente.  Tats√§chlich m√ºssen Sie eine Schnittstelle verwenden, die gem√§√ü den Regeln zum Erstellen einer Schnittstelle f√ºr eine Komponente zusammengesetzt ist.  Kurz gesagt, einfach Bereitstellungsmethoden, wenn Sie nur Getter f√ºr eine Art von Abh√§ngigkeiten haben.  Beispielcode finden Sie auch in der Dolchdokumentation. <br><br><img src="https://habrastorage.org/webt/ry/jo/63/ryjo63y8bfqo1a5kfkgeff4iv10.jpeg"><br><br>  Dort wird auch OtherComponent geschrieben, was verwirrend ist, da Sie dort nicht nur Komponenten einf√ºgen k√∂nnen. <br><br>  Wie m√∂chten wir dieses Gesch√§ft in der Realit√§t nutzen? <br><br><img src="https://habrastorage.org/webt/sy/v1/r_/syv1r_5jzsr7i8vkniesru582gg.jpeg"><br><br>  In Wirklichkeit gibt es ein Feature-Modul, es hat ein sichtbares API-Paket, das sich in der N√§he des Stamms aller Pakete befindet, und es gibt einen Einstiegspunkt - FeatureActivity.  Es ist nicht notwendig, Typealien zu verwenden, nur um es klar zu machen.  Es kann ein Fragment sein, es kann ein ViewController sein - es spielt keine Rolle.  Und es gibt seine Abh√§ngigkeiten, FeatureDeps, bei denen angegeben wird, dass er einen Kontext ben√∂tigt, einen Netzwerkdienst von Common, etwas, das Sie von der App erhalten m√∂chten, und jeder Client ist verpflichtet, dies zu erf√ºllen.  Wenn er es tut, wird alles funktionieren. <br><br><img src="https://habrastorage.org/webt/tu/rl/yk/turlykyi-zrmheakatdmpasqqr4.jpeg"><br><br>  Wie verwenden wir all dies im Funktionsmodul?  Hier verwende ich Aktivit√§t, dies ist optional.  Wie √ºblich erstellen wir unsere eigene Root-Dolch-Komponente und verwenden die magische Methode findComponentDependencies. Sie ist Dagger f√ºr Android sehr √§hnlich, kann sie jedoch nicht prim√§r verwenden, da wir keine Unterkomponenten ziehen m√∂chten.  Andernfalls k√∂nnen wir ihnen die gesamte Logik entziehen. <br><br>  Zuerst habe ich versucht zu sagen, wie es funktioniert, aber Sie k√∂nnen es im Beispielprojekt am Freitag sehen.  Wie soll dies von Ihren Bibliotheksclients in Ihrem Hauptmodul verwendet werden? <br><br><img src="https://habrastorage.org/webt/ui/nk/mj/uinkmj6kxqhr3218cfbo_y8v9uk.jpeg"><br><br>  Zuallererst sind es nur Typealien.  In der Tat hat es einen anderen Namen, aber der K√ºrze halber ist es.  Die Schnittstellenklasse MapOfDepth by Dependency bietet Ihnen die Implementierung.  In der App sagen wir, dass wir Abh√§ngigkeiten auf die gleiche Weise wie in Dagger f√ºr Android erstellen k√∂nnen. Es ist sehr wichtig, dass die Komponente diese Schnittstelle erbt und automatisch Bereitstellungsmethoden empf√§ngt.  Dolch von diesem Moment an beginnt uns zu zwingen, diese Abh√§ngigkeit bereitzustellen.  Bis Sie es bereitstellen, wird es nicht kompiliert.  Dies ist der Hauptkomfort: Sie haben beschlossen, eine Funktion einzurichten und Ihre Komponente mit dieser Schnittstelle zu erweitern - alles, bis Sie den Rest erledigen, wird nicht nur kompiliert, sondern es werden eindeutige Fehlermeldungen ausgegeben.  Das Modul ist einfach, der Punkt ist, dass es Ihre Komponente an die Implementierung der Schnittstelle bindet.  Ungef√§hr das gleiche wie in Dagger f√ºr Android. <br><br>  Kommen wir zu den Ergebnissen. <br><br><img src="https://habrastorage.org/webt/hs/gv/0o/hsgv0oyk_v-jbzjk8lono2uepju.jpeg"><br><br>  Ich habe unseren Mainframe und meinen lokalen Laptop √ºberpr√ºft, bevor ich alles ausgeschaltet habe, was m√∂glich war.  Wenn wir Feature eine √∂ffentliche Methode hinzuf√ºgen, unterscheidet sich die Erstellungszeit erheblich.  Hier zeige ich die Unterschiede beim Erstellen eines Beispielprojekts.  Das sind 16 Sekunden.  Oder wenn ich alle Karten sammle, bedeutet das zwei Minuten, um auf jede, auch nur minimale √Ñnderung zu warten.  Daher entwickeln wir viele Funktionen und werden sie in Beispielprojekten entwickeln.  Auf dem Mainframe ist die Zeit vergleichbar. <br><br><img src="https://habrastorage.org/webt/ey/ou/va/eyouvaxzp3kw8cl0eb3jznokvpe.jpeg"><br><br>  Ein weiteres wichtiges Ergebnis.  Vor dem Hervorheben des Feature-Moduls sah es so aus: Auf dem Mainframe waren es 28 Sekunden, jetzt sind es 49 Sekunden.  Wir haben das erste Modul zugewiesen und bereits fast zweimal eine Verz√∂gerung der Montage erhalten. <br><br><img src="https://habrastorage.org/webt/f2/px/_o/f2px_oqd8uktolgh3-f2ae8j6to.jpeg"><br><br>  Eine weitere Option ist eine einfache inkrementelle Montage unseres Moduls, keine Funktion wie in der vorherigen.  28 Sekunden waren, bis das Modul zugewiesen wurde.  Wenn wir einen Code zugewiesen haben, der nicht jedes Mal neu erstellt werden musste, und [k] apt, der nicht jedes Mal ausgef√ºhrt werden musste, haben wir drei Sekunden gewonnen.  Gott wei√ü was, aber ich hoffe, dass mit jedem neuen Modul die Zeit nur k√ºrzer wird. <br><br>  Hier finden Sie n√ºtzliche Links zu Artikeln: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API versus Implementierung</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel mit Messungen der Erstellungszeit</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispielmodul</a> .  Die Pr√§sentation wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verf√ºgbar sein</a> .  Vielen Dank. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419295/">https://habr.com/ru/post/de419295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419279/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 264 (30. Juli - 5. August)</a></li>
<li><a href="../de419281/index.html">rcm - rc-file manager: optimieren und verwenden</a></li>
<li><a href="../de419283/index.html">Bezos wirft Geld und Ingenieure, um eine Rakete im Zusammenhang mit der Beschleunigung des Weltraumrennens zu entwickeln</a></li>
<li><a href="../de419289/index.html">H√∂ren Sie zu und sprechen Sie: Ank√ºndigung von HolyJS 2018 Moskau</a></li>
<li><a href="../de419291/index.html">Ank√ºndigung des Heisenbug 2018 Moskau: Antworten auf alle Fragen</a></li>
<li><a href="../de419297/index.html">Anzeigen von Kommentaren zu Habr√© in der Reihenfolge des Hinzuf√ºgens</a></li>
<li><a href="../de419299/index.html">Eine intelligente Lampe, die die Stimmung in Ihrer Stadt zeigt</a></li>
<li><a href="../de419303/index.html">Der Tesla-Bericht zeigte h√∂here Verluste und Einnahmen als von den Investoren erwartet</a></li>
<li><a href="../de419305/index.html">Spionagespielzeug oder Fund: Barbie ‚Ñ¢ Schreibmaschine</a></li>
<li><a href="../de419307/index.html">Roskomnadzor interessiert sich f√ºr Facebook-Gesch√§ftsbeziehungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>