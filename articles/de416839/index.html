<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üàµ üëÉüèª üïí MIT-Kurs "Computer Systems Security". Vorlesung 3: Puffer√ºberl√§ufe: Exploits und Schutz, Teil 1 üèí ‚úãüèæ üë©üèº‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Vorlesung # 6.858. "Sicherheit von Computersystemen." Nikolai Zeldovich, James Mickens. 2014 Jahr 
 Computer Sy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIT-Kurs "Computer Systems Security". Vorlesung 3: Puffer√ºberl√§ufe: Exploits und Schutz, Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/416839/"><h3>  Massachusetts Institute of Technology.  Vorlesung # 6.858.  "Sicherheit von Computersystemen."  Nikolai Zeldovich, James Mickens.  2014 Jahr </h3><br>  Computer Systems Security ist ein Kurs zur Entwicklung und Implementierung sicherer Computersysteme.  Die Vortr√§ge behandeln Bedrohungsmodelle, Angriffe, die die Sicherheit gef√§hrden, und Sicherheitstechniken, die auf j√ºngsten wissenschaftlichen Arbeiten basieren.  Zu den Themen geh√∂ren Betriebssystemsicherheit, Funktionen, Informationsflussmanagement, Sprachsicherheit, Netzwerkprotokolle, Hardwaresicherheit und Sicherheit von Webanwendungen. <br><br>  Vorlesung 1: ‚ÄûEinf√ºhrung: Bedrohungsmodelle‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 2: ‚ÄûKontrolle von Hackerangriffen‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 3: ‚ÄûPuffer√ºberl√§ufe: Exploits und Schutz‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <a name="habracut"></a><br><br>  Willkommen zur Vorlesung √ºber Exploits f√ºr Puffer√ºberl√§ufe.  Heute werden wir die Diskussion √ºber <b>Baggy-Grenzen</b> beenden und dann zu anderen Methoden zum Schutz vor Puffer√ºberlauf √ºbergehen. <br><br><img src="https://habrastorage.org/webt/oq/lp/5p/oqlp5prpdjjnr1e7sdxhtnp_pay.jpeg"><br><br>  Als n√§chstes werden wir √ºber die gedruckten Materialien der heutigen Vorlesung sprechen, die der <b>Blind Return Oriented Programming (BROP) gewidmet sind</b> - Blind Reverse Oriented Programming.  Dies ist eine Exploit-Technik, die auch dann ausgef√ºhrt werden kann, wenn der Angreifer nicht √ºber die Zielbin√§rdatei verf√ºgt.  Diese Exploits zielen darauf ab, "Kanarienv√∂gel" in den Stapeln von 64-Bit-Systemen zu zerst√∂ren.  Wenn Sie also wie ich waren, als ich diese Materialien zum ersten Mal las, h√§tten Sie Lust haben, Christopher Nolans Film zu sehen.  Es war nur eine Gehirnexplosion! <br><br>  Wir werden √ºberlegen, wie diese Ger√§te richtig funktionieren.  Daher hoffe ich, dass Sie am Ende der Vorlesung alle diese in den Vorlesungsmaterialien beschriebenen Hochtechnologien verstehen k√∂nnen.  Aber zuerst werden wir, wie gesagt, die Diskussion √ºber <b>Baggy-Grenzen</b> beenden.  Betrachten Sie ein sehr einfaches Beispiel. <br><br>  Angenommen, wir werden einen Zeiger <b>p</b> zuweisen und ihm eine Gr√∂√üe von 44 Bytes zuweisen.  Angenommen, die Steckplatzgr√∂√üe betr√§gt 16 Byte. <br><br>  Was passiert, wenn wir die <b>Malloc-</b> Funktion zuweisen?  Sie wissen bereits, dass in diesem Fall das <b>Baggy-Bounds-</b> System versucht, diese Verteilung durch einen <b>2n-</b> Logarithmus zu erg√§nzen.  F√ºr unseren Zeiger von 44 Bytes werden also 64 Bytes Speicher zugewiesen.  Die Steckplatzgr√∂√üe betr√§gt jedoch 16 Byte, sodass 64/16 = 4 Grenztabellen mit jeweils 16 Byte erstellt werden.  Jeder dieser Eintr√§ge wird in das Gr√∂√üenverteilungsprotokoll eingef√ºgt. <br><br>  Weisen Sie als n√§chstes einen anderen Zeiger <b>char * q = p + 60 zu</b> .  Wir sehen, dass dieser Wert au√üerhalb der Grenzen liegt, da die Gr√∂√üe von <b>p</b> 44 Bytes betr√§gt und hier 60 Bytes.  Aber <b>Baggy Bounds</b> funktionieren so, dass in diesem Fall nichts <b>Schlimmes</b> passiert, obwohl der Programmierer dies nicht h√§tte tun sollen. <br><br>  Nehmen wir nun an, dass wir als n√§chstes einen anderen Zeiger zuweisen, der gleich <b>char * r = q + 16 ist</b> .  Dies f√ºhrt nun tats√§chlich zu einem Fehler, da die Versatzgr√∂√üe 60 + 16 = 76 betr√§gt, was 12 Byte gr√∂√üer ist als die 4 Slots (4x16 = 64 Byte), die das <b>Baggy-Bounds-</b> System <b>zugewiesen hat</b> .  Und dieser √úberschuss ist wirklich mehr als die H√§lfte des Slots. <br><br><img src="https://habrastorage.org/webt/tr/dc/6t/trdc6tmpujijucydynnv2t5ojyw.jpeg"><br><br>  Wenn Sie sich erinnern, reagiert das <b>Baggy-Bounds-</b> System in diesem Fall sofort auf einen kritischen Synchronisationsfehler, der zum Absturz des Programms f√ºhrt und es tats√§chlich stoppt. <br><br>  Stellen wir uns also vor, wir haben nur zwei Zeilen: <br><br>  <b>char * p = malloc (44)</b> <b><br></b>  <b>char * q = p + 60</b> <br><br>  Und es gibt keine dritte Zeile mit dem Code.  Stattdessen werden wir dies tun: <br><br>  <b>char * s = q + 8</b> <br><br>  In diesem Fall hat der Zeiger einen Wert von 60 + 8 = 68 Bit, was 4 Byte mehr ist als die durch <b>Baggy-</b> Grenzen zugewiesenen <b>Grenzen</b> .  Tats√§chlich verursacht dies keinen kritischen Fehler, obwohl der Wert die Grenzen √ºberschreitet.  Was wir hier gemacht haben, ist ein h√∂herwertiges Bit f√ºr den Zeiger zu setzen.  Wenn also jemand sp√§ter versucht, ihn zu dereferenzieren, f√ºhrt dies an dieser Stelle zu einem kritischen Fehler. <br><br><img src="https://habrastorage.org/webt/xp/i-/p-/xpi-p-rmy0hsdh3f53yw6qrtb0o.jpeg"><br><br>  Und das Letzte, was wir tun werden, ist einen weiteren Zeiger zuzuweisen: <br><br>  <b>char * t = s - 32</b> <br><br>  Tats√§chlich haben wir dies getan - wir haben den Zeiger auf die Grenze zur√ºckgegeben.  Wenn also anfangs <b>s</b> dar√ºber hinausging, haben wir es jetzt auf das urspr√ºnglich zugewiesene Volume zur√ºckgesetzt, das wir f√ºr den Zeiger erstellt haben.  Daher hat <b>t</b> jetzt kein Bit h√∂herer Ordnung in seiner Zusammensetzung und kann leicht dereferenziert werden. <br><br><img src="https://habrastorage.org/webt/27/2g/y6/272gy657iydta1tibemfmgqhcxe.jpeg"><br><br>  <b>Teilnehmerin:</b> Woher wei√ü das Programm, dass <b>r</b> einen √úberschuss von mehr als der H√§lfte des Stapels hat? <br><br>  <b>Professor Mickens:</b> Beachten Sie, dass wir beim Erstellen von <b>r</b> einen Werkzeugcode erhalten haben, der in all diesen Operationen mit Zeigern funktioniert.  So k√∂nnen wir sagen, wo sich <b>q befinden</b> wird, und wir wissen, dass es innerhalb der <b>Baggy-Grenzen liegt</b> .  Wenn wir diese Operation <b>q + 16</b> ausf√ºhren, wissen die <b>Baggy-Bounds-</b> Tools daher, woher dieser Anfangswert stammt.  Wenn dann ein Versatz dieser urspr√ºnglichen Gr√∂√üe <b>auftritt</b> , k√∂nnen <b>Baggy-Grenzen</b> leicht feststellen, dass der Versatz gr√∂√üer als die H√§lfte der Schlitzgr√∂√üe ist. <br><br>  Wenn Sie Operationen mit Zeigern ausf√ºhren, sollten Sie grunds√§tzlich pr√ºfen, ob diese die zugewiesene Gr√∂√üe √ºberschritten haben oder nicht.  Irgendwann befindet sich ein Zeiger innerhalb der Grenzen der <b>Baggy-Grenzen</b> , und dann passiert etwas, das ihn √ºber die Grenzen hinausgehen l√§sst.  In diesem Fall werden wir feststellen, dass eine Art H√§keln aus unserem Code ‚Äûherausgekommen‚Äú ist. <br><br>  Hoffe das ist verst√§ndlich.  Es war ein sehr kurzer √úberblick √ºber die Hausaufgaben, aber ich hoffe, Sie k√∂nnen es leicht verstehen. <br><br>  Wir haben also einen Zeiger, der so aussieht: <br><br>  <b>char * p = malloc (256)</b> , dann f√ºgen wir den Zeiger <b>char * q = p + 256 hinzu</b> , wonach wir versuchen, diesen Zeiger zu dereferenzieren. <br><br>  Was wird also passieren?  Beachten Sie, dass 256 eine <b>2n-</b> Sequenz ist, also innerhalb der <b>Baggy-Grenzen liegt</b> .  Wenn wir also weitere 256 Bits hinzuf√ºgen, bedeutet dies, dass wir einen weiteren Durchgang bis zum Ende der <b>Baggy-</b> Grenzen machen.  Wie im vorherigen Beispiel ist diese Zeile gut genug, f√ºhrt jedoch dazu, dass f√ºr <b>q</b> ein Bit h√∂herer Ordnung gesetzt wird.  Wenn wir versuchen, es zu dereferenzieren, explodiert daher alles und wir m√ºssen unseren Versicherungsagenten anrufen.  Das ist klar? <br><br><img src="https://habrastorage.org/webt/mk/oe/hn/mkoehn3hnwp9d100bt_wre7a2xg.jpeg"><br><br>  Anhand dieser beiden Beispiele k√∂nnen Sie verstehen, wie das <b>Baggy-Bounds-</b> System <b>funktioniert</b> .  Wie ich in der letzten Vorlesung erw√§hnt habe, m√ºssen Sie nicht wirklich jede Zeigeroperation instrumentieren, wenn Sie mithilfe der statischen Code-Analyse herausfinden k√∂nnen, dass ein bestimmter Satz von Zeigeroperationen sicher ist.  Ich werde die weitere Er√∂rterung einiger statischer Analysen verschieben, aber es gen√ºgt zu sagen, dass Sie diese mathematischen Aktionen nicht immer ausf√ºhren m√ºssen. Wir haben dies bereits zuvor √ºberpr√ºft. <br><br>  Eine weitere Frage, die auf der Piazza erw√§hnt wird: Wie kann die Kompatibilit√§t von <b>Baggy-Grenzen</b> mit fr√ºheren Nicht-Tool-Bibliotheken sichergestellt werden <b>?</b>  Die Idee ist, dass <b>Baggy-Grenzen beim</b> Initialisieren von <b>Randtabellen festlegen</b> , dass alle Datens√§tze innerhalb von 31 Bit liegen m√ºssen.  Wenn wir also die Begrenzungstabelle lesen, repr√§sentiert jeder Datensatz darin einen Wert der Form <b>2n + 31</b> .  Wenn wir also die Anfangsgrenzen der Gr√∂√üe 31 Bit initialisieren, nehmen wir an, dass jeder Zeiger die maximal m√∂gliche Gr√∂√üe von <b>2n + 31 hat</b> .  Lassen Sie mich Ihnen ein sehr einfaches Beispiel geben, das dies deutlich macht. <br><br>  Angenommen, wir haben einen Speicherplatz, den wir f√ºr einen Heap verwenden.  Dieser Speicherplatz besteht aus zwei Komponenten.  Oben haben wir einen Heap, der mit Nicht-Tool-Code zugewiesen wurde, und unten ist ein Heap, der mit Tool-Code zugewiesen wurde.  Was werden <b>Baggy Bounds</b> tun?  Wie Sie sich erinnern, hat dieses System das Konzept eines Steckplatzes, dessen Gr√∂√üe 16 Bit betr√§gt.  Daher besteht die Begrenzungstabelle aus 2 Abschnitten, die aus 31 Bits initiiert werden. <br><br>  Beim Ausf√ºhren des Toolcodes wird jedoch tats√§chlich der <b>Baggy-Bounds-</b> Algorithmus verwendet, um die entsprechenden Werte f√ºr diese Tabellenzeile festzulegen. <br><br><img src="https://habrastorage.org/webt/vu/bp/wb/vubpwbtkublhjc6ay3ytcek6j-y.jpeg"><br><br>  Wenn ein Zeiger vom oberen Rand des Speicherplatzes kommt, wird er immer auf die maximal m√∂glichen <b>2n + 31</b> Grenzen gesetzt.  Dies bedeutet, dass <b>Baggy-Grenzen</b> niemals ber√ºcksichtigen werden, dass eine Zeigeroperation, die aus einer Nicht-Tool-Bibliothek stammt, √ºber die Grenzen hinausgehen kann. <br><br>  Die Idee ist, dass wir im Werkzeugcode diese Vergleiche immer f√ºr Zeiger durchf√ºhren. Wenn wir jedoch die Zeigerschreibgrenzen f√ºr einen Nicht-Werkzeugcode der Form <b>2n + 31</b> festlegen, wird niemals ein Dereferenzierungsfehler auftreten.  Das hei√üt, wir haben eine gute Interaktion zwischen <b>Baggy-Bound-</b> Code- <b>Eintr√§gen</b> und nicht instrumentellen Datens√§tzen fr√ºherer Bibliotheken. <br><br>  Dies bedeutet, dass wir dieses System haben, was gut ist, da es das Programm bei Verwendung von Nicht-Tool-Bibliotheken nicht zum Absturz bringt, aber ein Problem hat.  Das Problem ist, dass wir niemals die Grenzen von Zeigern bestimmen k√∂nnen, die durch Nicht-Tool-Code generiert werden.  Weil wir niemals ein Bit h√∂herer Ordnung setzen werden, wenn dieser Zeiger beispielsweise zu viel oder zu wenig Platz erh√§lt.  Daher k√∂nnen wir tats√§chlich keine Speichersicherheit f√ºr Vorg√§nge gew√§hrleisten, die bei Verwendung von nicht instrumentellem Code auftreten.  Sie k√∂nnen auch nicht bestimmen, wann wir einen Zeiger √ºbergeben, der die Gr√∂√üengrenzen von Instrumentalcode zu Nicht-Instrumentalcode √ºberschritten hat.  In diesem Fall kann etwas Unvorstellbares passieren.  Wenn Sie einen solchen Zeiger aus dem Werkzeugcode gezogen haben, ist ein h√∂herwertiges Bit auf 1 gesetzt. Es scheint also gigantische Dimensionen zu haben. <br><br>  Wir wissen, dass wir dieses Flag an einigen Stellen l√∂schen k√∂nnen, wenn wir diesen Code nur in den Werkzeugcode einf√ºgen, wenn er an die R√§nder zur√ºckkehrt.  Aber wenn wir diese riesige Adresse nur an den nicht instrumentellen Code √ºbergeben, kann sie etwas Unvorstellbares bewirken.  Es kann sogar sein, dass dieser Zeiger wieder an die Grenzen zur√ºckkehrt, aber wir werden nie die Gelegenheit haben, dieses Bit h√∂herer Ordnung zu l√∂schen.  So k√∂nnen wir auch bei Verwendung der hier gezeigten Schaltung immer noch Probleme haben. <br><br>  <b>Zielgruppe:</b> Wenn wir Toolcode zum Zuweisen von Speicher haben, verwendet er dieselbe <b>Malloc-</b> Funktion wie der Attributcode? <br><br>  <b>Professor:</b> Dies ist eine heikle Frage.  Wenn wir den Fall hier betrachten, wird dies strikt eingehalten, da wir zwei Speicherbereiche haben, von denen jeder den daf√ºr festgelegten Regeln folgt.  Im Prinzip h√§ngt dies jedoch vom Code ab, der die ausgew√§hlte Programmiersprache verwendet.  Stellen Sie sich vor, Sie k√∂nnen beispielsweise in C ++ Ihr eigenes Qualifikationsmerkmal zuweisen.  Es kommt also auf bestimmte Details des Codes an. <br><br>  <b>Zielgruppe:</b> Wie kann der Qualifizierer pr√ºfen, ob das Limit auf 31 Bit festgelegt ist oder nicht? <br><br>  <b>Professor:</b> Auf den unteren Ebenen funktionieren Verteilungsalgorithmen so, dass beim Aufrufen eines unbekannten Systems der Zeiger nach oben bewegt wird.  Wenn Sie also mehrere Zuweiser haben, versuchen alle, Speicher zuzuweisen. Jeder von ihnen hat seinen eigenen Speicher, den sie im Grunde genommen korrekt f√ºr sich reservieren.  Im wirklichen Leben kann es also st√§rker fragmentiert sein als auf hohem Niveau. <br><br>  Alles, was wir oben untersucht haben, bezog sich also auf den Betrieb von <b>Baggy-Grenzen</b> in 32-Bit-Systemen.  √úberlegen Sie, was bei Verwendung von 64-Bit-Systemen passiert.  In solchen Systemen k√∂nnen Sie die Begrenzungstabelle tats√§chlich entfernen, da wir einige Informationen √ºber die Begrenzungen im Zeiger selbst speichern k√∂nnen. <br><br>  √úberlegen Sie, wie ein normaler Zeiger in Baggy-Grenzen aussieht.  Es besteht aus 3 Teilen.  21 Bits werden f√ºr den ersten Nullteil zugewiesen, weitere 5 Bits werden f√ºr die Gr√∂√üe zugewiesen, dies ist die Hauptgr√∂√üe des Protokolls und weitere 38 sind die Bits der √ºblichen Adresse. <br><br><img src="https://habrastorage.org/webt/gb/r5/6m/gbr56manocplt3wn7ueqgoxpcne.jpeg"><br><br>  Der Grund, warum dies die Gr√∂√üe der Adresse des von Ihnen verwendeten Programms nicht massiv einschr√§nkt, besteht darin, dass die meisten h√∂herwertigen Bits des Betriebssystems und / oder der Ausr√ºstung in den ersten beiden Teilen des Zeigers die Verwendung der Anwendung aus verschiedenen Gr√ºnden nicht zulassen.  Wie sich herausstellte, reduzieren wir die Anzahl der im System verwendeten Anwendungen nicht wesentlich.  So sieht ein normaler Zeiger aus. <br><br>  Was passiert, wenn wir nur einen dieser Zeiger haben?  Nun, auf einem 32-Bit-System k√∂nnen wir nur ein Bit h√∂herer Ordnung setzen und hoffen, dass dieses Ding nie mehr als die H√§lfte der Gr√∂√üe des Steckplatzes erreicht.  Aber jetzt, da wir all diesen zus√§tzlichen Adressraum haben, k√∂nnen Sie den Offset au√üerhalb der OOB-Grenzen (au√üerhalb der Grenzen) direkt in diesen Zeiger setzen.  Wir k√∂nnen also so etwas wie das in der Abbildung gezeigte tun, indem wir den Zeiger in 4 Teile teilen und seine Gr√∂√üe neu verteilen. <br><br>  Somit k√∂nnen wir 13 Bits f√ºr die Versatzgrenzen erhalten, dh aufschreiben, wie weit dieser OOB-Zeiger von der Stelle entfernt sein wird, an der er sein sollte.  Andererseits k√∂nnen Sie die tats√§chliche Gr√∂√üe des hier angegebenen Objekts auf 5 und den Rest des Nullteils auf 21-13 = 8 Bit einstellen.  Und dann folgt unser Adressenteil von 38 Bits.  In diesem Beispiel sehen Sie die Vorteile der Verwendung von 64-Bit-Systemen. <br><br><img src="https://habrastorage.org/webt/vx/ja/mp/vxjamp6bu-jxmc5xfrslev98o-s.jpeg"><br><br>  Beachten Sie, dass wir hier die √ºbliche Gr√∂√üe f√ºr einen regul√§ren Zeiger haben. In beiden F√§llen betr√§gt diese Gr√∂√üe 64 Bit und die Beschreibung ist elementar.  Und das ist gut so, denn wenn wir "dicke" Zeiger verwenden, brauchen wir viele W√∂rter, um sie zu beschreiben. <br>  Ich stelle auch fest, dass Nicht-Tool-Code hier leicht angewendet werden kann, da er funktioniert und dieselbe Gr√∂√üe wie normale Zeiger verwendet.  Wir k√∂nnen diese Dinge zum Beispiel in eine <b>Struktur einf√ºgen</b> , und die Gr√∂√üe dieser <b>Struktur</b> bleibt unver√§ndert.  Das ist also sehr gut, wenn wir die M√∂glichkeit haben, in einer 64-Bit-Welt zu arbeiten. <br><br>  <b>Zielgruppe:</b> Warum befindet sich der Versatz im zweiten Fall vor der Gr√∂√üe und nicht wie im vorherigen Fall, und was passiert, wenn der Versatz gro√ü ist? <br><br>  <b>Professor:</b> Ich denke, dass wir in einigen F√§llen bestimmte begrenzende Probleme haben, an denen wir arbeiten m√ºssen.  Beispielsweise tritt ein Problem auf, wenn mehr Bits vorhanden sind.  Aber im Grunde glaube ich nicht, dass es einen Grund gibt, warum Sie einige dieser Dinge nicht lesen konnten.  Es sei denn, bestimmte strenge Bedingungen, √ºber die ich jetzt nicht nachdenke, h√§tten die Gr√∂√üe des Nullteils festlegen sollen, da sonst Probleme mit der Hardware auftreten k√∂nnten. <br><br>  Sie k√∂nnen also immer noch einen Puffer√ºberlauf im <b>Baggy-Bounds-</b> System initiieren, da die Anwendung der oben genannten Ans√§tze nicht alle Probleme l√∂st, oder?  Ein weiteres Problem, auf das Sie m√∂glicherweise sto√üen, wenn Sie einen nicht instrumentellen Code haben, da wir keine Probleme im nicht instrumentellen Code erkennen k√∂nnen.  M√∂glicherweise treten auch Speicherschwachstellen auf, die sich aus einem dynamischen Speicherzuweisungssystem ergeben.  Wenn Sie sich erinnern, haben wir uns in einem fr√ºheren Vortrag diesen seltsamen Hinweis auf <b>freie Malloc angesehen</b> , und <b>Baggy-Grenzen</b> konnten das Auftreten solcher Dinge nicht verhindern. <br><br>  In der letzten Vorlesung haben wir auch die Tatsache diskutiert, dass Codezeiger keine Grenzen haben, die mit ihnen verbunden w√§ren.  Angenommen, wir haben eine Struktur, in der sich der Speicherpuffer unten und der Zeiger oben befindet und der Puffer √ºberl√§uft.  Wir gehen davon aus, dass der Puffer√ºberlauf immer noch innerhalb der <b>Baggy-Grenzen liegt</b> .  Dann m√ºssen Sie diesen Funktionszeiger neu definieren.  Andernfalls kann es, wenn wir versuchen, es zu verwenden, an b√∂sartigen Code gesendet werden, um einen kontrollierten Teil des Speichers anzugreifen.  In diesem Fall helfen uns die Grenzen nicht weiter, da wir keine mit diesen Funktionszeigern verkn√ºpften Grenzen haben. <br><br>  Was <b>kostet die</b> Verwendung von <b>Baggy Bounds</b> ?  Tats√§chlich haben wir nur 4 Komponenten dieses Preises. <br><br><img src="https://habrastorage.org/webt/2v/vo/c0/2vvoc00hrhpzj90khybubng8zsa.jpeg"><br><br>  Der erste ist Raum.  Denn wenn Sie einen ‚Äûdicken‚Äú Zeiger verwenden, ist es offensichtlich, dass Sie die Zeiger gr√∂√üer machen m√ºssen.  Wenn Sie das <b>Baggy-Bounds-</b> System verwenden, √ºber das wir gerade gesprochen haben, sollten Sie eine Grenztabelle speichern.  Und diese Tabelle hat eine solche Steckplatzgr√∂√üe, dass Sie steuern k√∂nnen, wie gro√ü diese Tabelle sein wird, bis Sie die M√∂glichkeiten des daf√ºr zugewiesenen Speichers ausgesch√∂pft haben. <br><br>  Dar√ºber hinaus haben Sie auch die CPU belastet, die gezwungen ist, alle diese instrumentellen Operationen mit Zeigern auszuf√ºhren.  Da f√ºr jeden oder fast jeden Zeiger die Grenzen mit denselben Betriebsarten √ºberpr√ºft werden m√ºssen, wird die Ausf√ºhrung Ihres Programms verlangsamt. <br><br>  Es gibt auch ein Problem mit Fehlalarmen.  Wir haben bereits besprochen, was passieren kann, wenn ein Programm Zeiger generiert, die √ºber die Grenzen hinausgehen, aber niemals versucht, sie zu dereferenzieren.  Genau genommen ist dies kein Problem.  <b>Baggy-Grenzen kennzeichnen</b> diese "au√üerhalb der <b>Grenzen</b> " -Flaggen, wenn sie zumindest in der 32-Bit-L√∂sung die H√§lfte der Steckplatzgr√∂√üe √ºberschreiten. <br><br>  Was Sie in den meisten Sicherheitstools sehen werden, ist, dass Fehlalarme die Wahrscheinlichkeit verringern, dass Benutzer diese Tools verwenden.  In der Praxis hoffen wir alle, dass uns die Sicherheit am Herzen liegt, aber was reizt die Menschen wirklich?  Sie m√∂chten ihre dummen Fotos auf Facebook hochladen k√∂nnen, sie m√∂chten den Upload-Prozess beschleunigen und so weiter.  Wenn Sie also wirklich m√∂chten, dass Ihre Sicherheitstools gefragt sind, sollten sie keine Fehlalarme enthalten.  Der Versuch, alle Schwachstellen zu erkennen, f√ºhrt normalerweise zu Fehlalarmen, die entweder Entwickler oder Benutzer st√∂ren. <br><br>  Dies f√ºhrt auch zu unproduktiven Kosten, f√ºr die Sie Compiler-Unterst√ºtzung ben√∂tigen.  Weil Sie alle Tools zum System hinzuf√ºgen m√ºssen, die Zeigerpr√ºfung umgehen und so weiter und so fort. <br><br>  F√ºr die Verwendung des <b>Baggy-Bounds-</b> Systems m√ºssen wir also einen Preis zahlen, der aus einer √ºberm√§√üigen Speicherplatznutzung, einer erh√∂hten CPU-Auslastung, Fehlalarmen und der Verwendung eines Compilers besteht. <br><br>  Damit ist <b>die</b> Diskussion der <b>Baggy-Grenzen abgeschlossen</b> . <br><br>  Jetzt k√∂nnen wir uns zwei andere Strategien zur Reduzierung des Puffer√ºberlaufs vorstellen.  Tats√§chlich sind sie viel einfacher zu erkl√§ren und zu verstehen. <br><br>  Einer dieser Ans√§tze wird als <b>nicht ausf√ºhrbarer Speicher bezeichnet</b> .  Seine Hauptidee ist, dass die Swap-Hardware 3 Bits von <b>R</b> , <b>W</b> und <b>X</b> anzeigt - Lesen, Schreiben und Ausf√ºhren - f√ºr jede Seite, die Sie im Speicher haben.       ,   ,  .  2  ,     ,  ,  ,    . <br><br>     ,     .     ,  ,      ,    ,     -   .    ,  .   ¬´ <b>W</b>  <b>X</b> ¬ª ,       ,      ,     ,       ,   .     ,       ,      .        .  ,        ,     .    ? <br><br>     -   ,         .    ,     .     ,       ,    . <br><br>    ,       ,   ,       ,      .      ,           ,      .     . <br><br>     ,        .     ‚Äì  <b>just-in-time</b> ,      . <br><br>       -,    JavaScript    .    JavaScript,      ,    -   - ¬´¬ª , - ¬´¬ª ,       x86    .    ,         . <br>      . ,  ,    <b>just-in-time</b>    <b>W</b> ,       <b>X</b> .     ,        ,    . <br><br>        ‚Äî       .  ,  ,      ,    . <br><br><img src="https://habrastorage.org/webt/f_/xj/xi/f_xjxihqdru85yadpa__ytdao-4.jpeg"><br><br> ,   ,       .     GDB,         ,        .  ,       .      ,      .       . <br><br> ,      .  ,           ,     ,   ,    ,     . <br><br>     : , ,   ‚Äî     .    ,  ,    ,    ,   , , , -   .           ,     ,  . <br><br> ,    ,           ,     GDB  ,     ,         ,       ,     .        . <br>  ,    ,    ,   ,       .    -   ,    - ,        .        ,      .       ,     ,           . <br><br>    ,      ? ,  .      ,    ,               .    ,    ,    ,  ,  -    ,          . <br><br> 27:10  <br><br> : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MIT-Kurs "Computer Systems Security".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 3: ¬´ :   ¬ª,  2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSQxaie_h1o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br>  Vielen Dank f√ºr Ihren Aufenthalt bei uns.  Gef√§llt dir unser Artikel?  M√∂chten Sie weitere interessante Materialien sehen?  Unterst√ºtzen Sie uns, indem Sie eine Bestellung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgeben</a> oder sie Ihren Freunden empfehlen. <b>Habr-Benutzer erhalten 30% Rabatt auf ein einzigartiges Analogon von Einstiegsservern, das wir f√ºr Sie erfunden haben:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die ganze Wahrheit √ºber VPS (KVM) E5-2650 v4 (6 Kerne) 10 GB DDR4 240 GB SSD 1 Gbit / s $ 20 oder wie teilt man den Server?</a>  (Optionen sind mit RAID1 und RAID10, bis zu 24 Kernen und bis zu 40 GB DDR4 verf√ºgbar). <br><br>  <b>Dell R730xd 2 mal g√ºnstiger?</b>  Nur wir haben <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128 GB DDR4 6 x 480 GB SSD 1 Gbit / s 100 TV von 249 US-Dollar</a> in den Niederlanden und den USA!</b>  Lesen Sie mehr √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Aufbau eines Infrastrukturgeb√§udes.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klasse mit Dell R730xd E5-2650 v4 Servern f√ºr 9.000 Euro f√ºr einen Cent?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416839/">https://habr.com/ru/post/de416839/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416827/index.html">Container f√ºr Erwachsene (Teil 02): Ein praktischer Leitfaden zur Terminologie</a></li>
<li><a href="../de416829/index.html">ABI Model Pattern v0.5.6 Beta</a></li>
<li><a href="../de416831/index.html">Die externe Weiterleitung des russischen Inlandsverkehrs wird auf 5% reduziert</a></li>
<li><a href="../de416833/index.html">Willkommen beim MskDotNet Meetup # 24</a></li>
<li><a href="../de416837/index.html"># Dashanalune 0</a></li>
<li><a href="../de416841/index.html">So testen Sie Hypothesen und verdienen mit Split-Tests Geld mit Swift</a></li>
<li><a href="../de416843/index.html">Nuklearraketenmotoren und elektrische Antriebssysteme f√ºr Nuklearraketen</a></li>
<li><a href="../de416845/index.html">10 Gr√ºnde, itracking zu verwenden oder es f√ºr immer aufzugeben</a></li>
<li><a href="../de416847/index.html">Ammyy Admin Site erneut kompromittiert</a></li>
<li><a href="../de416849/index.html">Oh mein Code. So werden Sie Systemadministrator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>