<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈵 👃🏻 🕒 MIT-Kurs "Computer Systems Security". Vorlesung 3: Pufferüberläufe: Exploits und Schutz, Teil 1 🏒 ✋🏾 👩🏼‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Vorlesung # 6.858. "Sicherheit von Computersystemen." Nikolai Zeldovich, James Mickens. 2014 Jahr 
 Computer Sy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIT-Kurs "Computer Systems Security". Vorlesung 3: Pufferüberläufe: Exploits und Schutz, Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/416839/"><h3>  Massachusetts Institute of Technology.  Vorlesung # 6.858.  "Sicherheit von Computersystemen."  Nikolai Zeldovich, James Mickens.  2014 Jahr </h3><br>  Computer Systems Security ist ein Kurs zur Entwicklung und Implementierung sicherer Computersysteme.  Die Vorträge behandeln Bedrohungsmodelle, Angriffe, die die Sicherheit gefährden, und Sicherheitstechniken, die auf jüngsten wissenschaftlichen Arbeiten basieren.  Zu den Themen gehören Betriebssystemsicherheit, Funktionen, Informationsflussmanagement, Sprachsicherheit, Netzwerkprotokolle, Hardwaresicherheit und Sicherheit von Webanwendungen. <br><br>  Vorlesung 1: „Einführung: Bedrohungsmodelle“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 2: „Kontrolle von Hackerangriffen“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 3: „Pufferüberläufe: Exploits und Schutz“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <a name="habracut"></a><br><br>  Willkommen zur Vorlesung über Exploits für Pufferüberläufe.  Heute werden wir die Diskussion über <b>Baggy-Grenzen</b> beenden und dann zu anderen Methoden zum Schutz vor Pufferüberlauf übergehen. <br><br><img src="https://habrastorage.org/webt/oq/lp/5p/oqlp5prpdjjnr1e7sdxhtnp_pay.jpeg"><br><br>  Als nächstes werden wir über die gedruckten Materialien der heutigen Vorlesung sprechen, die der <b>Blind Return Oriented Programming (BROP) gewidmet sind</b> - Blind Reverse Oriented Programming.  Dies ist eine Exploit-Technik, die auch dann ausgeführt werden kann, wenn der Angreifer nicht über die Zielbinärdatei verfügt.  Diese Exploits zielen darauf ab, "Kanarienvögel" in den Stapeln von 64-Bit-Systemen zu zerstören.  Wenn Sie also wie ich waren, als ich diese Materialien zum ersten Mal las, hätten Sie Lust haben, Christopher Nolans Film zu sehen.  Es war nur eine Gehirnexplosion! <br><br>  Wir werden überlegen, wie diese Geräte richtig funktionieren.  Daher hoffe ich, dass Sie am Ende der Vorlesung alle diese in den Vorlesungsmaterialien beschriebenen Hochtechnologien verstehen können.  Aber zuerst werden wir, wie gesagt, die Diskussion über <b>Baggy-Grenzen</b> beenden.  Betrachten Sie ein sehr einfaches Beispiel. <br><br>  Angenommen, wir werden einen Zeiger <b>p</b> zuweisen und ihm eine Größe von 44 Bytes zuweisen.  Angenommen, die Steckplatzgröße beträgt 16 Byte. <br><br>  Was passiert, wenn wir die <b>Malloc-</b> Funktion zuweisen?  Sie wissen bereits, dass in diesem Fall das <b>Baggy-Bounds-</b> System versucht, diese Verteilung durch einen <b>2n-</b> Logarithmus zu ergänzen.  Für unseren Zeiger von 44 Bytes werden also 64 Bytes Speicher zugewiesen.  Die Steckplatzgröße beträgt jedoch 16 Byte, sodass 64/16 = 4 Grenztabellen mit jeweils 16 Byte erstellt werden.  Jeder dieser Einträge wird in das Größenverteilungsprotokoll eingefügt. <br><br>  Weisen Sie als nächstes einen anderen Zeiger <b>char * q = p + 60 zu</b> .  Wir sehen, dass dieser Wert außerhalb der Grenzen liegt, da die Größe von <b>p</b> 44 Bytes beträgt und hier 60 Bytes.  Aber <b>Baggy Bounds</b> funktionieren so, dass in diesem Fall nichts <b>Schlimmes</b> passiert, obwohl der Programmierer dies nicht hätte tun sollen. <br><br>  Nehmen wir nun an, dass wir als nächstes einen anderen Zeiger zuweisen, der gleich <b>char * r = q + 16 ist</b> .  Dies führt nun tatsächlich zu einem Fehler, da die Versatzgröße 60 + 16 = 76 beträgt, was 12 Byte größer ist als die 4 Slots (4x16 = 64 Byte), die das <b>Baggy-Bounds-</b> System <b>zugewiesen hat</b> .  Und dieser Überschuss ist wirklich mehr als die Hälfte des Slots. <br><br><img src="https://habrastorage.org/webt/tr/dc/6t/trdc6tmpujijucydynnv2t5ojyw.jpeg"><br><br>  Wenn Sie sich erinnern, reagiert das <b>Baggy-Bounds-</b> System in diesem Fall sofort auf einen kritischen Synchronisationsfehler, der zum Absturz des Programms führt und es tatsächlich stoppt. <br><br>  Stellen wir uns also vor, wir haben nur zwei Zeilen: <br><br>  <b>char * p = malloc (44)</b> <b><br></b>  <b>char * q = p + 60</b> <br><br>  Und es gibt keine dritte Zeile mit dem Code.  Stattdessen werden wir dies tun: <br><br>  <b>char * s = q + 8</b> <br><br>  In diesem Fall hat der Zeiger einen Wert von 60 + 8 = 68 Bit, was 4 Byte mehr ist als die durch <b>Baggy-</b> Grenzen zugewiesenen <b>Grenzen</b> .  Tatsächlich verursacht dies keinen kritischen Fehler, obwohl der Wert die Grenzen überschreitet.  Was wir hier gemacht haben, ist ein höherwertiges Bit für den Zeiger zu setzen.  Wenn also jemand später versucht, ihn zu dereferenzieren, führt dies an dieser Stelle zu einem kritischen Fehler. <br><br><img src="https://habrastorage.org/webt/xp/i-/p-/xpi-p-rmy0hsdh3f53yw6qrtb0o.jpeg"><br><br>  Und das Letzte, was wir tun werden, ist einen weiteren Zeiger zuzuweisen: <br><br>  <b>char * t = s - 32</b> <br><br>  Tatsächlich haben wir dies getan - wir haben den Zeiger auf die Grenze zurückgegeben.  Wenn also anfangs <b>s</b> darüber hinausging, haben wir es jetzt auf das ursprünglich zugewiesene Volume zurückgesetzt, das wir für den Zeiger erstellt haben.  Daher hat <b>t</b> jetzt kein Bit höherer Ordnung in seiner Zusammensetzung und kann leicht dereferenziert werden. <br><br><img src="https://habrastorage.org/webt/27/2g/y6/272gy657iydta1tibemfmgqhcxe.jpeg"><br><br>  <b>Teilnehmerin:</b> Woher weiß das Programm, dass <b>r</b> einen Überschuss von mehr als der Hälfte des Stapels hat? <br><br>  <b>Professor Mickens:</b> Beachten Sie, dass wir beim Erstellen von <b>r</b> einen Werkzeugcode erhalten haben, der in all diesen Operationen mit Zeigern funktioniert.  So können wir sagen, wo sich <b>q befinden</b> wird, und wir wissen, dass es innerhalb der <b>Baggy-Grenzen liegt</b> .  Wenn wir diese Operation <b>q + 16</b> ausführen, wissen die <b>Baggy-Bounds-</b> Tools daher, woher dieser Anfangswert stammt.  Wenn dann ein Versatz dieser ursprünglichen Größe <b>auftritt</b> , können <b>Baggy-Grenzen</b> leicht feststellen, dass der Versatz größer als die Hälfte der Schlitzgröße ist. <br><br>  Wenn Sie Operationen mit Zeigern ausführen, sollten Sie grundsätzlich prüfen, ob diese die zugewiesene Größe überschritten haben oder nicht.  Irgendwann befindet sich ein Zeiger innerhalb der Grenzen der <b>Baggy-Grenzen</b> , und dann passiert etwas, das ihn über die Grenzen hinausgehen lässt.  In diesem Fall werden wir feststellen, dass eine Art Häkeln aus unserem Code „herausgekommen“ ist. <br><br>  Hoffe das ist verständlich.  Es war ein sehr kurzer Überblick über die Hausaufgaben, aber ich hoffe, Sie können es leicht verstehen. <br><br>  Wir haben also einen Zeiger, der so aussieht: <br><br>  <b>char * p = malloc (256)</b> , dann fügen wir den Zeiger <b>char * q = p + 256 hinzu</b> , wonach wir versuchen, diesen Zeiger zu dereferenzieren. <br><br>  Was wird also passieren?  Beachten Sie, dass 256 eine <b>2n-</b> Sequenz ist, also innerhalb der <b>Baggy-Grenzen liegt</b> .  Wenn wir also weitere 256 Bits hinzufügen, bedeutet dies, dass wir einen weiteren Durchgang bis zum Ende der <b>Baggy-</b> Grenzen machen.  Wie im vorherigen Beispiel ist diese Zeile gut genug, führt jedoch dazu, dass für <b>q</b> ein Bit höherer Ordnung gesetzt wird.  Wenn wir versuchen, es zu dereferenzieren, explodiert daher alles und wir müssen unseren Versicherungsagenten anrufen.  Das ist klar? <br><br><img src="https://habrastorage.org/webt/mk/oe/hn/mkoehn3hnwp9d100bt_wre7a2xg.jpeg"><br><br>  Anhand dieser beiden Beispiele können Sie verstehen, wie das <b>Baggy-Bounds-</b> System <b>funktioniert</b> .  Wie ich in der letzten Vorlesung erwähnt habe, müssen Sie nicht wirklich jede Zeigeroperation instrumentieren, wenn Sie mithilfe der statischen Code-Analyse herausfinden können, dass ein bestimmter Satz von Zeigeroperationen sicher ist.  Ich werde die weitere Erörterung einiger statischer Analysen verschieben, aber es genügt zu sagen, dass Sie diese mathematischen Aktionen nicht immer ausführen müssen. Wir haben dies bereits zuvor überprüft. <br><br>  Eine weitere Frage, die auf der Piazza erwähnt wird: Wie kann die Kompatibilität von <b>Baggy-Grenzen</b> mit früheren Nicht-Tool-Bibliotheken sichergestellt werden <b>?</b>  Die Idee ist, dass <b>Baggy-Grenzen beim</b> Initialisieren von <b>Randtabellen festlegen</b> , dass alle Datensätze innerhalb von 31 Bit liegen müssen.  Wenn wir also die Begrenzungstabelle lesen, repräsentiert jeder Datensatz darin einen Wert der Form <b>2n + 31</b> .  Wenn wir also die Anfangsgrenzen der Größe 31 Bit initialisieren, nehmen wir an, dass jeder Zeiger die maximal mögliche Größe von <b>2n + 31 hat</b> .  Lassen Sie mich Ihnen ein sehr einfaches Beispiel geben, das dies deutlich macht. <br><br>  Angenommen, wir haben einen Speicherplatz, den wir für einen Heap verwenden.  Dieser Speicherplatz besteht aus zwei Komponenten.  Oben haben wir einen Heap, der mit Nicht-Tool-Code zugewiesen wurde, und unten ist ein Heap, der mit Tool-Code zugewiesen wurde.  Was werden <b>Baggy Bounds</b> tun?  Wie Sie sich erinnern, hat dieses System das Konzept eines Steckplatzes, dessen Größe 16 Bit beträgt.  Daher besteht die Begrenzungstabelle aus 2 Abschnitten, die aus 31 Bits initiiert werden. <br><br>  Beim Ausführen des Toolcodes wird jedoch tatsächlich der <b>Baggy-Bounds-</b> Algorithmus verwendet, um die entsprechenden Werte für diese Tabellenzeile festzulegen. <br><br><img src="https://habrastorage.org/webt/vu/bp/wb/vubpwbtkublhjc6ay3ytcek6j-y.jpeg"><br><br>  Wenn ein Zeiger vom oberen Rand des Speicherplatzes kommt, wird er immer auf die maximal möglichen <b>2n + 31</b> Grenzen gesetzt.  Dies bedeutet, dass <b>Baggy-Grenzen</b> niemals berücksichtigen werden, dass eine Zeigeroperation, die aus einer Nicht-Tool-Bibliothek stammt, über die Grenzen hinausgehen kann. <br><br>  Die Idee ist, dass wir im Werkzeugcode diese Vergleiche immer für Zeiger durchführen. Wenn wir jedoch die Zeigerschreibgrenzen für einen Nicht-Werkzeugcode der Form <b>2n + 31</b> festlegen, wird niemals ein Dereferenzierungsfehler auftreten.  Das heißt, wir haben eine gute Interaktion zwischen <b>Baggy-Bound-</b> Code- <b>Einträgen</b> und nicht instrumentellen Datensätzen früherer Bibliotheken. <br><br>  Dies bedeutet, dass wir dieses System haben, was gut ist, da es das Programm bei Verwendung von Nicht-Tool-Bibliotheken nicht zum Absturz bringt, aber ein Problem hat.  Das Problem ist, dass wir niemals die Grenzen von Zeigern bestimmen können, die durch Nicht-Tool-Code generiert werden.  Weil wir niemals ein Bit höherer Ordnung setzen werden, wenn dieser Zeiger beispielsweise zu viel oder zu wenig Platz erhält.  Daher können wir tatsächlich keine Speichersicherheit für Vorgänge gewährleisten, die bei Verwendung von nicht instrumentellem Code auftreten.  Sie können auch nicht bestimmen, wann wir einen Zeiger übergeben, der die Größengrenzen von Instrumentalcode zu Nicht-Instrumentalcode überschritten hat.  In diesem Fall kann etwas Unvorstellbares passieren.  Wenn Sie einen solchen Zeiger aus dem Werkzeugcode gezogen haben, ist ein höherwertiges Bit auf 1 gesetzt. Es scheint also gigantische Dimensionen zu haben. <br><br>  Wir wissen, dass wir dieses Flag an einigen Stellen löschen können, wenn wir diesen Code nur in den Werkzeugcode einfügen, wenn er an die Ränder zurückkehrt.  Aber wenn wir diese riesige Adresse nur an den nicht instrumentellen Code übergeben, kann sie etwas Unvorstellbares bewirken.  Es kann sogar sein, dass dieser Zeiger wieder an die Grenzen zurückkehrt, aber wir werden nie die Gelegenheit haben, dieses Bit höherer Ordnung zu löschen.  So können wir auch bei Verwendung der hier gezeigten Schaltung immer noch Probleme haben. <br><br>  <b>Zielgruppe:</b> Wenn wir Toolcode zum Zuweisen von Speicher haben, verwendet er dieselbe <b>Malloc-</b> Funktion wie der Attributcode? <br><br>  <b>Professor:</b> Dies ist eine heikle Frage.  Wenn wir den Fall hier betrachten, wird dies strikt eingehalten, da wir zwei Speicherbereiche haben, von denen jeder den dafür festgelegten Regeln folgt.  Im Prinzip hängt dies jedoch vom Code ab, der die ausgewählte Programmiersprache verwendet.  Stellen Sie sich vor, Sie können beispielsweise in C ++ Ihr eigenes Qualifikationsmerkmal zuweisen.  Es kommt also auf bestimmte Details des Codes an. <br><br>  <b>Zielgruppe:</b> Wie kann der Qualifizierer prüfen, ob das Limit auf 31 Bit festgelegt ist oder nicht? <br><br>  <b>Professor:</b> Auf den unteren Ebenen funktionieren Verteilungsalgorithmen so, dass beim Aufrufen eines unbekannten Systems der Zeiger nach oben bewegt wird.  Wenn Sie also mehrere Zuweiser haben, versuchen alle, Speicher zuzuweisen. Jeder von ihnen hat seinen eigenen Speicher, den sie im Grunde genommen korrekt für sich reservieren.  Im wirklichen Leben kann es also stärker fragmentiert sein als auf hohem Niveau. <br><br>  Alles, was wir oben untersucht haben, bezog sich also auf den Betrieb von <b>Baggy-Grenzen</b> in 32-Bit-Systemen.  Überlegen Sie, was bei Verwendung von 64-Bit-Systemen passiert.  In solchen Systemen können Sie die Begrenzungstabelle tatsächlich entfernen, da wir einige Informationen über die Begrenzungen im Zeiger selbst speichern können. <br><br>  Überlegen Sie, wie ein normaler Zeiger in Baggy-Grenzen aussieht.  Es besteht aus 3 Teilen.  21 Bits werden für den ersten Nullteil zugewiesen, weitere 5 Bits werden für die Größe zugewiesen, dies ist die Hauptgröße des Protokolls und weitere 38 sind die Bits der üblichen Adresse. <br><br><img src="https://habrastorage.org/webt/gb/r5/6m/gbr56manocplt3wn7ueqgoxpcne.jpeg"><br><br>  Der Grund, warum dies die Größe der Adresse des von Ihnen verwendeten Programms nicht massiv einschränkt, besteht darin, dass die meisten höherwertigen Bits des Betriebssystems und / oder der Ausrüstung in den ersten beiden Teilen des Zeigers die Verwendung der Anwendung aus verschiedenen Gründen nicht zulassen.  Wie sich herausstellte, reduzieren wir die Anzahl der im System verwendeten Anwendungen nicht wesentlich.  So sieht ein normaler Zeiger aus. <br><br>  Was passiert, wenn wir nur einen dieser Zeiger haben?  Nun, auf einem 32-Bit-System können wir nur ein Bit höherer Ordnung setzen und hoffen, dass dieses Ding nie mehr als die Hälfte der Größe des Steckplatzes erreicht.  Aber jetzt, da wir all diesen zusätzlichen Adressraum haben, können Sie den Offset außerhalb der OOB-Grenzen (außerhalb der Grenzen) direkt in diesen Zeiger setzen.  Wir können also so etwas wie das in der Abbildung gezeigte tun, indem wir den Zeiger in 4 Teile teilen und seine Größe neu verteilen. <br><br>  Somit können wir 13 Bits für die Versatzgrenzen erhalten, dh aufschreiben, wie weit dieser OOB-Zeiger von der Stelle entfernt sein wird, an der er sein sollte.  Andererseits können Sie die tatsächliche Größe des hier angegebenen Objekts auf 5 und den Rest des Nullteils auf 21-13 = 8 Bit einstellen.  Und dann folgt unser Adressenteil von 38 Bits.  In diesem Beispiel sehen Sie die Vorteile der Verwendung von 64-Bit-Systemen. <br><br><img src="https://habrastorage.org/webt/vx/ja/mp/vxjamp6bu-jxmc5xfrslev98o-s.jpeg"><br><br>  Beachten Sie, dass wir hier die übliche Größe für einen regulären Zeiger haben. In beiden Fällen beträgt diese Größe 64 Bit und die Beschreibung ist elementar.  Und das ist gut so, denn wenn wir "dicke" Zeiger verwenden, brauchen wir viele Wörter, um sie zu beschreiben. <br>  Ich stelle auch fest, dass Nicht-Tool-Code hier leicht angewendet werden kann, da er funktioniert und dieselbe Größe wie normale Zeiger verwendet.  Wir können diese Dinge zum Beispiel in eine <b>Struktur einfügen</b> , und die Größe dieser <b>Struktur</b> bleibt unverändert.  Das ist also sehr gut, wenn wir die Möglichkeit haben, in einer 64-Bit-Welt zu arbeiten. <br><br>  <b>Zielgruppe:</b> Warum befindet sich der Versatz im zweiten Fall vor der Größe und nicht wie im vorherigen Fall, und was passiert, wenn der Versatz groß ist? <br><br>  <b>Professor:</b> Ich denke, dass wir in einigen Fällen bestimmte begrenzende Probleme haben, an denen wir arbeiten müssen.  Beispielsweise tritt ein Problem auf, wenn mehr Bits vorhanden sind.  Aber im Grunde glaube ich nicht, dass es einen Grund gibt, warum Sie einige dieser Dinge nicht lesen konnten.  Es sei denn, bestimmte strenge Bedingungen, über die ich jetzt nicht nachdenke, hätten die Größe des Nullteils festlegen sollen, da sonst Probleme mit der Hardware auftreten könnten. <br><br>  Sie können also immer noch einen Pufferüberlauf im <b>Baggy-Bounds-</b> System initiieren, da die Anwendung der oben genannten Ansätze nicht alle Probleme löst, oder?  Ein weiteres Problem, auf das Sie möglicherweise stoßen, wenn Sie einen nicht instrumentellen Code haben, da wir keine Probleme im nicht instrumentellen Code erkennen können.  Möglicherweise treten auch Speicherschwachstellen auf, die sich aus einem dynamischen Speicherzuweisungssystem ergeben.  Wenn Sie sich erinnern, haben wir uns in einem früheren Vortrag diesen seltsamen Hinweis auf <b>freie Malloc angesehen</b> , und <b>Baggy-Grenzen</b> konnten das Auftreten solcher Dinge nicht verhindern. <br><br>  In der letzten Vorlesung haben wir auch die Tatsache diskutiert, dass Codezeiger keine Grenzen haben, die mit ihnen verbunden wären.  Angenommen, wir haben eine Struktur, in der sich der Speicherpuffer unten und der Zeiger oben befindet und der Puffer überläuft.  Wir gehen davon aus, dass der Pufferüberlauf immer noch innerhalb der <b>Baggy-Grenzen liegt</b> .  Dann müssen Sie diesen Funktionszeiger neu definieren.  Andernfalls kann es, wenn wir versuchen, es zu verwenden, an bösartigen Code gesendet werden, um einen kontrollierten Teil des Speichers anzugreifen.  In diesem Fall helfen uns die Grenzen nicht weiter, da wir keine mit diesen Funktionszeigern verknüpften Grenzen haben. <br><br>  Was <b>kostet die</b> Verwendung von <b>Baggy Bounds</b> ?  Tatsächlich haben wir nur 4 Komponenten dieses Preises. <br><br><img src="https://habrastorage.org/webt/2v/vo/c0/2vvoc00hrhpzj90khybubng8zsa.jpeg"><br><br>  Der erste ist Raum.  Denn wenn Sie einen „dicken“ Zeiger verwenden, ist es offensichtlich, dass Sie die Zeiger größer machen müssen.  Wenn Sie das <b>Baggy-Bounds-</b> System verwenden, über das wir gerade gesprochen haben, sollten Sie eine Grenztabelle speichern.  Und diese Tabelle hat eine solche Steckplatzgröße, dass Sie steuern können, wie groß diese Tabelle sein wird, bis Sie die Möglichkeiten des dafür zugewiesenen Speichers ausgeschöpft haben. <br><br>  Darüber hinaus haben Sie auch die CPU belastet, die gezwungen ist, alle diese instrumentellen Operationen mit Zeigern auszuführen.  Da für jeden oder fast jeden Zeiger die Grenzen mit denselben Betriebsarten überprüft werden müssen, wird die Ausführung Ihres Programms verlangsamt. <br><br>  Es gibt auch ein Problem mit Fehlalarmen.  Wir haben bereits besprochen, was passieren kann, wenn ein Programm Zeiger generiert, die über die Grenzen hinausgehen, aber niemals versucht, sie zu dereferenzieren.  Genau genommen ist dies kein Problem.  <b>Baggy-Grenzen kennzeichnen</b> diese "außerhalb der <b>Grenzen</b> " -Flaggen, wenn sie zumindest in der 32-Bit-Lösung die Hälfte der Steckplatzgröße überschreiten. <br><br>  Was Sie in den meisten Sicherheitstools sehen werden, ist, dass Fehlalarme die Wahrscheinlichkeit verringern, dass Benutzer diese Tools verwenden.  In der Praxis hoffen wir alle, dass uns die Sicherheit am Herzen liegt, aber was reizt die Menschen wirklich?  Sie möchten ihre dummen Fotos auf Facebook hochladen können, sie möchten den Upload-Prozess beschleunigen und so weiter.  Wenn Sie also wirklich möchten, dass Ihre Sicherheitstools gefragt sind, sollten sie keine Fehlalarme enthalten.  Der Versuch, alle Schwachstellen zu erkennen, führt normalerweise zu Fehlalarmen, die entweder Entwickler oder Benutzer stören. <br><br>  Dies führt auch zu unproduktiven Kosten, für die Sie Compiler-Unterstützung benötigen.  Weil Sie alle Tools zum System hinzufügen müssen, die Zeigerprüfung umgehen und so weiter und so fort. <br><br>  Für die Verwendung des <b>Baggy-Bounds-</b> Systems müssen wir also einen Preis zahlen, der aus einer übermäßigen Speicherplatznutzung, einer erhöhten CPU-Auslastung, Fehlalarmen und der Verwendung eines Compilers besteht. <br><br>  Damit ist <b>die</b> Diskussion der <b>Baggy-Grenzen abgeschlossen</b> . <br><br>  Jetzt können wir uns zwei andere Strategien zur Reduzierung des Pufferüberlaufs vorstellen.  Tatsächlich sind sie viel einfacher zu erklären und zu verstehen. <br><br>  Einer dieser Ansätze wird als <b>nicht ausführbarer Speicher bezeichnet</b> .  Seine Hauptidee ist, dass die Swap-Hardware 3 Bits von <b>R</b> , <b>W</b> und <b>X</b> anzeigt - Lesen, Schreiben und Ausführen - für jede Seite, die Sie im Speicher haben.       ,   ,  .  2  ,     ,  ,  ,    . <br><br>     ,     .     ,  ,      ,    ,     -   .    ,  .   « <b>W</b>  <b>X</b> » ,       ,      ,     ,       ,   .     ,       ,      .        .  ,        ,     .    ? <br><br>     -   ,         .    ,     .     ,       ,    . <br><br>    ,       ,   ,       ,      .      ,           ,      .     . <br><br>     ,        .     –  <b>just-in-time</b> ,      . <br><br>       -,    JavaScript    .    JavaScript,      ,    -   - «» , - «» ,       x86    .    ,         . <br>      . ,  ,    <b>just-in-time</b>    <b>W</b> ,       <b>X</b> .     ,        ,    . <br><br>        —       .  ,  ,      ,    . <br><br><img src="https://habrastorage.org/webt/f_/xj/xi/f_xjxihqdru85yadpa__ytdao-4.jpeg"><br><br> ,   ,       .     GDB,         ,        .  ,       .      ,      .       . <br><br> ,      .  ,           ,     ,   ,    ,     . <br><br>     : , ,   —     .    ,  ,    ,    ,   , , , -   .           ,     ,  . <br><br> ,    ,           ,     GDB  ,     ,         ,       ,     .        . <br>  ,    ,    ,   ,       .    -   ,    - ,        .        ,      .       ,     ,           . <br><br>    ,      ? ,  .      ,    ,               .    ,    ,    ,  ,  -    ,          . <br><br> 27:10  <br><br> : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MIT-Kurs "Computer Systems Security".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 3: « :   »,  2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSQxaie_h1o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br><br>  Vielen Dank für Ihren Aufenthalt bei uns.  Gefällt dir unser Artikel?  Möchten Sie weitere interessante Materialien sehen?  Unterstützen Sie uns, indem Sie eine Bestellung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgeben</a> oder sie Ihren Freunden empfehlen. <b>Habr-Benutzer erhalten 30% Rabatt auf ein einzigartiges Analogon von Einstiegsservern, das wir für Sie erfunden haben:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die ganze Wahrheit über VPS (KVM) E5-2650 v4 (6 Kerne) 10 GB DDR4 240 GB SSD 1 Gbit / s $ 20 oder wie teilt man den Server?</a>  (Optionen sind mit RAID1 und RAID10, bis zu 24 Kernen und bis zu 40 GB DDR4 verfügbar). <br><br>  <b>Dell R730xd 2 mal günstiger?</b>  Nur wir haben <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128 GB DDR4 6 x 480 GB SSD 1 Gbit / s 100 TV von 249 US-Dollar</a> in den Niederlanden und den USA!</b>  Lesen Sie mehr über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Aufbau eines Infrastrukturgebäudes.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klasse mit Dell R730xd E5-2650 v4 Servern für 9.000 Euro für einen Cent?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416839/">https://habr.com/ru/post/de416839/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416827/index.html">Container für Erwachsene (Teil 02): Ein praktischer Leitfaden zur Terminologie</a></li>
<li><a href="../de416829/index.html">ABI Model Pattern v0.5.6 Beta</a></li>
<li><a href="../de416831/index.html">Die externe Weiterleitung des russischen Inlandsverkehrs wird auf 5% reduziert</a></li>
<li><a href="../de416833/index.html">Willkommen beim MskDotNet Meetup # 24</a></li>
<li><a href="../de416837/index.html"># Dashanalune 0</a></li>
<li><a href="../de416841/index.html">So testen Sie Hypothesen und verdienen mit Split-Tests Geld mit Swift</a></li>
<li><a href="../de416843/index.html">Nuklearraketenmotoren und elektrische Antriebssysteme für Nuklearraketen</a></li>
<li><a href="../de416845/index.html">10 Gründe, itracking zu verwenden oder es für immer aufzugeben</a></li>
<li><a href="../de416847/index.html">Ammyy Admin Site erneut kompromittiert</a></li>
<li><a href="../de416849/index.html">Oh mein Code. So werden Sie Systemadministrator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>