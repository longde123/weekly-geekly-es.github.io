<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßöüèæ üöÆ üë©‚Äçüîß Ir mecanismos de asignaci√≥n ü•ï üöÇ üïØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cuando intent√© entender por primera vez c√≥mo funcionan las herramientas de asignaci√≥n de memoria en Go, lo que quer√≠a tratar parec√≠a una misteriosa ca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ir mecanismos de asignaci√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442648/">  Cuando intent√© entender por primera vez c√≥mo funcionan las herramientas de asignaci√≥n de memoria en Go, lo que quer√≠a tratar parec√≠a una misteriosa caja negra.  Al igual que con cualquier otra tecnolog√≠a, lo m√°s importante aqu√≠ est√° oculto detr√°s de muchas capas de abstracciones, a trav√©s de las cuales debe pasar para comprender algo. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/tv/0k/gh/tv0kghio2zhsc-og7bjd-mtl41q.jpeg"></a> <br><br>  El autor del material, cuya traducci√≥n estamos publicando, decidi√≥ llegar al fondo de los medios de asignaci√≥n de memoria en Go y hablar sobre √©l. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Memoria f√≠sica y virtual</font> </h2><br>  Todos los medios para asignar memoria tienen que funcionar con el espacio de direcciones de la memoria virtual, que es controlado por el sistema operativo.  Veamos c√≥mo funciona la memoria, comenzando en el nivel m√°s bajo, con celdas de memoria. <br>  Aqu√≠ se explica c√≥mo imaginar una celda RAM. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e22/5e5/74c/e225e574c2649eb0bf9f5dd9cb1edadb.png"></div><br>  <i><font color="#999999">Dise√±o de celda de memoria</font></i> <br><br>  Si, muy simplificado, imagina una celda de memoria y lo que la rodea, entonces obtenemos lo siguiente: <br><br><ol><li>  La l√≠nea de direcci√≥n (el transistor act√∫a como un interruptor) es lo que da acceso al condensador (l√≠nea de datos). </li><li>  Cuando aparece una se√±al (l√≠nea roja) en la l√≠nea de direcci√≥n, la l√≠nea de datos le permite escribir datos en la celda de memoria, es decir, cargar el condensador, lo que permite almacenar un valor l√≥gico correspondiente a 1 en √©l. </li><li> Cuando no hay se√±al en la l√≠nea de direcci√≥n (l√≠nea verde), el capacitor est√° aislado y su carga no cambia.  Para escribir en la celda 0, debe seleccionar su direcci√≥n y enviar un 0 l√≥gico a trav√©s de la l√≠nea de datos, es decir, conectar la l√≠nea de datos con un signo menos, descargando as√≠ el condensador. </li><li>  Cuando el procesador necesita leer el valor de la memoria, la se√±al se env√≠a a lo largo de la l√≠nea de direcci√≥n (el interruptor se cierra).  Si el condensador est√° cargado, la se√±al pasa por la l√≠nea de datos (se lee 1), de lo contrario, la se√±al no pasa por la l√≠nea de datos (se lee 0). </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8d/33a/100/e8d33a100b5dbf94d34e794785670f24.png"></div><br>  <i><font color="#999999">El esquema de interacci√≥n de la memoria f√≠sica y el procesador.</font></i> <br><br>  El bus de datos es responsable de transportar los datos entre el procesador y la memoria f√≠sica. <br><br>  Ahora hablemos de la l√≠nea de direcci√≥n y los bytes direccionables. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d24/e38/542/d24e38542de230b449750b26641f5e8c.png"></div><br>  <i><font color="#999999">L√≠neas de direcci√≥n de bus entre procesador y memoria f√≠sica</font></i> <br><br><ol><li>  A cada byte en RAM se le asigna un identificador num√©rico √∫nico (direcci√≥n).  Cabe se√±alar que el n√∫mero de bytes f√≠sicos presentes en la memoria no es igual al n√∫mero de l√≠neas de direcci√≥n. </li><li>  Cada l√≠nea de direcci√≥n puede especificar un valor de 1 bit, por lo que indica un bit en la direcci√≥n de un determinado byte. </li><li>  Nuestro circuito tiene 32 l√≠neas de direcci√≥n.  Como resultado, cada byte direccionable utiliza un n√∫mero de 32 bits como su direcci√≥n.  [00000000000000000000000000000000] - la direcci√≥n de memoria m√°s baja.  [1111111111111111111111111111111111] - la direcci√≥n de memoria m√°s alta. </li><li>  Como cada byte tiene una direcci√≥n de 32 bits, nuestro espacio de direcciones consta de 2 <sup>32</sup> bytes direccionables (4 GB). </li></ol><br>  Como resultado, resulta que el n√∫mero de bytes direccionables depende del n√∫mero total de l√≠neas de direcci√≥n.  Por ejemplo, si hay 64 l√≠neas de direcci√≥n (procesadores x86-64), puede direccionar 2 <sup>64</sup> bytes (16 exabytes) de memoria, pero la mayor√≠a de las arquitecturas que usan punteros de 64 bits realmente usan l√≠neas de direcci√≥n de 48 bits (AMD64) y l√≠neas de direcciones de 42 bits (Intel), que te√≥ricamente permite que las computadoras est√©n equipadas con 256 terabytes de memoria f√≠sica (Linux permite, en la arquitectura x86-64, cuando se usan p√°ginas de direcciones de nivel 4, asignar hasta 128 TB de espacio de direcciones a los procesos, Windows le permite asignar hasta 192 TB). <br>  Dado que el tama√±o de la RAM f√≠sica es limitado, cada proceso se ejecuta en su propio "entorno limitado", en el denominado "espacio de direcciones virtuales", denominado memoria virtual. <br><br>  Las direcciones de bytes en el espacio de direcciones virtuales no coinciden con las direcciones que utiliza el procesador para acceder a la memoria f√≠sica.  Como resultado, necesitamos un sistema que nos permita convertir direcciones virtuales en f√≠sicas.  Eche un vistazo a c√≥mo se ven las direcciones de memoria virtual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d0/09b/354/9d009b354ada519bf1280ea96e139e64.jpg"></div><br>  <i><font color="#999999">Representaci√≥n virtual del espacio de direcciones</font></i> <br><br>  Como resultado, cuando el procesador ejecuta una instrucci√≥n que se refiere a una direcci√≥n de memoria, el primer paso es traducir la direcci√≥n l√≥gica a una direcci√≥n lineal.  Esta conversi√≥n es realizada por la unidad de gesti√≥n de memoria. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/330/ba9/56a330ba9d27daeb5737e013c0c15156.png"></div><br>  <i><font color="#999999">Representaci√≥n simplificada de la relaci√≥n entre memoria virtual y f√≠sica.</font></i> <br><br>  Dado que las direcciones l√≥gicas son demasiado grandes para ser convenientes para trabajar con ellas por separado (esto depende de varios factores), la memoria est√° organizada en estructuras llamadas p√°ginas.  En este caso, el espacio de direcciones virtuales se divide en peque√±as √°reas, p√°ginas, que en la mayor√≠a de los sistemas operativos tienen un tama√±o de 4 KB, aunque generalmente este tama√±o se puede cambiar.  Esta es la unidad m√°s peque√±a de administraci√≥n de memoria en la memoria virtual.  La memoria virtual no almacena nada, simplemente establece la correspondencia entre el espacio de direcciones del programa y la memoria f√≠sica. <br><br>  Los procesos solo ven las direcciones de memoria virtual.  ¬øQu√© sucede si un programa necesita m√°s memoria din√°mica (tambi√©n llamada memoria de mont√≥n, o "mont√≥n")?  Aqu√≠ hay un ejemplo de c√≥digo de ensamblador simple en el que se solicita memoria adicional asignada din√°micamente al sistema: <br><br><pre><code class="plaintext hljs">_start:        mov $12, %rax #    brk        mov $0, %rdi # 0 -  ,            syscall b0:        mov %rax, %rsi #  rsi    ,           mov %rax, %rdi #     ...        add $4, %rdi # ..  4 ,           mov $12, %rax #    brk        syscall</code> </pre> <br>  As√≠ es como se puede representar en forma de diagrama. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c22/962/904/c229629041c7612e254d89d146fcc4ef.png"></div><br>  <i><font color="#999999">Aumenta la memoria asignada din√°micamente</font></i> <br><br>  El programa solicita memoria adicional utilizando la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">llamada al</a> sistema brk (sbrk / mmap, etc.).  El n√∫cleo actualiza la informaci√≥n sobre la memoria virtual, pero todav√≠a no se han presentado p√°ginas nuevas en la memoria f√≠sica, y aqu√≠ hay una diferencia entre la memoria virtual y la f√≠sica. <br><br><h2>  <font color="#3AC1EF">Asignador de memoria</font> </h2><br>  Despu√©s de que, en t√©rminos generales, discutimos el trabajo con el espacio de direcciones virtuales, hablamos sobre c√≥mo solicitar memoria din√°mica adicional (memoria en el mont√≥n), nos ser√° m√°s f√°cil hablar sobre los medios para asignar memoria. <br><br>  Si el mont√≥n tiene suficiente memoria para satisfacer nuestras solicitudes de c√≥digo, entonces el asignador de memoria puede ejecutar estas solicitudes sin acceder al n√∫cleo.  De lo contrario, tiene que aumentar el tama√±o del mont√≥n utilizando una llamada al sistema (utilizando brk, por ejemplo), mientras solicita un gran bloque de memoria.  En el caso de malloc, "grande" significa el tama√±o descrito por el par√°metro <code>MMAP_THRESHOLD</code> , que, por defecto, es de 128 Kb. <br><br>  Sin embargo, un asignador de memoria tiene m√°s responsabilidades que simplemente asignar memoria.  Una de sus responsabilidades m√°s importantes es reducir la fragmentaci√≥n de la memoria interna y externa, y asignar bloques de memoria lo m√°s r√°pido posible.  Suponga que nuestro programa ejecuta secuencialmente solicitudes para asignar bloques continuos de memoria usando una funci√≥n de la forma <code>malloc(size)</code> , despu√©s de lo cual esta memoria se libera usando una funci√≥n de la forma <code>free(pointer)</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/8a0/779/9448a077982dfb81e4c982c1228cad15.png"></div><br>  <i><font color="#999999">Demostraci√≥n de fragmentaci√≥n externa</font></i> <br><br>  En el diagrama anterior, en el paso p4, no tenemos suficientes bloques de memoria ubicados secuencialmente para cumplir con la solicitud de asignaci√≥n de seis de esos bloques, aunque la cantidad total de memoria libre lo permite.  Esta situaci√≥n lleva a la fragmentaci√≥n de la memoria. <br><br>  ¬øC√≥mo reducir la fragmentaci√≥n de la memoria?  La respuesta a esta pregunta depende del algoritmo de asignaci√≥n de memoria espec√≠fico, en el que se utiliza la biblioteca base para trabajar con la memoria. <br><br>  Ahora veremos la herramienta de asignaci√≥n de memoria TCMalloc, en la que se basan los mecanismos de asignaci√≥n de memoria Go. <br><br><h2>  <font color="#3AC1EF">TCMalloc</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TCMalloc</a> se basa en la idea de dividir la memoria en varios niveles para reducir la fragmentaci√≥n de la memoria.  Dentro de TCMalloc, la administraci√≥n de memoria se divide en dos partes: trabajar con memoria de subprocesos y trabajar con el mont√≥n. <br><br><h3>  <font color="#3AC1EF">‚ñç Memoria de hilo</font> </h3><br>  Cada p√°gina de memoria se divide en una secuencia de fragmentos de ciertos tama√±os, seleccionados de acuerdo con las clases de tama√±o.  Esto reduce la fragmentaci√≥n.  Como resultado, cada subproceso tiene a su disposici√≥n una memoria cach√© para objetos peque√±os, lo que permite una asignaci√≥n muy eficiente de la memoria para objetos menores o iguales a 32 KB. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/331/901/7c8/3319017c8657e4b75a25003357d4b4f4.png"></div><br>  <i><font color="#999999">Flujo de cach√©</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñçBunch</font> </h3><br>  Un mont√≥n gestionado TCMalloc es una colecci√≥n de p√°ginas en las que un conjunto de p√°ginas consecutivas se puede representar como un rango de p√°ginas (intervalo).  Cuando necesita asignar memoria para un objeto que es mayor que 32 KB, el mont√≥n se usa para asignar memoria. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48c/f49/707/48cf497071e18b1539c18e6c2057e85d.png"></div><br>  <i><font color="#999999">Apila y trabaja con p√°ginas</font></i> <br><br>  Cuando no hay suficiente espacio para colocar peque√±os objetos en la memoria, recurren al mont√≥n de memoria.  Si el mont√≥n no tiene suficiente memoria libre, se solicita memoria adicional del sistema operativo. <br><br>  Como resultado, el modelo presentado de trabajar con memoria admite el conjunto de memoria de espacio de usuario; su uso mejora significativamente la eficiencia de asignaci√≥n y liberaci√≥n de memoria. <br><br>  Cabe se√±alar que la herramienta de asignaci√≥n de memoria Go se bas√≥ originalmente en TCMalloc, pero difiere ligeramente de ella. <br><br><h2>  <font color="#3AC1EF">Ir asignador de memoria</font> </h2><br>  Sabemos que el tiempo de ejecuci√≥n de Go planea ejecutar goroutines en procesadores l√≥gicos.  De manera similar, la versi√≥n de TCMalloc utilizada por Go divide las p√°ginas de memoria en bloques cuyos tama√±os corresponden a ciertas clases de tama√±os de las cuales existen 67. <br><br>  Si no est√° familiarizado con el planificador Go <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> puede leer sobre esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/824/d5c/0df/824d5c0dfac562629662650924292583.png"></div><br>  <i><font color="#999999">Ir clases de tama√±o</font></i> <br><br>  Dado que el tama√±o m√≠nimo de p√°gina en Go es de 8192 bytes (8 Kb), si dicha p√°gina se divide en bloques de 1 KB, obtendremos 8 de esos bloques. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/150/865/6ba/1508656ba4a4c009624468a164d41e5b.png"></div><br>  <i><font color="#999999">Un tama√±o de p√°gina de 8 KB se divide en bloques correspondientes a un tama√±o de clase de 1 KB</font></i> <br><br>  Secuencias de p√°gina similares en Go se controlan utilizando una estructura llamada mspan. <br><br><h3>  <font color="#3AC1EF">‚ñçEstructura mspan</font> </h3><br>  La estructura mspan es una lista doblemente vinculada, un objeto que contiene la direcci√≥n de inicio de la p√°gina, informaci√≥n sobre el tama√±o de la p√°gina y el n√∫mero de p√°ginas incluidas en ella. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dbd/cae/fc0/dbdcaefc090a443369d33c2cde7e06ae.png"></div><br>  <i><font color="#999999">Estructura mspan</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç estructura mcache</font> </h3><br>  Al igual que TCMalloc, Go proporciona a cada procesador l√≥gico un cach√© de subprocesos local, conocido como mcache.  Como resultado, si goroutine necesita memoria, puede obtenerla directamente de mcache.  Para hacer esto, no necesita realizar bloqueos, ya que en un momento dado solo se ejecuta una goroutin en un procesador l√≥gico. <br><br>  La estructura mcache contiene, en forma de cach√©, estructuras mspan de varias clases de tama√±o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/478/7bb/459/4787bb4597d56f89b474189c5e86441b.png"></div><br>  <i><font color="#999999">Interacci√≥n entre procesador l√≥gico, mcache y mspan en Go</font></i> <br><br>  Dado que cada procesador l√≥gico tiene su propio mcache, no hay necesidad de bloqueos al asignar memoria desde mcache. <br><br>  Cada clase de tama√±o se puede representar mediante uno de los siguientes objetos: <br><br><ul><li>  Un objeto de escaneo es un objeto que contiene un puntero. </li><li>  Un objeto noscan es un objeto en el que no hay puntero. </li></ul><br>  Una de las fortalezas de este enfoque es que cuando se realiza la recolecci√≥n de basura, no es necesario eludir los objetos noscan, ya que no contienen objetos para los que se asigna memoria. <br><br>  ¬øQu√© se mete en mcache?  Los objetos cuyo tama√±o no exceda los 32 KB van directamente a mcache usando mspan de la clase de tama√±o correspondiente. <br><br>  ¬øQu√© sucede si mcache no tiene una c√©lula libre?  Luego obtienen un nuevo mspan de la clase de tama√±o deseada de la lista de objetos mspan llamada mcentral. <br><br><h3>  <font color="#3AC1EF">‚ñç Estructura central</font> </h3><br>  La estructura central recopila todos los rangos de p√°gina de una clase de tama√±o particular.  Cada objeto central contiene dos listas de objetos mspan. <br><br><ol><li>  Lista de objetos mspan en los que no hay objetos libres, o aquellos mspan que est√°n en mcache. </li><li>  Lista de objetos mspan que tienen objetos libres. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6dc/b88/7f9/6dcb887f9c717bb1f24735daa4b50aa7.png"></div><br>  <i><font color="#999999">Estructura central</font></i> <br><br>  Cada estructura central existe dentro de la estructura mheap. <br><br><h3>  <font color="#3AC1EF">‚ñç Estructura del mapa</font> </h3><br>  La estructura mheap est√° representada por un objeto que maneja la gesti√≥n del mont√≥n en Go.  Solo hay un objeto global de este tipo que posee un espacio de direcciones virtual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8e/b07/01b/c8eb0701bbe46523e2735e695db97115.png"></div><br>  <i><font color="#999999">Estructura Mheap</font></i> <br><br>  Como puede ver en el diagrama anterior, la estructura mheap contiene una matriz de estructuras centrales.  Este conjunto contiene estructuras centrales para todas las clases de tama√±o. <br><br><pre> <code class="plaintext hljs">central [numSpanClasses]struct { mcentral mcentral   pad     [sys.CacheLineSize unsafe.Sizeof(mcentral{})%sys.CacheLineSize]byte }</code> </pre> <br>  Dado que tenemos una estructura central para cada clase de tama√±o, cuando mcache solicita la estructura mspan de mcentral, se aplica un bloqueo en el nivel central individual, como resultado, las solicitudes de otras estructuras mspan solicitantes de mcache de otros tama√±os pueden ser atendidas al mismo tiempo. <br><br>  La alineaci√≥n (almohadilla) asegura que las estructuras centrales est√©n separadas entre s√≠ por el n√∫mero de bytes correspondientes al valor <code>CacheLineSize</code> .  Como resultado, cada <code>mcentral.lock</code> tiene su propia l√≠nea de cach√©, lo que evita los problemas asociados con el uso compartido de memoria falsa. <br><br>  ¬øQu√© sucede si la lista central est√° vac√≠a?  Luego, mcentral recibe una secuencia de p√°ginas de mheap para asignar fragmentos de memoria de la clase de tama√±o requerida. <br><br><ul><li>  <code>free[_MaxMHeapList]mSpanList</code> es una matriz de spanList.  La estructura de mspan en cada spanList consta de 1 ~ 127 (_MaxMHeapList - 1) p√°ginas.  Por ejemplo, free [3] es una lista vinculada de estructuras mspan que contiene 3 p√°ginas.  La palabra "libre" en este caso indica que estamos hablando de una lista vac√≠a en la que no se asigna memoria.  Una lista puede ser, en lugar de estar vac√≠a, una lista en la que se asigna memoria (ocupada). </li><li>  <code>freelarge mSpanList</code> es una lista de estructuras de mspan gratuitas.  El n√∫mero de p√°ginas por elemento (es decir, mspan) es superior a 127. Para admitir esta lista, se utiliza la estructura de datos mtreap.  La lista de estructuras mspan ocupadas se llama busylarge. </li></ul><br>  Los objetos de m√°s de 32 Kb se consideran objetos grandes, la memoria para ellos se asigna directamente desde mheap.  Las solicitudes para asignar memoria para tales objetos se realizan mediante un bloqueo, como resultado, en un momento dado, una solicitud similar puede procesarse desde un solo procesador l√≥gico. <br><br><h2>  <font color="#3AC1EF">El proceso de asignaci√≥n de memoria para objetos.</font> </h2><br><ul><li>  Si el tama√±o del objeto excede los 32 Kb, se considera grande, la memoria para √©l se asigna directamente desde mheap. </li><li>  Si el tama√±o del objeto es inferior a 16 Kb, se utiliza el mecanismo de mcache llamado peque√±o asignador. </li><li>  Si el tama√±o del objeto est√° en el rango de 16-32 Kb, resulta qu√© clase de tama√±o (sizeClass) usar, entonces se asigna un bloque adecuado en mcache. </li><li>  Si no hay bloques disponibles en la clase de tama√±o correspondiente a mcache, se llama a mcentral. </li><li>  Si mcentral no tiene bloques libres, llaman a mheap y buscan el mspan m√°s adecuado.  Si el tama√±o de memoria requerido por la aplicaci√≥n resulta ser m√°s grande de lo que se puede asignar, el tama√±o de memoria solicitado se procesar√° para que sea posible devolver tantas p√°ginas como sea necesario por el programa, formando una nueva estructura de mspan. </li><li>  Si la memoria virtual de la aplicaci√≥n a√∫n no es suficiente, se accede al sistema operativo para un nuevo conjunto de p√°ginas (se requiere al menos 1 MB de memoria). </li></ul><br>  De hecho, a nivel del sistema operativo, Go solicita la asignaci√≥n de piezas de memoria a√∫n m√°s grandes llamadas arenas.  La asignaci√≥n simult√°nea de grandes fragmentos de memoria le permite encontrar un compromiso entre la cantidad de memoria asignada a la aplicaci√≥n y el costoso acceso al sistema operativo en t√©rminos de rendimiento. <br><br>  La memoria solicitada en el mont√≥n se asigna desde la arena.  Considere este mecanismo. <br><br><h2>  <font color="#3AC1EF">Memoria virtual ir</font> </h2><br>  Eche un vistazo al uso de la memoria con un programa simple escrito en Go: <br><br><pre> <code class="plaintext hljs">func main() {   for {} }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c33/4cd/dee/c334cddee46f32a66d3528b08deda48e.png"></div><br>  <i><font color="#999999">Informaci√≥n del proceso del programa</font></i> <br><br>  El espacio de direcciones virtuales de incluso un programa tan simple es de aproximadamente 100 MB, mientras que el √≠ndice RSS es de solo 696 Kb.  Primero, intentemos averiguar el motivo de esta discrepancia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f34/2a7/f41/f342a7f41d8ff7fbf3b5f081415c5ab4.png"></div><br>  <i><font color="#999999">Informaci√≥n de mapas y smap</font></i> <br><br>  Aqu√≠ puede ver las √°reas de memoria, cuyo tama√±o es aproximadamente igual a 2 MB, 64 MB, 32 MB.  ¬øQu√© tipo de memoria es esta? <br><br><h3>  <font color="#3AC1EF">‚ñçArena</font> </h3><br>  Resulta que la memoria virtual en Go consiste en un conjunto de arenas.  El tama√±o de memoria inicial destinado al almacenamiento din√°mico corresponde a una arena, es decir, 64 MB (esto es relevante para Go 1.11.5). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9dd/17e/ba9/9dd17eba9a4c5acf9371052d62d902d9.png"></div><br>  <i><font color="#999999">Tama√±o actual de arena en varios sistemas</font></i> <br><br>  Como resultado, la memoria necesaria para las necesidades actuales del programa se asigna en peque√±as porciones.  Este proceso comienza con una arena de 64 MB. <br><br>  Esos indicadores num√©ricos de los que estamos hablando aqu√≠ no deben tomarse para algunos valores absolutos y sin cambios.  Pueden cambiar.  Anteriormente, por ejemplo, Go reserv√≥ un espacio virtual continuo por adelantado, en sistemas de 64 bits el tama√±o de la arena era 512 GB (es interesante pensar en lo que sucede si la demanda de memoria real es tan grande que mmap rechazar√° la solicitud correspondiente). <br><br>  De hecho, llamamos a un mont√≥n de arenas un mont√≥n.  En Go, las arenas se perciben como fragmentos de memoria, divididos en bloques de 8192 bytes (8 Kb) de tama√±o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55b/927/7e0/55b9277e0c55876b1bbf11bb1b869c9e.png"></div><br>  <i><font color="#999999">Una arena de 64 MB</font></i> <br><br>  Go tiene un par de sabores m√°s de bloques: span y mapa de bits.  La memoria para ellos se asigna fuera del mont√≥n, almacenan metadatos de arena.  Se utilizan principalmente en la recolecci√≥n de basura. <br>  Aqu√≠ hay un resumen general de c√≥mo funcionan los mecanismos de asignaci√≥n de memoria en Go. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b01/61f/13f/b0161f13f6bc905731f0bfb339fd3a10.png"></div><br>  <i><font color="#999999">Esquema general de los mecanismos de asignaci√≥n de memoria en Go</font></i> <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  En general, se puede observar que en este material describimos los subsistemas para trabajar con la memoria Go en t√©rminos muy generales.  La idea principal del subsistema de memoria en Go es asignar memoria usando varias estructuras y cach√©s de diferentes niveles.  Esto tiene en cuenta el tama√±o de los objetos para los que se asigna memoria. <br><br>  La representaci√≥n de un solo bloque de direcciones de memoria continua recibidas del sistema operativo en forma de una estructura multinivel aumenta la eficiencia del mecanismo de asignaci√≥n de memoria debido al hecho de que este enfoque evita el bloqueo.  La asignaci√≥n de recursos, teniendo en cuenta el tama√±o de los objetos que deben almacenarse en la memoria, reduce la fragmentaci√≥n y, despu√©s de liberar memoria, le permite acelerar la recolecci√≥n de basura. <br><br>  <b>Estimados lectores!</b>  ¬øHa encontrado problemas causados ‚Äã‚Äãpor un mal funcionamiento de la memoria en los programas escritos en Go? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442648/">https://habr.com/ru/post/442648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442638/index.html">Escalado de aplicaciones Kubernetes basado en m√©tricas de Prometheus</a></li>
<li><a href="../442640/index.html">Error perfecto: uso de Type Confusion en Flash. Parte 1</a></li>
<li><a href="../442642/index.html">Qu√© leer en marzo: 22 libros nuevos para vendedores, gerentes, desarrolladores y dise√±adores</a></li>
<li><a href="../442644/index.html">La mayor√≠a de las habilidades que no son de programaci√≥n aumentan el valor del desarrollador</a></li>
<li><a href="../442646/index.html">Redes de Kubernetes: entrada</a></li>
<li><a href="../442650/index.html">An√°lisis y optimizaci√≥n de aplicaciones React.</a></li>
<li><a href="../442652/index.html">Uso de Fastify y Preact para prototipar r√°pidamente aplicaciones web</a></li>
<li><a href="../442654/index.html">Cambiar a Next.js y acelerar la carga de la p√°gina de inicio de manifold.co 7.5 veces</a></li>
<li><a href="../442658/index.html">8 trucos para trabajar con CSS: paralaje, pie de p√°gina adhesivo y otros</a></li>
<li><a href="../442660/index.html">Matem√°ticas reconciliando a Newton con el mundo cu√°ntico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>