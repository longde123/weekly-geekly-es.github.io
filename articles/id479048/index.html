<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ŠğŸ¾ ğŸ§“ ğŸš¶ Node.js Streaming untuk boneka atau cara bekerja dengan aliran ğŸ™‡ ğŸ´ ğŸ‘‹ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya pikir banyak orang telah mendengar tentang Node js Streams lebih dari sekali, tetapi tidak pernah menggunakannya, atau menggunakannya tanpa memik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js Streaming untuk boneka atau cara bekerja dengan aliran</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479048/">  Saya pikir banyak orang telah mendengar tentang Node js Streams lebih dari sekali, tetapi tidak pernah menggunakannya, atau menggunakannya tanpa memikirkan bagaimana mereka bekerja, aliran pipa dan norma.  Mari kita cari tahu apa itu stream, pipa (pipe), chunk (chunk - bagian dari data) dan semua itu)) <br><br><img src="https://habrastorage.org/webt/m8/iv/cp/m8ivcpkrvfaq1vfm53mhxafmzna.jpeg"><br><a name="habracut"></a><br>  Mengapa penting untuk memahami bagaimana stream bekerja di Node js?  Jawabannya sederhana: banyak modul built-in di Node js mengimplementasikan stream, seperti permintaan / tanggapan HTTP, baca / tulis fs, zlib, crypto, soket TCP, dan lainnya.  Anda juga perlu stream, misalnya, saat memproses file besar, saat bekerja dengan gambar.  Anda mungkin tidak menulis aliran Anda sendiri, tetapi memahami cara kerjanya akan membuat Anda menjadi pengembang yang lebih kompeten. <br><br>  Jadi, apa sebenarnya stream (selanjutnya saya akan gunakan sebagai pengganti Stream (stream)).  Stream adalah konsep yang dengannya Anda dapat memproses data dalam bagian-bagian kecil, yang memungkinkan Anda untuk menggunakan sejumlah kecil RAM.  Juga, dengan bantuannya, kita dapat membagi pemrosesan masing-masing bagian menjadi modul yang tidak saling bergantung (fungsi atau kelas).  Misalnya, kita dapat langsung mengompres bagian dari data, kemudian mengenkripsi dan menulis ke file.  Gagasan utamanya bukan untuk bekerja dengan seluruh data, tetapi untuk memproses bagian dari data satu per satu. <br><br>  Ada 4 jenis aliran di Node js: <br><br><ul><li>  Dapat dibaca </li><li>  Tertulis - Menulis </li><li>  Dupleks - Baca dan Tulis </li><li>  Transform - sejenis aliran Duplex yang dapat mengubah data </li></ul><br>  Anda dapat menemukan informasi lebih rinci di situs web resmi, dan sekarang mari kita beralih ke praktik. <br><br><h3>  Contoh sederhana </h3><br>  Saya pikir banyak yang sudah menggunakan stream tanpa menyadarinya.  Dalam contoh ini, kami cukup mengirim file ke klien. <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 - ( )      ,         const getFile = async (req, res, next) =&gt; { const fileStream = fs.createReadStream('path to file'); res.contentType('application/pdf'); fileStream.pipe(res); }; // 2 - (  )         const getFile = async (req, res, next) =&gt; { const file = fs.readFileSync('path to file'); res.contentType('application/pdf'); res.send(file); };</span></span></code> </pre> <br>  Satu-satunya perbedaan adalah bahwa dalam kasus pertama, kami mengunduh sebagian file dan mengirimkannya, dengan demikian, tidak memuat RAM server.  Dalam kasus kedua, kami segera memuat seluruh file ke dalam RAM dan baru kemudian mengirimkannya. <br><br>  Lebih lanjut dalam artikel kami akan menganalisis setiap aliran secara terpisah.  Anda dapat membuat aliran menggunakan warisan atau menggunakan fungsi konstruktor. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Readable } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 1 -   const myReadable = new Readable(opt); // 2 -   class myReadable extends Readable { constructor(opt) { super(opt); } }</span></span></code> </pre><br>  Dalam semua contoh, saya akan menggunakan 2 metode. <br><br><h3>  Aliran yang dapat dibaca </h3><br>  Mari kita lihat bagaimana kita dapat membuat aliran yang dapat dibaca di NodeJS. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Readable } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myReadable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Readable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(opt) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(opt); } _read(size) {} }</code> </pre><br>  Seperti yang Anda lihat dari contoh di atas, kelas ini menerima satu set parameter.  Kami hanya akan mempertimbangkan yang diperlukan untuk pemahaman umum tentang aliran yang Dapat Dibaca, sisanya dapat Anda lihat dalam dokumentasi.  Kami tertarik pada parameter highWaterMark dan metode _read. <br><br>  highWaterMark - ini adalah jumlah byte maksimum buffer aliran internal (secara default 16kb) setelah mencapai di mana pembacaan dari sumber daya ditangguhkan.  Untuk melanjutkan membaca, kita perlu membebaskan buffer internal.  Kita dapat melakukan ini dengan memanggil pipa, melanjutkan metode, atau dengan berlangganan acara data. <br><br>  _read adalah implementasi dari metode privat yang disebut dengan metode internal kelas Readable.  Itu disebut terus menerus sampai ukuran data mencapai highWaterMark. <br><br>  Nah, metode terakhir yang menarik bagi kita adalah readable.push, secara langsung menambahkan data ke buffer internal.  Ini mengembalikan true, tetapi segera setelah buffer penuh, panggilan ke metode ini akan mulai kembali salah.  Itu dapat dikontrol oleh metode readable._read. <br><br>  Mari kita lihat contoh untuk memperjelas situasi. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Readable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(opt) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(opt); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._max = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index = <span class="hljs-number"><span class="hljs-number">0</span></span>; } _read() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._max) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.from(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">._index}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Added: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">._index}</span></span></span><span class="hljs-string">. Could be added? `</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(buf)); } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Received: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${counter.read().toString()}</span></span></span><span class="hljs-string">`</span></span>);</code> </pre><br>  Untuk memulainya, saya akan mengatakan bahwa counter.read () bukan _read yang kami implementasikan di kelas.  Metode itu pribadi, dan ini publik, dan mengembalikan data dari buffer internal.  Ketika kita menjalankan kode ini, di konsol kita akan melihat yang berikut: <br><br><img src="https://habrastorage.org/webt/lg/yt/ih/lgytihuwtk4wpqbwz2p5xz2iudo.jpeg"><br><br>  Apa yang terjadi di sini?  Saat membuat aliran Penghitung baru ({highWaterMark: 2}), kami mengindikasikan bahwa ukuran buffer internal kami akan menjadi 2 byte, mis.  dapat menyimpan 2 karakter (1 karakter = 1 byte).  Setelah memanggil counter.read (), aliran mulai membaca, menulis '1' ke buffer internal dan mengembalikannya.  Kemudian dia melanjutkan membaca, menulis '2'.  Ketika ia menulis '3', buffer akan penuh, dapat dibaca.push akan mengembalikan false, dan aliran akan menunggu sampai buffer internal dibebaskan.  Karena  dalam contoh kita, tidak ada logika untuk membebaskan buffer, skrip akan berakhir. <br><br>  Seperti yang disebutkan sebelumnya, untuk memastikan bahwa bacaan tidak terganggu, kita perlu terus-menerus menghapus buffer internal.  Untuk melakukan ini, kami berlangganan acara data.  Ganti 2 baris terakhir dengan kode berikut. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); counter.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, chunk =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Received: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${chunk.toString()}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre><br>  Sekarang jika kita menjalankan contoh ini, kita akan melihat bahwa semuanya berfungsi sebagaimana mestinya dan angka dari 1 hingga 1000 ditampilkan di konsol. <br><br><h3>  Aliran tertulis </h3><br>  Bahkan, sangat mirip dengan aliran yang Dapat Dibaca, hanya dimaksudkan untuk menulis data. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Writable } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myWritable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(opt) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(opt); } _write(chunk, encoding, callback) {} }</code> </pre><br>  Ia menerima parameter serupa, seperti Stream yang Dapat Dibaca.  Kami tertarik pada highWaterMark dan _write. <br><br>  _write adalah metode pribadi yang dipanggil oleh metode internal kelas Writable untuk menulis sepotong data.  Dibutuhkan 3 parameter: chunk (bagian dari data), encoding (penyandian jika chunk adalah sebuah string), callback (fungsi yang dipanggil setelah penulisan yang berhasil atau tidak berhasil). <br><br>  highWaterMark adalah jumlah byte maksimum dari buffer aliran internal (secara default 16kb), setelah mencapai yang stream.write akan mulai mengembalikan false. <br><br>  Mari kita menulis ulang contoh sebelumnya dengan penghitung. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Writable } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writable</span></span></span><span class="hljs-class"> </span></span>{ _write(chunk, encoding, callback) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chunk.toString()); callback(); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { counter.write(Buffer.from(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${i}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>)); }</code> </pre><br>  Sebenarnya, semuanya sederhana, tetapi ada satu nuansa menarik yang patut diingat!  Saat membuat aliran Penghitung baru ({highWaterMark: 2}), kami mengindikasikan bahwa ukuran buffer internal kami akan menjadi 2 byte, mis.  dapat menyimpan 2 karakter (1 karakter = 1 byte).  Ketika penghitung mencapai sepuluh, buffer akan diisi dengan masing-masing panggilan untuk menulis, masing-masing, jika rekaman dilakukan dalam sumber yang lambat, maka semua data lain saat panggilan tulis akan disimpan dalam RAM, yang dapat menyebabkannya meluap (dalam contoh ini, ini Tentu saja itu tidak masalah, karena buffer kami adalah 2 byte, tetapi dengan file besar Anda perlu mengingat ini).  Ketika situasi seperti itu muncul, kita perlu menunggu sampai aliran menulis bagian data saat ini, melepaskan buffer internal (memicu peristiwa drainase), dan kemudian kita dapat melanjutkan merekam data.  Mari kita menulis ulang contoh kita. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Writable } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { once } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writable</span></span></span><span class="hljs-class"> </span></span>{ _write(chunk, encoding, callback) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chunk.toString()); callback(); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canWrite = counter.write(Buffer.from(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${i}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Can we write bunch of data? </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${canWrite}</span></span></span><span class="hljs-string">`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!canWrite) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> events.once(counter, <span class="hljs-string"><span class="hljs-string">'drain'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'drain event fired.'</span></span>); } } })();</code> </pre><br>  Metode events.once ditambahkan di v11.13.0 dan memungkinkan Anda untuk membuat janji dan menunggu acara tertentu dijalankan sekali.  Dalam contoh ini, kami memeriksa apakah data dapat ditulis ke aliran, jika tidak, maka tunggu hingga buffer dibebaskan dan melanjutkan perekaman. <br><br>  Pada pandangan pertama, ini mungkin tampak seperti tindakan yang tidak perlu, tetapi ketika bekerja dengan sejumlah besar data, misalnya file yang beratnya lebih dari 10GB, lupa untuk melakukan ini, Anda mungkin mengalami kebocoran kehabisan memori. <br><br><h3>  Aliran duplex </h3><br>  Ini menggabungkan aliran Readable dan Writable, yaitu, kita harus menulis implementasi dari dua metode _read dan _write. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Duplex } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myDuplex</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Duplex</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(opt) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(opt); } _read(size) {} _write(chunk, encoding, callback) {} }</code> </pre><br>  Di sini kita tertarik pada 2 parameter yang dapat kita lewati ke konstruktor, ini dapat dibacaHighWaterMark dan writableHighWaterMark, yang memungkinkan kita untuk menentukan ukuran buffer internal untuk Readable, Writable stream, masing-masing.  Ini adalah bagaimana implementasi dari dua contoh sebelumnya dengan bantuan aliran Duplex akan terlihat. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Duplex } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> events = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Duplex</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(opt) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(opt); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._max = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index = <span class="hljs-number"><span class="hljs-number">0</span></span>; } _read() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._max) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.from(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">._index}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(buf); } } _write(chunk, encoding, callback) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chunk.toString()); callback(); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter({ <span class="hljs-attr"><span class="hljs-attr">readableHighWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">writableHighWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> chunk = counter.read(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (chunk !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canWrite = counter.write(chunk); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Can we write bunch of data? </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${canWrite}</span></span></span><span class="hljs-string">`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!canWrite) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> events.once(counter, <span class="hljs-string"><span class="hljs-string">'drain'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'drain event fired.'</span></span>); } chunk = counter.read(); } })();</code> </pre><br>  Saya pikir kode ini tidak perlu penjelasan, karena sama seperti sebelumnya, hanya dalam satu kelas. <br><br><h3>  Ubah aliran </h3><br>  Aliran ini adalah aliran dupleks.  Diperlukan untuk mengonversi sepotong data dan mengirimkannya lebih jauh ke rantai.  Itu dapat diimplementasikan dengan cara yang sama seperti sisa aliran. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Transform } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myTransform</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Transform</span></span></span><span class="hljs-class"> </span></span>{ _ transform(chunk, encoding, callback) {} }</code> </pre><br>  Kami tertarik dengan metode _transform. <br><br>  _transform adalah metode pribadi yang dipanggil oleh metode internal kelas Transform untuk mentransformasi sepotong data.  Dibutuhkan 3 parameter: chunk (bagian dari data), encoding (penyandian jika chunk adalah sebuah string), callback (fungsi yang dipanggil setelah penulisan yang berhasil atau tidak berhasil). <br><br>  Dengan menggunakan metode ini, perubahan dalam porsi data akan terjadi.  Di dalam metode ini, kita bisa memanggil transform.push () nol atau lebih, yang melakukan perubahan.  Ketika kami menyelesaikan konversi data, kami perlu menelepon panggilan balik, yang akan mengirim semua yang kami tambahkan ke transform.push ().  Parameter pertama dari fungsi panggilan balik ini adalah kesalahan.  Selain itu, kami tidak dapat menggunakan transform.push (), tetapi mengirim data yang diubah sebagai parameter kedua ke fungsi callback (contoh: callback (null, data)).  Untuk memahami cara menggunakan jenis aliran ini, mari kita menganalisis metode stream.pipe. <br><br>  stream.pipe - metode ini digunakan untuk menghubungkan aliran Readable ke stream Writable, serta untuk membuat rantai aliran.  Ini berarti bahwa kita dapat membaca bagian dari data dan mentransfernya ke aliran berikutnya untuk diproses, dan kemudian ke yang berikutnya, dll. <br><br>  Mari kita menulis aliran Transform yang akan menambahkan karakter * ke awal dan akhir setiap bagian data. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CounterReader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Readable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(opt) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(opt); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._max = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index = <span class="hljs-number"><span class="hljs-number">0</span></span>; } _read() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._max) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.from(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">._index}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(buf); } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CounterWriter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writable</span></span></span><span class="hljs-class"> </span></span>{ _write(chunk, encoding, callback) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chunk.toString()); callback(); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CounterTransform</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Transform</span></span></span><span class="hljs-class"> </span></span>{ _transform(chunk, encoding, callback) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resultString = <span class="hljs-string"><span class="hljs-string">`*</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${chunk.toString(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'utf8'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">*`</span></span>; callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, resultString); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { callback(err); } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counterReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CounterReader({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counterWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CounterWriter({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counterTransform = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CounterTransform({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); counterReader.pipe(counterTransform).pipe(counterWriter);</code> </pre><br>  Dalam contoh ini, saya menggunakan aliran Readable dan Writable dari contoh sebelumnya, dan juga menambahkan Transform.  Seperti yang Anda lihat, ternyata cukup sederhana. <br><br>  Jadi kami melihat bagaimana aliran diatur.  Konsep utama mereka adalah pemrosesan data di bagian-bagian, yang sangat nyaman dan tidak memerlukan sumber daya yang besar.  Selain itu, stream dapat digunakan dengan iterator, yang membuatnya lebih nyaman digunakan, tetapi ini adalah cerita yang sama sekali berbeda. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479048/">https://habr.com/ru/post/id479048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479036/index.html">Intel tidak dapat mengatasi permintaan akan prosesor. Akibatnya, HP dan Dell menderita</a></li>
<li><a href="../id479038/index.html">Transformasi Digital Leroy Merlin: Merancang Antarmuka untuk Bekerja dengan Panggilan Pelanggan</a></li>
<li><a href="../id479040/index.html">Tes regresi visual. Mulai ulang</a></li>
<li><a href="../id479042/index.html">Metode Y adalah cara yang sangat mudah untuk membangun Rubik's Cube</a></li>
<li><a href="../id479044/index.html">Implementasi ring ring saya di NOR flash</a></li>
<li><a href="../id479050/index.html">Penelitian paten di bidang TI. Kursus pejuang muda. Bagian II Sumber informasi untuk penelitian paten</a></li>
<li><a href="../id479052/index.html">[Superkomputer 2019]. Penyimpanan multi-cloud sebagai aplikasi untuk drive Kingston DC1000M baru</a></li>
<li><a href="../id479054/index.html">Polling Ponsel Jumat</a></li>
<li><a href="../id479056/index.html">Bicara tentang kehidupan? Tim DREAM tentang Tantangan Alexa Prize Socialbot 3</a></li>
<li><a href="../id479058/index.html">Pemantauan sebagai proses manajemen acara</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>