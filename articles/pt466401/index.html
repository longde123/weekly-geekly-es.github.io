<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö≥ üßëüèæ ‚ú≥Ô∏è Um pouco de matem√°tica financeira: calculando infla√ß√£o e juros üßò ‚ùóÔ∏è üò´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente, tive que verificar os c√°lculos feitos pelos servi√ßos p√∫blicos da minha cidade. Houve um problema controverso, que s√≥ pode ser resolvido ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Um pouco de matem√°tica financeira: calculando infla√ß√£o e juros</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466401/"> Recentemente, tive que verificar os c√°lculos feitos pelos servi√ßos p√∫blicos da minha cidade.  Houve um problema controverso, que s√≥ pode ser resolvido atrav√©s da realiza√ß√£o de c√°lculos corretos.  Olhando para o futuro, direi que os servi√ßos p√∫blicos pensam errado.  Portanto, consideraremos aqui como calcular corretamente os custos da infla√ß√£o e 3% ao ano da d√≠vida por obriga√ß√µes, de acordo com o C√≥digo Civil da Ucr√¢nia. <br><br>  A primeira parte descreve o c√°lculo dos custos da infla√ß√£o, isto √© espec√≠fico para a Ucr√¢nia. <br>  A segunda parte (maior) ser√° dedicada √† quest√£o do c√°lculo de 3% ao ano.  Tamb√©m √© aplic√°vel √† Federa√ß√£o Russa, Bielorr√∫ssia e Cazaquist√£o, mas nesses pa√≠ses a taxa n√£o √© fixa, mas depende da taxa de refinanciamento do Banco Central.  O resto do pa√≠s n√£o parecia. <br><br>  A segunda parte est√° muito pr√≥xima do c√°lculo de juros sobre transa√ß√µes de cr√©dito comuns (empr√©stimos, empr√©stimos, empr√©stimos etc.). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/di/2q/9l/di2q9lbdqyzqzcywadgdnny0bgo.png" alt="imagem alt"></div><br>  Primeiro uma teoria, no final, um pequeno c√≥digo. <br><br>  Tudo isso sob o corte. <br><a name="habracut"></a><br>  Por isso, entrei nas m√£os de um documento dos servi√ßos p√∫blicos "Declara√ß√£o de compet√™ncia dos custos da infla√ß√£o e 3% ao ano".  Foi verificado por mim e descobri que foi calculado usando o algoritmo errado e √© de interesse, pois ele deve implementar os requisitos do artigo do C√≥digo Civil da Ucr√¢nia. <br><br>  O que deve ser considerado est√° escrito no C√≥digo Civil da Ucr√¢nia: <br><blockquote>  Artigo 625 do C√≥digo Civil da Ucr√¢nia.  "Responsabilidade pela viola√ß√£o de uma obriga√ß√£o monet√°ria" <br>  2. Um devedor que atrasou o cumprimento de uma obriga√ß√£o monet√°ria, a pedido do credor, √© obrigado a pagar o valor da d√≠vida, levando em considera√ß√£o o √≠ndice de infla√ß√£o estabelecido para todo o per√≠odo de atraso, bem como 3% ao ano do montante vencido ... </blockquote>  Com base nos valores da d√≠vida, os servi√ßos p√∫blicos calcularam os custos da infla√ß√£o e 3% ao ano. <br><br><h2>  Custos de infla√ß√£o </h2><br>  Al√©m disso, falarei sobre o algoritmo de c√°lculo, e n√£o sobre n√∫meros espec√≠ficos. <br><br>  A infla√ß√£o √© um processo caracterizado por uma deprecia√ß√£o da moeda, ou seja, uma diminui√ß√£o no seu poder de compra e um aumento geral nos pre√ßos.  Excluindo a infla√ß√£o, os resultados finais dos c√°lculos de fluxo de caixa s√£o muito arbitr√°rios. <br><br>  √çndice de Infla√ß√£o (II) ou √çndice de Pre√ßos ao Consumidor (IPC), √çndice de Pre√ßos ao Consumidor (IPC) - um dos tipos de √≠ndices de pre√ßos criados para medir o n√≠vel m√©dio de pre√ßos de bens e servi√ßos (cesta de consumidores) durante um determinado per√≠odo da economia. <br><br>  A IA √© um indicador que caracteriza a din√¢mica do n√≠vel geral de pre√ßos de bens e servi√ßos que a popula√ß√£o adquire para consumo n√£o produtivo.  Esse √© o √≠ndice de crescimento, que mostra quantos por cento do aumento m√©dio de pre√ßo no per√≠odo em an√°lise. <br><br>  Na Ucr√¢nia, AI e CPI s√£o sin√¥nimos <br><br>  Como o √≠ndice de pre√ßos √© um √≠ndice em cadeia, para per√≠odos seguintes um ap√≥s o outro, √© calculado multiplicando os indicadores, por exemplo, 101% * 102% = (1,01 * 1,02) * 100% = 103,02%. <br><br>  A IA √© calculada pelo Comit√™ Estatal de Estat√≠stica da Ucr√¢nia e publicada em peri√≥dicos oficiais.  Esses √≠ndices podem ser usados ‚Äã‚Äãpara recalcular os valores em dinheiro. <br>  O que os trabalhadores comunit√°rios pensam? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/5p/hv/ge5phvi9cjhbbz7kkx0jndzuyli.png" alt="Parte do documento de cobran√ßa de servi√ßos p√∫blicos"></div><br>  A √∫ltima data de liquida√ß√£o √© 7 de dezembro de 2016. <br><br>  Vamos ver como os trabalhadores comunit√°rios obtiveram √≠ndices de custo da infla√ß√£o? <br><br>  Pode ser visto a olho nu que na terceira (e quinta coluna), em vez da parte inteira 1, deve haver a parte inteira 0. Como eles conseguiram a parte fracion√°ria? <br><br>  <strong>Setembro de 2016.</strong> Parte fracion√°ria 0,028.  O prazo para pagamento √© 20 de setembro de 2016. A parte fracion√°ria corresponde ao √≠ndice de infla√ß√£o publicado pelo Comit√™ de Estat√≠stica do Estado, para outubro de 2016 - 102,8% <br><br>  <strong>Agosto de 2016.</strong> Parte fracion√°ria 0,0465.  O prazo de pagamento para agosto √© 20 de setembro de 2016. A parte fracion√°ria corresponde ao √≠ndice de infla√ß√£o para setembro multiplicado por II para outubro: 101,8% * 102,8% = 104,65%, ou em a√ß√µes, 1,018 * 1,028 = 1,046504.  Os servi√ßos p√∫blicos s√£o arredondados para 1,0465 e imprimem esse n√∫mero, embora a unidade deva ser retirada, porque na pr√≥xima coluna eles imprimem apenas o valor dos custos de infla√ß√£o e n√£o o valor acumulado. <br><br>  <strong>Julho de 2016 e anteriores.</strong>  Realizei esses c√°lculos e restaurei o algoritmo.  Os servi√ßos p√∫blicos multiplicam os √≠ndices de infla√ß√£o, come√ßando no m√™s seguinte ao da presta√ß√£o dos servi√ßos (m√™s do vencimento) e terminando em outubro de 2016. <br><br>  <strong>O ponto de partida √©</strong> apenas parcialmente verdadeiro.  Como mostrarei mais adiante, no caso geral, o c√°lculo realmente precisa come√ßar a partir deste m√™s, mas no nosso caso particular, o primeiro m√™s deve ser ignorado (equacione AI a 100%). <br><br>  <strong>O ponto final da</strong> multiplica√ß√£o.  Como o √∫ltimo dia de c√°lculo √© em dezembro, e voc√™ precisa terminar em dezembro, esse geralmente √© o caso.  Como mostrarei mais adiante, nesse caso em particular, dezembro tamb√©m precisa ser ignorado (tamb√©m equivale a AI a 100%).  E em 7 de dezembro, as AIs de dezembro n√£o tiveram tempo de publicar. <br><br>  Por que novembro n√£o √© levado em considera√ß√£o em lugar algum?  Eu acho que eles simplesmente esqueceram de inseri-lo no sistema. <br><br>  Agora vamos ver como calcular o √≠ndice de infla√ß√£o.  Conforme <strong>necess√°rio</strong> - descrito na Carta de informa√ß√µes do Supremo Tribunal Econ√¥mico da Ucr√¢nia n¬∫ 01-06 / 928/2012, de 17.07.2012 [6]. <br><br>  Vou dar parte do par√°grafo: <br><blockquote>  O valor da d√≠vida a ser paga do 1¬∫ ao 15¬∫ dia do m√™s √© indexado levando em considera√ß√£o este m√™s e, se a d√≠vida for paga do 16 ao 31 do dia, o c√°lculo come√ßa no pr√≥ximo m√™s. <br><br>  Da mesma forma, se uma d√≠vida tiver sido paga de 1 a 15 dias de um m√™s, os custos de infla√ß√£o ser√£o calculados sem levar em considera√ß√£o este m√™s e, se de 16 a 31 dias de um m√™s, os custos de infla√ß√£o ser√£o calculados levando em considera√ß√£o este m√™s. </blockquote>  No nosso caso, o prazo de pagamento √© o vig√©simo dia do m√™s seguinte ao da presta√ß√£o dos servi√ßos, ou seja,  para a presta√ß√£o de servi√ßos em setembro, a data de in√≠cio dos assentamentos √© 21 de outubro de 2016 e o ‚Äã‚Äãprazo final √© 7 de dezembro de 2016. <br><br>  I.e.  √© correto considerar o seguinte: para a presta√ß√£o de servi√ßos em setembro de 2016, considere a infla√ß√£o por tr√™s meses (passe o cursor ou o ciclo), de outubro a dezembro, mas no primeiro e no √∫ltimo m√™s, considere a IA igual a 1 (100%) e leve em considera√ß√£o apenas novembro. <br><br>  Em novembro de 2016, a IA atingiu 101,8%, ou seja,  o coeficiente deve ser 0,0180, n√£o 0,0280.  Eu escrevi sobre a unidade principal antes. <br><br><h2>  3% ao ano </h2><br>  Vamos ver como os servi√ßos comunit√°rios receberam coeficientes e acumulam montantes de 3% ao ano?  Esta √© a quinta coluna na tabela acima. <br><br>  Como escrevi anteriormente, n√£o deve haver uma unidade principal, deve haver 0. Observamos a parte fracion√°ria e percebemos que ela √© suspeita de alguma forma redonda - cada m√™s anterior √© 0,0025 mais que o m√™s atual. <br><br>  Usando c√°lculos simples, pode-se determinar que os servi√ßos p√∫blicos, sem mais delongas, dividam 3% em 12 meses, recebem 0,0025 ou 0,25% por m√™s e acumulam esse percentual para cada m√™s completo e incompleto de atraso.  Sim, se voc√™ olhar para outubro de 2016, cujo prazo de pagamento chegou em 21 de novembro e os c√°lculos foram feitos em 7 de dezembro, por um m√™s incompleto, eles contaram os mesmos 0,25%. <br><br>  A abordagem admira objetividade brutal, mas, como mostrarei mais adiante, a matem√°tica financeira n√£o conhece esse algoritmo. <br><br>  A legisla√ß√£o da Ucr√¢nia e a matem√°tica financeira n√£o d√£o uma resposta clara √† quest√£o de como cobrar 3% ao ano?  Procurei v√°rios livros sobre esse assunto, mas os livros s√£o antigos, datando de 2002.  Portanto, os algoritmos dos livros ser√£o complementados pelo fato de que foi poss√≠vel pesquisar no Google a partir de artigos mais modernos e ocidentais.  [1] foi reimpresso em 2007, e livros mais recentes em russo n√£o foram encontrados.  Talvez porque a matem√°tica financeira, como ci√™ncia, tenha se originado h√° muito tempo, muito antes do advento dos computadores, conceitos como "cr√©dito" e "juros sobre cr√©dito" surgiram centenas de anos atr√°s.  E os algoritmos n√£o mudaram muito desde 2002. <br><br>  Mas a vis√£o ocidental do problema √© diferente da descrita nos livros em russo.  Citarei informa√ß√µes primeiro de livros em russo e depois de artigos ocidentais, indicando onde eles coincidem. <br><br>  O que est√° escrito abaixo refere-se ao caso espec√≠fico de acumular 3% ao ano dos atrasados, mas pode ser generalizado para o c√°lculo dos juros de outras rela√ß√µes de cr√©dito se os juros forem acumulados de acordo com o esquema de juros simples e n√£o com juros compostos. <br><br>  De acordo com o art.  625 O C√≥digo Civil da Ucr√¢nia precisa acumular 3% ao ano, de acordo com o esquema de juros simples.  Para calcular a quantia de juros, a quantia de d√≠vida (ou o corpo do empr√©stimo, no caso geral) deve ser multiplicada pela taxa de juros anual normalizada de 3% e multiplicada pela fra√ß√£o do ano (dura√ß√£o em anos) a que o atraso chegou.  Esse compartilhamento pode ser maior que 1 se o atraso for superior a um ano. <br><br>  A dura√ß√£o do atraso √© expressa em dias.  Em um caso mais geral, o prazo do empr√©stimo <strong>pode ser</strong> expresso em dias (a situa√ß√£o em que o prazo do empr√©stimo √© expresso em meses e anos n√£o √© considerada aqui).  E a taxa anual de 3% √© a taxa normalizada de juros simples para o ano.  <strong>Portanto, voc√™ precisa conseguir aumentar a dura√ß√£o do atraso (cr√©dito) em dias para a dura√ß√£o em anos.</strong>  <strong>Esta n√£o √© uma tarefa trivial, pois a dura√ß√£o do ano depende do seu n√∫mero.</strong> <br><br>  A dura√ß√£o em dias √© uma medida definida exclusivamente da dura√ß√£o das lacunas do calend√°rio, em oposi√ß√£o √† dura√ß√£o em anos.  A defini√ß√£o deste √∫ltimo requer esclarecimentos na forma de uma regra para converter a dura√ß√£o em dias para a dura√ß√£o em anos.  V√°rios m√©todos padr√£o para converter a dura√ß√£o em dias para a dura√ß√£o em anos s√£o baseados na divis√£o do n√∫mero de dias pelo chamado <strong>"divisor anual"</strong> .  Os valores mais t√≠picos do divisor anual s√£o 360 e 365 dias.  Nos casos mais simples, o divisor √© um n√∫mero constante e independente de intervalo.  O n√∫mero de dias em um per√≠odo sempre atua como um dividendo (numerador de uma fra√ß√£o). <br>  E voc√™ precisa decidir sobre o procedimento para calcular os termos em dias.  Vamos considerar dois exemplos absurdos: <br><br><ol><li>  O cliente recebe um empr√©stimo de curto prazo do banco de 6 de dezembro de 2018 a 7 de dezembro de 2018.  Qual √© o prazo do contrato e quantos dias eu preciso para acumular juros?  Obviamente - 1 dia. </li><li>  O assinante pr√©-encomenda o servi√ßo da operadora de telecomunica√ß√µes, com um per√≠odo de validade no futuro de 6 de dezembro de 2018 a 7 de dezembro de 2018.  Quais s√£o as linhas de presta√ß√£o de servi√ßos e por quantos dias tenho que pagar uma taxa de assinatura pelo servi√ßo?  Obviamente 2 dias. </li></ol><br>  Qual a diferen√ßa? <br><br>  O fato √© que o dia n√£o √© um ponto na linha do tempo, mas um intervalo que pode ser escrito de duas maneiras (lembro que o colchete na borda do intervalo significa que o ponto est√° no intervalo, o par√™ntese √© o ponto que n√£o est√° no intervalo): <br><br><ul><li>  [06.12.2018 00.00.00, 07/07/2018 00.00.00) - aqui a borda direita do intervalo n√£o est√° inclu√≠da no intervalo, </li><li>  [06/06/2018 00.00.00, 06/06/2018 23.59.59] - aqui a borda direita do intervalo est√° inclu√≠da no intervalo. </li></ul><br>  No primeiro caso (1), quando o intervalo de tempo n√£o √© fornecido explicitamente, mas na forma de um intervalo entre datas, o n√∫mero exato de dias √© geralmente calculado, incluindo o primeiro ou o √∫ltimo dia, mas n√£o os dois.  [4] diz o mesmo em outras palavras: "O dia em que o empr√©stimo √© emitido e o dia do reembolso √© considerado um dia". <br><br>  Este m√©todo determina o tempo exato chamado.  Tamb√©m pode ser facilmente determinado se as duas datas se referem ao mesmo ano e se um calend√°rio est√° dispon√≠vel mostrando o n√∫mero de s√©rie de cada dia do ano.  Basta subtrair o n√∫mero de s√©rie da data inicial do n√∫mero de s√©rie da data final e o resultado fornecer√° a dura√ß√£o do per√≠odo.  No Oracle Database, voc√™ pode simplesmente subtrair datas (tipo DATE) truncadas para um dia (com tempo descartado), uma da outra, a diferen√ßa √© um n√∫mero inteiro de dias. <br><br>  No segundo caso (2) estamos falando de dias, ent√£o contamos dois dias. <br><br>  Al√©m disso, procedo do fato de que o n√∫mero de dias em que voc√™ j√° foi determinado, por exemplo, no caso de servi√ßos comunit√°rios, quando o prazo de pagamento √© 20 de setembro (ou seja, este √© o √∫ltimo dia de pagamento aceit√°vel) e foi pago em 21 de setembro, ou seja. √© √≥bvio que o atraso deve ser igual a 1 dia.  Caso voc√™ se depare com uma indica√ß√£o do intervalo que n√£o inclui a borda esquerda - basta mover a borda esquerda um dia para a direita. <br><br>  Como contamos o n√∫mero de dias e o numerador de uma fra√ß√£o?  H√° um c√°lculo exato e um c√°lculo aproximado. <br><br><h3>  Contagem precisa de dias </h3><br><h4>  Pr√°tica de l√≠ngua russa </h4><br>  O texto √© ainda baseado em [1]. <br><br>  A escolha do n√∫mero exato de dias em um per√≠odo como divisor e as duas regras mais comuns fornecem as regras mais comuns como denominador - um divisor anual de 360 ‚Äã‚Äãou 365: <br><br>  <strong>Regra (R1) ACT / 365.</strong>  Para esta regra, a dura√ß√£o em dias √© dividida pelo n√∫mero 365. Observo que a dura√ß√£o de um ano bissexto ser√° 366/365 = 1,00274, que √© mais de um.  O erro de regra do ACT / 365 ser√° o maior, mais anos bissextos em um per√≠odo.  Portanto, o valor de 3% ao ano acumulado por esta regra ser√° superior a 3%. <br><br>  <strong>Regra (R2) ACT / 360.</strong>  Essa √© a chamada "regra banc√°ria", segundo a qual a dura√ß√£o em dias √© dividida em 360. Essa regra aumenta ainda mais a dura√ß√£o anual das lacunas.  Para um ano n√£o bissexto, sua dura√ß√£o ser√° 365/360 = 1.01389, e para um ano bissexto 366/360 = 1.01667.  Naturalmente, quanto mais longo o per√≠odo, maior o grau de ‚Äúalongamento‚Äù em anos.  Essa regra √© mais frequentemente usada em c√°lculos relacionados ao mercado monet√°rio, ou seja,  d√≠vida de curto prazo do mercado, como dep√≥sitos em bancos, letras, t√≠tulos comerciais, certificados de dep√≥sito, etc. O valor de 3% ao ano para o ano ser√° ainda maior do que quando se utiliza a regra anterior. <br><br>  No caso de o divisor anual ser aceito igual a 360 dias, os juros obtidos com esse divisor s√£o denominados <strong>ordin√°rios</strong> ou <strong>comerciais</strong> .  Se o divisor for considerado igual a 365 ou, como mostrarei mais adiante, 366 dias, o interesse ser√° chamado exato. <br><br>  Obviamente, porcentagens comuns s√£o mais que exatas. <br><br>  Embora a primeira regra seja mais precisa que a segunda, ambas n√£o s√£o precisas o suficiente. <br><br>  Para eliminar o efeito de anos bissextos nos resultados, existem duas outras regras. <br><br>  <strong>Regra (R3) ACT / 365, Jap√£o.</strong>  O c√°lculo √© realizado da mesma maneira que para a regra ACT / 365, mas ao calcular a dura√ß√£o do intervalo (numerador de fra√ß√µes), as datas dos saltos s√£o exclu√≠das.  O divisor anual permanece inalterado. <br><br>  De acordo com o Wiki: <br><blockquote>  Em muitos pa√≠ses europeus, at√© o s√©culo 18, o dia 29 de fevereiro era considerado um dia inexistente, uma data que n√£o possui status legal.  Muitas vezes, as transa√ß√µes n√£o eram feitas naquele dia, os pagamentos n√£o eram feitos, eles n√£o eram endividados, etc., devido ao fato de haver dificuldades com o lado formal da quest√£o e com a solu√ß√£o de casos em tribunal. </blockquote><br><br>  Outra maneira est√° relacionada √† mudan√ßa real do divisor. <br><br>  <strong>Regra (R4) ACT / ACT b√°sica.</strong>  Dividimos o per√≠odo desejado em tr√™s partes: <br><br><ul><li>  a primeira parte, a partir da data de in√≠cio at√© o final do ano em que a data de in√≠cio est√° localizada, </li><li>  a terceira parte - do in√≠cio do ano em que a data final est√° localizada, at√© a data final, </li><li>  a segunda parte - 0 ou v√°rios anos civis completos entre a primeira e a terceira partes. </li></ul><br>  As dura√ß√µes da primeira e terceira partes s√£o obtidas dividindo o n√∫mero de dias pelo divisor anual 365 ou 366, dependendo de se tratar de um ano bissexto.  A dura√ß√£o do segundo per√≠odo consiste em um n√∫mero inteiro de anos civis completos, por defini√ß√£o, independentemente de serem saltos ou n√£o.  A dura√ß√£o em anos de todo o per√≠odo √© obtida somando-se as dura√ß√µes de tr√™s partes, representadas por tr√™s n√∫meros, dos quais o segundo √© um todo e o primeiro e o terceiro s√£o fracion√°rios. <br><br>  <strong>Regra (R5) ACT / ACT modifica√ß√£o "curta", por per√≠odos inferiores a um ano.</strong>  Nesse caso, a dura√ß√£o em dias √© dividida pelo divisor anual 365 ou 366, dependendo da exist√™ncia de uma data em 29 de fevereiro no per√≠odo de pesquisa?  Um recurso da regra curta ACT / ACT √© que, se o intervalo n√£o se encaixar no ano civil (seus fins pertencem aos anos vizinhos), a aplica√ß√£o das regras b√°sicas e breves levar√° a resultados diferentes. <br><br><h4>  Pr√°tica ocidental </h4><br>  Na pr√°tica ocidental, as regras s√£o descritas de maneira diferente.  Freq√ºentemente, as mesmas regras no idioma russo recebem nomes diferentes e, al√©m disso, n√£o uma por vez. <br><br>  A informa√ß√£o √© baseada mais em [2].  Este √© Vicki, verifiquei todas as fontes e usei outras informa√ß√µes do google: nas regras com um n√∫mero exato de dias, tudo est√° correto, mas nas regras com um n√∫mero aproximado de dias h√° outras interpreta√ß√µes das regras e, com frequ√™ncia, elas mudam com o tempo, portanto, para colocar as regras em pr√°tica o n√∫mero aproximado de dias em que este artigo n√£o √© suficiente. <br><br>  <strong>Regra (W1) ISDA real / real.</strong>  Essa regra fornece o mesmo resultado que (R4) ‚ÄúACT / ACT main‚Äù, mas √© formulada de maneira diferente: o intervalo √© dividido em anos bissextos e n√£o bissextos, independentemente de serem completos ou incompletos, al√©m disso, a soma dos dias que se seguem anos bissextos, divididos por 365, e a soma dos dias em anos n√£o bissextos √© dividida por 366, os dois n√∫meros s√£o somados. <br><br>  Outros nomes da regra na pr√°tica ocidental: Real / Real, Ato / Ato, Real / 365, Ato / 365.  Sim, o sobrenome √© igual √† regra (R1), embora a ess√™ncia da regra seja diferente. <br><br>  <strong>Regra (W2) Real / 365 corrigida.</strong>  Essa regra repete exatamente a regra (R1) ACT / 365 - o n√∫mero de dias √© dividido por 365. <br><br>  Outros nomes da regra na pr√°tica ocidental: Act / 365 Fixo, A / 365 Fixo, A / 365F, Ingl√™s. <br><br>  <strong>Regra (W3) Real / 360.</strong>  Esta regra repete (R2) ACT / 360 - o n√∫mero exato de dias √© dividido por 360. <br><br>  <strong>Regra (W4) Real / 364.</strong>  O n√∫mero de dias √© dividido por 364. N√£o possui an√°logo na pr√°tica de l√≠ngua russa. <br><br>  <strong>Regra (W5) Real / 365L.</strong>  Consiste em dois ajustes: <br><ol><li>  Para pagamentos anuais.  Se a data for 29 de fevereiro no per√≠odo, o n√∫mero de dias no per√≠odo ser√° dividido pelo divisor anual 366, se n√£o, por 365. Nesse sentido, ele coincide com a regra (R5) ACT / ACT ‚Äúmodifica√ß√£o curta‚Äù. </li><li>  Se a frequ√™ncia dos pagamentos for diferente da anual.  Se a data final estiver em um ano bissexto (e n√£o for necessariamente igual a 29 de fevereiro), o divisor anual ser√° 366, caso contr√°rio - 365. Na pr√°tica de l√≠ngua russa, n√£o h√° anal√≥gico. </li></ol><br>  Outro nome √© ISMA-Year. <br><br>  <strong>Regra (W6) AFB real / real.</strong>  Consiste em dois ajustes: <br><ol><li>  O principal para per√≠odos inferiores a um ano: se a data for 29 de fevereiro no per√≠odo, o n√∫mero de dias no per√≠odo ser√° dividido pelo divisor anual 366, se n√£o, por 365. Nesse sentido, ele tamb√©m coincide com a regra de ‚Äúmodifica√ß√£o curta‚Äù do R / ACT ACT / ACT . </li><li>  Estendido, por per√≠odos superiores a um ano: um ano inteiro inteiro √© contado da data final at√© a data inicial.  Para um saldo inferior a um ano, a regra principal se aplica.  O n√∫mero de anos completos e a parcela do ano de acordo com a regra b√°sica s√£o resumidos. <br></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem nuances associadas √† contagem regressiva anos atr√°s, se a contagem regressiva foi realizada em 28 de fevereiro e, ap√≥s um n√∫mero inteiro de anos completos atr√°s, o ano acabou sendo um ano bissexto. </font><font style="vertical-align: inherit;">Nesse caso, a data de n anos atr√°s deve ser adotada em 29 de fevereiro. </font><font style="vertical-align: inherit;">Acrescentarei que a pergunta tamb√©m surge se a contagem regressiva foi realizada em 29 de fevereiro e o n√∫mero de anos completos atr√°s n√£o √© um m√∫ltiplo de quatro, e, portanto, o ano anterior n√£o foi um ano bissexto. </font><font style="vertical-align: inherit;">N√£o entrei em detalhes aqui. </font><font style="vertical-align: inherit;">Mas voc√™ pode consultar os links de [2]. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E ‚Äúcereja no bolo‚Äù, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regra (W7) 1/1. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O n√∫mero de dias √© dividido pelo divisor anual 365.25. </font><font style="vertical-align: inherit;">Usado para c√°lculos relacionados √† infla√ß√£o.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contagem estimada de dias </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As regras listadas acima foram baseadas na dura√ß√£o exata em dias de per√≠odos do calend√°rio. No entanto, algumas vezes existem esquemas baseados na chamada contagem simplificada ou aproximada de dias. A id√©ia desses esquemas √© "igualar" a dura√ß√£o de todos os meses a 30 dias. Assim, o ano consistir√° em 12 meses de 30 dias, ou seja, de 360 ‚Äã‚Äãdias. Portanto, o divisor anual (denominador da fra√ß√£o) para essas regras sempre ser√° 360 e o numerador √© calculado de maneira especial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o n√∫mero exato de dias de empr√©stimo na maioria dos casos, mas √© claro, nem sempre, √© maior que o valor aproximado (que pode ser facilmente verificado atrav√©s da determina√ß√£o do n√∫mero m√©dio anual de dias em um m√™s, que √© 30,44), o m√©todo de c√°lculo de juros com o n√∫mero exato de dias de empr√©stimo geralmente fornece maior crescimento que aproximado. [4]</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A vers√£o mais simples desta regra, a chamada </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regra b√°sica 30/360</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , √© descrita a seguir (a seguir, as informa√ß√µes do livro [1] - pr√°tica em l√≠ngua russa): </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regra b√°sica 30/360. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O n√∫mero aproximado de dias entre as datas √©</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 360 * (y2 - y1) + 30 * (m2 - m1) + (d2 - d1), </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onde y, m, d - ano, m√™s e dia na segunda e na primeira datas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa regra apareceu antes da cria√ß√£o dos primeiros dispositivos de computa√ß√£o e economizou significativamente o custo das opera√ß√µes de computa√ß√£o na pr√°tica financeira. </font><font style="vertical-align: inherit;">Embora agora a necessidade de m√©todos simplificados tenha desaparecido, no entanto, tendo adquirido um ponto de apoio na pr√°tica, por tradi√ß√£o eles s√£o √†s vezes usados ‚Äã‚Äãno presente momento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A regra se aplica a uma indica√ß√£o obrigat√≥ria de uma modifica√ß√£o que indica como lidar com os √∫ltimos dias dos meses:</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pr√°tica de l√≠ngua russa </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conduzido por [1]. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regra (R6) 30/360 ISDA. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se d1 = 31, ent√£o d1 '= 30, caso contr√°rio, d1' = d1. </font><font style="vertical-align: inherit;">Se d2 = 31 ed1 '= 30, ent√£o d2' = 30, caso contr√°rio d2 '= d2. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regra (R7) 30E / 360. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se d1 = 31, ent√£o d1 '= 30, caso contr√°rio, d1' = d1. </font><font style="vertical-align: inherit;">Se d2 = 31, ent√£o d2 '= 30, caso contr√°rio d2' = d2. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta regra √© uma variante da regra ISDA 30/360, usada principalmente na Europa, da√≠ o r√≥tulo "E" no nome da regra. </font><font style="vertical-align: inherit;">Difere da regra ISDA 30/360 somente quando a segunda data tamb√©m √© a 31¬™. </font><font style="vertical-align: inherit;">A vers√£o europ√©ia sempre a converte no 30¬∫ n√∫mero, independentemente da primeira data. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regra (R8) 30/360 PSA. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se d1 = 31 ou d1 for o √∫ltimo dia de fevereiro, ent√£o d1 '= 30, caso contr√°rio, d1' = d1. </font><font style="vertical-align: inherit;">Se d2 = 31 ed1 '= 30, ent√£o d2' = 30, caso contr√°rio d2 '= d2.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A descri√ß√£o da regra 30/360 SIA em [1] provavelmente √© um erro, portanto n√£o a darei aqui. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pr√°tica ocidental </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado de acordo com [2]. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regra (W8) 30/360 Base de obriga√ß√µes.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O mesmo que (R6) 30/360 ISDA. Outro nome: 30A / 360. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regra (W9) 30E / 360.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O mesmo que (R7) 30E / 360. Outros nomes: 30/360 ICMA, 30S / 360, base Eurobond (ISDA 2006), alem√£o especial. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regra (W10) 30E / 360 ISDA.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se d1 for o √∫ltimo dia do m√™s, ent√£o d1 '= 30. Se d2 for o √∫ltimo dia de N√ÉO fevereiro, d2 '= 30. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outros nomes: ISE 30E / 360, base Eurobond (ISDA 2000), alem√£o. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regra (W11) 30/360 SIA.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se d1 for o √∫ltimo dia de fevereiro e d2 for o √∫ltimo dia de fevereiro, d2 '= 30. Se d1 = 31 ou o √∫ltimo dia de fevereiro, ent√£o d1 '= 30, caso contr√°rio, d1' = d1. Se d1 '= 30 ed2 = 31, ent√£o d2' = 30, caso contr√°rio, d2 '= d1.</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As regras (R4) ACT / ACT, (W1) ISDA Real / Real, (W2) Real / 365 Fixo tamb√©m s√£o chamadas de ‚ÄúPr√°tica de Ingl√™s‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As regras (R2) ACT / 360 e (W3) Atual / 360 tamb√©m s√£o chamadas de "pr√°tica francesa". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As regras (R7) 30E / 360, (W9) 30E / 360 e (W10) 30E / 360 ISDA tamb√©m s√£o chamadas de "pr√°tica alem√£" ou "pr√°tica alem√£". </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, levando em considera√ß√£o o interesse exato e ordin√°rio, bem como o n√∫mero exato e aproximado de dias para calcular o interesse, temos quatro m√©todos para calcular o interesse simples (os nomes das regras s√£o indicados na pr√°tica de l√≠ngua russa):</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Juros normais com o n√∫mero exato de dias (ACT / 360 - regra banc√°ria), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Porcentagens exatas com o n√∫mero exato de dias (ACT / 365, ACT / ACT), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Juros normais com um n√∫mero aproximado de dias (30/360), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Porcentagens exatas com um n√∫mero aproximado de dias. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O primeiro m√©todo mais comumente usado √© chamado de regra banc√°ria, menos frequentemente o segundo e o terceiro e quase nunca o quarto [1]. E [4] diz: "... uma op√ß√£o de c√°lculo com juros exatos e um n√∫mero aproximado de dias de empr√©stimo n√£o tem sentido e n√£o se aplica." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os c√°lculos acima da dura√ß√£o aproximada dos per√≠odos em fra√ß√µes de um ano mostram a n√£o trivialidade e variedade das regras aplicadas. Sua aplica√ß√£o (assim como a origem) depende do pa√≠s, moeda, tipo de instrumento financeiro, associa√ß√£o profissional, acordos. [1] </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CONCLUS√ÉO:</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como conto 3% no meu caso com servi√ßos p√∫blicos na Ucr√¢nia?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An√°lise da pr√°tica judicial de aplica√ß√£o do art. 625 do C√≥digo Civil da Ucr√¢nia afirma que o m√©todo (R1) ACT / 365 [3] √© geralmente usado, mas isso n√£o est√° claramente formulado. Eu acho que voc√™ ainda precisa se inscrever (R4) ACT / ACT, e eis o porqu√™: se voc√™ acumular 3% por um ano bissexto completo usando o m√©todo ACT / 365, o montante dos juros ser√° igual a 3.008219%, que √© para d√≠vida (ou o tamanho do organismo de empr√©stimo) 1 milh√£o de unidades monet√°rias dar√° um excesso de UM 82,19 acima de 3%, que s√£o estipulados pela taxa de juros padronizada anual nos termos da lei. Isso se tornar√° especialmente importante com a acumula√ß√£o progressiva de juros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu gostaria de receber coment√°rios, especialmente de funcion√°rios do banco. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fontes utilizadas</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1) Bocharov, P.P., Kasimov, Yu.F. Matem√°tica financeira. Moscou: Gardariki, 2002 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) Conven√ß√£o de contagem de dias,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Day_count_convention</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3) An√°lise da aplica√ß√£o do art. 625 do C√≥digo Civil da Ucr√¢nia em processos civis, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zib.com.ua/ua/74602-analiz_praktiki_zastosuvannya_st_625_civilnogo_kodeksu_ukrai.html</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4) Chetyrkin E.M. Matem√°tica financeira. Moscou: Caso, 2005 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5) Conven√ß√µes de contagem de dias e fatores de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">provis√£o</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">docs.fincad.com/support/developerfunc/mathref/Daycount.htm</font></a></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6) Carta de informa√ß√µes do Supremo Tribunal Econ√¥mico da Ucr√¢nia n¬∫ 01-06 / 928/2012, de 17.07.2012, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zakon.rada.gov.ua/laws/show/v_928600-12</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E agora um pequeno c√≥digo no Oracle Database: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui est√° um pacote que fiz para o meu caso em particular - calcula os custos de infla√ß√£o e 3% ao ano para a Ucr√¢nia.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o h√° fun√ß√£o agregada no banco de dados Oracle que multiplique os valores da infla√ß√£o. </font><font style="vertical-align: inherit;">Portanto, eu uso a soma dos logaritmos.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texto oculto</font></font></b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_OVERHEAD_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, OVERHEAD_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_AMOUNT_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, DEBT_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PAYMENT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_MONTH <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_RATE <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, SKIP_INFLATION <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>), INF_RATE_ACCUMULATED <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> , INF_COEF_ACCUMULATED <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, INF_AMOUNT_ACCUMULATED <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, INF_AMOUNT_MONTH <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, DEBT_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PAYMENT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_MONTH <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_RATE <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, SKIP_INFLATION <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_PCT_AMOUNT_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, DEBT_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PAYMENT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, PCT_YEAR <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_DAYS <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_PCT_PER_DAY <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_BEGIN_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span> , PCT_YEAR_END_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, PCT_YEAR_DAYS_CALC <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_PCT_PER_YEAR <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_AMOUNT_PER_YEAR <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_OVERHEAD_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_OVERHEAD_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_AMOUNT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_WITH_INF_AMOUNT_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_WITH_INF_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_PCT_AMOUNT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_WITH_PCT_AMOUNT_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> CALC_OVERHEADS_P <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> GET_DEBT_WITH_INF (p_debt_date_begin <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_debt_date_end <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_last_collection_date <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DEBT_WITH_INF_LIST_T; function GET_DEBT_WITH_INF_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_INF_AMOUNT_LIST_T; function GET_DEBT_WITH_INF_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T; function GET_DEBT_WITH_PCT_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_PCT_AMOUNT_LIST_T; function GET_DEBT_WITH_PCT_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span> CALC_OVERHEADS_P <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> GET_DEBT_WITH_INF (p_debt_date_begin <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_debt_date_end <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_last_collection_date <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DEBT_WITH_INF_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ret_value DEBT_WITH_INF_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a.ID, a.DEBT_DATE, a.DEBT_AMOUNT, a.PAYMENT_DATE, b.INF_MONTH, c.AVAL <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_RATE <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> DEBTS a <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">apply</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> add_months (trunc (a.PAYMENT_DATE, <span class="hljs-string"><span class="hljs-string">'month'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= months_between (trunc (p_last_collection_date, <span class="hljs-string"><span class="hljs-string">'month'</span></span>), trunc (a.PAYMENT_DATE, <span class="hljs-string"><span class="hljs-string">'month'</span></span>)) + <span class="hljs-number"><span class="hljs-number">1</span></span>) b <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> INFLATION c <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> c.ADATE = b.INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.TYP = <span class="hljs-string"><span class="hljs-string">'M'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a.DEBT_DATE <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> p_debt_date_begin <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> p_debt_date_end ) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE , <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> trunc (PAYMENT_DATE, <span class="hljs-string"><span class="hljs-string">'month'</span></span>) = INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PAYMENT_DATE) <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> trunc (p_last_collection_date, <span class="hljs-string"><span class="hljs-string">'month'</span></span>) = INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p_last_collection_date) <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> SKIP_INFLATION <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_WITH_INF_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_INF_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_INF_AMOUNT_LIST_T is ret_value DEBT_WITH_INF_AMOUNT_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION , <span class="hljs-keyword"><span class="hljs-keyword">exp</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ln</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> SKIP_INFLATION = <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> INF_RATE <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> INF_RATE / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unbounded</span></span> <span class="hljs-keyword"><span class="hljs-keyword">preceding</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>)) * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_RATE_ACCUMULATED <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (CALC_OVERHEADS_P.GET_DEBT_WITH_INF (p_debt_date_begin, p_debt_date_end, p_last_collection_date))) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION, INF_RATE_ACCUMULATED , (INF_RATE_ACCUMULATED - <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_COEF_ACCUMULATED , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> (((INF_RATE_ACCUMULATED - <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span>) * DEBT_AMOUNT, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_AMOUNT_ACCUMULATED <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_WITH_INF_AMOUNT_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION, INF_RATE_ACCUMULATED, INF_COEF_ACCUMULATED, INF_AMOUNT_ACCUMULATED , INF_AMOUNT_ACCUMULATED - lag (INF_AMOUNT_ACCUMULATED, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> INF_MONTH)) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_INF_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T is ret_value DEBT_OVERHEAD_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> , DEBT_DATE , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">exp</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ln</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> SKIP_INFLATION = <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> INF_RATE / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>))) - <span class="hljs-number"><span class="hljs-number">1</span></span>) * DEBT_AMOUNT, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_AMOUNT <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (CALC_OVERHEADS_P.GET_DEBT_WITH_INF (p_debt_date_begin, p_debt_date_end, p_last_collection_date)) <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_OVERHEAD_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, INF_AMOUNT) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_PCT_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_PCT_AMOUNT_LIST_T is ret_value DEBT_WITH_PCT_AMOUNT_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> DEBTS a <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">apply</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PAYMENT_DATE) + <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p_last_collection_date) - <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PAYMENT_DATE) + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> DEBT_DATE <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> p_debt_date_begin <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> p_debt_date_end ) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'31.12.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>) - <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'01.01.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_DAYS <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) , T3 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS , <span class="hljs-number"><span class="hljs-number">0.03</span></span> / PCT_YEAR_DAYS <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_PCT_PER_DAY <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2) , T4 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS, PCT_YEAR_PCT_PER_DAY , <span class="hljs-keyword"><span class="hljs-keyword">greatest</span></span> (PAYMENT_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'01.01.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD-MM-YYYY'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_BEGIN_DATE , <span class="hljs-keyword"><span class="hljs-keyword">least</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'31.12.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD-MM-YYYY'</span></span>), p_last_collection_date) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_END_DATE <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T3) , T5 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS, PCT_YEAR_PCT_PER_DAY, PCT_YEAR_BEGIN_DATE, PCT_YEAR_END_DATE , PCT_YEAR_END_DATE - PCT_YEAR_BEGIN_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_DAYS_CALC , (PCT_YEAR_END_DATE - PCT_YEAR_BEGIN_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span>) * PCT_YEAR_PCT_PER_DAY <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_PCT_PER_YEAR , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> ((PCT_YEAR_END_DATE - PCT_YEAR_BEGIN_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span>) * PCT_YEAR_PCT_PER_DAY * DEBT_AMOUNT, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_AMOUNT_PER_YEAR <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T4) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_WITH_PCT_AMOUNT_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS, PCT_YEAR_PCT_PER_DAY, PCT_YEAR_BEGIN_DATE, PCT_YEAR_END_DATE, PCT_YEAR_DAYS_CALC, PCT_YEAR_PCT_PER_YEAR, PCT_AMOUNT_PER_YEAR) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T5; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_PCT_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T is ret_value DEBT_OVERHEAD_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_OVERHEAD_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> (PCT_AMOUNT_PER_YEAR)) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (CALC_OVERHEADS_P.GET_DEBT_WITH_PCT_AMOUNT (p_debt_date_begin, p_debt_date_end, p_last_collection_date)) <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466401/">https://habr.com/ru/post/pt466401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466379/index.html">Execute o software "desktop" no microcontrolador</a></li>
<li><a href="../pt466381/index.html">Como as l√¢mpadas LED da Era mudaram em 2019</a></li>
<li><a href="../pt466383/index.html">Oceano de criptomoedas: an√°lise dos 50 principais projetos com o CoinMarketCap</a></li>
<li><a href="../pt466385/index.html">Entendendo os Corretores de Mensagens. Aprendendo a mec√¢nica das mensagens atrav√©s do ActiveMQ e Kafka. Cap√≠tulo 1</a></li>
<li><a href="../pt466397/index.html">N√≥s reprogramamos o caixa e imprimimos nele Keanu Reeves. Parte 2. Software para PC</a></li>
<li><a href="../pt466403/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 35. Protocolo de entroncamento din√¢mico de DTP</a></li>
<li><a href="../pt466405/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 36. Protocolo de Canal STP</a></li>
<li><a href="../pt466407/index.html">Cultura de recrutamento em grandes empresas de estat√≠sticas Glassdoor</a></li>
<li><a href="../pt466409/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 37. STP: sele√ß√£o de Bridge Root, recursos de prote√ß√£o PortFast e BPDU. Parte 1</a></li>
<li><a href="../pt466413/index.html">Troca de sites por Bitrix e 1C: resolvendo os principais problemas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>