<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏼 👨🏾‍🤝‍👨🏻 🕊️ Dukungan Antrian Hangfire ↖️ ☁️ 👵🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hangfire adalah pustaka untuk .net (inti), yang memungkinkan eksekusi beberapa kode secara asinkron dengan prinsip "fire and forget". Contoh kode sepe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dukungan Antrian Hangfire</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434364/"><p>  Hangfire adalah pustaka untuk .net (inti), yang memungkinkan eksekusi beberapa kode secara asinkron dengan prinsip "fire and forget".  Contoh kode seperti itu dapat mengirim E-Mail, pemrosesan video, sinkronisasi dengan sistem lain, dll.  Selain "jalankan dan lupakan" ada dukungan untuk tugas yang ditangguhkan, serta tugas yang dijadwalkan dalam format Cron. </p><br><p>  Saat ini, ada banyak perpustakaan seperti itu.  Beberapa manfaat Hangfire adalah: </p><br><ul><li>  Konfigurasi sederhana, API yang nyaman </li><li>  Keandalan  Hangfire menjamin bahwa tugas yang dibuat akan dieksekusi setidaknya sekali </li><li>  Kemampuan untuk melakukan tugas secara paralel dan kinerja luar biasa </li><li>  Ekstensibilitas (di sini kita akan menggunakannya di bawah) </li><li>  Dokumentasi yang cukup lengkap dan mudah dipahami </li><li>  Dasbor tempat Anda dapat melihat semua statistik tentang tugas </li></ul><br><p>  Saya tidak akan membahas terlalu banyak detail, karena ada banyak artikel bagus tentang Hangfire dan cara menggunakannya.  Pada artikel ini saya akan membahas cara menggunakan dukungan dari beberapa antrian (atau kumpulan tugas), cara memperbaiki fungsi coba lagi standar dan membuat setiap antrian memiliki konfigurasi individual. </p><a name="habracut"></a><br><h3 id="suschestvuyuschaya-podderzhka-psevdo-ocheredey">  Dukungan yang ada untuk antrian (semu) </h3><br><p>  Catatan penting: dalam judul, saya menggunakan istilah pseudo-queue karena Hangfire tidak menjamin bahwa tugas akan dilakukan dalam urutan tertentu.  Yaitu  prinsip "First In First Out" tidak berlaku dan kami tidak akan bergantung padanya.  Selain itu, penulis perpustakaan merekomendasikan membuat tugas idempoten, yaitu  stabil terhadap beberapa eksekusi yang tidak terduga.  Selanjutnya saya hanya akan menggunakan kata "antrian", karena  Hangfire menggunakan istilah "Antrian". </p><br><p>  Hangfire memiliki dukungan antrian sederhana.  Meskipun tidak menawarkan fleksibilitas Sistem Antrian Pesan seperti rabbitMQ atau Azure Service Bus, seringkali cukup untuk menyelesaikan berbagai tugas. </p><br><p>  Setiap tugas memiliki properti "Antrian", yaitu nama antrian di mana ia harus dieksekusi.  Secara default, tugas dikirim ke antrian dengan nama "default", kecuali ditentukan lain.  Dukungan untuk beberapa antrian diperlukan untuk mengelola secara terpisah pelaksanaan tugas dari berbagai jenis.  Misalnya, kami mungkin ingin tugas pemrosesan video masuk ke antrean "video_queue", dan mengirimkan E-Mail ke antrian "email_queue".  Dengan demikian, kami dapat melakukan dua jenis tugas ini secara independen.  Jika kami ingin memindahkan pemrosesan video ke server khusus, kami dapat dengan mudah melakukan ini dengan menjalankan server Hangfire terpisah sebagai aplikasi konsol yang akan memproses antrian "video_queue". </p><br><h3 id="pereydem-k-praktike">  Mari kita lanjutkan berlatih </h3><br><p>  Menyiapkan server Hangfire di inti asp.net adalah sebagai berikut: </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IApplicationBuilder app</span></span></span><span class="hljs-function">)</span></span> { app.UseHangfireServer(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BackgroundJobServerOptions { WorkerCount = <span class="hljs-number"><span class="hljs-number">2</span></span>, Queues = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-string"><span class="hljs-string">"email_queue"</span></span>, <span class="hljs-string"><span class="hljs-string">"video_queue"</span></span> } }); }</code> </pre> <br><h3 id="problema-1---zadachi-pri-povtore-popadayut-v-ochered-default">  Masalah 1 - Memutar ulang tugas termasuk dalam antrian standar </h3><br><p>  Seperti yang saya sebutkan di atas, ada antrian default di Hangfire yang disebut "default".  Jika tugas ditempatkan dalam antrian, misalnya, "video_queue", gagal dan perlu dicoba lagi, maka akan dikirim ke antrian "default" lagi dan bukan "video_queue" dan, akibatnya, tugas kami tidak akan dilakukan sama sekali contoh dari server Hangfire yang kami inginkan, jika sama sekali.  Perilaku ini dibuat oleh saya secara eksperimental dan mungkin merupakan bug di Hangfire sendiri. </p><br><h4 id="job-filters">  Filter pekerjaan </h4><br><p>  Hangfire memberi kami kemampuan untuk memperluas fungsionalitas dengan bantuan filter yang disebut ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Filter Pekerjaan</a> ), yang pada prinsipnya mirip dengan Filter Tindakan di ASP.NET MVC.  Faktanya adalah bahwa logika internal Hangfire diimplementasikan sebagai Mesin Negara.  Ini adalah mesin yang secara berurutan mentransfer tugas-tugas di kumpulan dari satu keadaan ke keadaan lain (misalnya, dibuat -&gt; enqueued -&gt; pemrosesan -&gt; berhasil), dan filter memungkinkan kita untuk "mencegat" tugas yang dieksekusi setiap kali keadaannya berubah dan untuk memanipulasinya.  Filter diimplementasikan sebagai atribut yang dapat diterapkan ke metode tunggal, kelas, atau global. </p><br><h4 id="job-parameters">  Parameter pekerjaan </h4><br><p>  Objek ElectStateContext dilewatkan sebagai argumen ke metode filter.  Objek ini berisi informasi lengkap tentang tugas saat ini.  Antara lain, ia memiliki metode GetJobParameter &lt;&gt; (...) dan SettJobParameter &lt;&gt; (...).  Parameter Pekerjaan memungkinkan Anda untuk menyimpan informasi yang terkait dengan tugas dalam database.  Dalam Parameter Pekerjaan, nama antrian tempat tugas semula dikirim disimpan, hanya karena alasan tertentu informasi ini diabaikan selama coba lagi berikutnya. </p><br><h3 id="reshenie">  Solusi </h3><br><p>  Jadi, kami memiliki tugas yang berakhir dengan kesalahan dan harus dikirim untuk dieksekusi kembali dalam antrian yang benar (dalam tugas yang sama dengan yang ditugaskan pada saat pembuatan awal).  Pengulangan tugas yang dilengkapi dengan kesalahan adalah transisi dari keadaan "gagal" ke keadaan "enqueued".  Untuk mengatasi masalah, buat filter yang, ketika tugas memasuki keadaan "enqueued", akan memeriksa di mana antrian tugas yang dikirim pada awalnya dan meletakkan parameter "QueueName" di nilai yang diinginkan: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HangfireUseCorrectQueueFilter</span></span> : <span class="hljs-title"><span class="hljs-title">JobFilterAttribute</span></span>, <span class="hljs-title"><span class="hljs-title">IElectStateFilter</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnStateElection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ElectStateContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context.CandidateState <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> EnqueuedState enqueuedState) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> queueName = context.GetJobParameter&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"QueueName"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(queueName)) { context.SetJobParameter(<span class="hljs-string"><span class="hljs-string">"QueueName"</span></span>, enqueuedState.Queue); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { enqueuedState.Queue = queueName; } } } }</code> </pre> <br><p>  Untuk menerapkan filter default ke semua tugas (mis. Secara global), tambahkan kode berikut ke konfigurasi kami: </p><br><pre> <code class="cs hljs">GlobalJobFilters.Filters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireUseCorrectQueueFilter { Order = <span class="hljs-number"><span class="hljs-number">1</span></span> });</code> </pre> <br><p>  Hasil tangkapan kecil lainnya adalah bahwa koleksi GlobalJobFilters secara default berisi turunan dari kelas AutomaticRetryAttribute.  Ini adalah filter standar yang bertanggung jawab untuk menjalankan kembali tugas yang gagal.  Dia juga mengirim tugas ke antrian "default", mengabaikan antrian asli.  Agar sepeda kami dapat mengendarai, Anda harus menghapus filter ini dari koleksi dan membiarkan filter kami bertanggung jawab atas tugas yang diulang.  Akibatnya, kode konfigurasi akan terlihat seperti ini: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defaultRetryFilter = GlobalJobFilters.Filters .FirstOrDefault(f =&gt; f.Instance <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> AutomaticRetryAttribute); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (defaultRetryFilter != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; defaultRetryFilter.Instance != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { GlobalJobFilters.Filters.Remove(defaultRetryFilter.Instance); } GlobalJobFilters.Filters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireUseCorrectQueueFilter { Order = <span class="hljs-number"><span class="hljs-number">1</span></span> });</code> </pre> <br><p>  Perlu dicatat bahwa AutomaticRetryAttribute mengimplementasikan logika secara otomatis meningkatkan interval antara upaya (interval meningkat dengan setiap upaya berikutnya), dan menghapus AutomaticRetryAttribute dari koleksi GlobalJobFilters, kami meninggalkan fungsi ini (lihat penerapan metode <a href="">ScheduleAgainLater</a> ) </p><br><p>  Jadi, kami telah mencapai bahwa tugas kami dapat dilakukan dalam antrian yang berbeda, dan ini memungkinkan kami untuk mengelola eksekusi secara mandiri, termasuk memproses antrian yang berbeda pada mesin yang berbeda.  Hanya sekarang kita tidak tahu berapa kali dan berapa interval tugas kita akan diulang jika terjadi kesalahan, karena kita menghapus AutomaticRetryAttribute dari koleksi filter. </p><br><h3 id="problema-2---individualnye-nastroyki-dlya-kazhdoy-ocheredi">  Masalah 2 - Pengaturan Individual untuk Setiap Antrian </h3><br><p>  Kami ingin dapat mengkonfigurasi interval dan jumlah pengulangan secara terpisah untuk setiap antrian, dan juga, jika untuk beberapa antrian kami tidak menentukan nilai secara eksplisit, kami ingin nilai default diterapkan.  Untuk melakukan ini, kami menerapkan filter lain dan menyebutnya <code>HangfireRetryJobFilter</code> . </p><br><p>  Idealnya, kode konfigurasi akan terlihat seperti ini: </p><br><pre> <code class="cs hljs">GlobalJobFilters.Filters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireRetryJobFilter { Order = <span class="hljs-number"><span class="hljs-number">2</span></span>, [<span class="hljs-string"><span class="hljs-string">"email_queue"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireQueueSettings { DelayInSeconds = <span class="hljs-number"><span class="hljs-number">120</span></span>, RetryAttempts = <span class="hljs-number"><span class="hljs-number">3</span></span> }, [<span class="hljs-string"><span class="hljs-string">"video_queue"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireQueueSettings { DelayInSeconds = <span class="hljs-number"><span class="hljs-number">60</span></span>, RetryAttempts = <span class="hljs-number"><span class="hljs-number">5</span></span> } });</code> </pre> <br><h3 id="reshenie-1">  Solusi </h3><br><p>  Untuk melakukan ini, pertama-tama tambahkan kelas <code>HangfireQueueSettings</code> , yang akan berfungsi sebagai wadah untuk pengaturan kami. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HangfireQueueSettings</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RetryAttempts { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> DelayInSeconds { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br><p>  Kemudian kami menambahkan implementasi dari filter itu sendiri, yang, ketika tugas diulang setelah kesalahan, akan menerapkan pengaturan tergantung pada konfigurasi antrian dan memantau jumlah percobaan ulang: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HangfireRetryJobFilter</span></span> : <span class="hljs-title"><span class="hljs-title">JobFilterAttribute</span></span>, <span class="hljs-title"><span class="hljs-title">IElectStateFilter</span></span>, <span class="hljs-title"><span class="hljs-title">IApplyStateFilter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HangfireQueueSettings _defaultQueueSettings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireQueueSettings { RetryAttempts = <span class="hljs-number"><span class="hljs-number">3</span></span>, DelayInSeconds = <span class="hljs-number"><span class="hljs-number">10</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, HangfireQueueSettings&gt; _settings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, HangfireQueueSettings&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HangfireQueueSettings <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> queueName] { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _settings.TryGetValue(queueName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> HangfireQueueSettings queueSettings) ? queueSettings : _defaultQueueSettings; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _settings[queueName] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnStateElection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ElectStateContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(context.CandidateState <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> FailedState failedState)) { <span class="hljs-comment"><span class="hljs-comment">// This filter accepts only failed job state. return; } var retryAttempt = context.GetJobParameter&lt;int&gt;("RetryCount") + 1; var queueName = context.GetJobParameter&lt;string&gt;("QueueName"); if (retryAttempt &lt;= this[queueName].RetryAttempts) { ScheduleAgainLater(context, retryAttempt, failedState, queueName); } else { TransitionToDeleted(context, failedState, queueName); } } public void OnStateApplied( ApplyStateContext context, IWriteOnlyTransaction transaction) { if (context.NewState is ScheduledState &amp;&amp; context.NewState.Reason != null &amp;&amp; context.NewState.Reason.StartsWith("Retry attempt")) { transaction.AddToSet("retries", context.BackgroundJob.Id); } } public void OnStateUnapplied( ApplyStateContext context, IWriteOnlyTransaction transaction) { if (context.OldStateName == ScheduledState.StateName) { transaction.RemoveFromSet("retries", context.BackgroundJob.Id); } } private void ScheduleAgainLater( ElectStateContext context, int retryAttempt, FailedState failedState, string queueName) { context.SetJobParameter("RetryCount", retryAttempt); var delay = TimeSpan.FromSeconds(this[queueName].DelayInSeconds); const int maxMessageLength = 50; var exceptionMessage = failedState.Exception.Message.Length &gt; maxMessageLength ? failedState.Exception.Message.Substring(0, maxMessageLength - 1) + "…" : failedState.Exception.Message; // If attempt number is less than max attempts, we should // schedule the job to run again later. var reason = $"Retry attempt {retryAttempt} of {this[queueName].RetryAttempts}: {exceptionMessage}"; context.CandidateState = delay == TimeSpan.Zero ? (IState)new EnqueuedState { Reason = reason } : new ScheduledState(delay) { Reason = reason }; } private void TransitionToDeleted( ElectStateContext context, FailedState failedState, string queueName) { context.CandidateState = new DeletedState { Reason = this[queueName].RetryAttempts &gt; 0 ? "Exceeded the maximum number of retry attempts." : "Retries were disabled for this job." }; } }</span></span></code> </pre> <br><blockquote>  Catatan untuk kode: ketika menerapkan kelas <code>HangfireRetryJobFilter</code> , kelas <code>AutomaticRetryAttribute</code> dari <code>HangfireRetryJobFilter</code> diambil sebagai dasar, oleh karena itu implementasi beberapa metode sebagian bertepatan dengan metode yang sesuai dari kelas ini. </blockquote><br><h3 id="problema-3---kak-otpravit-zadachu-na-vypolnenie-v-konkretnuyu-ochered">  Masalah 3 - Bagaimana cara mengirim tugas ke antrian tertentu? </h3><br><p>  Saya berhasil menemukan dua cara untuk menetapkan tugas ke antrian: didokumentasikan dan - tidak. </p><br><p>  <strong>Metode 1</strong> - gantung atribut yang sesuai pada metode </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Queue(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"video_queue"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } BackgroundJob.Enqueue(() =&gt; SomeMethod());</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://docs.hangfire.io/en/latest/background-processing/configuring-queues.html</a> </p><br><p>  <strong>Metode 2</strong> (tidak berdokumen) - gunakan kelas <code>BackgroundJobClient</code> </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BackgroundJobClient(); client.Create(() =&gt; MyMethod(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnqueuedState(<span class="hljs-string"><span class="hljs-string">"video_queue"</span></span>));</code> </pre> <br><p>  Keuntungan dari metode kedua adalah tidak membuat dependensi yang tidak perlu pada Hangfire dan memungkinkan Anda untuk memutuskan selama proses mana tugas harus pergi.  Sayangnya, dalam dokumentasi resmi, saya tidak menemukan penyebutan tentang kelas <code>BackgroundJobClient</code> dan bagaimana menerapkannya.  Saya menggunakan metode kedua dalam solusi saya, jadi itu diuji dalam praktek. </p><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>  Di artikel ini, kami menggunakan dukungan beberapa antrian di Hangfire untuk memisahkan pemrosesan berbagai jenis tugas.  Kami menerapkan mekanisme kami untuk mengulangi tugas yang tidak selesai dengan kemungkinan konfigurasi individual untuk setiap antrian, memperluas fungsionalitas Hangfire menggunakan Filter Pekerjaan, dan juga belajar bagaimana mengirim tugas ke antrian yang diinginkan untuk dieksekusi. </p><br><p>  Semoga artikel ini bermanfaat bagi seseorang.  Saya akan senang berkomentar. </p><br><h3 id="poleznye-ssylki">  Tautan yang bermanfaat </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi Hangfire</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode Sumber Hangfire</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Scott Hanselman - Cara menjalankan Tugas Latar Belakang di ASP.NET</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434364/">https://habr.com/ru/post/id434364/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434348/index.html">Apakah Anda ingat kata sandi di Habré?</a></li>
<li><a href="../id434356/index.html">Python Stiller dengan Email</a></li>
<li><a href="../id434358/index.html">Substitusi impor sistem operasi. Bagaimana cara melihat OS domestik</a></li>
<li><a href="../id434360/index.html">Penjelasan pembicaraan tentang pemrograman asinkron dalam Javascript</a></li>
<li><a href="../id434362/index.html">BUKAN perkiraan untuk 2019</a></li>
<li><a href="../id434368/index.html">Pembelajaran Mesin untuk Menemukan Kesalahan dalam Kode: Bagaimana Saya Magang di JetBrains Research</a></li>
<li><a href="../id434370/index.html">Penakluk bayangan lain di Phaser, atau penggunaan sepeda</a></li>
<li><a href="../id434374/index.html">Memeriksa RBAC di Kubernetes</a></li>
<li><a href="../id434380/index.html">Dasar-dasar Injeksi Ketergantungan</a></li>
<li><a href="../id434382/index.html">Porting Alpine Linux ke RISC-V</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>