<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏽 👨🏾‍⚖️ 🦋 测试如何帮助您创建自己的UI-kit 👨‍👨‍👦‍👦 👃 👨🏾‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="对于那些不喜欢冗长介绍的人，让我们直接得出结论-为您的组件编写测试。 说真的，这就是我要说的。 但是，我们不要太在意这个，想象一下这些是定理（一个前端定理）的结论。 而现在，我们将需要拿出证据。 

 所以，让我们想象。 在IT开发中，不仅在前端，后端或设计，编程语言，管理，方法论等方面有什么共同点...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>测试如何帮助您创建自己的UI-kit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481528/"> 对于那些不喜欢冗长介绍的人，让我们直接得出结论-为您的组件编写测试。 说真的，这就是我要说的。 但是，我们不要太在意这个，想象一下这些是定理（一个前端定理）的结论。 而现在，我们将需要拿出证据。 <br><a name="habracut"></a><br> 所以，让我们想象。 在IT开发中，不仅在前端，后端或设计，编程语言，管理，方法论等方面有什么共同点？ 我猜有一个主要原理-分解和成分。 <br><br> 无论我们是否想要，无论我们是否了解自己编写的内容，我们都使用组件，我们总是将任务分解成较小的任务。 <br><br> 我想到了百万分之一的时间，为我们内在的漂亮UI包编写表的下一个实现，我想-我需要做哪些初步工作？ 到底应该写什么？ 从哪里开始？ <br><br><img src="https://habrastorage.org/getpro/habr/post_images/600/120/eb4/600120eb4a5523a073af57d1d56e36b4.png" alt="图片"><br><br> 与队友交谈后，我听到了一些提示。 我只是真的很喜欢一个。 由于我是奇异性的爱好者，并且喜欢使用graphql，所以有人要求我不要写任何东西。 使用{table}标签，一些神经网络将处理该表，创建graphql查询，并使用数据填充该表。 简单的一个:)。 <br> 但是正如他们所说-“任何系统中都存在致命缺陷”，我开始考虑“如何发明自己的车轮”。 聪明的人已经想出了摆在我们面前的一切。 千禧世代，我们只能重新排列盘子并以不同的方式命名。 <br><br> 我准备介绍自己的一套原型UI套件原理-IDOLS！ 让我们来看看！ <br><br> 我代表接口隔离，D代表依赖倒置，O代表……只是在开玩笑，当然，它是SOLID <br><br> 将组件工作正式化的所有尝试都减少了。 这些原则可以无限期扩展，但最终的结果总是减少到这五个。 当然，如果我们谈论的是OOP或CBP（基于组件的编程）。 <br><br> 让我们将这些原理加载到我们的“ RAM”中，并仔细研究这些要点。 <br><br><h3>  S-单一责任 </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/512/df3/3b6/512df33b63f26500f8925f172b4a9915.gif" alt="图片"><br> 嗯，请不要... <br><br> 针对不同情况使用特殊的组件。 您不应该制造一个可以同时切掉某些东西和拧下东西的组件。 做两个不同的部分。 <br><br><h3>  O-打开/关闭 </h3><br> 该原则说，您的组件应该开放以便改进，而封闭则可以进行修改，换句话说，您可以在另一个组件中重用您的组件，但是如果组件已经遵循单一职责原则，则不应更改它。 <br><br><h3>  L-里斯科夫替代 </h3><br> 作为先前原理的一个小扩展，可以使用子类的任何实例来代替基类的实例。 我不确定该原则如何适合组件的上下文，很可能只是先前原则的重复。 <br><br><h3>  I-接口隔离 </h3><br> 我们将进一步讨论这一点，现在我们可以说，给其他开发人员很多小接口比提供一个大接口更好，但是可以解决所有问题。 让我们比较下面的示例。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b5b/7bb/981/b5b7bb981c678f483ebed5cf91971716.png" alt="图片"><br> 一切都在一个地方配置，无法维护，不可重用... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/576/dc0/c47/576dc0c47a3c8edc5f21ecb64153f42b.png" alt="图片"><br> 一切都作为构造函数，可以随意组装 <br><br><h3>  D-依赖倒置 </h3><br> 应用程序的各个部分不应该相互了解的原理，应该仅通过公共接口继承。 在这里，我们更多地讨论重用和减少组件的连接性。  Table的组件不需要知道数据的来源和来源，只需要知道条件数据加载器即可。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3cf/7c7/a9a/3cf7c7a9a29d4616f239367d4c13027f.png" alt="图片"><br><br> 但是，一种观点对我们来说还不够。 由于在这种情况下，很容易成为该想法的人质。 因此，另一方面，我们从设计方面来看组件的开发。 <br><br> 在这种情况下，我们将考虑一种越来越流行的设计方法，即原子设计。 相对而言，原子设计是将UI元素与来自物理和生物学的层次结构进行比较的另一种分解UI元素的方法。 <br><br> 因此，让我们看看什么是原子设计。 <br><br><h3> 代币 </h3><br> 第一级是令牌，有人在模型中包含了令牌，有人没有，但是值得一提。 令牌（颜色，字体大小，间距，动画）是我们可以在任何平台上重用的所有原语。 <br><br> 值得注意的是，原子设计的层次结构越高，可重用性的降低就越大。 但是稍后会更多。 <br><br><h3> 原子 </h3><br> 接下来是原子（没有逻辑，输入，按钮的简单组件）。 第一层是组件的显示位置及其输出。 原子没有任何状态，仅显示静态样式的标记。 <br><br><h3> 分子 </h3><br> 原子然后组装成分子（更复杂的组分键）。 分子可以具有自己的状态，但这不是业务状态，可以是配置状态（例如isOpen）。 我们可以猜测，分子更像是顶级业务状态与我们如何根据此状态排列原子或子级内容之间的代理。 <br><br> 分子是我们可以满足样式要求的最后一个层次。 <br><br><h3> 生物体 </h3><br> 分子组成生物（组成部分的整体工作组），例如，页眉，页脚等。 有机体对其他生物和样式一无所知，这就是我们的“ DNA容器”，也是我们的业务逻辑，它们知道如何显示这一点以及何时应该对其进行更改。 <br><br><h3> 模板/页面 </h3><br> 原子设计的最后一个层次。 此级别代表生物体组，当前页面包括在内。 <br><br> 我们可以通过分子在页面上构成生物体，然后将该页面称为“布局”，并重复使用它来改变其中的生物体。 <br><br> 使用这两种方法（SOLID和Atomic），我们将在开发组件时尝试提出一些建议。 因此，我们需要这些建议才能理解，当我们说“创建另一个组件”时，我们到底在做什么。 <br><br> 考虑到这些组件将可以与其他开发人员一起使用，因此在放置接口和API时，请牢记这一点。 <br><br> 我们可以开始开发理想的界面。 <br><br> 首先要做的不是开始开发理想的界面。 理想的界面是它的不足。 接口是您所做的事情与开始工作之间的障碍。 这是一种痛苦，必须避免。 <br><br> 因此，最好的解决方案是： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b78/283/6cc/b782836ccaf89f564af263a1dc2eb274.png" alt="图片"><br> 这顺利地带给我们以下内容： <br><br><h3>  1.确定组件的状态 </h3><br> 如果使用此组件的开发人员第一次看到它，请对其进行一些入门，随着设置复杂性的增加，将该组件转换为新状态，并告知开发人员。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a0/57c/fab/9a057cfab3b778d2db16ff7781442a0f.png" alt="图片"><br><br> 状态在不同时间可以完全不同。 <br> 空→下载→正在加载→正在加载另一部分→已完全加载→错误等。 <br> 指导开发人员完成所有可能的状态组合，并在工作时教他们。 <br><br> 在处理状态问题时，人们不由自主地发现了默认状态问题。 因此，第二个建议。 <br><br><h3>  2.定义默认值 </h3><br> 使用此项目，您可以用一块石头杀死两只鸟，您不仅可以向开发人员提供应用程序正在发生的基本信息，而且对您来说，缺少一个或另一个变量也不会破坏所有功能。 另外，原则上也不需要进行难看的检查。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/af5/319/7d2/af53197d2ee168059b47030a793bf8a8.png" alt="图片"><br><br> 此外，如果开发人员仍想添加设置，则有必要对此提供帮助，并且不要干预。 <br><br> 根据理查德·格雷戈里（Richard Gregory）的理论，人们根据以前的视觉体验来探索周围的世界。 而且，如果您的组件在后台进行了某些更改，并且您想让开发人员知道它，那么可以预测地调用钩子和回调。 <br><br><h3>  3.无需重新发明轮子 </h3><br> 不是changePasswordInputValue，而是onChange，因为如果它是您的“分子”，则将始终清楚该值将发生什么变化。 <br><br> 好吧，尝试遵循一般的命名规则，事件的on前缀，动作的动词，并且如果在一个地方使用布尔标志isDisabled，然后在各处使用它，则不再需要isEnabled，保持一致。 <br><br> 接下来要注意的是，当您完成对组件的操作后，将其传递给其他开发人员，将进一步处理它。 如果您的组件出了问题，您将不得不开始一个新的开发周期：开发人员发现错误或无法做他们想要的事情→打开问题→您正在寻找时间来修复它→考虑一致性→修复→更新软件包→向开发人员宣布→更新软件包→尝试一周前要做的事情。 <br><br><h3>  4.尝试给予开发人员尽可能多的控制权 </h3><br> 就像他们现在正在编写此组件一样-SOLID原理之一的直接结论 <br> 假设您允许将一段文本传递到您的组件。 如果存在此文本，则将显示该文本，但您也要记住有关默认状态的规则，并写出以下条件：如果不传输文本，则显示默认文本。 因此，以一种良好的语气，它将使开发人员明确指出此处不需要该文本。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c4c/a1a/730/c4ca1a7300df915ee720aeaf1d211d31.png" alt="图片"><br><br> 好吧，如果您认为我们首先开始使用原子组件，那么下面的建议来自于此。 <br><br><h3>  5.保持组件清洁干燥，以免抽象泄漏（KISS）。 </h3><br> 如何遵循呢？  -很简单，不要在组件中编写代码。 仅模板及其如何绘制输入数据。 如果您需要制作地图，进行过滤，对数据进行缩减，那么您将无法在外部重新定义常量，您的模板将使用文字，这是错误的-它不再是原子，而在其他方面则更难以维护。 必须避免这种情况。 <br><br> 因此，我们获得了一些建议的简短清单，可以遵循这些建议。 <br><br><ol><li> 定义状态 </li><li> 定义默认值 </li><li> 不要重新发明轮子 </li><li> 让他们（开发者）统治 </li><li> 保持简单，愚蠢（KISS） </li></ol><br> 但是我们的大脑如此安排，以至于在写完三个部分之后，我们开始认为我们不需要查看此列表即可检查所有要点。 而且我们知道，在较复杂和较容易的任务中，我们总是选择较容易的一项，因为它可以那样工作。 我们热爱节约能源，我们需要储备能源。 因此，此类列表始终会在融合之前丢失，直到出现更好的情况为止，而我们会继续将错误列表修正到主列表中。 <br><br> 只有了解到，对我们来说明智的选择通常要比连续两周不睡觉，修复生产中的错误要容易得多，我们才会使任务更加困难（出于客观原因）并且更加容易（对于我们而言）原因）。 <br><br> 那么如何欺骗我们的大脑并提出建议呢？ <br><br> 好吧，让我们尝试使其自动化。 <br><br><h3> 自动化 </h3><br> 我们可以使用eslint + lefthook捆绑包或任何其他git-hooks工具。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca4/d27/576/ca4d27576be845430a6c9f8f63266e17.png" alt="图片"><br><br> 我们描述了如何查看变量以及如何设置代码样式的规则。 我们禁止模板中使用幻数和文字，我们期望我们将立即为代码编写停靠栏。 我们将这些检查挂起以获取git钩子，并自动收到有关我们的代码错误并应更新的通知。 <br><br> 但这不是灵丹妙药，我们无法实现所有建议。 只有一部分。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/011/93c/bd8/01193cbd83fd6e04332f434db6a41ddb.png" alt="图片"><br><br> 这样，我们无法处理可能的状态，也无法保证其他开发人员会得到他们想要的东西。 例如，我们可以假设某个东西仍然会返回（也就是默认值），但不会再返回。 <br><br> 然后，您可以尝试另一种方法。 通过SDD开发我们的组件。 故事书驱动的开发。 <br><br><h3> 故事书驱动的开发 </h3><br> 我们有一个故事文件，该文件的形式描述了组件的所有可能状态。 还有一本收集这些故事的故事书。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d4/cd7/ae4/3d4cd7ae4d32a947e46e20302ceed45e.png" alt="图片"><br> 我们关于组件的故事 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74b/33a/4e8/74b33a4e84ead0e44854f1d217222e11.png" alt="图片"><br> 故事书如何向我们展示故事 <br><br> 与工作环境隔离地开发组件不仅可以提高组件的纯度，而且还可以使您立即查看测试未涵盖哪些状态，以及原则上不存在哪些状态。 <br><br> 但是最后，这也不会给我们我们想要的一切。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d1f/cd1/000/d1fcd1000db741827c30f198dd5caf1d.png" alt="图片"><br><br> 因此，只剩下一件事。 <br><br><h3> 测试和快照 </h3><br> 由于我们的组件是原子和分子，因此编写单元测试变得很高兴，每个组件都负责一项功能，我们可以通过一次丢弃推荐列表中的几项来轻松地测试这些功能。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb3/1e7/454/eb31e7454245f6427aa2667263a1b8b5.png" alt="图片"><br><br> 我们可以设置快照检查，这将使我们能够监视组件的状态并了解将来的所有更改。 <br><br> 在开发过程中，我们可以将束与酶结合使用以控制我们的期望。 奇怪的是，在建议中，我们期望编写代码的开发人员有所帮助，只有测试及其编写才最适合。 他们实际上是为此发明的。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/012/7de/3e7/0127de3e73e263b686cb9fbe8f7d0dea.png" alt="图片"><br><br> 然后我们开始... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f8/e0d/adf/0f8e0dadfc1c7d70455e70a06f691ce1.png" alt="图片"><br><br> 为您的组件编写测试。 谢谢 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN481528/">https://habr.com/ru/post/zh-CN481528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN481514/index.html">使用真实示例使用Newtonsoft.Json库。 第一部分</a></li>
<li><a href="../zh-CN481516/index.html">解决航天器的复杂性</a></li>
<li><a href="../zh-CN481518/index.html">项目管理专业人员（PMP）：第六版什么？ 怎么了 为什么？</a></li>
<li><a href="../zh-CN481522/index.html">在较低的小节上，或反对理智的推定</a></li>
<li><a href="../zh-CN481524/index.html">电子投票期间的并发审核</a></li>
<li><a href="../zh-CN481530/index.html">Nevanger：提速</a></li>
<li><a href="../zh-CN481532/index.html">内存取证，橡皮鸭和GPO密码。 用r0ot-mi解决问题。 第二部分</a></li>
<li><a href="../zh-CN481534/index.html">是Delphi快死了-错误</a></li>
<li><a href="../zh-CN481536/index.html">域名系统的历史：“战争”协议</a></li>
<li><a href="../zh-CN481538/index.html">20 SEO神话将在2020年消失</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>