<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈯️ 👩🏿‍🤝‍👩🏼 🎸 Endroits glissants en C ++ 17 🎗️ 👵🏼 👩🏾‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ces dernières années, le C ++ a fait des pas de géant et suivre toutes les subtilités et les subtilités du langage peut être très, très difficile. Une...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Endroits glissants en C ++ 17</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/465181/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/fp/nd/-g/fpnd-ggxjx4-xafw3sb7rx2keca.png" alt="image"></a> <br><br>  Ces dernières années, le C ++ a fait des pas de géant et suivre toutes les subtilités et les subtilités du langage peut être très, très difficile.  Une nouvelle norme n'est pas loin, cependant, l'introduction de nouvelles tendances n'est pas le processus le plus rapide et le plus simple, donc, même s'il reste un peu de temps avant C ++ 20, je suggère de rafraîchir ou de découvrir des endroits particulièrement «glissants» de la norme actuelle la langue. <br><br>  Aujourd'hui, je vais vous dire pourquoi si constexpr ne remplace pas les macros, quels sont les «internes» de la liaison structurée et ses «pièges», et est-il vrai que la copie élision fonctionne désormais toujours et que vous pouvez écrire n'importe quel retour sans hésitation. <br><br>  Si vous n’avez pas peur de vous salir un peu les mains, de plonger dans l’intérieur de votre langue, bienvenue chez Cat. <br><a name="habracut"></a><br><hr><br><h1>  si constexpr </h1><br>  Commençons par la plus simple - <code>if constexpr</code> vous permet de <code>if constexpr</code> la branche d'expression conditionnelle pour laquelle la condition souhaitée n'est pas remplie même au stade de la compilation. <br><br>  Il semble que cela remplace la macro <code>#if</code> pour désactiver la logique "extra"?  Non.  Pas du tout. <br><br>  Tout d'abord, un tel <code>if</code> a des propriétés qui ne sont pas disponibles pour les macros - à l'intérieur, vous pouvez compter toute expression <code>constexpr</code> qui peut être <code>constexpr</code> en <code>bool</code> .  Eh bien, et deuxièmement, le contenu de la branche supprimée doit être syntaxiquement et sémantiquement correct. <br><br>  En raison de la deuxième exigence, <code>if constexpr</code> ne peut pas être utilisé, par exemple, des fonctions inexistantes (le code dépendant de la plate-forme ne peut pas être explicitement séparé de cette manière) ou mauvaises du point de vue du langage de construction (par exemple, " <code>void T = 0;</code> "). <br><br>  Quel est l'intérêt d'utiliser <code>if constexpr</code> ?  Le point principal est dans les modèles.  Il existe une règle spéciale pour eux: la branche supprimée n'est pas instanciée lorsque le modèle est instancié.  Cela facilite l'écriture de code qui dépend en quelque sorte des propriétés des types de modèles. <br><br>  Cependant, dans les modèles, il ne faut pas oublier que le code à l'intérieur des branches doit être correct au moins pour une variante (même purement potentielle) d'instanciation, il est donc tout simplement <code>static_assert(false)</code> d'écrire, par exemple, <code>static_assert(false)</code> à l'intérieur d'une des branches (il est nécessaire que ce <code>static_assert</code> dépendait d'un paramètre dépendant du modèle). <br><br>  Exemples: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-comment"><span class="hljs-comment">//    ,       if constexpr ( os == OS::win ) {        win_api_call(); //         }    else {        some_other_os_call(); //  win      } }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-comment"><span class="hljs-comment">//    ,    T      if constexpr ( os == OS::win ) {        T::win_api_call(); //  T   ,    win    }    else {        T::some_other_os_call(); //  T   ,         } }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition1)</span></span></span><span class="hljs-function"> </span></span>{        <span class="hljs-comment"><span class="hljs-comment">// ...    }    else if constexpr (condition2) {        // ...    }    else {        // static_assert(false); //          static_assert(trait&lt;T&gt;::value); // ,   ,  trait&lt;T&gt;::value   false    } }</span></span></code> </pre><br><h2>  Choses à retenir </h2><br><ol><li>  Le code dans toutes les succursales doit être correct. <br></li><li>  À l'intérieur des modèles, le contenu des branches supprimées n'est pas instancié. <br></li><li>  Le code à l'intérieur de n'importe quelle branche doit être correct pour au moins une variante purement potentielle d'instanciation du modèle. <br></li></ol><br><h1>  Reliure structurée </h1><br><img src="https://habrastorage.org/webt/0v/jl/x4/0vjlx42it96fu5j20yz-m-pvhpq.png"><br><br>  En C ++ 17, un mécanisme assez pratique pour décomposer divers objets de type tuple est apparu, vous permettant de lier de manière pratique et concise leurs éléments internes à des variables nommées: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     —    : for (const auto&amp; [key, value] : map) {    std::cout &lt;&lt; key &lt;&lt; ": " &lt;&lt; value &lt;&lt; std::endl; }</span></span></code> </pre><br>  Par un objet de type tuple, je veux dire un tel objet pour lequel le nombre d'éléments internes disponibles au moment de la compilation est connu (de "tuple" - une liste ordonnée avec un nombre fixe d'éléments (vecteur)). <br><br>  Cette définition inclut des types tels que: <code>std::pair</code> , <code>std::tuple</code> , <code>std::array</code> , des tableaux de la forme « <code>T a[N]</code> », ainsi que diverses structures et classes auto-écrites. <br><br>  Arrêtez ... Pouvez-vous utiliser vos propres structures dans la liaison structurelle?  Spoiler: vous le pouvez (bien que parfois vous deviez travailler dur (mais plus à ce sujet ci-dessous)). <br><br><h2>  Comment ça marche </h2><br>  Le travail de liaison structurelle mérite un article séparé, mais comme nous parlons spécifiquement d'endroits «glissants», je vais essayer d'expliquer brièvement comment tout fonctionne. <br><br>  La norme fournit la syntaxe suivante pour définir la liaison: <br><br>  <i>attr</i> (facultatif) <i>cv-auto</i> <i>ref-operator</i> (facultatif) <i>expression</i> [ <i>liste d'identificateurs</i> ]; <br><br><ul><li>  <code>attr</code> - liste d'attributs facultative; <br></li><li>  <code>cv-auto</code> - auto avec des modificateurs const / volatile possibles; <br></li><li>  <code>ref-operator</code> - spécificateur de référence facultatif (&amp; ou &amp;&amp;); <br></li><li>  <code>identifier-list</code> - une liste de noms de nouvelles variables; <br></li><li>  <code>expression</code> est une expression qui aboutit à un objet de type tuple utilisé pour la liaison (l'expression peut être sous la forme " <code>= expr</code> ", " <code>{expr}</code> " ou " <code>(expr)</code> "). <br></li></ul><br>  Il est important de noter que le nombre de noms dans la <code>identifier-list</code> doit correspondre au nombre d'éléments dans l'objet résultant de l' <code>expression</code> . <br><br>  Tout cela vous permet d'écrire des constructions du formulaire: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp; [a,b,c] = Foo{};</code> </pre><br>  Et nous arrivons ici au premier endroit «glissant»: rencontrer une expression de la forme « <code>auto a = expr;</code>  ", Vous voulez généralement dire que le type" <code>a</code> "sera calculé par l'expression" <code>expr</code> ", et vous vous attendez à ce que dans l'expression" <code>const auto&amp; [a,b,c] = expr;</code>  "La même chose sera faite, seuls les types pour" <code>a,b,c</code> "seront les types <code>const&amp;</code> element correspondants de" <code>expr</code> "... <br><br>  La vérité est différente: le spécificateur d' <code>cv-auto ref-operator</code> est utilisé pour calculer le type d'une variable invisible, dans laquelle le résultat du calcul de expr est affecté (c'est-à-dire que le compilateur remplace « <code>const auto&amp; [a,b,c] = expr</code> » par « <code>const auto&amp; e = expr</code> "). <br><br>  Ainsi, une nouvelle entité invisible apparaît (ci-après je l'appellerai {e}), cependant, l'entité est très utile: par exemple, elle peut matérialiser des objets temporaires (par conséquent, vous pouvez les connecter en toute sécurité " <code>const auto&amp; [a,b,c] = Foo {};</code> "). <br><br>  Le deuxième endroit glissant découle immédiatement du remplacement effectué par le compilateur: si le type déduit pour {e} n'est pas une référence, le résultat de <code>expr</code> sera copié dans {e}. <br><br>  Quels types les variables auront-elles dans la <code>identifier-list</code> ?  Pour commencer, ce ne seront pas exactement des variables.  Oui, ils se comportent comme des variables réelles et ordinaires, mais seulement avec la différence qu’ils se réfèrent à l’intérieur à une entité qui leur est associée, et le <code>decltype</code> partir d’une telle variable de «référence» produira le type d’entité auquel cette variable se réfère: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; t(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [a, b] = t; <span class="hljs-comment"><span class="hljs-comment">// decltype(a) — int, decltype(b) — float ++a; // ,  « »,   t std::cout &lt;&lt; std::get&lt;0&gt;(t); //  2</span></span></code> </pre><br>  Les types eux-mêmes sont définis comme suit: <br><br><ol><li>  Si <b>{e}</b> est un tableau ( <code>T a[N]</code> ), alors le type sera un - T, les modificateurs cv coïncideront avec ceux du tableau. <br></li><li>  Si <b>{e}</b> est de type E et supporte l'interface tuple, les structures sont définies: <br><br><pre> <code class="plaintext hljs">std::tuple_size&lt;E&gt;</code> </pre> <br><pre> <code class="plaintext hljs">std::tuple_element&lt;i, E&gt;</code> </pre> <br>  et fonction: <br><br><pre> <code class="plaintext hljs">get&lt;i&gt;({e}); //  {e}.get&lt;i&gt;()</code> </pre> <br>  alors le type de chaque variable sera le type <code>std::tuple_element_t&lt;i, E&gt;</code> <br></li><li>  Dans d'autres cas, le type de la variable correspondra au type d'élément de structure auquel la liaison est effectuée. <br></li></ol><br>  Donc, si très brièvement, les étapes suivantes sont prises avec la liaison structurelle: <br><br><ol><li>  Calcul du type et initialisation de l'entité invisible {e} sur la base des modificateurs type <code>expr</code> et <code>cv-ref</code> . <br></li><li>  Créez des pseudo-variables et liez-les aux éléments {e}. <br></li></ol><br><h2>  Lier structurellement vos classes / structures </h2><br>  Le principal obstacle à la liaison de leurs structures est le manque de réflexion en C ++.  Même le compilateur, qui, semble-t-il, doit savoir avec certitude comment telle ou telle structure est organisée à l'intérieur, a du mal: les modificateurs d'accès (public / privé / protégé) et l'héritage compliquent grandement les choses. <br><br>  En raison de ces difficultés, les restrictions sur l'utilisation de leurs classes sont très strictes (au moins pour l'instant: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P1061</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P1096</a> ): <br><br><ol><li>  Tous les champs internes non statiques d'une classe doivent provenir de la même classe de base et doivent être disponibles au moment de l'utilisation. <br></li><li>  Ou la classe doit implémenter la «réflexion» (prendre en charge l'interface tuple). <br></li></ol><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  «»  struct A { int a; }; struct B : A {}; struct C : A { int c; }; class D { int d; }; auto [a] = A{}; //  (a -&gt; A::a) auto [a] = B{}; //  (a -&gt; B::A::a) auto [a, c] = C{}; // : a  c    auto [d] = D{}; // : d — private void D::foo() {    auto [d] = *this; //  (d   ) }</span></span></code> </pre><br>  L'implémentation de l'interface tuple vous permet d'utiliser n'importe laquelle de vos classes pour la liaison, mais elle semble un peu lourde et comporte un autre écueil.  Prenons immédiatement un exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,      int   class Foo; template&lt;&gt; struct std::tuple_size&lt;Foo&gt; : std::integral_constant&lt;std::size_t, 1&gt; {}; template&lt;&gt; struct std::tuple_element&lt;0, Foo&gt; { using type = int&amp;; }; class Foo { public: template&lt;std::size_t i&gt; std::tuple_element_t&lt;i, Foo&gt; const&amp; get() const; template&lt;std::size_t i&gt; std::tuple_element_t&lt;i, Foo&gt; &amp; get(); private: int _foo = 0; int&amp; _bar = _foo; }; template&lt;&gt; std::tuple_element_t&lt;0, Foo&gt; const&amp; Foo::get&lt;0&gt;() const { return _bar; } template&lt;&gt; std::tuple_element_t&lt;0, Foo&gt; &amp; Foo::get&lt;0&gt;() { return _bar; }</span></span></code> </pre><br>  Maintenant, nous lions: <br><br><pre> <code class="cpp hljs">Foo foo; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [f1] = foo; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [f2] = foo; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [f3] = foo; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [f4] = foo;</code> </pre><br>  Et il est temps de réfléchir aux types que nous avons?  (Celui qui pourrait répondre tout de suite mérite un délicieux bonbon.) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f2); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f3); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f4);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Bonne réponse</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-comment"><span class="hljs-comment">// int&amp; decltype(f2); // int&amp; decltype(f3); // int&amp; decltype(f4); // int&amp; ++f1; //     foo._foo,  {e}    const</span></span></code> </pre><br></div></div><br>  Pourquoi est-ce arrivé?  La réponse réside dans la spécialisation par défaut de <code>std::tuple_element</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:tuple_element&lt;i, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">add_const_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">tuple_element_t</span></span>&lt;i, T&gt;&gt;; };</code> </pre><br>  <code>std::add_const</code> n'ajoute pas <code>const</code> aux types de référence, donc le type de <code>Foo</code> sera toujours <code>int&amp;</code> . <br><br>  Comment gagner ça?  Ajoutez juste une spécialisation pour <code>const Foo</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:tuple_element&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Foo&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;; };</code> </pre><br>  Ensuite, tous les types seront attendus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-comment"><span class="hljs-comment">// const int&amp; decltype(f2); // const int&amp; decltype(f3); // int&amp; decltype(f4); // int&amp; ++f1; //    </span></span></code> </pre><br>  Par ailleurs, le même comportement est vrai pour, par exemple, <code>std::tuple&lt;T&amp;&gt;</code> <br>  - vous pouvez obtenir une référence non constante à l'élément interne, même si l'objet lui-même sera constant. <br><br><h2>  Choses à retenir </h2><br><ol><li>  « <code>cv-auto ref</code> » dans « <code>cv-auto ref [a1..an] = expr</code> » fait référence à la variable invisible {e}. <br></li><li>  Si le type déduit {e} n'est pas référencé, {e} sera initialisé par copie (avec précaution avec les classes "lourdes"). <br></li><li>  Les variables <code>decltype</code> sont des liens «implicites» (elles se comportent comme des liens, bien que <code>decltype</code> renvoie un type non référence pour elles (sauf si la variable fait référence à un lien)). <br></li><li>  Des précautions doivent être prises lors de l'utilisation de types de référence pour la liaison. <br></li></ol><br><h1>  Optimisation de la valeur de retour (rvo, copie élision) </h1><br><img src="https://habrastorage.org/webt/gt/0i/ln/gt0iln8n664yvitfqfpkjk9vuds.png"><br><br>  C'était peut-être l'une des fonctionnalités les plus discutées de la norme C ++ 17 (au moins dans mon cercle d'amis).  Et en effet: C ++ 11 a apporté la sémantique du mouvement, ce qui a grandement simplifié le transfert de l '"interne" de l'objet et la création de diverses usines, et C ++ 17 en général, semble-t-il, a permis de ne pas penser à comment renvoyer l'objet d'une méthode d'usine , - maintenant tout devrait être sans copier et en général, "bientôt tout fleurira sur Mars" ... <br><br>  Mais soyons un peu réalistes: l'optimisation de la valeur de retour n'est pas la chose la plus simple à mettre en œuvre.  Je recommande fortement de regarder cette présentation de cppcon2018: « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Optimisation de la valeur de retour: plus</a> difficile qu'il n'y paraît» d'Arthur O'Dwyer, dans laquelle l'auteur explique pourquoi cela est difficile. <br><br>  Becquet court: <br><br>  Il existe une «fente pour la valeur de retour».  Cet emplacement est essentiellement juste une place sur la pile qui est allouée par celui qui appelle et passe à l'appelé.  Si le code appelé sait exactement quel objet unique sera renvoyé, il peut simplement le créer immédiatement dans cet emplacement directement (à condition que la taille et le type de l'objet et de l'emplacement soient identiques). <br><br>  Qu'est-ce qui en découle?  Prenons-le à part avec des exemples. <br><br>  Tout ira bien ici - NRVO fonctionnera, l'objet sera construit immédiatement dans le "slot": <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Base a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre><br>  Ici, il n'est plus possible de déterminer sans ambiguïté quel objet devrait être le résultat, de sorte que le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">constructeur de déplacement</a> (c ++ 11) sera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">implicitement appelé</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Base a,b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; }</code> </pre><br>  Ici, c'est un peu plus compliqué ... Puisque le type de la valeur de retour est différent du type déclaré, vous ne pouvez pas implicitement appeler <code>move</code> , donc le constructeur de copie est appelé par défaut.  Pour éviter que cela ne se produise, vous devez appeler explicitement <code>move</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Derived a,b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(a); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b); }</code> </pre><br>  Il semblerait que ce soit la même chose que <code>foo2</code> , mais l'opérateur ternaire est une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chose</a> très <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">particulière</a> ... <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Base a, b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(c ? a : b); }</code> </pre><br>  Similaire à <code>foo4</code> , mais également d'un type différent, il faut donc <code>move</code> exactement: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Derived a, b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(c ? a : b); }</code> </pre><br>  Comme vous pouvez le voir dans les exemples, il faut encore réfléchir à la manière de redonner du sens même dans des cas apparemment triviaux ... Y a-t-il des moyens de vous simplifier un peu la vie?  Oui: clang soutient depuis un certain temps le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">diagnostic de la</a> nécessité d'appeler explicitement <code>move</code> , et il existe plusieurs propositions ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P1155</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P0527</a> ) dans la nouvelle norme qui rendront le <code>move</code> explicite moins nécessaire. <br><br><h2>  Choses à retenir </h2><br><ol><li>  RVO / NRVO ne fonctionnera que si: <br><ul><li>  on sait sans ambiguïté quel objet unique doit être créé dans le "slot de valeur de retour"; </li><li>  les types d'objet et de fonction de retour sont identiques. </li></ul></li><li>  S'il y a ambiguïté dans la valeur de retour, alors: <br><ul><li>  si les types de l'objet et de la fonction retournés correspondent, move sera appelé implicitement; </li><li>  sinon, vous devez explicitement appeler move. </li></ul></li><li>  Attention à l'opérateur ternaire: il est concis, mais peut nécessiter un déplacement explicite. <br></li><li>  Il est préférable d'utiliser des compilateurs avec des diagnostics utiles (ou au moins des analyseurs statiques). <br></li></ol><br><h1>  Conclusion </h1><br>  Et pourtant j'aime C ++;) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr465181/">https://habr.com/ru/post/fr465181/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr465167/index.html">Planification des ressources. Pourquoi ça ne marche pas? Partie 1</a></li>
<li><a href="../fr465169/index.html">DIY de PVS-Studio: Gamification des réalisations</a></li>
<li><a href="../fr465173/index.html">Comment modifier le coût de l'abonnement créé dans votre application. App Store Connect et console Google Play</a></li>
<li><a href="../fr465177/index.html">Pas une nouvelle relique: un regard sur Datadog et Atatus</a></li>
<li><a href="../fr465179/index.html">L'automatisation remplacera-t-elle les tests manuels?</a></li>
<li><a href="../fr465185/index.html">Nouvelles normes de vidéosurveillance: couleur la nuit, anti-bruit, ePoE</a></li>
<li><a href="../fr465187/index.html">6 phrases en anglais pouvant être utilisées dans les négociations salariales avec des entreprises étrangères</a></li>
<li><a href="../fr465189/index.html">Équipe de développement Workflow One Sprint</a></li>
<li><a href="../fr465191/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 25. Étude approfondie de l'IPv6</a></li>
<li><a href="../fr465193/index.html">Construire un projet Android dans un conteneur Docker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>