<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸˆ¯ï¸ ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘©ğŸ¼ ğŸ¸ Endroits glissants en C ++ 17 ğŸ—ï¸ ğŸ‘µğŸ¼ ğŸ‘©ğŸ¾â€âš–ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ces derniÃ¨res annÃ©es, le C ++ a fait des pas de gÃ©ant et suivre toutes les subtilitÃ©s et les subtilitÃ©s du langage peut Ãªtre trÃ¨s, trÃ¨s difficile. Une...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Endroits glissants en C ++ 17</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/465181/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/fp/nd/-g/fpnd-ggxjx4-xafw3sb7rx2keca.png" alt="image"></a> <br><br>  Ces derniÃ¨res annÃ©es, le C ++ a fait des pas de gÃ©ant et suivre toutes les subtilitÃ©s et les subtilitÃ©s du langage peut Ãªtre trÃ¨s, trÃ¨s difficile.  Une nouvelle norme n'est pas loin, cependant, l'introduction de nouvelles tendances n'est pas le processus le plus rapide et le plus simple, donc, mÃªme s'il reste un peu de temps avant C ++ 20, je suggÃ¨re de rafraÃ®chir ou de dÃ©couvrir des endroits particuliÃ¨rement Â«glissantsÂ» de la norme actuelle la langue. <br><br>  Aujourd'hui, je vais vous dire pourquoi si constexpr ne remplace pas les macros, quels sont les Â«internesÂ» de la liaison structurÃ©e et ses Â«piÃ¨gesÂ», et est-il vrai que la copie Ã©lision fonctionne dÃ©sormais toujours et que vous pouvez Ã©crire n'importe quel retour sans hÃ©sitation. <br><br>  Si vous nâ€™avez pas peur de vous salir un peu les mains, de plonger dans lâ€™intÃ©rieur de votre langue, bienvenue chez Cat. <br><a name="habracut"></a><br><hr><br><h1>  si constexpr </h1><br>  CommenÃ§ons par la plus simple - <code>if constexpr</code> vous permet de <code>if constexpr</code> la branche d'expression conditionnelle pour laquelle la condition souhaitÃ©e n'est pas remplie mÃªme au stade de la compilation. <br><br>  Il semble que cela remplace la macro <code>#if</code> pour dÃ©sactiver la logique "extra"?  Non.  Pas du tout. <br><br>  Tout d'abord, un tel <code>if</code> a des propriÃ©tÃ©s qui ne sont pas disponibles pour les macros - Ã  l'intÃ©rieur, vous pouvez compter toute expression <code>constexpr</code> qui peut Ãªtre <code>constexpr</code> en <code>bool</code> .  Eh bien, et deuxiÃ¨mement, le contenu de la branche supprimÃ©e doit Ãªtre syntaxiquement et sÃ©mantiquement correct. <br><br>  En raison de la deuxiÃ¨me exigence, <code>if constexpr</code> ne peut pas Ãªtre utilisÃ©, par exemple, des fonctions inexistantes (le code dÃ©pendant de la plate-forme ne peut pas Ãªtre explicitement sÃ©parÃ© de cette maniÃ¨re) ou mauvaises du point de vue du langage de construction (par exemple, " <code>void T = 0;</code> "). <br><br>  Quel est l'intÃ©rÃªt d'utiliser <code>if constexpr</code> ?  Le point principal est dans les modÃ¨les.  Il existe une rÃ¨gle spÃ©ciale pour eux: la branche supprimÃ©e n'est pas instanciÃ©e lorsque le modÃ¨le est instanciÃ©.  Cela facilite l'Ã©criture de code qui dÃ©pend en quelque sorte des propriÃ©tÃ©s des types de modÃ¨les. <br><br>  Cependant, dans les modÃ¨les, il ne faut pas oublier que le code Ã  l'intÃ©rieur des branches doit Ãªtre correct au moins pour une variante (mÃªme purement potentielle) d'instanciation, il est donc tout simplement <code>static_assert(false)</code> d'Ã©crire, par exemple, <code>static_assert(false)</code> Ã  l'intÃ©rieur d'une des branches (il est nÃ©cessaire que ce <code>static_assert</code> dÃ©pendait d'un paramÃ¨tre dÃ©pendant du modÃ¨le). <br><br>  Exemples: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-comment"><span class="hljs-comment">//    ,       if constexpr ( os == OS::win ) {        win_api_call(); //         }    else {        some_other_os_call(); //  win      } }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-comment"><span class="hljs-comment">//    ,    T      if constexpr ( os == OS::win ) {        T::win_api_call(); //  T   ,    win    }    else {        T::some_other_os_call(); //  T   ,         } }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition1)</span></span></span><span class="hljs-function"> </span></span>{        <span class="hljs-comment"><span class="hljs-comment">// ...    }    else if constexpr (condition2) {        // ...    }    else {        // static_assert(false); //          static_assert(trait&lt;T&gt;::value); // ,   ,  trait&lt;T&gt;::value   false    } }</span></span></code> </pre><br><h2>  Choses Ã  retenir </h2><br><ol><li>  Le code dans toutes les succursales doit Ãªtre correct. <br></li><li>  Ã€ l'intÃ©rieur des modÃ¨les, le contenu des branches supprimÃ©es n'est pas instanciÃ©. <br></li><li>  Le code Ã  l'intÃ©rieur de n'importe quelle branche doit Ãªtre correct pour au moins une variante purement potentielle d'instanciation du modÃ¨le. <br></li></ol><br><h1>  Reliure structurÃ©e </h1><br><img src="https://habrastorage.org/webt/0v/jl/x4/0vjlx42it96fu5j20yz-m-pvhpq.png"><br><br>  En C ++ 17, un mÃ©canisme assez pratique pour dÃ©composer divers objets de type tuple est apparu, vous permettant de lier de maniÃ¨re pratique et concise leurs Ã©lÃ©ments internes Ã  des variables nommÃ©es: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     â€”    : for (const auto&amp; [key, value] : map) {    std::cout &lt;&lt; key &lt;&lt; ": " &lt;&lt; value &lt;&lt; std::endl; }</span></span></code> </pre><br>  Par un objet de type tuple, je veux dire un tel objet pour lequel le nombre d'Ã©lÃ©ments internes disponibles au moment de la compilation est connu (de "tuple" - une liste ordonnÃ©e avec un nombre fixe d'Ã©lÃ©ments (vecteur)). <br><br>  Cette dÃ©finition inclut des types tels que: <code>std::pair</code> , <code>std::tuple</code> , <code>std::array</code> , des tableaux de la forme Â« <code>T a[N]</code> Â», ainsi que diverses structures et classes auto-Ã©crites. <br><br>  ArrÃªtez ... Pouvez-vous utiliser vos propres structures dans la liaison structurelle?  Spoiler: vous le pouvez (bien que parfois vous deviez travailler dur (mais plus Ã  ce sujet ci-dessous)). <br><br><h2>  Comment Ã§a marche </h2><br>  Le travail de liaison structurelle mÃ©rite un article sÃ©parÃ©, mais comme nous parlons spÃ©cifiquement d'endroits Â«glissantsÂ», je vais essayer d'expliquer briÃ¨vement comment tout fonctionne. <br><br>  La norme fournit la syntaxe suivante pour dÃ©finir la liaison: <br><br>  <i>attr</i> (facultatif) <i>cv-auto</i> <i>ref-operator</i> (facultatif) <i>expression</i> [ <i>liste d'identificateurs</i> ]; <br><br><ul><li>  <code>attr</code> - liste d'attributs facultative; <br></li><li>  <code>cv-auto</code> - auto avec des modificateurs const / volatile possibles; <br></li><li>  <code>ref-operator</code> - spÃ©cificateur de rÃ©fÃ©rence facultatif (&amp; ou &amp;&amp;); <br></li><li>  <code>identifier-list</code> - une liste de noms de nouvelles variables; <br></li><li>  <code>expression</code> est une expression qui aboutit Ã  un objet de type tuple utilisÃ© pour la liaison (l'expression peut Ãªtre sous la forme " <code>= expr</code> ", " <code>{expr}</code> " ou " <code>(expr)</code> "). <br></li></ul><br>  Il est important de noter que le nombre de noms dans la <code>identifier-list</code> doit correspondre au nombre d'Ã©lÃ©ments dans l'objet rÃ©sultant de l' <code>expression</code> . <br><br>  Tout cela vous permet d'Ã©crire des constructions du formulaire: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp; [a,b,c] = Foo{};</code> </pre><br>  Et nous arrivons ici au premier endroit Â«glissantÂ»: rencontrer une expression de la forme Â« <code>auto a = expr;</code>  ", Vous voulez gÃ©nÃ©ralement dire que le type" <code>a</code> "sera calculÃ© par l'expression" <code>expr</code> ", et vous vous attendez Ã  ce que dans l'expression" <code>const auto&amp; [a,b,c] = expr;</code>  "La mÃªme chose sera faite, seuls les types pour" <code>a,b,c</code> "seront les types <code>const&amp;</code> element correspondants de" <code>expr</code> "... <br><br>  La vÃ©ritÃ© est diffÃ©rente: le spÃ©cificateur d' <code>cv-auto ref-operator</code> est utilisÃ© pour calculer le type d'une variable invisible, dans laquelle le rÃ©sultat du calcul de expr est affectÃ© (c'est-Ã -dire que le compilateur remplace Â« <code>const auto&amp; [a,b,c] = expr</code> Â» par Â« <code>const auto&amp; e = expr</code> "). <br><br>  Ainsi, une nouvelle entitÃ© invisible apparaÃ®t (ci-aprÃ¨s je l'appellerai {e}), cependant, l'entitÃ© est trÃ¨s utile: par exemple, elle peut matÃ©rialiser des objets temporaires (par consÃ©quent, vous pouvez les connecter en toute sÃ©curitÃ© " <code>const auto&amp; [a,b,c] = Foo {};</code> "). <br><br>  Le deuxiÃ¨me endroit glissant dÃ©coule immÃ©diatement du remplacement effectuÃ© par le compilateur: si le type dÃ©duit pour {e} n'est pas une rÃ©fÃ©rence, le rÃ©sultat de <code>expr</code> sera copiÃ© dans {e}. <br><br>  Quels types les variables auront-elles dans la <code>identifier-list</code> ?  Pour commencer, ce ne seront pas exactement des variables.  Oui, ils se comportent comme des variables rÃ©elles et ordinaires, mais seulement avec la diffÃ©rence quâ€™ils se rÃ©fÃ¨rent Ã  lâ€™intÃ©rieur Ã  une entitÃ© qui leur est associÃ©e, et le <code>decltype</code> partir dâ€™une telle variable de Â«rÃ©fÃ©renceÂ» produira le type dâ€™entitÃ© auquel cette variable se rÃ©fÃ¨re: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; t(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [a, b] = t; <span class="hljs-comment"><span class="hljs-comment">// decltype(a) â€” int, decltype(b) â€” float ++a; // ,  Â« Â»,   t std::cout &lt;&lt; std::get&lt;0&gt;(t); //  2</span></span></code> </pre><br>  Les types eux-mÃªmes sont dÃ©finis comme suit: <br><br><ol><li>  Si <b>{e}</b> est un tableau ( <code>T a[N]</code> ), alors le type sera un - T, les modificateurs cv coÃ¯ncideront avec ceux du tableau. <br></li><li>  Si <b>{e}</b> est de type E et supporte l'interface tuple, les structures sont dÃ©finies: <br><br><pre> <code class="plaintext hljs">std::tuple_size&lt;E&gt;</code> </pre> <br><pre> <code class="plaintext hljs">std::tuple_element&lt;i, E&gt;</code> </pre> <br>  et fonction: <br><br><pre> <code class="plaintext hljs">get&lt;i&gt;({e}); //  {e}.get&lt;i&gt;()</code> </pre> <br>  alors le type de chaque variable sera le type <code>std::tuple_element_t&lt;i, E&gt;</code> <br></li><li>  Dans d'autres cas, le type de la variable correspondra au type d'Ã©lÃ©ment de structure auquel la liaison est effectuÃ©e. <br></li></ol><br>  Donc, si trÃ¨s briÃ¨vement, les Ã©tapes suivantes sont prises avec la liaison structurelle: <br><br><ol><li>  Calcul du type et initialisation de l'entitÃ© invisible {e} sur la base des modificateurs type <code>expr</code> et <code>cv-ref</code> . <br></li><li>  CrÃ©ez des pseudo-variables et liez-les aux Ã©lÃ©ments {e}. <br></li></ol><br><h2>  Lier structurellement vos classes / structures </h2><br>  Le principal obstacle Ã  la liaison de leurs structures est le manque de rÃ©flexion en C ++.  MÃªme le compilateur, qui, semble-t-il, doit savoir avec certitude comment telle ou telle structure est organisÃ©e Ã  l'intÃ©rieur, a du mal: les modificateurs d'accÃ¨s (public / privÃ© / protÃ©gÃ©) et l'hÃ©ritage compliquent grandement les choses. <br><br>  En raison de ces difficultÃ©s, les restrictions sur l'utilisation de leurs classes sont trÃ¨s strictes (au moins pour l'instant: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P1061</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P1096</a> ): <br><br><ol><li>  Tous les champs internes non statiques d'une classe doivent provenir de la mÃªme classe de base et doivent Ãªtre disponibles au moment de l'utilisation. <br></li><li>  Ou la classe doit implÃ©menter la Â«rÃ©flexionÂ» (prendre en charge l'interface tuple). <br></li></ol><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  Â«Â»  struct A { int a; }; struct B : A {}; struct C : A { int c; }; class D { int d; }; auto [a] = A{}; //  (a -&gt; A::a) auto [a] = B{}; //  (a -&gt; B::A::a) auto [a, c] = C{}; // : a  c    auto [d] = D{}; // : d â€” private void D::foo() {    auto [d] = *this; //  (d   ) }</span></span></code> </pre><br>  L'implÃ©mentation de l'interface tuple vous permet d'utiliser n'importe laquelle de vos classes pour la liaison, mais elle semble un peu lourde et comporte un autre Ã©cueil.  Prenons immÃ©diatement un exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,      int   class Foo; template&lt;&gt; struct std::tuple_size&lt;Foo&gt; : std::integral_constant&lt;std::size_t, 1&gt; {}; template&lt;&gt; struct std::tuple_element&lt;0, Foo&gt; { using type = int&amp;; }; class Foo { public: template&lt;std::size_t i&gt; std::tuple_element_t&lt;i, Foo&gt; const&amp; get() const; template&lt;std::size_t i&gt; std::tuple_element_t&lt;i, Foo&gt; &amp; get(); private: int _foo = 0; int&amp; _bar = _foo; }; template&lt;&gt; std::tuple_element_t&lt;0, Foo&gt; const&amp; Foo::get&lt;0&gt;() const { return _bar; } template&lt;&gt; std::tuple_element_t&lt;0, Foo&gt; &amp; Foo::get&lt;0&gt;() { return _bar; }</span></span></code> </pre><br>  Maintenant, nous lions: <br><br><pre> <code class="cpp hljs">Foo foo; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [f1] = foo; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [f2] = foo; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [f3] = foo; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [f4] = foo;</code> </pre><br>  Et il est temps de rÃ©flÃ©chir aux types que nous avons?  (Celui qui pourrait rÃ©pondre tout de suite mÃ©rite un dÃ©licieux bonbon.) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f2); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f3); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f4);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Bonne rÃ©ponse</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-comment"><span class="hljs-comment">// int&amp; decltype(f2); // int&amp; decltype(f3); // int&amp; decltype(f4); // int&amp; ++f1; //     foo._foo,  {e}    const</span></span></code> </pre><br></div></div><br>  Pourquoi est-ce arrivÃ©?  La rÃ©ponse rÃ©side dans la spÃ©cialisation par dÃ©faut de <code>std::tuple_element</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:tuple_element&lt;i, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">add_const_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">tuple_element_t</span></span>&lt;i, T&gt;&gt;; };</code> </pre><br>  <code>std::add_const</code> n'ajoute pas <code>const</code> aux types de rÃ©fÃ©rence, donc le type de <code>Foo</code> sera toujours <code>int&amp;</code> . <br><br>  Comment gagner Ã§a?  Ajoutez juste une spÃ©cialisation pour <code>const Foo</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:tuple_element&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Foo&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;; };</code> </pre><br>  Ensuite, tous les types seront attendus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-comment"><span class="hljs-comment">// const int&amp; decltype(f2); // const int&amp; decltype(f3); // int&amp; decltype(f4); // int&amp; ++f1; //    </span></span></code> </pre><br>  Par ailleurs, le mÃªme comportement est vrai pour, par exemple, <code>std::tuple&lt;T&amp;&gt;</code> <br>  - vous pouvez obtenir une rÃ©fÃ©rence non constante Ã  l'Ã©lÃ©ment interne, mÃªme si l'objet lui-mÃªme sera constant. <br><br><h2>  Choses Ã  retenir </h2><br><ol><li>  Â« <code>cv-auto ref</code> Â» dans Â« <code>cv-auto ref [a1..an] = expr</code> Â» fait rÃ©fÃ©rence Ã  la variable invisible {e}. <br></li><li>  Si le type dÃ©duit {e} n'est pas rÃ©fÃ©rencÃ©, {e} sera initialisÃ© par copie (avec prÃ©caution avec les classes "lourdes"). <br></li><li>  Les variables <code>decltype</code> sont des liens Â«implicitesÂ» (elles se comportent comme des liens, bien que <code>decltype</code> renvoie un type non rÃ©fÃ©rence pour elles (sauf si la variable fait rÃ©fÃ©rence Ã  un lien)). <br></li><li>  Des prÃ©cautions doivent Ãªtre prises lors de l'utilisation de types de rÃ©fÃ©rence pour la liaison. <br></li></ol><br><h1>  Optimisation de la valeur de retour (rvo, copie Ã©lision) </h1><br><img src="https://habrastorage.org/webt/gt/0i/ln/gt0iln8n664yvitfqfpkjk9vuds.png"><br><br>  C'Ã©tait peut-Ãªtre l'une des fonctionnalitÃ©s les plus discutÃ©es de la norme C ++ 17 (au moins dans mon cercle d'amis).  Et en effet: C ++ 11 a apportÃ© la sÃ©mantique du mouvement, ce qui a grandement simplifiÃ© le transfert de l '"interne" de l'objet et la crÃ©ation de diverses usines, et C ++ 17 en gÃ©nÃ©ral, semble-t-il, a permis de ne pas penser Ã  comment renvoyer l'objet d'une mÃ©thode d'usine , - maintenant tout devrait Ãªtre sans copier et en gÃ©nÃ©ral, "bientÃ´t tout fleurira sur Mars" ... <br><br>  Mais soyons un peu rÃ©alistes: l'optimisation de la valeur de retour n'est pas la chose la plus simple Ã  mettre en Å“uvre.  Je recommande fortement de regarder cette prÃ©sentation de cppcon2018: Â« <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Optimisation de la valeur de retour: plus</a> difficile qu'il n'y paraÃ®tÂ» d'Arthur O'Dwyer, dans laquelle l'auteur explique pourquoi cela est difficile. <br><br>  Becquet court: <br><br>  Il existe une Â«fente pour la valeur de retourÂ».  Cet emplacement est essentiellement juste une place sur la pile qui est allouÃ©e par celui qui appelle et passe Ã  l'appelÃ©.  Si le code appelÃ© sait exactement quel objet unique sera renvoyÃ©, il peut simplement le crÃ©er immÃ©diatement dans cet emplacement directement (Ã  condition que la taille et le type de l'objet et de l'emplacement soient identiques). <br><br>  Qu'est-ce qui en dÃ©coule?  Prenons-le Ã  part avec des exemples. <br><br>  Tout ira bien ici - NRVO fonctionnera, l'objet sera construit immÃ©diatement dans le "slot": <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Base a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre><br>  Ici, il n'est plus possible de dÃ©terminer sans ambiguÃ¯tÃ© quel objet devrait Ãªtre le rÃ©sultat, de sorte que le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">constructeur de dÃ©placement</a> (c ++ 11) sera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">implicitement appelÃ©</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Base a,b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; }</code> </pre><br>  Ici, c'est un peu plus compliquÃ© ... Puisque le type de la valeur de retour est diffÃ©rent du type dÃ©clarÃ©, vous ne pouvez pas implicitement appeler <code>move</code> , donc le constructeur de copie est appelÃ© par dÃ©faut.  Pour Ã©viter que cela ne se produise, vous devez appeler explicitement <code>move</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Derived a,b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(a); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b); }</code> </pre><br>  Il semblerait que ce soit la mÃªme chose que <code>foo2</code> , mais l'opÃ©rateur ternaire est une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chose</a> trÃ¨s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">particuliÃ¨re</a> ... <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Base a, b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(c ? a : b); }</code> </pre><br>  Similaire Ã  <code>foo4</code> , mais Ã©galement d'un type diffÃ©rent, il faut donc <code>move</code> exactement: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Derived a, b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(c ? a : b); }</code> </pre><br>  Comme vous pouvez le voir dans les exemples, il faut encore rÃ©flÃ©chir Ã  la maniÃ¨re de redonner du sens mÃªme dans des cas apparemment triviaux ... Y a-t-il des moyens de vous simplifier un peu la vie?  Oui: clang soutient depuis un certain temps le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">diagnostic de la</a> nÃ©cessitÃ© d'appeler explicitement <code>move</code> , et il existe plusieurs propositions ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P1155</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P0527</a> ) dans la nouvelle norme qui rendront le <code>move</code> explicite moins nÃ©cessaire. <br><br><h2>  Choses Ã  retenir </h2><br><ol><li>  RVO / NRVO ne fonctionnera que si: <br><ul><li>  on sait sans ambiguÃ¯tÃ© quel objet unique doit Ãªtre crÃ©Ã© dans le "slot de valeur de retour"; </li><li>  les types d'objet et de fonction de retour sont identiques. </li></ul></li><li>  S'il y a ambiguÃ¯tÃ© dans la valeur de retour, alors: <br><ul><li>  si les types de l'objet et de la fonction retournÃ©s correspondent, move sera appelÃ© implicitement; </li><li>  sinon, vous devez explicitement appeler move. </li></ul></li><li>  Attention Ã  l'opÃ©rateur ternaire: il est concis, mais peut nÃ©cessiter un dÃ©placement explicite. <br></li><li>  Il est prÃ©fÃ©rable d'utiliser des compilateurs avec des diagnostics utiles (ou au moins des analyseurs statiques). <br></li></ol><br><h1>  Conclusion </h1><br>  Et pourtant j'aime C ++;) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr465181/">https://habr.com/ru/post/fr465181/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr465167/index.html">Planification des ressources. Pourquoi Ã§a ne marche pas? Partie 1</a></li>
<li><a href="../fr465169/index.html">DIY de PVS-Studio: Gamification des rÃ©alisations</a></li>
<li><a href="../fr465173/index.html">Comment modifier le coÃ»t de l'abonnement crÃ©Ã© dans votre application. App Store Connect et console Google Play</a></li>
<li><a href="../fr465177/index.html">Pas une nouvelle relique: un regard sur Datadog et Atatus</a></li>
<li><a href="../fr465179/index.html">L'automatisation remplacera-t-elle les tests manuels?</a></li>
<li><a href="../fr465185/index.html">Nouvelles normes de vidÃ©osurveillance: couleur la nuit, anti-bruit, ePoE</a></li>
<li><a href="../fr465187/index.html">6 phrases en anglais pouvant Ãªtre utilisÃ©es dans les nÃ©gociations salariales avec des entreprises Ã©trangÃ¨res</a></li>
<li><a href="../fr465189/index.html">Ã‰quipe de dÃ©veloppement Workflow One Sprint</a></li>
<li><a href="../fr465191/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 25. Ã‰tude approfondie de l'IPv6</a></li>
<li><a href="../fr465193/index.html">Construire un projet Android dans un conteneur Docker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>