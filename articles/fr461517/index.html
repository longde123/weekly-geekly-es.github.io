<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏻 💋 👩‍🚀 Meilleurs algorithmes de copier-coller pour C et C ++. Haiku OS Cookbook 👩 🏼 👩🏾‍🤝‍👩🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De nombreuses fautes de frappe et du code copier-coller sont devenus le sujet principal de l'article supplémentaire sur la vérification du code Haiku ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meilleurs algorithmes de copier-coller pour C et C ++. Haiku OS Cookbook</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/461517/">  De nombreuses fautes de frappe et du code copier-coller sont devenus le sujet principal de l'article supplémentaire sur la vérification du code Haiku par l'analyseur PVS-Studio.  Pourtant, cet article parle principalement d'erreurs liées à l'insouciance et à l'échec de la refactorisation, plutôt qu'aux fautes de frappe.  Les erreurs trouvées démontrent la force du facteur humain dans le développement de logiciels. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/628/e3b/d89/628e3bd8949d3e3155f16a836fc0595c.png" alt="Image 1"></div><a name="habracut"></a><br><h2>  Présentation </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Haiku</a> est un système d'exploitation open source gratuit pour les ordinateurs personnels.  Une équipe de développement international travaille actuellement sur les composants du système.  Le portage de Libre Office dans le système d'exploitation et la première version R1 Beta 1 se distinguent parmi les améliorations de développement importantes récentes. <br><br>  L'équipe de développeurs de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PVS-Studio</a> suit ce développement de projet depuis 2015 et publie des revues de défauts de code.  Il s'agit du quatrième examen de tous les temps.  Vous pouvez lire les articles précédents par ces liens: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyse du système d'exploitation Haiku (famille BeOS), par PVS-Studio, partie 1</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyse du système d'exploitation Haiku (famille BeOS) par PVS-Studio.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment se tirer une balle dans le pied en C et C ++.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Livre de cuisine Haiku OS</a> </li></ol><br>  La caractéristique de la dernière analyse de code est la possibilité d'utiliser la version officielle de PVS-Studio pour Linux.  Ni PVS-Studio pour Linux, ni un rapport pratique pour afficher les erreurs n'était disponible en 2015. Cette fois, nous enverrons le rapport complet dans un format pratique aux développeurs de Haiku. <br><br><h2>  Classique </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V501</a> Il existe des sous-expressions identiques à gauche et à droite de l'opérateur '-': (addr_t) b - (addr_t) b BitmapManager.cpp 51 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare_app_pointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ServerApp* a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ServerApp* b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span>)b - (<span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span>)b; }</code> </pre> <br>  Chaque développeur doit mélanger les variables <i>a</i> et <i>b</i> , <i>x</i> et <i>y</i> , <i>i</i> et <i>j</i> ... au moins une fois dans sa vie. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V501</a> Il existe des sous-expressions identiques à gauche et à droite de '||'  opérateur: entrée == __null ||  input == __null MediaClient.cpp 182 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> BMediaClient::Unbind(BMediaInput* input, BMediaOutput* output) { CALLED(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || input == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> B_ERROR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input-&gt;fOwner != <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> || output-&gt;fOwner != <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> B_ERROR; input-&gt;fBind = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; output-&gt;fBind = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> B_OK; }</code> </pre> <br>  Le même pointeur d' <i>entrée</i> est vérifié deux fois dans la condition.  Alors que le pointeur de <i>sortie</i> est resté non contrôlé, ce qui peut entraîner la déréférence du pointeur nul. <br><br>  Code fixe: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || output == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> B_ERROR;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V583</a> L' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">opérateur</a> '?:', <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quelle</a> que soit son expression conditionnelle, renvoie toujours une seule et même valeur: 500000. usb_modeswitch.cpp 361 <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> status_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_transfer_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bigtime_t</span></span> timeout = directionIn ? <span class="hljs-number"><span class="hljs-number">500000</span></span> : <span class="hljs-number"><span class="hljs-number">500000</span></span>; result = acquire_sem_etc(device-&gt;notify, <span class="hljs-number"><span class="hljs-number">1</span></span>, B_RELATIVE_TIMEOUT, timeout); .... } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (result == B_INTERRUPTED); .... }</code> </pre> <br>  L'opérateur ternaire est devenu inutile, lorsque l'auteur du code a fait une erreur et a écrit deux valeurs de retour identiques - <i>500000</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V519</a> La variable 'm_kindex1' reçoit des valeurs successives deux fois.  C'est peut-être une erreur.  Vérifiez les lignes: 40, 41. agg_trans_double_path.cpp 41 <br><br><pre> <code class="cpp hljs">trans_double_path::trans_double_path() : m_kindex1(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), m_kindex2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), m_base_length(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), m_base_height(<span class="hljs-number"><span class="hljs-number">1.0</span></span>), m_status1(initial), m_status2(initial), m_preserve_x_scale(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> trans_double_path::reset() { m_src_vertices1.remove_all(); m_src_vertices2.remove_all(); m_kindex1 = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; m_kindex1 = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; m_status1 = initial; m_status2 = initial; }</code> </pre> <br>  Il y a une erreur dans la fonction de <i>réinitialisation</i> : une faute de frappe dans l' <i>index des</i> variables <i>m_kindex2</i> .  Cette variable ne sera pas réinitialisée, ce qui affectera probablement l'exécution d'autres fragments de code. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V501</a> Il existe des sous-expressions identiques à gauche et à droite de l'opérateur '&gt;': fg [order_type :: R]&gt; fg [order_type :: R] agg_span_image_filter_rgba.h 898 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Source source_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> source_type::color_type color_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> source_type::order_type order_type; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(color_type* span, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fg[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) fg[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fg[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) fg[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fg[<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) fg[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fg[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) fg[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fg[order_type::A] &gt; base_mask) fg[order_type::A] = base_mask; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fg[order_type::R] &gt; fg[order_type::R])fg[order_type::R] = fg[order_type::R]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fg[order_type::G] &gt; fg[order_type::G])fg[order_type::G] = fg[order_type::G]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fg[order_type::B] &gt; fg[order_type::B])fg[order_type::B] = fg[order_type::B]; .... }</code> </pre> <br>  Dans les dernières lignes, il y a deux problèmes à la fois: la comparaison et l'affectation de variables égales.  Je ne peux même pas suggérer l'idée originale de l'auteur.  Je vais juste noter cet extrait comme suspect. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V570</a> La variable 'wPipeIndex' est assignée à elle-même.  CEchoGals_transport.cpp 244 <br><br><pre> <code class="cpp hljs">ECHOSTATUS CEchoGals::CloseAudio (....) { .... wPipeIndex = wPipeIndex; m_ProcessId[ wPipeIndex ] = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; m_Pipes[ wPipeIndex ].wInterleave = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }</code> </pre> <br>  La variable <i>wPipeIndex</i> est initialisée par sa propre valeur.  Très probablement, une faute de frappe a été faite. <br><br><h2>  Erreurs avec des pointeurs </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V522 Le</a> déréférencement du pointeur nul 'currentInterface' peut avoir lieu.  Device.cpp 258 <br><br><pre> <code class="cpp hljs">Device::Device(....) : .... { .... usb_interface_info* currentInterface = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= uint32 descriptorStart = sizeof(usb_configuration_descriptor); while (descriptorStart &lt; actualLength) { switch (configData[descriptorStart + 1]) { .... case USB_DESCRIPTOR_ENDPOINT: { .... if (currentInterface == NULL) // &lt;= break; currentInterface-&gt;endpoint_count++; .... } .... case USB_DESCRIPTOR_ENDPOINT_COMPANION: { usb_endpoint_descriptor* desc = currentInterface // &lt;= -&gt;endpoint[currentInterface-&gt;endpoint_count - 1].descr; .... } .... }</span></span></code> </pre> <br>  Le pointeur <i>currentInterface</i> est initialement initialisé par null puis vérifié lors de la saisie dans les branches de l'opérateur <i>switch</i> , mais pas dans tous les cas.  L'analyseur avertit que lors du passage à l' <i>étiquette de</i> cas <i>USB_DESCRIPTOR_ENDPOINT_COMPANION</i> , une déréférence de pointeur nul peut se produire. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V522 Le</a> déréférencement du pointeur nul 'répertoire' peut avoir lieu.  PathMonitor.cpp 1465 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> PathHandler::_EntryCreated(....) { .... Directory* directory = directoryNode-&gt;ToDirectory(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (directory == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// We're out of sync with reality. if (!dryRun) { if (Entry* nodeEntry = directory-&gt;FirstNodeEntry()) { .... } } return false; } .... }</span></span></code> </pre> <br>  Je pense qu'il y a une erreur dans la condition de comparaison du pointeur de <i>répertoire</i> avec la valeur nulle;  la condition doit être le contraire.  Avec l'implémentation actuelle, si la variable <i>dryRun</i> est <i>fausse</i> , le pointeur null du <i>répertoire</i> sera déréférencé. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V522 Le</a> déréférencement du pointeur nul «entrée» peut avoir lieu.  MediaRecorder.cpp 343 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(media_input* input)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> media_input&amp; BMediaRecorder::MediaInput() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { CALLED(); media_input* input = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; fNode-&gt;GetInput(input); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *input; }</code> </pre> <br>  Le pointeur d' <i>entrée</i> est initialisé par null et reste avec une telle valeur, car le pointeur ne change pas dans la fonction GetInput.  Dans d'autres méthodes de la classe <i>BMediaRecorder</i> , l'implémentation est différente, par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> BMediaRecorder::_Connect(....) { .... <span class="hljs-comment"><span class="hljs-comment">// Find our Node's free input media_input ourInput; fNode-&gt;GetInput(&amp;ourInput); // &lt;= .... }</span></span></code> </pre> <br>  Tout est correct ici, mais le premier fragment doit être réécrit, sinon la fonction renverra une référence à un objet local. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V522 Le</a> déréférencement du pointeur nul «mustFree» peut avoir lieu.  RequestUnflattener.cpp 35 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> Reader::Read(int32 size, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>** buffer, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>* mustFree) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || !buffer || mustFree) <span class="hljs-comment"><span class="hljs-comment">// &lt;= return B_BAD_VALUE; if (size == 0) { *buffer = NULL; *mustFree = false; // &lt;= return B_OK; } .... }</span></span></code> </pre> <br>  Dans l'expression conditionnelle où toutes les données incorrectes sont vérifiées, l'auteur a fait une faute de frappe lors de la vérification du pointeur <i>mustFree</i> .  Très probablement, la fonction devrait se terminer lorsqu'elle a la valeur nulle de ce pointeur: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || !buffer || !mustFree) <span class="hljs-comment"><span class="hljs-comment">// &lt;= return B_BAD_VALUE;</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V757</a> Il est possible qu'une variable incorrecte soit comparée à nullptr après la conversion de type en utilisant 'dynamic_cast'.  Vérifiez les lignes: 474, 476. Recover.cpp 474 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkStructure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Disk &amp;disk)</span></span></span><span class="hljs-function"> </span></span>{ .... Inode* missing = gMissing.Get(run); dir = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;Directory *&gt;(missing); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (missing == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { .... } .... }</code> </pre> <br>  Le développeur aurait dû vérifier le pointeur <i>dir</i> au lieu de <i>manquer</i> après la conversion de type.  Soit dit en passant, les développeurs C # font également <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">souvent</a> une erreur similaire.  Cela prouve une fois de plus que certaines erreurs ne dépendent pas de la langue utilisée. <br><br>  Quelques endroits similaires dans le code: <br><br><ul><li>  V757 Il est possible qu'une variable incorrecte soit comparée à nullptr après la conversion de type en utilisant 'dynamic_cast'.  Vérifiez les lignes: 355, 357. ExpandoMenuBar.cpp 355 </li><li>  V757 Il est possible qu'une variable incorrecte soit comparée à nullptr après la conversion de type en utilisant 'dynamic_cast'.  Vérifiez les lignes: 600, 601. ValControl.cpp 600 </li></ul><br><h2>  Erreurs d'index </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V557 Le</a> dépassement de matrice est possible.  L'index 'BT_SCO' pointe au-delà de la limite du tableau.  h2upper.cpp 75 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bt_usb_dev</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nbuffersTx</span></span></span><span class="hljs-class">[(1 + 1 + 0 + 0)];</span></span> <span class="hljs-comment"><span class="hljs-comment">// &lt;= [0..1] .... } typedef enum { BT_COMMAND = 0, BT_EVENT, BT_ACL, BT_SCO, // &lt;= 3 BT_ESCO, HCI_NUM_PACKET_TYPES } bt_packet_t; void sched_tx_processing(bt_usb_dev* bdev) { .... if (!list_is_empty(&amp;bdev-&gt;nbuffersTx[BT_SCO])) { // &lt;= fail // TODO to be implemented } .... }</span></span></code> </pre> <br>  Le <i>tableau bdev-&gt; nbuffersTx se</i> compose uniquement de 2 éléments, mais il est adressé par la constante BT_SCO, qui est 3. Voici l'index du tableau infaillible hors limites. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V557 Le</a> dépassement de matrice est possible.  La fonction 'ieee80211_send_setup' traite la valeur '16'.  Inspectez le quatrième argument.  Vérifiez les lignes: 842, 911. ieee80211_output.c 842 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ieee80211_node</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ieee80211_tx_ampdu</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ni_tx_ampdu</span></span></span><span class="hljs-class">[16];</span></span> <span class="hljs-comment"><span class="hljs-comment">// &lt;= [0..15] .... }; #define IEEE80211_NONQOS_TID 16 int ieee80211_mgmt_output(....) { .... ieee80211_send_setup(ni, m, IEEE80211_FC0_TYPE_MGT | type, IEEE80211_NONQOS_TID, // &lt;= 16 vap-&gt;iv_myaddr, ni-&gt;ni_macaddr, ni-&gt;ni_bssid); .... } void ieee80211_send_setup( struct ieee80211_node *ni, struct mbuf *m, int type, int tid, // &lt;= 16 ....) { .... tap = &amp;ni-&gt;ni_tx_ampdu[tid]; // &lt;= 16 .... }</span></span></code> </pre> <br>  Un autre index de tableau hors limites.  Cette fois, juste par un élément.  L'analyse interprocédurale a permis de révéler le cas où le tableau <i>ni-&gt; ni_tx_ampdu</i> , composé de 16 éléments, était traité par l'index 16. En C et C ++, les tableaux sont indexés à partir de zéro. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V781</a> La valeur de la variable "vecteur" est vérifiée après son utilisation.  Il y a peut-être une erreur dans la logique du programme.  Vérifiez les lignes: 802, 805. oce_if.c 802 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OCE_MAX_EQ 32 typedef struct oce_softc { .... OCE_INTR_INFO intrs[OCE_MAX_EQ]; .... } OCE_SOFTC, *POCE_SOFTC; static int oce_alloc_intr(POCE_SOFTC sc, int vector, void (*isr) (void *arg, int pending)) { POCE_INTR_INFO ii = &amp;sc-&gt;intrs[vector]; int rc = 0, rr; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (vector &gt;= OCE_MAX_EQ) return (EINVAL); .... }</span></span></code> </pre> <br>  L'analyseur a détecté qu'un élément du tableau <i>sc-&gt; intrs</i> était adressé par un index non valide, qui était hors limites.  La raison en est l'ordre incorrect des opérations dans le code.  Tout d'abord, l'élément est adressé, puis vient la vérification si la valeur d'index est valide. <br><br>  Certains pourraient dire qu'il n'y aura aucun problème.  Il ne supprime pas la valeur de l'élément de tableau, il prend simplement l'adresse de la cellule.  Mais non, ce n'est pas la façon de faire les choses.  En savoir plus: "Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">déréférencement de pointeur nul provoque un comportement indéfini</a> ". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V519</a> La variable se voit attribuer des valeurs deux fois de suite.  C'est peut-être une erreur.  Vérifiez les lignes: 199, 200. nvme_ctrlr.c 200 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nvme_ctrlr_set_intel_supported_features</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct nvme_ctrlr *ctrlr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> *supported_feature = ctrlr-&gt;feature_supported; supported_feature[NVME_INTEL_FEAT_MAX_LBA] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; supported_feature[NVME_INTEL_FEAT_MAX_LBA] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; supported_feature[NVME_INTEL_FEAT_NATIVE_MAX_LBA] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; supported_feature[NVME_INTEL_FEAT_POWER_GOVERNOR_SETTING] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; supported_feature[NVME_INTEL_FEAT_SMBUS_ADDRESS] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; supported_feature[NVME_INTEL_FEAT_LED_PATTERN] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; supported_feature[NVME_INTEL_FEAT_RESET_TIMED_WORKLOAD_COUNTERS] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; supported_feature[NVME_INTEL_FEAT_LATENCY_TRACKING] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  L'élément de tableau avec l'index <i>NVME_INTEL_FEAT_MAX_LBA</i> reçoit la même valeur.  La bonne nouvelle est que cette fonction présente toutes les constantes possibles, ce qui fait que ce code n'est que le résultat de la programmation du copier-coller.  Mais il y a des chances que des erreurs se faufilent ici. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V519</a> La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">variable</a> 'copiedPath [len]' reçoit des valeurs successives deux fois.  C'est peut-être une erreur.  Vérifiez les lignes: 92, 93. kernel_emu.cpp 93 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UserlandFS::KernelEmu::new_path(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *path, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **copy) { .... <span class="hljs-comment"><span class="hljs-comment">// append a dot, if desired if (appendDot) { copiedPath[len] = '.'; copiedPath[len] = '\0'; } .... }</span></span></code> </pre> <br>  Eh bien, ici, le programmeur n'a pas eu de chance avec la copie.  Le symbole "point" est ajouté à une ligne et est réécrit avec un terminal nul.  Il est fort probable que l'auteur ait simplement copié la ligne et oublié d'incrémenter l'index. <br><br><h2>  Des conditions étranges </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V517</a> L'utilisation du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modèle</a> 'if (A) {...} else if (A) {...}' a été détectée.  Il y a une probabilité de présence d'erreur logique.  Vérifiez les lignes: 1407, 1410. FindPanel.cpp 1407 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FindPanel::BuildAttrQuery(BQuery* query, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> &amp;dynamicDate) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> B_BOOL_TYPE: { uint32 value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (strcasecmp(textControl-&gt;Text(), <span class="hljs-string"><span class="hljs-string">"true"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { value = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (strcasecmp(textControl-&gt;Text(), <span class="hljs-string"><span class="hljs-string">"true"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { value = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> value = (uint32)atoi(textControl-&gt;Text()); value %= <span class="hljs-number"><span class="hljs-number">2</span></span>; query-&gt;PushUInt32(value); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... }</code> </pre> <br>  La copie du code a conduit à deux erreurs à la fois.  Les expressions conditionnelles sont identiques.  Très probablement, une comparaison avec la chaîne "false" au lieu de "true" doit être dans l'un d'eux.  Plus loin dans la branche qui gère la "fausse" valeur, la <i>valeur</i> qui doit être changée de <i>1</i> à <i>0</i> .  L'algorithme requiert que toute autre valeur, différente de <i>true</i> ou <i>false,</i> soit convertie en un nombre à l'aide de la fonction <i>atoi</i> .  Mais en raison d'une erreur, le texte "false" entrera dans la fonction. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V547 L'</a> expression 'error == ((int) 0)' est toujours vraie.  Directory.cpp 688 <br><br><pre> <code class="cpp hljs">int32 BDirectory::CountEntries() { <span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> error = Rewind(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error != B_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error; int32 count = <span class="hljs-number"><span class="hljs-number">0</span></span>; BPrivate::Storage::LongDirEntry entry; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (error == B_OK) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetNextDirents(&amp;entry, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(entry), <span class="hljs-number"><span class="hljs-number">1</span></span>) != <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(entry.d_name, <span class="hljs-string"><span class="hljs-string">"."</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(entry.d_name, <span class="hljs-string"><span class="hljs-string">".."</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) count++; } Rewind(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (error == B_OK ? count : error); }</code> </pre> <br>  L'analyseur a détecté que la valeur de la variable d' <i>erreur</i> sera toujours <i>B_OK</i> .  Très certainement, cette modification de variable a été manquée dans la boucle while. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V564</a> L'opérateur '&amp;' est appliqué à la valeur de type bool.  Vous avez probablement oublié d'inclure des parenthèses ou avez l'intention d'utiliser l'opérateur '&amp;&amp;'.  strtod.c 545 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lo0bits</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ULong *y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k; ULong x = *y; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(x &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>)) { k++; x &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!x &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= return 32; } *y = x; return k; }</span></span></code> </pre> <br>  Il est fort probable que dans la dernière expression conditionnelle, on ait oublié de placer des crochets, comme dans les conditions ci-dessus.  L'opérateur complémentaire est susceptible d'être en dehors des parenthèses: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(x &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= return 32;</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V590</a> Envisagez d'inspecter cette expression.  L'expression est excessive ou contient une erreur d'impression.  PoseView.cpp 5851 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BPoseView::AttributeChanged(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BMessage* message) { .... result = poseModel-&gt;OpenNode(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == B_OK || result != B_BUSY) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br>  Ce n'est pas évident, mais le résultat de la condition ne dépend pas de la valeur de la valeur B_OK.  Cela peut donc être simplifié: <br><br><pre> <code class="cpp hljs">If (result != B_BUSY) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre> <br>  Vous pouvez facilement le vérifier en dessinant une table de vérité pour les valeurs de la variable de <i>résultat</i> .  Si l'on voulait considérer spécifiquement d'autres valeurs, différentes de <i>B_OK</i> et <i>B_BUSY</i> , le code devrait être réécrit d'une autre manière. <br><br>  Deux autres fragments similaires: <br><br><ul><li>  V590 Envisagez d'inspecter cette expression.  L'expression est excessive ou contient une erreur d'impression.  Tracker.cpp 1714 </li><li>  V590 Envisagez d'inspecter cette expression.  L'expression est excessive ou contient une erreur d'impression.  if_ipw.c 1871 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V590</a> Envisagez d'inspecter le 'argc == 0 ||  argc! = expression 2 '.  L'expression est excessive ou contient une erreur d'impression.  cmds.c 2667 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsetoption</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argc == <span class="hljs-number"><span class="hljs-number">0</span></span> || argc != <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(ttyout, <span class="hljs-string"><span class="hljs-string">"usage: %s option\n"</span></span>, argv[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  C'est peut-être l'exemple le plus simple qui démontre le travail du diagnostic <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V590</a> .  Vous devez afficher la description du programme au cas où aucun argument n'est passé ou s'il n'y en a pas deux.  De toute évidence, toute valeur autre que deux, y compris zéro, ne satisfera pas la condition.  Par conséquent, la condition peut être simplifiée en toute sécurité à ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argc != <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(ttyout, <span class="hljs-string"><span class="hljs-string">"usage: %s option\n"</span></span>, argv[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V590</a> Pensez à inspecter le '* ptr =='; '  &amp;&amp; * ptr! = expression '\ 0' '.  L'expression est excessive ou contient une erreur d'impression.  pc.c 316 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ULONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_expression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str)</span></span></span><span class="hljs-function"> </span></span>{ .... ptr = skipwhite(ptr); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (*ptr == SEMI_COLON &amp;&amp; *ptr != <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) { ptr++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*ptr == <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; val = assignment_expr(&amp;ptr); } .... }</code> </pre> <br>  Dans cet exemple, l'opérateur logique a été modifié, mais la logique est toujours la même.  Ici, la condition de la boucle while dépend uniquement de si le caractère est égal à <i>SEMI_COLON</i> ou non. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V590</a> Envisagez d'inspecter cette expression.  L'expression est excessive ou contient une erreur d'impression.  writembr.cpp 99 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> choice; getline(<span class="hljs-built_in"><span class="hljs-built_in">cin</span></span>, choice, <span class="hljs-string"><span class="hljs-string">'\n'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (choice == <span class="hljs-string"><span class="hljs-string">"no"</span></span> || choice == <span class="hljs-string"><span class="hljs-string">""</span></span> || choice != <span class="hljs-string"><span class="hljs-string">"yes"</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"MBR was NOT written"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; fs.close(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> B_ERROR; } .... }</code> </pre> <br>  Il y a déjà trois conditions dans cet exemple.  Il peut également être simplifié avant de vérifier si l'utilisateur a choisi "oui" ou non: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (choice != <span class="hljs-string"><span class="hljs-string">"yes"</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"MBR was NOT written"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; fs.close(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> B_ERROR; }</code> </pre> <br><h2>  Divers </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V530</a> La valeur de retour de la fonction 'begin' doit être utilisée.  IMAPFolder.cpp 414 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IMAPFolder::RegisterPendingBodies(...., <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BMessenger* replyTo) { .... IMAP::MessageUIDList::const_iterator iterator = uids.begin(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; iterator != uids.end(); iterator++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (replyTo != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) fPendingBodies[*iterator].push_back(*replyTo); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fPendingBodies[*iterator].begin(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } }</span></span></code> </pre> <br>  L'analyseur a trouvé un appel inutile de l'itérateur <i>begin ().</i>  Je ne peux pas imaginer comment réparer le code.  Les développeurs doivent faire attention à ce code. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V609</a> Divisez par zéro.  Plage de dénominateurs [0..64].  UiUtils.cpp 544 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> int32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSIMDFormatByteSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint32 format)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (format) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SIMD_RENDER_FORMAT_INT8: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SIMD_RENDER_FORMAT_INT16: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(int16); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SIMD_RENDER_FORMAT_INT32: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(int32); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SIMD_RENDER_FORMAT_INT64: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(int64); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SIMD_RENDER_FORMAT_FLOAT: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SIMD_RENDER_FORMAT_DOUBLE: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BString&amp; UiUtils::FormatSIMDValue(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BVariant&amp; value, uint32 bitSize, uint32 format, BString&amp; _output) { _output.SetTo(<span class="hljs-string"><span class="hljs-string">"{"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* data = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)value.ToPointer(); uint32 count = bitSize / (GetSIMDFormatByteSize(format) * <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  La fonction <i>GetSIMDFormatByteSize</i> renvoie vraiment <i>0</i> comme valeur par défaut, ce qui pourrait potentiellement conduire à une division par zéro. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V654</a> La condition 'specificSequence! = Sequence' de la boucle est toujours fausse.  pthread_key.cpp 55 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_key_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pthread_thread* thread, uint32 key, int32 sequence)</span></span></span><span class="hljs-function"> </span></span>{ pthread_key_data&amp; keyData = thread-&gt;specific[key]; int32 specificSequence; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* value; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { specificSequence = keyData.sequence; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (specificSequence != sequence) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; value = keyData.value; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (specificSequence != sequence); keyData.value = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; }</code> </pre> <br>  L'analyseur a raison de dire que la condition de l'opérateur <i>while</i> est toujours fausse.  Pour cette raison, la boucle n'exécute pas plus d'une itération.  En d'autres termes, rien ne changerait si vous écriviez <i>while (0)</i> .  Tout cela est bizarre et ce code contient une erreur logique.  Les développeurs doivent examiner attentivement cet extrait. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V672</a> Il n'est probablement pas nécessaire de créer ici la nouvelle variable 'path'.  Un des arguments de la fonction possède le même nom et cet argument est une référence.  Vérifier les lignes: 348, 429. translate.cpp 429 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> Translator::FindPath(...., TypeList &amp;path, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> &amp;pathQuality) { .... TypeList path; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> quality; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FindPath(&amp;formats[j], stream, typesSeen, path, quality) == B_OK) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bestQuality &lt; quality * formatQuality) { bestQuality = quality * formatQuality; bestPath.SetTo(path); bestPath.Add(formats[j].type); status = B_OK; } } .... }</code> </pre> <br>  La variable <i>path</i> est transmise à la fonction <i>FindPath</i> par référence.  Ce qui signifie que cette variable peut être modifiée dans le corps de la fonction.  Mais il existe une variable locale du même nom, qui est modifiée.  Dans ce cas, toutes les modifications resteront uniquement dans la variable locale.  L'auteur du code peut vouloir renommer ou supprimer la variable locale. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V705</a> Il est possible que le bloc "else" ait été oublié ou commenté, altérant ainsi la logique de fonctionnement du programme.  HostnameView.cpp 109 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> HostnameView::_LoadHostname() { BString fHostnameString; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> hostname[MAXHOSTNAMELEN]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gethostname(hostname, MAXHOSTNAMELEN) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { fHostnameString.SetTo(hostname, MAXHOSTNAMELEN); fHostname-&gt;SetText(fHostnameString); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> B_OK; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> B_ERROR; }</code> </pre> <br>  L'exemple d'une mauvaise mise en forme du code.  Le mot-clé "suspendu" <i>else</i> ne change pas encore la logique, mais une fois qu'un fragment de code est inséré avant l'opérateur de <i>retour</i> , la logique ne sera plus la même. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V763 Le</a> «menu» des paramètres est toujours réécrit dans le corps de la fonction avant d'être utilisé.  video.cpp 648 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">video_mode_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Menu *menu, MenuItem *item)</span></span></span><span class="hljs-function"> </span></span>{ video_mode *mode = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; menu = item-&gt;Submenu(); item = menu-&gt;FindMarked(); .... }</code> </pre> <br>  J'ai trouvé de nombreux cas où les arguments de fonction sont réécrits en entrant dans la fonction.  Ce comportement induit en erreur les autres développeurs qui appellent ces mêmes fonctions. <br><br>  La liste complète des endroits suspects: <br><br><ul><li>  V763 Le paramètre 'force_16bit' est toujours réécrit dans le corps de la fonction avant d'être utilisé.  ata_adapter.cpp 151 </li><li>  V763 Le paramètre 'force_16bit' est toujours réécrit dans le corps de la fonction avant d'être utilisé.  ata_adapter.cpp 179 </li><li>  V763 Le «menu» des paramètres est toujours réécrit dans le corps de la fonction avant d'être utilisé.  video.cpp 264 </li><li>  V763 La «longueur» du paramètre est toujours réécrite dans le corps de la fonction avant d'être utilisée.  MailMessage.cpp 677 </li><li>  V763 L'entrée de paramètre est toujours réécrite dans le corps de la fonction avant d'être utilisée.  IconCache.cpp 773 </li><li>  V763 L'entrée de paramètre est toujours réécrite dans le corps de la fonction avant d'être utilisée.  IconCache.cpp 832 </li><li>  V763 L'entrée de paramètre est toujours réécrite dans le corps de la fonction avant d'être utilisée.  IconCache.cpp 864 </li><li>  V763 Le paramètre 'rect' est toujours réécrit dans le corps de la fonction avant d'être utilisé.  ErrorLogWindow.cpp 56 </li><li>  V763 Le paramètre 'updateRect' est toujours réécrit dans le corps de la fonction avant d'être utilisé.  CalendarMenuWindow.cpp 49 </li><li>  V763 Le paramètre 'rect' est toujours réécrit dans le corps de la fonction avant d'être utilisé.  MemoryView.cpp 165 </li><li>  V763 Le paramètre 'rect' est toujours réécrit dans le corps de la fonction avant d'être utilisé.  TypeEditors.cpp 1124 </li><li>  V763 Le paramètre 'hauteur' est toujours réécrit dans le corps de la fonction avant d'être utilisé.  Workspaces.cpp 857 </li><li>  V763 Le paramètre 'largeur' est toujours réécrit dans le corps de la fonction avant d'être utilisé.  Workspaces.cpp 856 </li><li>  V763 Le «cadre» du paramètre est toujours réécrit dans le corps de la fonction avant d'être utilisé.  SwatchGroup.cpp 48 </li><li>  V763 Le «cadre» du paramètre est toujours réécrit dans le corps de la fonction avant d'être utilisé.  PlaylistWindow.cpp 89 </li><li>  V763 Le paramètre 'rect' est toujours réécrit dans le corps de la fonction avant d'être utilisé.  ConfigView.cpp 78 </li><li>  V763 Le paramètre 'm' est toujours réécrit dans le corps de la fonction avant d'être utilisé.  mkntfs.c 3917 </li><li>  V763 Le paramètre 'rxchainmask' est toujours réécrit dans le corps de la fonction avant d'être utilisé.  ar5416_cal.c 463 </li><li>  V763 Le paramètre 'c' est toujours réécrit dans le corps de la fonction avant d'être utilisé.  if_iwn.c 6854 </li></ul><br><h2>  Conclusion </h2><br>  Le projet Haiku est une source d'erreurs intéressantes et rares.  Nous avons ajouté à notre base de données quelques exemples d'erreur et corrigé quelques problèmes d'analyseur qui se présentaient lors de l'analyse du code. <br><br>  Si vous n'avez pas vérifié votre code avec des outils d'analyse de code depuis longtemps, certains des problèmes que j'ai décrits se cachent probablement dans votre code.  Utilisez PVS-Studio dans votre projet (s'il est écrit en C, C ++, C # ou Java) pour contrôler la qualité du code.  Téléchargez l'analyseur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> sans inscription ni sms. <br><br>  Voulez-vous essayer Haiku et vous avez des questions?  Les développeurs de Haiku vous invitent sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">canal télégramme</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461517/">https://habr.com/ru/post/fr461517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461503/index.html">Rendre la base de données disponible pour une connexion à distance</a></li>
<li><a href="../fr461505/index.html">8 bugs de développeurs JavaScript novices qui vous empêchent de devenir un professionnel</a></li>
<li><a href="../fr461507/index.html">Pourquoi avons-nous décidé de lancer l'accélérateur d'entreprise Gazprom Neft StartupDrive, et qui l'a déjà adopté</a></li>
<li><a href="../fr461509/index.html">Assistants de voyage: une sélection de gadgets et accessoires</a></li>
<li><a href="../fr461511/index.html">Gestion des dépendances Python: une comparaison des approches</a></li>
<li><a href="../fr461519/index.html">Meilleurs algorithmes de copier-coller pour C et C ++. Collection de recettes Haiku OS</a></li>
<li><a href="../fr461523/index.html">WAL dans PostgreSQL: 4. Configuration du journal</a></li>
<li><a href="../fr461525/index.html">Comment j'ai fait un curseur vraiment adaptatif (carrousel)</a></li>
<li><a href="../fr461527/index.html">Lévitation acoustique bricolage</a></li>
<li><a href="../fr461531/index.html">Tic Tac Toe, Partie 6: Flacon et céleri / RabbitMQ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>