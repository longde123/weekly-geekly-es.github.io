<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🍳 🤹🏻 👩🏼‍💻 概念：简化STD Utility类的实现 🔴 👩🏾‍🤝‍👨🏿 👴🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ 20中出现的概念是一个长期且广泛讨论的主题。 尽管这些年来积累了过多的材料（包括世界一流专家的演讲），但应用程序程序员（他们每天都不睡着使用标准）仍然感到困惑，C ++ 20概念是什么？我们需要多年来是否检查过enable_if。 部分原因是概念在大约15年的时间内是如何演变的（概念完整+...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>概念：简化STD Utility类的实现</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/467299/"><p><img src="https://habrastorage.org/webt/et/c4/ir/etc4ir2odcs1wv10o5jcu0yneng.jpeg"></p><br><p>  C ++ 20中出现的概念是一个长期且广泛讨论的主题。 尽管这些年来积累了过多的材料（包括世界一流专家的演讲），但应用程序程序员（他们每天都不睡着使用标准）仍然感到困惑，C ++ 20概念是什么？我们需要多年来是否检查过enable_if。 部分原因是概念在大约15年的时间内是如何演变的（概念完整+概念图-&gt;概念精简版），部分原因是这些概念与其他语言中的类似工具（Java / C＃通用范围，Rust trait）不同。 ..）。 </p><br><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++ Russia 2019</a>大会的ReSharper C ++团队的Andrey Davydov的报告的剪辑片段和录像带下。  Andrey简要回顾了C ++ 20的概念相关创新，之后他通过比较C ++ 17和C ++ 20解决方案，研究了STL的某些类和功能的实现。 这个故事进一步代表了他。 </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/vYzjV0xSqJE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> 谈论概念。 这是一个相当复杂和广泛的主题，因此在准备报告时，我遇到了一些困难。 我决定转向C ++社区<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Andrei Alexandrescu</a>最好的发言人之一的经验。 </p><br><p>  2018年11月，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">会议C ++</a>开幕式上，安德烈（Andrei）向听众询问了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++</a>的下一个主要功能是什么： </p><br><ul><li> 概念 </li><li> 元类 </li><li> 还是内省？ </li></ul><br><p> 让我们从这个问题开始。 您认为C ++的下一个重要功能是概念吗？ </p><br><p> 根据Alexandrescu所说，概念很无聊。 我建议您这样做很无聊。 而且，我仍然不能像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Herb Sutter</a>这样的元类或者像Alexandrescu这样的内省那样有趣而激烈地谈论。 </p><br><p> 当我们谈论C ++ 20中的概念时，我们指的是什么？ 至少从2003年开始就对该功能进行了讨论，在此期间，它已经有了很大的发展。 让我们看看C ++ 20中出现了哪些与新概念相关的功能。 </p><br><p>由<code>concept</code>关键字定义了一个称为“ concepts”的新实体。 这是模板参数的谓词。 看起来像这样： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept NoThrowDefaultConstructible = noexept(T{}); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> From, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> To&gt; concept Assignable = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_assignable_v&lt;From, To&gt;</code> </pre> <br><p> 我不仅使用了“在模板参数上”一词，还没有在“类型上”一词，因为可以在非标准模板参数上定义概念。 如果您根本无事可做，则可以为数字定义一个概念： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> I&gt; concept Even = I % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p> 但是混合使用典型的和非典型的模板参数更有意义。 如果类型的大小和对齐方式不超过指定的限制，则将其称为小类型： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> MaxSize, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> MaxAlign&gt; concept Small = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T) &lt;= MaxSize &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">alignof</span></span>(T) &lt;= MaxAlign;</code> </pre> <br><p> 可能尚不明确，为什么我们需要用这种语言围起一个新实体，以及为什么这个概念不仅仅是<code>constexpr bool</code>变量。 </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  `concept`    ? #define concept constexpr bool</span></span></code> </pre> <br><h1 id="kak-ispolzuyutsya-koncepty"> 如何使用概念？ </h1><br><p> 要了解，让我们看看如何使用概念。 </p><br><p> 首先，就像<code>constexpr bool</code>变量一样，它们可以在编译时需要布尔表达式的任何地方使用。 例如，在<code>static_assert</code>内部或<code>noexcept</code>内部 <br> 规格： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// bool expression evaluated in compile-time static_assert(Assignable&lt;float, int&gt;); template&lt;typename T&gt; void test() noexcept(NothrowDefaultConstructible&lt;T&gt;) { T t; ... }</span></span></code> </pre> <br><p> 其次，在定义模板参数时，可以使用概念代替<code>typename</code>或<code>class</code>关键字。 定义一个简单的<code>optional</code>类，该类将简单地存储一对<code>initialized</code>的布尔值和值。 自然，此类<code>optional</code>仅适用于琐碎的类型。 因此，我们在这里编写<code>Trivial</code>东西，当我们尝试从非琐碎的东西实例化时，例如从<code>std::string</code>实例化时，将出现编译错误： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  type-parameter-key (class, typename) template&lt;Trivial T&gt; class simple_optional { T value; bool initialized = false; ... };</span></span></code> </pre> <br><p> 概念可以部分应用。 例如，我们使用小缓冲区优化来实现我们的<code>any</code>类。 使用固定的<code>Size</code>和<code>Alignment</code>定义<code>SB</code>结构（小缓冲区），我们将<code>SB</code>并集和指针存储在堆上。 现在，如果在构造函数中使用小类型，则可以将其放入<code>SB</code> 。 为了确定类型是小类型，我们写道它满足<code>Small</code>的概念。  <code>Small</code>概念使用了3个模板参数：我们定义了两个，并从一个模板参数得到了一个函数： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   class any { struct SB { static constexpr size_t Size = ...; static constexpr size_t Alignment = ...; aligned_storage_t&lt;Size, Alignment&gt; storage; }; union { SB sb; void* handle; }; template&lt;Small&lt;SB::Size, SB::Alignment&gt; T&gt; any(T const &amp; t) : sb(...) ... };</span></span></code> </pre> <br><p> 记录较短。 我们在<code>auto</code>之前写出模板参数的名称，可能带有一些参数。 前面的示例以这种方式重写： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Terse syntax (  auto) class any { struct SB { static constexpr size_t Size = ...; static constexpr size_t Alignment = ...; aligned_storage_t&lt;Size, Alignment&gt; storage; }; union { SB sb; void* handle; }; any(Small&lt;SB::Size, SB::Alignment&gt; auto const &amp; t) : sb(...) ... };</span></span></code> </pre> <br><p> 可能在我们编写<code>auto</code>任何地方，现在您都可以在概念的前面写下它的名称。 </p><br><p> 定义<code>get_handle</code>函数，该函数返回对象的某些<code>handle</code> 。 <br> 我们假设小对象本身是<code>handle</code> ，而对于大对象，指向它们的指针是<code>handle</code> 。 因为<code>if constexpr</code>表示不同类型的表达式，我们有两个分支，所以对我们来说，不显式指定此函数的类型而是要求编译器输出它是方便的。 但是，如果我们仅<code>auto</code> ，我们将丢失指示值较小的信息，该值不会超出指针： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Terse syntax (  auto) template&lt;typename T&gt; concept LEPtr = Small&lt;T, sizeof(void *), alignof(void *)&gt;; template&lt;typename T&gt; auto get_handle(T&amp; object) { if constexpr (LEPtr&lt;T&gt;) return object; else return &amp;object; }</span></span></code> </pre> <br><p> 在C ++ 20中，可以在它之前写出它不仅是<code>auto</code> ，而且是有限制的<code>auto</code> ： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Terse syntax (  auto) template&lt;typename T&gt; concept LEPtr = Small&lt;T, sizeof(void *), alignof(void *)&gt;; template&lt;typename T&gt; LEPtr auto get_handle(T &amp;object) { if constexpr (LEPtr&lt;T&gt;) return object; else return &amp;object; }</span></span></code> </pre> <br><h1 id="requires-expression"> 需要表达 </h1><br><p> 需要expression是整个expressionov族，它们都是<code>bool</code>类型，并且在编译时计算。 它们用于测试有关表达式和类型的语句。 需要表达对于定义概念非常有用。 </p><br><p>  <code>Constructible</code>示例。 我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以前的报告中的</a>那些人已经见过他： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; concept Constructible = requires(Args... args) { T{args...} };</code> </pre> <br><p> 并以<code>Comparable</code>为例。 假设如果可以使用“较少”运算符<code>Comparable</code>两个类型为<code>T</code>对象，并且结果转换为<code>bool</code> ，则类型<code>T</code>是可比较的。 此箭头及其后面的类型表示类型表达式已转换为<code>bool</code> ，而不是等于<code>bool</code> ： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept Comparable = requires(T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; a, T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; b) { {a &lt; b} -&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>; };</code> </pre> <br><p> 我们研究的内容已经足够显示出概念使用的完整示例。 </p><br><p> 我们已经有一个<code>Comparable</code>概念，让我们为迭代器定义概念。 假设<code>RandomAccessIterator</code>是<code>BidirectionalIterator</code>和其他一些属性。 这样，我们定义了<code>Sortable</code>的概念。 如果可以比较<code>Range</code>的<code>RandomAccess</code>迭代器及其元素，则将<code>Range</code>称为<code>Sortable</code> 。 现在我们可以编写一个<code>sort</code>函数，该函数不仅接受该函数，还接受<code>Sortable Range</code> ： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// concepts,    ++20 template&lt;typename Iterator&gt; concept RandomAccessIterator = BidirectionalIterator&lt;Iterator&gt; &amp;&amp; ...; template&lt;typename R&gt; concept Sortable = RandomAccessIterator&lt;Iterator&lt;R&gt;&gt; &amp;&amp; Comparable&lt;ValueType&lt;R&gt;&gt;; template&lt;Sortable Range&gt; void sort(Range &amp;) {...}</span></span></code> </pre> <br><p> 现在，如果我们尝试从不满足<code>Sortable</code>概念的对象中调用此函数，则会从编译器收到一条清晰的消息，指出对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SFINAE友好</a>的良好错误。 让我们尝试<code>std::list</code>无法比较的元素<code>std::list</code> '或向量来实例化<code>std::list</code> ： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//concepts,    ++20,  struct X {}; void test() { vector&lt;int&gt; vi; sort(vi); // OK list &lt;int&gt; li; sort(li); // Fail, list&lt;int&gt;::iterator is not random access vector&lt; X &gt; vx; sort(vx); // Fail, X is not Comparable }</span></span></code> </pre> <br><p> 您是否已经看过使用概念或类似内容的类似示例？ 我已经看过几次了。 老实说，它根本没有说服我。 如果我们可以在C ++ 17中获得它，是否需要用这种语言来限制这么多新实体？ </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//concepts,    ++17 #define concept constexpr bool template&lt;typename T&gt; concept Comparable = is_convertible_v&lt; decltype(declval&lt;T const &amp;&gt;() &lt; declval&lt;T const &amp;&gt;()), bool &gt;; template&lt;typename Iterator&gt; concept RandomAccessIterator = BidirectionalIterator&lt;Iterator&gt; &amp;&amp; ...; template&lt;typename R&gt; concept Sortable = RandomAccessIterator&lt;Iterator&lt;R&gt;&gt; &amp;&amp; Comparable&lt;ValueType&lt;R&gt;&gt;; template&lt;typename Range, typename = enable_if_t&lt;Sortable&lt;Range&gt;&gt;&gt; void sort(Range &amp;) { ... }</span></span></code> </pre> <br><p> 我<code>concept</code>宏输入了关键字<code>concept</code> ，并且<code>Comparable</code>以此方式进行了重写。 它变得有些丑陋，这向我们暗示要求表达确实是有用且方便的事情。 因此，我们定义了<code>Sortable</code>的概念，并使用<code>enable_if</code>表示<code>sort</code>函数接受<code>Sortable Range</code> 。 </p><br><p> 您可能会认为，根据编译错误消息，此方法会损失很多，但是，实际上，这与编译器实现的质量有关。 假设Clang在这个主题上大惊小怪，特别是跳过了如果您用<code>enable_if</code>替换了第一个参数 <br> 如果计算为<code>false</code> ，则他们会出现此错误，因此不满足此要求。 </p><br><p> 上面的示例似乎是通过概念编写的。 我有一个假设：此示例没有定论，因为它没有使用概念的主要功能-require子句。 </p><br><h1 id="requires-clause"> 要求条款 </h1><br><p>  Requires子句几乎挂在任何模板声明或非模板函数上。 从语法上讲，这看起来像<code>requires</code>关键字，后跟一些布尔表达式。 为了筛选出模板特化或重载候选，这是必需的，也就是说，它与SFINAE的工作方式相同，只能正确完成，而不能被黑客入侵： </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// requires-clause template&lt;typename R&gt; concept Sortable = RandomAccessIterator&lt;Iterator&lt;R&gt;&gt; &amp;&amp; Comparable&lt;ValueType&lt;R&gt;&gt;; template&lt;Sortable Range&gt; void sort(Range &amp;) { ... }</span></span></code> </pre> <br><p> 在排序后的示例中，我们可以在哪里使用require子句？ 我们使用以下代码代替应用概念的简短语法： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R&gt; concept Sortable = RandomAccessIterator&lt;Iterator&lt;R&gt;&gt; &amp;&amp; Comparable&lt;ValueType&lt;R&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Range&gt; requires Sortable&lt;Range&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Range &amp;)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p> 似乎代码变得越来越差，变得越来越大。 但是现在我们可以摆脱<code>Sortable</code>概念了。 在我看来，这是一种改进，因为<code>Sortable</code>概念<code>Sortable</code>重言式的：我们将可以传递给<code>sort</code>函数的所有东西都称为<code>Sortable</code> 。 这没有物理意义。 我们以这种方式重写代码： </p><br><pre> <code class="plaintext hljs">//template&lt;typename R&gt; concept Sortable // = RandomAccessIterator&lt;Iterator&lt;R&gt;&gt; &amp;&amp; Comparable&lt;ValueType&lt;R&gt;&gt;; template&lt;typename Range&gt; requires RandomAccessIterator&lt;Iterator&lt;Range&gt;&gt; &amp;&amp; Comparable&lt;ValueType&lt;Range&gt;&gt;; void sort(Range &amp;) { ... }</code> </pre> <br><h1 id="itogovyy-spisok-concept-related-fich"> 概念相关功能的摘要列表 </h1><br><p>  C ++ 20中与概念相关的创新的列表如下所示。 从我的主观角度来看，此列表中的项目是通过增加功能的实用性进行排序的： </p><br><ul><li> 新的实体<code>concept</code> 。 在我看来，可以通过给<code>constexpr bool</code>变量赋予附加的语义来消除<code>concept</code>实质。 </li><li> 应用概念的特殊语法。 当然，这很令人愉快，但这只是语法。 如果C ++程序员害怕语法错误，他们早就因恐惧而死。 </li><li> 需要表达确实是一件很酷的事情，不仅对定义概念有用。 </li><li>  Requires子句是概念的最大价值，它使您可以忘记SFINAE和其他C ++模板的传奇恐怖。 </li></ul><br><h1 id="podrobnee-o-requires-expression"> 更多内容需要表达 </h1><br><p> 在我们进入对require子句的讨论之前，请先介绍一下require表达式。 </p><br><p> 首先，它们不仅可以用于定义概念。 从远古时代开始，Microsoft编译器的扩展名为<code>__if_exists</code> <code>__if_not_exists</code> 。 它允许编译时验证名称的存在，并根据此启用或禁用代码块的编译。 在几年前使用的代码库中，就是这样。 有一个函数<code>f()</code> ，它获取模板类型的一个点，并从该点开始获取高度。 它可以通过三维或二维点实例化。 对于三维，我们将<code>z</code>坐标视为高度，对于二维，我们转向特殊的表面传感器。 看起来像这样： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y, z; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Point&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h; __if_exists(Point::z) { h = pz; } __if_not_exists(Point::z) { h = sensor.get_height(p); } }</code> </pre> <br><p> 在C ++ 20中，我们无需使用标准代码使用编译器扩展就可以重写此代码。 在我看来，情况并没有恶化： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y, z; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Point&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(requires { Point::z; })</span></span></span><span class="hljs-function"> h </span></span>= pz; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> h = sensor.get_height(p); }</code> </pre> <br><p> 第二点是您需要警惕需要表达的语法。 <br> 它们非常强大，通过引入许多新的句法结构可以实现这种功能。 至少在一开始，您可能会对它们感到困惑。 </p><br><p> 让我们定义一个<code>Sizable</code>概念，该概念检查容器是否具有返回<code>size_t</code>的恒定方法<code>size</code> 。 我们自然希望<code>vector&lt;int&gt;</code>是<code>Sizable</code> ，但是<code>static_assert</code> 。 您了解我们为什么有错误吗？ 为什么此代码无法编译？ </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Container&gt; concept Sizable = requires(Container <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; c) { c.size() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(Sizable&lt;<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-comment"><span class="hljs-comment">// Fail</span></span></code> </pre> <br><p> 让我向您展示编译的代码。 这样的<code>X</code>类满足<code>Sizable</code>概念。 现在您了解我们有什么问题吗？ </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>; }; <span class="hljs-function"><span class="hljs-function">Inner* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(Sizable&lt;X&gt;); <span class="hljs-comment"><span class="hljs-comment">// OK</span></span></code> </pre> <br><p> 让我修复突出显示的代码。 左边的代码是我想要的颜色。 但实际上，它应该画在右边： </p><br><p><img src="https://habrastorage.org/webt/mu/ht/l2/muhtl2zbr7nbutf7an8or2qjhse.jpeg"></p><br><p> 看到，站在箭头后面的<code>size_t</code>的颜色已经改变了吗？ 我希望它是一种类型，但这只是我们正在访问的字段。 我们需要表达的所有内容都是一个大表达，我们检查它的正确性。 对于类型<code>X</code> ，是，这是一个有效的表达式；对于<code>vector&lt;int&gt;</code> ，否。 为了实现我们想要的，我们需要将花括号括起来： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Container&gt; concept Sizable = requires(Container <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; c) { {c.size()} -&gt; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(Sizable&lt;<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-comment"><span class="hljs-comment">// OK struct X { struct Inner { int size_t; }; Inner* size() const; }; static_assert(Sizable&lt;X&gt;); // Fail</span></span></code> </pre> <br><p> 但这只是一个有趣的例子。 通常，您只需要小心。 </p><br><h1 id="primery-ispolzovaniya-konceptov"> 使用概念的例子 </h1><br><h2 id="realizaciya-klassa-pair"> 配对类的实现 </h2><br><p> 此外，我将演示一些可以在C ++ 17中实现的STL片段，但相当麻烦。 <br> 然后我们将看到在C ++ 20中我们如何改进实现。 </p><br><p> 让我们从<code>pair</code>类开始。 <br> 这是一个非常古老的类，它仍然在C ++ 98中。 <br> 它不包含任何复杂的逻辑，因此 <br> 我希望他的定义看起来像这样。 <br> 从我的角度来看，它应该大致在此结束： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; ... };</code> </pre> <br><p> 但是，根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cppreference</a> ，一<code>pair</code>设计师只有8件。 <br> 而且，如果您查看实际的实现（例如，在Microsoft STL中），那么<code>pair</code>类的构造器将多达15个。 我们不会看所有这些功能并将自己局限于默认构造函数。 </p><br><p> 看来这很复杂？ 首先，我们了解为什么需要它。 我们想要的是， <code>pair</code>类的参数之一是微不足道的类型，例如<code>int</code> ，那么在构造<code>pair</code>类之后，它会初始化为零，并且不会保持未初始化状态。 为此，我们要编写一个构造函数，该构造函数调用字段<code>f</code> （第一）和<code>s</code> （第二）的值初始化。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; pair() : f() , s() {} };</code> </pre> <br><p> 不幸的是，如果我们尝试从没有默认构造函数的实例中实例化一<code>pair</code> ，例如从此类<code></code>实例化，我们会立即收到编译错误。 理想的行为是，如果尝试构造<code>pair</code> ，则默认值为编译错误，但是如果我们显式传递<code>f</code>和<code>s</code>的值，则一切都会起作用： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> A(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); }; pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, A&gt; a2; <span class="hljs-comment"><span class="hljs-comment">// must fail pair&lt;int, A&gt; a1; { 1, 2 }; // must be OK</span></span></code> </pre> <br><p> 为此，将默认构造函数设为模板并将其限制为SFINAE。 <br> 让我们想到的第一个想法是让我们编写，以便仅当<code>f</code>和<code>s</code>为<code>is_default_constructable</code>时才允许使用此构造函数： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;conjunction_v&lt; is_default_constructible&lt;F&gt;, <span class="hljs-comment"><span class="hljs-comment">// not dependent is_default_constructible&lt;S&gt; &gt;&gt;&gt; pair() : f(), s() {} };</span></span></code> </pre> <br><p> 这将不起作用，因为<code>enable_if_t</code>参数仅取决于类的模板参数。 即，在替换类别之后，它们变得独立，可以立即对其进行计算。 但是，如果分别得到<code>false</code> ，则会再次遇到硬编译器错误。 </p><br><p> 为了克服这个问题，让我们向此构造函数添加更多模板参数，并使条件<code>enable_if_t</code>依赖于这些模板参数： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T = F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U = S, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;conjunction_v&lt; is_default_constructible&lt;T&gt;, is_default_constructible&lt;U&gt; &gt;&gt;&gt; pair() : f(), s() {} };</code> </pre> <br><p> 情况很可笑。 事实是模板参数<code>T</code>和<code>U</code>不能由用户明确设置。 在C ++中，没有语法来显式设置构造函数的模板参数；它们不能由编译器输出，因为它无处可显示。 它们只能来自默认值。 也就是说，该代码实际上与前面示例中的代码没有区别。 但是，从编译器的角度来看，它是有效的，但在前面的示例中无效。 </p><br><p> 我们解决了第一个问题，但又遇到了第二个问题。 假设我们有一个带有显式默认构造函数的类<code>B</code> ，并且我们想隐式构造<code>pair&lt;int, B&gt;</code> ： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }; pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, B&gt; p = {};</code> </pre> <br><p> 我们可以做到，但是按照标准，它不可行。 按照标准，只有当两个元素的两个元素都被隐式默认为构造时，才应将其隐式默认为构造。 </p><br><p> 问题：我们是否需要编写显式对的构造函数？ 在C ++ 17中，我们有一个Solomon解决方案：让我们这样写。 </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T = F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U = S, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;conjunction_v&lt; is_default_constructible&lt;T&gt;, is_default_constructible&lt;U&gt;, is_implicity_default_constructible&lt;T&gt;, is_implicity_default_constructible&lt;U&gt; &gt;&gt;&gt; pair() : f(), s() {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;...&gt; <span class="hljs-keyword"><span class="hljs-keyword">explicit</span></span> pair() : f(), s() {} };</code> </pre> <br><p> 现在我们有两个默认的构造函数： </p><br><ul><li> 当元素隐式默认可构造时，我们将根据SFINAE切断其中之一； </li><li> 第二种情况则相反。 </li></ul><br><p> 顺便说一下，要在C ++ 17中实现trait <code>is_implicitly_default_constructible</code>类型，我知道这样的解决方案，但是如果没有SFINAE，我不知道解决方案： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typrname T&gt; <span class="hljs-function"><span class="hljs-function">true_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typrname T&gt; <span class="hljs-function"><span class="hljs-function">false_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ...)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;typrname T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> is_implicity_default_constructible = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(test&lt;T&gt;({}, <span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre> <br><p> 如果现在尝试隐式构造<code>pair &lt;int, B&gt;</code> ，则将得到编译错误，如下所示： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;..., <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;conjuction_v&lt; is_default_constructible&lt;T&gt;, is_default_constructible&lt;U&gt;, is_implicity_default_constructible&lt;T&gt;, is_implicity_default_constructible&lt;U&gt; &gt;&gt;&gt; ... pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, B&gt; p = {}; ... candidate <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> ignored: requirement <span class="hljs-string"><span class="hljs-string">'conjunction_v&lt; is_default_constructible&lt;int&gt;, is_default_constructible&lt;B&gt;, is_implicity_default_constructible&lt;int&gt;, is_implicity_default_constructible&lt;B&gt; &gt;'</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> satisfied [with T=<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, U=B]</code> </pre> <br><p> 在不同的编译器中，此错误将具有不同程度的可理解性。 例如，在这种情况下，Microsoft编译器说：“不可能从空的大括号构造成对<code>&lt;int, B&gt;</code> 。”  GCC和Clang会补充说：“我们尝试了这样的构造函数，没有一个出现过，”他们将说出各自的理由。 </p><br><p> 我们在这里有什么设计师？ 复制和移动编译器生成了一些构造函数；有些是我们编写的。 使用复制和移动，一切都很简单：他们期望一个参数，而我们传递零。 对于我们的构造函数，原因是替换是软盘的。 </p><br><p>  GCC说：“替换失败，试图在<code>enable_if&lt;false&gt;</code>找到类型<code>type</code> -找不到，抱歉。” </p><br><p>  Clang认为这种情况是特例。 因此，他很酷的显示了这个错误。 如果在评估第一个参数的<code>enable_if</code>时我们得到的是<code>false</code> ，则他写道不满足特定的要求。 </p><br><p> 同时，我们自己通过使繁琐的条件<code>enable_if</code>破坏了我们的生活。 我们看到事实证明它是<code>false</code> ，但是我们还不知道为什么。 </p><br><p> 如果我们以这种方式将<code>enable_if</code>分为四个部分，可以克服这一问题： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;..., <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;is_default_constructible&lt;T&gt;::value&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;is_default_constructible&lt;U&gt;::value&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;is_implicity_default_constructible&lt;T&gt;::value&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;is_implicity_default_constructible&lt;U&gt;::value&gt;&gt; &gt; ...</code> </pre> <br><p> 现在，当我们尝试隐式构造一个对时，我们会收到一条很好的消息，即<code>is_implicitly_default_constructable</code>候选者不适合，因为不满足特征类型<code>is_implicitly_default_constructable</code>要求： </p><br><pre> <code class="cpp hljs">pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, B&gt; p = {}; <span class="hljs-comment"><span class="hljs-comment">// candidate template ignored: requirement 'is_implicity_default_constructible&lt;B&gt;::value' was not satisfied with...</span></span></code> </pre> <br><p> 似乎甚至有一秒钟：如果我们拥有如此出色的编译器，为什么我们需要一个概念？ <br> 但是我们回想起，默认情况下使用两个模板函数来实现构造函数，并且每个模板都有六个模板参数。 对于声称强大的语言，这是一种失败。 </p><br><p>  C ++ 20将如何帮助我们？ 首先，通过使用require子句重写此模式来摆脱这些模式。 之前我们在<code>enable_if</code>编写的内容，现在我们在<code>enable_if</code>子句参数中编写的内容： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; pair() requires DefaultConstructible&lt;F&gt; &amp;&amp; DefaultConstructible&lt;S&gt; &amp;&amp; ImplicitlyDefaultConstructible&lt;F&gt; &amp;&amp; ImplicitlyDefaultConstructible&lt;S&gt; : f(), s() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> ... }</span></span>;</code> </pre> <br><p>  <code>ImplicitlyDefaultConstructible</code>的概念可以使用这样一个不错的require表达式来实现，其中几乎只使用不同形状的括号： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; concept ImplicitlyDefaultConstructible = requires { [] (T) {} ({}); };</code> </pre> <br><p>   <code>T</code>  <code>ImplicitlyDefaultConstructible</code> ,  ,     <code>T</code>      .  ,   ,      SFINAE. </p><br><p>    C++20:   (conditional) <code>explicit</code> (    <code>noexcept</code> ).     <code>explicit</code>  .          ,     <code>explicit</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> {</span></span> F f; S s; <span class="hljs-keyword"><span class="hljs-keyword">explicit</span></span>(!ImplicityDefaultConstructible&lt;F&gt; || !ImplicityDefaultConstructible&lt;S&gt;) pair() requires DefaultConstructible&lt;F&gt; &amp;&amp; DefaultConstructible&lt;S&gt; : f(), s() {} };</code> </pre> <br><p>      ,   .      ,    <code>DefaultConstructible</code> ,   <code>explicit</code> ,       <code>explicit</code> . </p><br><h2 id="realizaciya-klassa-optional-v-c17">   Optional  C++17 </h2><br><p>       <code>Optional</code> .       ,     . </p><br><p>      .    ?   ,     C++    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Option&lt;T&gt; { None, Some(t) }</code> </pre> <br><p>  : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Optional</span></span></span><span class="hljs-class">&lt;T&gt; {</span></span> final T value; Optional() {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = null; } Optional(T value) {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; } }</code> </pre> <br><p>       C++:   <code>null</code> ,    value-? </p><br><p>    C++ .    <code>initialized</code>  <code>storage</code> ,      ,   .         <code>T</code> ,     <code>optional</code>   <code>T</code>   ,  C++ memory model. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> initialized; <span class="hljs-keyword"><span class="hljs-keyword">aligned_storage_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">alignof</span></span>(T)&gt; storage; ...</code> </pre> <br><p>    ,   .  :    <code>optional</code> ,   <code>optional</code>  .     : </p><br><pre> <code class="cpp hljs"> ... <span class="hljs-function"><span class="hljs-function">T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> &amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;T &amp;&gt;(storage); } <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;&gt;(storage); } <span class="hljs-function"><span class="hljs-function">T &amp;&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> &amp;&amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> move(get()); } optional() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : initialized(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) {} optional(T <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; value) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(NothrowCopyConstructible&lt;T&gt;) : initialized(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (&amp;storage) T(value); } ~optional() : <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(NothrowDestructible&lt;T&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (initialized) get().~T(); } };</code> </pre><br><p>  <code>optional</code> '   .    <code>optional</code> ,   <code>optional</code>  ,   ,   <code>optional</code>      .     ,        copy  move . </p><br><p>   .   :     assignment .   ,   .      .  copy constructor.   : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> initialized; <span class="hljs-keyword"><span class="hljs-keyword">aligned_storage_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">alignof</span></span>(T)&gt; storage; ... optional(optional <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(NothrowCopyConstructible&lt;T&gt;) : initialized(other.initialized) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (initialized) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (&amp;storage) T(other.get()); } optional&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(optional &amp;&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(...) {...} };</code> </pre> <br><p>  move assignment.    ,    : </p><br><ul><li>   <code>optional</code> ' ,    . </li><li>     ,   . </li><li>    ,   — ,   ,  . </li></ul><br><p>      <code>T</code>  : move constructor, move assignment  : </p><br><pre> <code class="cpp hljs">optional&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(optional &amp;&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(...) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (initialized) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other.initialized) { get() = move(other.get()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { initialized = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; other.initilized = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(&amp;other.storage) T(move(get())); get().~T(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other.initialized) { initialized = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; other.initialized = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(&amp;storage) T(move(get())); other.get().~T(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br><p>         <code>noexcept</code> : </p><br><pre> <code class="cpp hljs">optional&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(optional &amp;&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(NothrowAssignable&lt;T&gt; &amp;&amp; NothrowMoveConstructible&lt;T&gt; &amp;&amp; NothrowDestructible&lt;T&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (initialized) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other.initialized) { get() = move(other.get()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { initialized = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; other.initialized = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (&amp;other.storage) T(move(get())); get().~T(); } } ... }</code> </pre> <br><p>  <code>optional</code>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> {</span></span> ... optional(optional <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(NothrowCopyConstructible&lt;T&gt;); optional(optional &amp;&amp;) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(NothrowMoveConstructible&lt;T&gt;); optional&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(optional <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(...); optional&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(optional &amp;&amp;) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(...); };</code> </pre> <br><p>        ,        <code>pair</code> : <br>      <code>Optional</code>  -,        (, deleted),   compilation error. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class">&lt;unique_ptr&lt;int&gt;&gt;;</span></span> <span class="hljs-comment"><span class="hljs-comment">// compilation error</span></span></code> </pre> <br><p>    ,  <code>optional</code>  <code>unique_ptr</code>    , <br>  copy constructor  copy assignment   deleted.           ,    ,     SFINAE. <br>      copy  move   assignment ,       —     .   - ,     copy ,      . </p><br><p>   —  .        copy      : deleted operation , , operation: </p><br><ul><li> <code>deleted_copy_construct</code>    <code>delete</code> ,   — <code>default</code> ; </li><li> <code>copy_construct</code>   ,   <code>copy_construct</code>     . </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">deleted_copy_construct</span></span></span><span class="hljs-class"> :</span></span> Base { deleted_copy_construct(deleted_copy_construct <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; deleted_copy_construct(deleted_copy_construct &amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; deleted_copy_construct&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(deleted_copy_construct <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; deleted_copy_construct&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(deleted_copy_construct &amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">copy_construct</span></span></span><span class="hljs-class"> :</span></span> Base { copy_construct(copy_construct <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; other) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(Base::construct(other))) { Base::construct(other); } copy_construct(copy_construct &amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; copy_construct&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(copy_construct <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; copy_construct&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> =(copy_construct &amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; };</code> </pre> <br><p>   <code>select_copy_construct</code> ,     ,   <code>CopyConstrictuble</code>  ,    <code>copy_construct</code> ,  <code>deleted_copy_construct</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_copy_construct</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">conditional_t</span></span></span><span class="hljs-class">&lt;CopyConstructible&lt;T&gt; copy_construct&lt;Base&gt; deleted_copy_construct&lt;Base&gt; &gt;;</span></span></code> </pre> <br><p> ,    <code>optional</code> ,   <code>optional_base</code> , copy     <code>construct</code>   ,   <code>optional</code>   <br> <code>select_copy_construct&lt;T, optional_base&lt;T&gt;&gt;</code> .       copy : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional_base</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(optional_base </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NothrowCopyConstructible&lt;T&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((initialized = other.initialized)) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (&amp;storage) t(other.get()); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> :</span></span> select_copy_construct&lt;T, optional_base&lt;T&gt;&gt; { ... };</code> </pre> <br><p>      . , ,    <code>copy_construct</code>    ,  <code>move_construct</code>       <code>copy_construct</code> , <code>copy_assign</code> , ,  <code>move_construct</code> ,        , ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_move_construct</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_copy_construct</span></span></span><span class="hljs-class">&lt;T, conditional_t&lt;MoveConstructible&lt;T&gt;, move_construct&lt;Base&gt; &gt; &gt;;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_copy_assign</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_move_construct</span></span></span><span class="hljs-class">&lt;T, conditional_t&lt;CopyAssignable&lt;T&gt; &amp;&amp; CopyConstructible&lt;T&gt;, copy_assign&lt;Base&gt; delete_copy_assign&lt;Base&gt; &gt; &gt;;</span></span></code> </pre> <br><p> , <code>move_assign</code>  <code>copy_assign</code> , <code>optional_base</code>   ,    assignment   <code>construct</code>  <code>assign</code> ,  <code>optional</code>   <code>select_move_assign&lt;T, optional_base&lt;T&gt;&gt;</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_move_assign</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_copy_assign</span></span></span><span class="hljs-class">&lt;T, ...&gt;;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional_base</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(optional_base </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NothrowCopyConstructible&lt;T&gt;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(optional_base &amp;&amp;)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NothrowMoveConstructible&lt;T&gt;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">optional_base&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(optional_base &amp;&amp;)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">optional_base&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(optional_base </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noexcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> :</span></span> select_move_assign&lt;T, optional_base&lt;T&gt;&gt; { ... };</code> </pre> <br><p> ,      : <br> <code>optional&lt;unique_ptr&gt;</code>   <code>deleted_copy_construct</code> ,   <br> <code>move_construct</code>   .  ! </p><br><pre> <code class="cpp hljs">optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; : deleted_copy_construct&lt;...&gt; : move_construct&lt;...&gt; : deleted_copy_assign&lt;...&gt; : move_assign&lt;...&gt; : optional_base&lt;<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;</code> </pre> <br><p>       :  <code>optional</code>   <code>TriviallyCopyable</code>    <code>TriviallyCopyable</code> . </p><br><p>   <code>TriviallyCopyable</code> ?  ,  <code>T</code>  <code>TriviallyCopyable</code> ,    <br>    <code>memcpy</code> .    ,          . </p><br><p>  ,            , ,  .    <code>resize</code>  <code>vector</code> <code>TriviallyCopyable</code> ,              <code>memcpy</code> ,       ,   .  ,  ,    . </p><br><p>      <code>TriviallyCopyable</code> , ,     <code>static_assert</code> ',    copy-move     : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> :</span></span> select_move_assign&lt;T, optional_base&lt;T&gt;&gt; {...}; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(TriviallyCopyable&lt;optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(TriviallyCopyConstructible&lt;optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(TriviallyMoveConstructible&lt;optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(TriviallyCopyAssignable &lt;optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(TriviallyMoveAssignable &lt;optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;); <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(TriviallyDestructible &lt;optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;);</code> </pre> <br><p>      <code>static_assert</code> ' .  ,   ,      .   <code>optional</code> —  <code>aligned_storage</code> ,  ,  ,   ,  <code>TriviallyCopyable</code> . </p><br><p>    ,          .       ,     <code>TriviallyCopyable</code> . </p><br><p>  ,      .     <code>select_copy_construct</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_copy_construct</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">conditional_t</span></span></span><span class="hljs-class">&lt;CopyConstructible&lt;T&gt;, copy_construct&lt;Base&gt; deleted_copy_construct&lt;Base&gt; &gt;;</span></span></code> </pre> <br><p>  <code>CopyContructible</code>    <code>copy_construct</code> ,      <code>if</code>  compile-time:   <code>CopyContructible</code>  <code>TriviallyCopyContructible</code> ,     <code>Base</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_copy_construct</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">conditional_t</span></span></span><span class="hljs-class">&lt;CopyConstructible&lt;T&gt;, conditional_t&lt;TriviallyCopyConstructible&lt;T&gt;, Base, copy_construct&lt;Base&gt; &gt;, deleted_copy_construct&lt;Base&gt; &gt;;</span></span></code> </pre> <br><p> ,     copy .        ,    <code>select_destruct</code>  .    <code>int</code>   ,  -     - ,    . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">select_destruct</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">conditional_t</span></span></span><span class="hljs-class">&lt;TriviallyDenstructible&lt;T&gt;, Base, destruct&lt;Base&gt; &gt; &gt;;</span></span></code> </pre> <br><p>  ,     ,    .  , ,  : </p><br><pre> <code class="cpp hljs">optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; : deleted_copy_construct&lt;...&gt; : move_construct&lt;...&gt; : deleted_copy_assign&lt;...&gt; : move_assign&lt;...&gt; : destruct&lt;optional_base&lt;<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;&gt; : optional_base&lt;<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;</code> </pre> <br><p>  ,  C++17   <code>optional</code>      7;      :    <code>operation</code> , <code>deleted_operation</code>   <code>select_operation</code> ;   <code>construct</code>  <code>assign</code>   .  ,    . </p><br><p>     -   .      .        :   deleted. </p><br><p>  ,       <code>noexcept</code> . <br>  ,   ,   ,    <code>trivial</code> , <code>noexcept</code>         .   ,   ,    <code>trivial</code>  <code>noexcept</code> ,   <code>noexcept</code> ,    <code>deleted</code> .           .        ,     ,    . </p><br><p>          type trait,  ,        . , , copy :  <code>deleted</code>  ,  <code>nothrow</code>  ,    ? </p><br><p>   ,            - special member, ,    ,    ,     : </p><br><ul><li>   ,    <code>deleted</code> ,   <code>= delete</code>      <code>deleted_copy_construct</code> ; </li><li>      ,     <code>copy_construct</code> ,   c  noexcept ; </li><li> ,   ,     ,  . </li></ul><br><p>              . </p><br><h2 id="realizaciya-klassa-optional-v-c20">   optional  C++20 </h2><br><p>   C++20   <code>optional</code>   copy ? <br>   : </p><br><ul><li>   <code>T</code>  <code>CopyConstructible</code> ,     <code>deleted</code> ; </li><li>   <code>TriviallyCopyConstructible</code> ,   ; </li><li>        <code>noexcept</code> . </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> {</span></span> ... optional(optional <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;) requires(!CopyConstructible&lt;T&gt;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-comment"><span class="hljs-comment">// #1 optional(optional const &amp;) requires(TriviallyCopyConstructible&lt;T&gt;) = default; // #2 optional(optional const &amp;) noexcept(NothrowCopyConstructible&lt;T&gt;) {...} // #3 ... ~optional() requires(TriviallyDestructible&lt;T&gt;) = default; ~optional() noexcept(NothroeDestructible&lt;T&gt;) {...} };</span></span></code> </pre> <br><p>  ,   . -,     ,      <code>T</code>  requires clause      <code>false</code> .    <code>requires(false)</code> ,   ,      overload resolution.     ,        <code>requires(true)</code> ,             . <br>         ,    . </p><br><p>   requires clause    <code>= delete</code> : </p><br><ul><li>   <code>= delete</code>   overload resolution,     ,     ,     deleted . </li><li>   <code>requires(false)</code>     overload resolution. </li></ul><br><p>   ,     copy ,  ,    requires clause.       . </p><br><p>  ,      . !    C++    ,   ?  , , .        ,   ,    ,     .   ,   ,     ,      , ,   <code>optional</code> . </p><br><p> ,       ,  GCC   internal compiler error,  Clang    .   ,   .     ,  . </p><br><p>  ,   ,       <code>optional</code>  C++20.  ,   ,   C++17. </p><br><h1 id="alternativa-aligned_storage-i-aligned_union">  aligned_storage  aligned_union </h1><br><p>   :   <code>aligned_storage</code>         <code>reinterpret_cast</code> ,  <code>reinterpret_cast</code>    constexpr . ,  compile-time  <code>optional</code>   ,         compile-time.    STL   <code>aligned_storage</code>   <code>optional</code>    <code>aligned_union</code>   <code>variant</code> . ,  ,     STL  Boost    <code>optional</code>  <code>variant</code> .     <code>variant</code> ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> all_types_are_trivially_destructible, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>...&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Variant_storage_</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... _Types&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> _Variant_storage = _Variant_storage_&lt; conjunction_v&lt;is_trivially_destructible&lt;_Types&gt;...&gt;, _Types... &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> _First, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... _Rest&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Variant_storage_</span></span></span><span class="hljs-class">&lt;true, _First, _Rest...&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">remove_const_t</span></span>&lt;First&gt; _Head; _Variant_storage&lt;_Rest...&gt; _Tail; }; };</code> </pre> <br><p>      <code>variant</code> .    <code>_Variant_storage_</code> ,  , -, ,    <code>variant</code> ,  -,    .  ,    <code>trivially_destructible</code> ?     type alias,       .      <code>_Variant_storage_</code>  ,    <code>true</code>    <code>false</code> . ,   <code>true</code> ,  .      <code>trivially_destructible</code> ,     union     <code>Variant</code> '  . </p><br><p>  ,  ,   ,  ,    .     type alias  <code>_Variant_storage</code> .      : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... _Types, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> = conjunction_v&lt;is_trivially_destructible&lt;_Types&gt;...&gt; &gt; class _Variant_storage_;</code> </pre> <br><p>        .        ,   variadic template    . ,        ,            ,          <code>_Types</code> .   C++17  ,   . </p><br><p>  C++20        , <br>     ,       <br> requires clause.        C++20    requires clause: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... _Types&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Variant_storage_</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> _First, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... _Rest&gt; requires(TriviallyDestructible&lt;_First&gt; &amp;&amp; ... &amp;&amp; TriviallyDestuctible&lt;_Rest&gt;) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Variant_storage_</span></span></span><span class="hljs-class">&lt;_First, _Rest...&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">remove_const_t</span></span>&lt;_First&gt; _Head; _Variant_storage_&lt;_Rest...&gt; _Tail }; };</code> </pre> <br><p>    <code>_Variant_storage_</code> ,     <code>TriviallyDestructible</code> .  ,       requires clause   ,   ,       . </p><br><h1 id="ispolzovanie-requires-clause-dlya-template-type-alias">  requires clause  template type alias </h1><br><p> ,     requires clause   template type alias.      C++20  -  <code>enable_if</code> ,         : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> condition, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; requires condition <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span> = T;</code> </pre> <br><h1 id="kod-kotoryy-ne-podderzhit-ni-odin-kompilyator"> ,       </h1><br><p>  ,         .       : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Equivalent, but functionally not equivalent template&lt;typename T&gt; enable_if_t&lt;(sizeof(T) &lt; 239)&gt; f(); template&lt;typename T&gt; enable_if_t&lt;(sizeof(T) &gt; 239)&gt; f(); // Not equivalent template&lt;typename T&gt; requires(sizeof(T) &lt; 239) void f(); template&lt;typename T&gt; requires(sizeof(T) &gt; 239) void f();</span></span></code> </pre> <br><p>       ,     <code>enable_if</code>      .    ?     <code>f()</code> :   <code>enable_if</code> ,      ,  239, , ,  ,  239.       ,     : </p><br><ul><li>   ,      ,     template type alias',      «void f(); void f(); </li><li>   ,    SFINAE, ,      ,     . </li></ul><br><p> ,     <code>enable_if</code> ,      ,          <code>size &lt; 239</code> ,      <code>size &gt; 239</code> .      ,            .      ,      <code>f()</code>   .       requires clause.    —   ,      . </p><br><blockquote>        —  ,      .      C++ Russia 2019 Piter,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">«:   core language»</a> .     , , :   reachable entity      visible,     ADL,   entities  internal linkage    .   ,    C++ Russia       (JetBrains)   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">«  ++20 —   ?»</a> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN467299/">https://habr.com/ru/post/zh-CN467299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN467281/index.html">数据科学家画象在俄罗斯。 仅事实</a></li>
<li><a href="../zh-CN467283/index.html">如何向祖母解释SQL和NoSQL之间的区别</a></li>
<li><a href="../zh-CN467289/index.html">开发单片类Unix操作系统-GDT和IDT（5）</a></li>
<li><a href="../zh-CN467291/index.html">iOS创造力：绘图</a></li>
<li><a href="../zh-CN467295/index.html">期待已久的Android中的视图绑定</a></li>
<li><a href="../zh-CN467301/index.html">AI在《杀手》中的运作方式（2016）</a></li>
<li><a href="../zh-CN467303/index.html">最年轻的PSB程序员的故事：黑客马拉松成为银行的大门</a></li>
<li><a href="../zh-CN467305/index.html">当城市变得聪明时：大城市的体验</a></li>
<li><a href="../zh-CN467313/index.html">PostgreSQL和MySQL之间的交叉复制</a></li>
<li><a href="../zh-CN467317/index.html">软银如何吞噬世界</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>