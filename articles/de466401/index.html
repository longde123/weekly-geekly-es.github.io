<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüåæ üßñ üçü Ein bisschen Finanzmathematik: Berechnung von Inflation und Zinsen üèóÔ∏è üë©üèø‚Äçü§ù‚Äçüë©üèª üôå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor kurzem musste ich die Berechnungen der Stadtwerke √ºberpr√ºfen. Es gab ein kontroverses Problem, das nur durch korrekte Berechnungen gel√∂st werden k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein bisschen Finanzmathematik: Berechnung von Inflation und Zinsen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466401/"> Vor kurzem musste ich die Berechnungen der Stadtwerke √ºberpr√ºfen.  Es gab ein kontroverses Problem, das nur durch korrekte Berechnungen gel√∂st werden kann.  Mit Blick auf die Zukunft werde ich sagen, dass die √∂ffentlichen Versorgungsunternehmen falsch denken.  Daher werden wir hier √ºberlegen, wie die Inflationskosten und 3% pa ‚Äã‚Äãauf Schulden f√ºr Verpflichtungen gem√§√ü dem Zivilgesetzbuch der Ukraine korrekt berechnet werden k√∂nnen. <br><br>  Der erste Teil beschreibt die Berechnung der Inflationskosten, dies ist spezifisch f√ºr die Ukraine. <br>  Der zweite (gr√∂√üere) Teil befasst sich mit der Berechnung von 3% pro Jahr.  Dies gilt auch f√ºr die Russische F√∂deration, Wei√ürussland und Kasachstan. In diesen L√§ndern ist der Zinssatz jedoch nicht festgelegt, sondern h√§ngt vom Refinanzierungssatz der Zentralbank ab.  Der Rest des Landes sah nicht aus. <br><br>  Der zweite Teil ist sehr nahe an der Berechnung der Zinsen f√ºr normale Kreditgesch√§fte (Kredite, Kredite, Kredite usw.). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/di/2q/9l/di2q9lbdqyzqzcywadgdnny0bgo.png" alt="Bild alt"></div><br>  Zuerst eine Theorie, am Ende ein kleiner Code. <br><br>  All dies unter dem Schnitt. <br><a name="habracut"></a><br>  Also kam ich in die H√§nde eines Dokuments der √∂ffentlichen Versorgungsunternehmen "Erkl√§rung √ºber die R√ºckstellung von Inflationskosten und 3% pro Jahr".  Es wurde von mir √ºberpr√ºft und ich fand heraus, dass es mit dem falschen Algorithmus berechnet wurde und von Interesse ist, da es die Anforderungen des Artikels des Zivilgesetzbuches der Ukraine umsetzen muss. <br><br>  Was zu beachten ist, steht im Zivilgesetzbuch der Ukraine: <br><blockquote>  Artikel 625 des Zivilgesetzbuches der Ukraine.  "Verantwortung f√ºr die Verletzung einer Geldverpflichtung" <br>  (2) Ein Schuldner, der die Erf√ºllung einer Geldverpflichtung verz√∂gert hat, ist auf Antrag des Gl√§ubigers verpflichtet, den Betrag der Schuld unter Ber√ºcksichtigung des festgelegten Inflationsindex f√ºr den gesamten Verz√∂gerungszeitraum sowie 3% pa ‚Äã‚Äãdes √ºberf√§lligen Betrags zu zahlen ... </blockquote>  Auf der Grundlage der Schuldenzahlen berechneten die √∂ffentlichen Versorgungsunternehmen die Inflationskosten und 3% pro Jahr. <br><br><h2>  Inflationskosten </h2><br>  Weiter werde ich √ºber den Berechnungsalgorithmus sprechen und nicht √ºber bestimmte Zahlen. <br><br>  Die Inflation ist ein Prozess, der durch eine Abwertung der W√§hrung gekennzeichnet ist, dh eine Abnahme ihrer Kaufkraft und einen allgemeinen Preisanstieg.  Ohne Inflation sind die Endergebnisse der Cashflow-Berechnungen sehr willk√ºrlich. <br><br>  Inflationsindex (II) oder Verbraucherpreisindex (VPI), Verbraucherpreisindex (VPI) - eine der Arten von Preisindizes, die zur Messung des durchschnittlichen Preisniveaus f√ºr Waren und Dienstleistungen (Verbraucherkorb) f√ºr einen bestimmten Zeitraum in der Wirtschaft erstellt wurden. <br><br>  KI ist ein Indikator, der die Dynamik des allgemeinen Preisniveaus f√ºr Waren und Dienstleistungen kennzeichnet, die die Bev√∂lkerung f√ºr den nicht produktiven Konsum erwirbt.  Dies ist der Wachstumsindex, der angibt, wie viel Prozent der durchschnittliche Preisanstieg im Berichtszeitraum betr√§gt. <br><br>  In der Ukraine sind KI und CPI synonym <br><br>  Da der Preisindex f√ºr aufeinanderfolgende Zeitr√§ume ein Kettenindex ist, wird er durch Multiplikation der Indikatoren berechnet, z. B. 101% * 102% = (1,01 * 1,02) * 100% = 103,02%. <br><br>  AI wird vom Staatlichen Statistikausschuss der Ukraine berechnet und in offiziellen Zeitschriften ver√∂ffentlicht.  Diese Kennzahlen k√∂nnen zur Neuberechnung von Bargeldbetr√§gen verwendet werden. <br>  Was denken Gemeindearbeiter? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/5p/hv/ge5phvi9cjhbbz7kkx0jndzuyli.png" alt="Teil des abrechnungsbelegs"></div><br>  Der letzte Abrechnungstermin ist der 7. Dezember 2016. <br><br>  Mal sehen, wie die kommunalen Arbeiter Inflationskostenquoten bekamen? <br><br>  Mit blo√üem Auge kann man sehen, dass in der dritten (und f√ºnften Spalte) anstelle des ganzzahligen Teils 1 der ganzzahlige Teil 0 stehen sollte. Wie haben sie den Bruchteil erhalten? <br><br>  <strong>September 2016.</strong> Bruchteil 0.028.  Die Zahlungsfrist f√ºr September ist der 20. Oktober 2016. Der Bruchteil entspricht dem vom State Statistics Committee ver√∂ffentlichten Inflationsindex f√ºr Oktober 2016 - 102,8% <br><br>  <strong>August 2016.</strong> Bruchteil 0.0465.  Die Zahlungsfrist f√ºr August ist der 20. September 2016. Der Bruchteil entspricht dem Inflationsindex f√ºr September multipliziert mit II f√ºr Oktober: 101,8% * 102,8% = 104,65% oder in Aktien 1,018 * 1,028 = 1,046504.  Stadtwerke werden auf 1,0465 gerundet und drucken diese Zahl aus, obwohl die Einheit weggenommen werden sollte, da in der n√§chsten Spalte nur die H√∂he der Inflationskosten und nicht der kumulierte Betrag angegeben werden. <br><br>  <strong>Juli 2016 und fr√ºher.</strong>  Ich habe diese Berechnungen durchgef√ºhrt und den Algorithmus wiederhergestellt.  √ñffentliche Versorgungsunternehmen multiplizieren die Inflationsindizes ab dem Monat nach dem Monat der Leistungserbringung (Monat des F√§lligkeitstermins) und endend mit Oktober 2016. <br><br>  <strong>Der Startpunkt ist</strong> nur teilweise wahr.  Wie ich sp√§ter zeigen werde, muss die Berechnung im allgemeinen Fall wirklich ab diesem Monat beginnen, aber in unserem speziellen Fall sollte der erste Monat √ºbersprungen werden (entspricht AI 100%). <br><br>  <strong>Der Endpunkt der</strong> Multiplikation.  Da der letzte Berechnungstag im Dezember liegt und Sie den Dezember beenden m√ºssen, ist dies im Allgemeinen der Fall.  Wie ich sp√§ter zeigen werde, muss in diesem speziellen Fall auch der Dezember √ºbersprungen werden (entspricht auch AI 100%).  Und am 7. Dezember hatten die AIs im Dezember keine Zeit zum Ver√∂ffentlichen. <br><br>  Warum wird der November nirgendwo ber√ºcksichtigt?  Ich denke, sie haben einfach vergessen, es in das System einzugeben. <br><br>  Nun wollen wir sehen, wie der Inflationsindex berechnet wird.  Bei <strong>Bedarf</strong> - beschrieben im Informationsschreiben des Obersten Wirtschaftsgerichts der Ukraine Nr. 01-06 / 928/2012 vom 17.07.2012 [6]. <br><br>  Ich werde einen Teil des Absatzes geben: <br><blockquote>  Der vom 1. bis zum 15. Tag des Monats zu zahlende Schuldenbetrag wird unter Ber√ºcksichtigung dieses Monats indexiert. Wenn die Schulden vom 16. bis zum 31. Tag des Monats bezahlt werden sollen, beginnt die Berechnung mit dem n√§chsten Monat. <br><br>  Wenn eine Schuld von 1 bis 15 Tagen im Monat zur√ºckgezahlt wurde, werden die Inflationskosten ohne Ber√ºcksichtigung dieses Monats berechnet, und wenn von 16 bis 31 Tagen im Monat die Inflationskosten unter Ber√ºcksichtigung dieses Monats berechnet werden. </blockquote>  In unserem Fall ist die Zahlungsfrist der 20. Tag des Monats, der auf den Monat der Leistungserbringung folgt, d. H.  F√ºr die Erbringung von Dienstleistungen im September ist der Beginn der Abrechnung der 21. Oktober 2016 und die Frist der 7. Dezember 2016. <br><br>  Das hei√üt,  Es ist richtig, dies zu ber√ºcksichtigen: Ber√ºcksichtigen Sie bei der Erbringung von Dienstleistungen im September 2016 die Inflation f√ºr drei Monate (√ºbergeben Sie den Cursor oder den Zyklus) von Oktober bis Dezember. Ber√ºcksichtigen Sie jedoch im ersten und letzten Monat die KI gleich 1 (100%) und ber√ºcksichtigen Sie nur den November. <br><br>  Im November 2016 betrug die KI 101,8%, d.h.  Der Koeffizient sollte 0,0180 und nicht 0,0280 betragen.  Ich habe vorher √ºber die Lead Unit geschrieben. <br><br><h2>  3% pro Jahr </h2><br>  Mal sehen, wie die kommunalen Dienste Koeffizienten und R√ºckstellungsbetr√§ge von 3% pro Jahr erhalten haben.  Dies ist die f√ºnfte Spalte in der obigen Tabelle. <br><br>  Wie ich bereits geschrieben habe, sollte es keine f√ºhrende Einheit geben, es sollte 0 sein. Wir betrachten den Bruchteil und stellen fest, dass er irgendwie verd√§chtig rund ist - jeder Vormonat ist 0,0025 mehr als der aktuelle Monat. <br><br>  Mit einfachen Berechnungen kann festgestellt werden, dass die √∂ffentlichen Versorgungsunternehmen ohne weiteres 3% in 12 Monate aufgeteilt haben, 0,0025 oder 0,25% pro Monat erhalten haben und diesen Prozentsatz f√ºr jeden vollen und unvollst√§ndigen Monat der Verz√∂gerung erhalten.  Ja, wenn Sie sich den Oktober 2016 ansehen, dessen Zahlungsfrist am 21. November lag und dessen Berechnungen am 7. Dezember durchgef√ºhrt wurden, dann z√§hlten sie f√ºr einen unvollst√§ndigen Monat die gleichen 0,25%. <br><br>  Der Ansatz bewundert brutale Geradlinigkeit, aber wie ich sp√§ter zeigen werde, kennt die Finanzmathematik einen solchen Algorithmus nicht. <br><br>  Die Gesetzgebung der Ukraine und die Finanzmathematik geben keine klare Antwort auf die Frage, wie 3% pro Jahr berechnet werden sollen.  Ich habe nach mehreren B√ºchern zu diesem Thema gesucht, aber B√ºcher sind uralt und stammen aus dem Jahr 2002.  Daher werden die Algorithmen aus den B√ºchern durch die Tatsache erg√§nzt, dass es m√∂glich war, aus moderneren und westlicheren Artikeln zu googeln.  [1] wurde 2007 nachgedruckt, und neuere russischsprachige B√ºcher konnten nicht gefunden werden.  Vielleicht, weil die Finanzmathematik als Wissenschaft vor sehr langer Zeit, lange vor dem Aufkommen der Computer, ihren Ursprung hatte, entstanden vor einigen hundert Jahren Konzepte wie ‚ÄûKredit‚Äú und ‚ÄûZins auf Kredit‚Äú.  Und die Algorithmen haben sich seit 2002 nicht viel ge√§ndert. <br><br>  Die westliche Sichtweise des Problems unterscheidet sich jedoch von der in russischsprachigen B√ºchern beschriebenen.  Ich werde zuerst Informationen aus russischsprachigen B√ºchern und dann aus westlichen Artikeln zitieren, aus denen hervorgeht, wo sie zusammenfallen. <br><br>  Was nachstehend geschrieben wird, bezieht sich auf den speziellen Fall, dass 3% pa ‚Äã‚Äãnachtr√§glich anfallen, kann jedoch auf die Berechnung der Zinsen f√ºr andere Kreditbeziehungen verallgemeinert werden, wenn die Zinsen eher nach dem einfachen Zins- als nach dem Zinseszinsschema aufgelaufen sind. <br><br>  Nach Art.  625 Das Zivilgesetzbuch der Ukraine muss nach dem einfachen Zinsschema 3% pro Jahr anfallen.  Zur Berechnung des Zinsbetrags muss der Schuldenbetrag (oder im Allgemeinen der Kreditk√∂rper) mit dem normalisierten j√§hrlichen Zinssatz von 3% multipliziert und mit dem Bruchteil des Jahres (Dauer in Jahren) multipliziert werden, auf den sich die Verz√∂gerung belief.  Dieser Anteil kann mehr als 1 betragen, wenn die Verz√∂gerung mehr als ein Jahr betr√§gt. <br><br>  Die Versp√§tungsdauer wird in Tagen angegeben.  In einem allgemeineren Fall kann die Darlehenslaufzeit in Tagen ausgedr√ºckt werden (die Situation, in der die Darlehenslaufzeit in Monaten und Jahren ausgedr√ºckt wird, wird hier nicht ber√ºcksichtigt).  Und der j√§hrliche Zinssatz von 3% ist der normalisierte einfache Zinssatz f√ºr das Jahr.  <strong>Daher m√ºssen Sie in der Lage sein, die Dauer der Verz√∂gerung (Gutschrift) in Tagen auf die Dauer in Jahren zu bringen.</strong>  <strong>Dies ist keine triviale Aufgabe, da die L√§nge des Jahres von seiner Anzahl abh√§ngt.</strong> <br><br>  Die Dauer in Tagen ist ein eindeutig definiertes Ma√ü f√ºr die Dauer von Kalenderl√ºcken im Gegensatz zur Dauer in Jahren.  Die Definition des letzteren bedarf einer Klarstellung in Form einer Regel zur Umrechnung der Dauer in Tagen in die Dauer in Jahren.  Eine Reihe von Standardmethoden zur Umrechnung der Dauer in Tagen in die Dauer in Jahren basiert auf der Division der Anzahl der Tage durch den sogenannten <strong>‚Äûj√§hrlichen Teiler‚Äú</strong> .  Die typischsten Werte des j√§hrlichen Teilers sind 360 und 365 Tage.  Im einfachsten Fall ist der Divisor eine konstante und intervallunabh√§ngige Zahl.  Die Anzahl der Tage in einem Zeitraum dient immer als Dividende (Z√§hler eines Bruchteils). <br>  Und Sie m√ºssen sich f√ºr das Verfahren zur Berechnung der Bedingungen in Tagen entscheiden.  Betrachten wir zwei weit hergeholte Beispiele: <br><br><ol><li>  Der Kunde erh√§lt vom 6. Dezember 2018 bis zum 7. Dezember 2018 ein kurzfristiges Darlehen von der Bank.  Was ist die Vertragslaufzeit und wie viele Tage brauche ich, um Zinsen zu erhalten?  Offensichtlich - 1 Tag. </li><li>  Der Teilnehmer bestellt den Dienst beim Telekommunikationsbetreiber mit einer zuk√ºnftigen G√ºltigkeitsdauer vom 6. Dezember 2018 bis zum 7. Dezember 2018 vor.  Was sind die Linien der Servicebereitstellung und f√ºr wie viele Tage muss ich eine Abonnementgeb√ºhr f√ºr den Service erheben?  Offensichtlich 2 Tage. </li></ol><br>  Was ist der Unterschied? <br><br>  Tatsache ist, dass der Tag kein Punkt auf der Zeitachse ist, sondern ein Intervall, das auf zwei Arten geschrieben werden kann (erinnern Sie sich, die eckige Klammer am Rand des Intervalls bedeutet, dass der Punkt im Intervall liegt, die Klammer ist der Punkt, der nicht im Intervall liegt): <br><br><ul><li>  [06.12.2018 00.00.00, 12/07/2018 00.00.00) - hier ist der rechte Rand des Intervalls nicht im Intervall enthalten, </li><li>  [06/12/2018 00.00.00, 12/06/2018 23.59.59] - hier ist der rechte Rand des Intervalls im Intervall enthalten. </li></ul><br>  Im ersten Fall (1) wird normalerweise die genaue Anzahl der Tage berechnet, einschlie√ülich des ersten oder letzten Tages, jedoch nicht beider, wenn das Zeitintervall nicht explizit, sondern in Form eines Intervalls zwischen Daten angegeben wird.  [4] sagt dasselbe mit anderen Worten: "Der Tag der Kreditvergabe und der R√ºckzahlungstag gelten als ein Tag." <br><br>  Diese Methode bestimmt die sogenannte genaue Zeit.  Es kann auch leicht festgestellt werden, ob sich beide Daten auf dasselbe Jahr beziehen und ein Kalender mit der Seriennummer jedes Tages des Jahres verf√ºgbar ist.  Dann reicht es aus, die Seriennummer des fr√ºhen Datums von der Seriennummer des sp√§ten Datums zu subtrahieren, und das Ergebnis gibt die Dauer des Zeitraums an.  In Oracle Database k√∂nnen Sie einfach Daten (Typ DATE), die auf einen Tag (mit verworfener Zeit) gek√ºrzt wurden, voneinander subtrahieren. Der Unterschied ist eine ganzzahlige Anzahl von Tagen. <br><br>  Im zweiten Fall (2) sprechen wir √ºber Tage, also z√§hlen wir zwei Tage. <br><br>  Ferner gehe ich von der Tatsache aus, dass die Anzahl der Tage, die Sie bereits festgelegt haben, beispielsweise im Fall von kommunalen Diensten, wenn die Zahlungsfrist der 20. September ist (d. H. Dies ist der letzte akzeptable Zahlungstag) und am 21. September gezahlt wurde, d. H. Es ist offensichtlich, dass die Verz√∂gerung 1 Tag betragen muss.  Wenn Sie mit einer Angabe des Intervalls ohne linken Rand konfrontiert werden, verschieben Sie den linken Rand einfach einen Tag nach rechts. <br><br>  Wie z√§hlen wir die Anzahl der Tage und den Z√§hler eines Bruchs?  Es gibt eine genaue Berechnung und eine ungef√§hre Berechnung. <br><br><h3>  Genaue Z√§hlung der Tage </h3><br><h4>  Russischsprachige Praxis </h4><br>  Der Text basiert weiter auf [1]. <br><br>  Die Wahl der genauen Anzahl von Tagen in einem Zeitraum als Teiler und die beiden h√§ufigsten Regeln geben die h√§ufigsten Regeln als Nenner an - ein j√§hrlicher Teiler von 360 oder 365: <br><br>  <strong>Regel (R1) ACT / 365.</strong>  F√ºr diese Regel wird die Dauer in Tagen durch die Zahl 365 geteilt. Ich stelle fest, dass die L√§nge eines Schaltjahres 366/365 = 1,00274 betr√§gt, was mehr als eins ist.  Der ACT / 365-Regelfehler ist umso gr√∂√üer, je mehr Schaltjahre in einem Zeitraum vorhanden sind.  Daher betr√§gt der durch diese Regel aufgelaufene Wert von 3% pro Jahr mehr als 3%. <br><br>  <strong>Regel (R2) ACT / 360.</strong>  Dies ist die sogenannte ‚ÄûBankregel‚Äú, nach der die Dauer in Tagen durch 360 geteilt wird. Diese Regel erh√∂ht die j√§hrliche L√§nge der L√ºcken weiter.  F√ºr ein Nicht-Schaltjahr betr√§gt seine L√§nge 365/360 = 1,01389 und f√ºr ein Schaltjahr 366/360 = 1,01667.  Je l√§nger der Zeitraum ist, desto gr√∂√üer ist nat√ºrlich der Grad der ‚ÄûDehnung‚Äú in Jahren.  Diese Regel wird am h√§ufigsten in Berechnungen verwendet, die sich auf den Geldmarkt beziehen, d. H.  kurzfristige Marktschulden wie Einlagen bei Banken, Wechsel, Commercial Papers, Einlagenzertifikate usw. Der Wert von 3% pro Jahr f√ºr das Jahr ist sogar noch h√∂her als bei Verwendung der vorherigen Regel. <br><br>  F√ºr den Fall, dass der j√§hrliche Teiler in H√∂he von 360 Tagen akzeptiert wird, werden die mit einem solchen Teiler erzielten Zinsen als <strong>gew√∂hnlich</strong> oder <strong>kommerziell bezeichnet</strong> .  Wenn der Divisor gleich 365 oder, wie ich sp√§ter zeigen werde, 366 Tage angenommen wird, wird das Interesse als genau bezeichnet. <br><br>  Offensichtlich sind gew√∂hnliche Prozents√§tze mehr als genau. <br><br>  Obwohl die erste Regel genauer ist als die zweite, sind beide nicht genau genug. <br><br>  Um die Auswirkung von Schaltjahren auf die Ergebnisse zu eliminieren, gibt es zwei weitere Regeln. <br><br>  <strong>Regel (R3) ACT / 365, Japan.</strong>  Die Berechnung wird auf die gleiche Weise wie f√ºr die ACT / 365-Regel durchgef√ºhrt, aber bei der Berechnung der Intervalldauer (Bruchz√§hler) werden Schaltdaten ausgeschlossen.  Der j√§hrliche Teiler bleibt unver√§ndert. <br><br>  Laut Wiki: <br><blockquote>  In vielen europ√§ischen L√§ndern galt der 29. Februar bis zum 18. Jahrhundert als nicht existierender Tag, ein Datum, das keinen rechtlichen Status hat.  Oft wurden an diesem Tag keine Transaktionen get√§tigt, keine Zahlungen get√§tigt, keine Schulden gemacht usw., da es Schwierigkeiten mit der formalen Seite der Angelegenheit und der gerichtlichen Beilegung von F√§llen gab. </blockquote><br><br>  Ein anderer Weg h√§ngt mit der tats√§chlichen √Ñnderung des Divisors zusammen. <br><br>  <strong>Regel (R4) ACT / ACT basic.</strong>  Wir teilen den gew√ºnschten Zeitraum in drei Teile: <br><br><ul><li>  der erste Teil vom Startdatum bis zum Ende des Jahres, in dem sich das Startdatum befindet, </li><li>  der dritte Teil - vom Beginn des Jahres, in dem sich das Enddatum befindet, bis zum Enddatum, </li><li>  der zweite Teil - 0 oder mehrere volle Kalenderjahre zwischen dem ersten und dritten Teil. </li></ul><br>  Die Dauer des ersten und dritten Teils ergibt sich aus der Division der Anzahl der Tage durch den j√§hrlichen Teiler 365 oder 366, je nachdem, ob es sich um ein Schaltjahr handelt.  Die Dauer der zweiten Periode besteht per Definition aus einer Ganzzahl von vollen Kalenderjahren, unabh√§ngig davon, ob es sich um einen Sprung handelt oder nicht.  Die Dauer in Jahren des gesamten Zeitraums ergibt sich aus der Summe der Dauer von drei Teilen, dargestellt durch drei Zahlen, von denen die zweite ein Ganzes ist und die erste und dritte gebrochen sind. <br><br>  <strong>Regel (R5) ACT / ACT ‚Äûkurze‚Äú √Ñnderung f√ºr Zeitr√§ume von weniger als einem Jahr.</strong>  In diesem Fall wird die Dauer in Tagen durch den j√§hrlichen Teiler 365 oder 366 geteilt, je nachdem, ob es im Suchzeitraum ein Datum am 29. Februar gibt.  Ein Merkmal der kurzen ACT / ACT-Regel ist, dass die Anwendung der Grund- und Kurzregeln zu unterschiedlichen Ergebnissen f√ºhrt, wenn das Intervall nicht in das Kalenderjahr passt (seine Enden geh√∂ren zu den Nachbarjahren). <br><br><h4>  Westliche Praxis </h4><br>  In der westlichen Praxis werden die Regeln unterschiedlich beschrieben.  Oft erhalten dieselben russischsprachigen Regeln unterschiedliche Namen und dar√ºber hinaus nicht jeweils einen. <br><br>  Die Informationen basieren ferner auf [2].  Dies ist Vicki, ich habe alle Quellen √ºberpr√ºft und andere Google-Informationen verwendet: In Regeln mit einer genauen Anzahl von Tagen ist alles korrekt, aber in Regeln mit einer ungef√§hren Anzahl von Tagen gibt es andere Interpretationen der Regeln, und oft √§ndern sie sich im Laufe der Zeit, um die Regeln in die Praxis umzusetzen. Die ungef√§hre Anzahl der Tage, die dieser Artikel nicht ausreicht. <br><br>  <strong>Regel (W1) Tats√§chliche / tats√§chliche ISDA.</strong>  Diese Regel liefert das gleiche Ergebnis wie (R4) ‚ÄûACT / ACT main‚Äú, ist jedoch unterschiedlich formuliert: Das Intervall wird in Schalt- und Nicht-Schaltjahre unterteilt, unabh√§ngig davon, ob sie voll oder unvollst√§ndig sind, und die Summe der Tage, in die sie fallen Schaltjahre, geteilt durch 365, und die Summe der Tage in Nicht-Schaltjahren wird durch 366 geteilt, die beiden Zahlen werden summiert. <br><br>  Andere Namen der Regel in der westlichen Praxis: Actual / Actual, Act / Act, Actual / 365, Act / 365.  Ja, der Nachname ist derselbe wie die Regel (R1), obwohl das Wesen der Regel unterschiedlich ist. <br><br>  <strong>Regel (W2) Ist / 365 behoben.</strong>  Diese Regel wiederholt genau die Regel (R1) ACT / 365 - die Anzahl der Tage wird durch 365 geteilt. <br><br>  Andere Namen der Regel in der westlichen Praxis: Act / 365 Fixed, A / 365 Fixed, A / 365F, Englisch. <br><br>  <strong>Regel (W3) Ist / 360.</strong>  Diese Regel wiederholt (R2) ACT / 360 - die genaue Anzahl der Tage wird durch 360 geteilt. <br><br>  <strong>Regel (W4) Ist / 364.</strong>  Die Anzahl der Tage wird durch 364 geteilt. In der russischsprachigen Praxis gibt es kein Analogon. <br><br>  <strong>Regel (W5) Ist / 365L.</strong>  Es besteht aus zwei Verbesserungen: <br><ol><li>  F√ºr j√§hrliche Zahlungen.  Wenn das Datum innerhalb des Zeitraums der 29. Februar ist, wird die Anzahl der Tage in dem Zeitraum durch den j√§hrlichen Teiler 366 geteilt, wenn nicht durch 365. In diesem Sinne stimmt dies mit der Regel (R5) ACT / ACT ‚Äûkurze √Ñnderung‚Äú √ºberein. </li><li>  Wenn die H√§ufigkeit der Zahlungen von der j√§hrlichen abweicht.  Wenn das Enddatum in einem Schaltjahr liegt (und nicht unbedingt dem 29. Februar entspricht), betr√§gt der j√§hrliche Teiler 366, andernfalls - 365. In der russischsprachigen Praxis gibt es kein Analogon. </li></ol><br>  Ein anderer Name ist ISMA-Jahr. <br><br>  <strong>Regel (W6) Tats√§chliche / tats√§chliche AFB.</strong>  Es besteht aus zwei Verbesserungen: <br><ol><li>  Die wichtigste f√ºr Zeitr√§ume von weniger als einem Jahr: Wenn das Datum innerhalb des Zeitraums der 29. Februar ist, wird die Anzahl der Tage in dem Zeitraum durch den j√§hrlichen Teiler 366, wenn nicht durch 365 geteilt. In diesem Sinne stimmt sie auch mit der R / ACT ACT / ACT-Regel ‚Äûkurze √Ñnderung‚Äú √ºberein . </li><li>  Erweitert f√ºr Zeitr√§ume von mehr als einem Jahr: Ein ganzzahliges ganzes Jahr wird vom Enddatum bis zum Startdatum zur√ºckgez√§hlt.  F√ºr einen Saldo von weniger als einem Jahr gilt die Hauptregel.  Die Anzahl der vollen Jahre und der Anteil des Jahres nach der Grundregel werden zusammengefasst. <br></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Countdown vor Jahren sind Nuancen verbunden, wenn der Countdown am 28. Februar durchgef√ºhrt wurde, und nach einer ganzen Reihe von vollen Jahren stellte sich heraus, dass das Jahr ein Schaltjahr war. </font><font style="vertical-align: inherit;">In diesem Fall sollte das Datum vor n Jahren am 29. Februar festgelegt werden. </font><font style="vertical-align: inherit;">Ich f√ºge hinzu, dass sich die Frage auch stellt, ob der Countdown ab dem 29. Februar durchgef√ºhrt wurde und die Anzahl der vollen Jahre nicht ein Vielfaches von vier ist, und dementsprechend war das Vorjahr kein Schaltjahr. </font><font style="vertical-align: inherit;">Ich habe hier nicht auf Details eingegangen. </font><font style="vertical-align: inherit;">Sie k√∂nnen jedoch auf die Links aus [2] verweisen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und "Kirsche auf dem Kuchen", </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel (W7) 1/1. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anzahl der Tage wird durch den j√§hrlichen Teiler 365,25 geteilt. </font><font style="vertical-align: inherit;">Wird f√ºr Inflationsberechnungen verwendet.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gesch√§tzte Tage z√§hlen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die oben aufgef√ºhrten Regeln basierten auf der genauen Dauer in Tagen von Kalenderperioden. Manchmal gibt es jedoch Schemata, die auf der sogenannten vereinfachten oder ungef√§hren Z√§hlung von Tagen basieren. Die Idee dieser Systeme ist es, die Dauer aller Monate auf 30 Tage ‚Äûauszugleichen‚Äú. Somit besteht das Jahr aus 12 Monaten von 30 Tagen, d.h. von 360 Tagen. Daher betr√§gt der j√§hrliche Teiler (Nenner des Bruchs) f√ºr diese Regeln immer 360, und der Z√§hler wird auf spezielle Weise berechnet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die genaue Anzahl der Tage eines Kredits in den meisten F√§llen, aber nat√ºrlich nicht immer, mehr als ungef√§hr ist (wie leicht durch die Bestimmung der durchschnittlichen Anzahl von Tagen in einem Monat f√ºr ein Jahr, die 30,44 betr√§gt), ergibt sich normalerweise die Zinsberechnungsmethode mit der genauen Anzahl von Tagen eines Kredits gr√∂√üeres Wachstum als ungef√§hr. [4]</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die einfachste Version dieser Regel, die sogenannte </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grundregel 30/360</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wird wie folgt beschrieben (im Folgenden die Informationen im Buch [1] - Russischsprachige Praxis): </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grundregel 30/360. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die ungef√§hre Anzahl der Tage zwischen den Daten betr√§gt</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 360 * (y2 - y1) + 30 * (m2 - m1) + (d2 - d1), </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wobei y, m, d - Jahr, Monat und Tag im zweiten und ersten Datum. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Regel trat vor der Erstellung der ersten Computerger√§te auf und sparte die Kosten f√ºr Computeroperationen in der Finanzpraxis erheblich. </font><font style="vertical-align: inherit;">Obwohl jetzt die Notwendigkeit vereinfachter Methoden verschwunden ist, haben sie, nachdem sie in der Praxis Fu√ü gefasst haben, traditionell manchmal gegenw√§rtig verwendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Regel gilt mit einem obligatorischen Hinweis auf eine √Ñnderung, die angibt, wie mit den letzten Tagen der Monate umzugehen ist:</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Russischsprachige Praxis </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gegeben von [1]. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel (R6) 30/360 ISDA. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn d1 = 31, dann ist d1 '= 30, andernfalls ist d1' = d1. </font><font style="vertical-align: inherit;">Wenn d2 = 31 und d1 '= 30, dann ist d2' = 30, andernfalls ist d2 '= d2. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel (R7) 30E / 360. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn d1 = 31, dann ist d1 '= 30, andernfalls ist d1' = d1. </font><font style="vertical-align: inherit;">Wenn d2 = 31, dann ist d2 '= 30, andernfalls ist d2' = d2. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Regel ist eine Variante der ISDA-Regel 30/360, die haupts√§chlich in Europa verwendet wird, daher die Bezeichnung ‚ÄûE‚Äú im Namen der Regel. </font><font style="vertical-align: inherit;">Es unterscheidet sich von der ISDA-Regel 30/360 nur, wenn das zweite Datum auch das 31. ist. </font><font style="vertical-align: inherit;">Die europ√§ische Version konvertiert sie unabh√§ngig vom ersten Datum immer in die 30. Nummer. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel (R8) 30/360 PSA. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn d1 = 31 oder d1 der letzte Tag im Februar ist, dann ist d1 '= 30, andernfalls ist d1' = d1. </font><font style="vertical-align: inherit;">Wenn d2 = 31 und d1 '= 30, dann ist d2' = 30, andernfalls ist d2 '= d2.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Beschreibung der 30/360 SIA-Regel in [1] ist h√∂chstwahrscheinlich ein Fehler, daher werde ich sie hier nicht angeben. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Westliche Praxis </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gegeben nach [2]. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel (W8) 30/360 Anleihebasis.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gleich wie (R6) 30/360 ISDA. Anderer Name: 30A / 360. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel (W9) 30E / 360.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gleich wie (R7) 30E / 360. Andere Namen: 30/360 ICMA, 30S / 360, Eurobond-Basis (ISDA 2006), Spezialdeutsch. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel (W10) 30E / 360 ISDA.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn d1 der letzte Tag des Monats ist, ist d1 '= 30. Wenn d2 der letzte Tag von NICHT Februar ist, dann ist d2 '= 30. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere Namen: 30E / 360 ISDA, Eurobond-Basis (ISDA 2000), Deutsch. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel (W11) 30/360 SIA.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn d1 der letzte Tag im Februar und d2 der letzte Tag im Februar ist, dann ist d2 '= 30. Wenn d1 = 31 oder der letzte Tag im Februar ist, dann ist d1 '= 30, andernfalls ist d1' = d1. Wenn d1 '= 30 und d2 = 31, dann ist d2' = 30, andernfalls ist d2 '= d1.</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Regeln (R4) ACT / ACT, (W1) Actual / Actual ISDA, (W2) Actual / 365 Fixed werden auch als "English Practice" bezeichnet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Regeln (R2) ACT / 360 und (W3) Actual / 360 werden auch als ‚Äûfranz√∂sische Praxis‚Äú bezeichnet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel (R7) 30E / 360, (W9) 30E / 360 und (W10) 30E / 360 ISDA werden auch als "deutsche Praxis" oder "deutsche Praxis" bezeichnet. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter Ber√ºcksichtigung des genauen und gew√∂hnlichen Interesses sowie der genauen und ungef√§hren Anzahl von Tagen f√ºr die Berechnung des Interesses erhalten wir vier Methoden zur Berechnung des einfachen Interesses (die Namen der Regeln sind in der russischsprachigen Praxis angegeben):</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Normales Interesse mit der genauen Anzahl von Tagen (ACT / 360 - Bankregel), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Genaue Prozents√§tze mit der genauen Anzahl von Tagen (ACT / 365, ACT / ACT), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Normales Interesse mit einer ungef√§hren Anzahl von Tagen (30/360), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Genaue Prozents√§tze mit einer ungef√§hren Anzahl von Tagen. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste am h√§ufigsten verwendete Methode wird als Bankregel bezeichnet, seltener als zweite und dritte und fast nie als vierte [1]. Und [4] sagt: "... eine Berechnungsoption mit genauen Zinsen und einer ungef√§hren Anzahl von Darlehenstagen ist bedeutungslos und gilt nicht." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die obigen Berechnungen der ungef√§hren Dauer von Perioden in Bruchteilen eines Jahres zeigen die Nicht-Trivialit√§t und Vielfalt der angewandten Regeln. Ihre Anwendung (sowie Herkunft) h√§ngt von Land, W√§hrung, Art des Finanzinstruments, Berufsverband und Vereinbarungen ab. [1] </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SCHLUSSFOLGERUNG:</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie z√§hle ich in meinem Fall 3% bei √∂ffentlichen Versorgungsunternehmen in der Ukraine?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse der gerichtlichen Praxis der Anwendung von Art. 625 des Zivilgesetzbuches der Ukraine besagt, dass normalerweise die Methode (R1) ACT / 365 [3] angewendet wird, die jedoch nicht klar formuliert ist. Ich denke, dass Sie noch (R4) ACT / ACT anwenden m√ºssen, und hier ist der Grund: Wenn Sie mit der ACT / 365-Methode 3% f√ºr ein volles Schaltjahr verdienen, entspricht der Zinsbetrag 3,008219%, was f√ºr Schulden (oder die Gr√∂√üe des Darlehensorgans) gilt. von 1 Million Geldeinheiten ergibt einen √úberschuss von 82,19 WE √ºber 3%, die durch den j√§hrlichen standardisierten Zinssatz nach dem Gesetz festgelegt sind. Dies wird besonders wichtig mit der fortschreitenden Zinsabgrenzung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich w√ºrde mich √ºber Kommentare freuen, insbesondere von Bankangestellten. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendete Quellen</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1) Bocharov, P. P., Kasimov, Yu. F. Financial Mathematics. Moskau: Gardariki, 2002 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) Tagz√§hlkonvention,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Day_count_convention</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3) Analyse der Anwendung von Kunst. 625 des Zivilgesetzbuches der Ukraine in Zivilverfahren, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zib.com.ua/ua/74602-analiz_praktiki_zastosuvannya_st_625_civilnogo_kodeksu_ukrai.html</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4) Chetyrkin E.M. Finanzmathematik. Moskau: Rechtssache 2005 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tagesz√§hlungskonventionen</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Abgrenzungsfaktoren</font></a><font style="vertical-align: inherit;"> , </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">docs.fincad.com/support/developerfunc/mathref/Daycount.htm</font></a></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6) Informationsschreiben des Obersten Wirtschaftsgerichts der Ukraine Nr. 01-06 / 928/2012 vom 17.07.2012, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zakon.rada.gov.ua/laws/show/v_928600-12</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und jetzt ein kleiner Code zur Oracle-Datenbank: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein Paket, das ich f√ºr meinen speziellen Fall erstellt habe - es berechnet die Inflationskosten und 3% pro Jahr f√ºr die Ukraine.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Oracle Database gibt es keine Aggregatfunktion, die Inflationswerte multipliziert. </font><font style="vertical-align: inherit;">Daher verwende ich die Summation von Logarithmen.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_OVERHEAD_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, OVERHEAD_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_AMOUNT_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, DEBT_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PAYMENT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_MONTH <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_RATE <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, SKIP_INFLATION <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>), INF_RATE_ACCUMULATED <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> , INF_COEF_ACCUMULATED <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, INF_AMOUNT_ACCUMULATED <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, INF_AMOUNT_MONTH <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, DEBT_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PAYMENT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_MONTH <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_RATE <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, SKIP_INFLATION <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_PCT_AMOUNT_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, DEBT_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PAYMENT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, PCT_YEAR <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_DAYS <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_PCT_PER_DAY <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_BEGIN_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span> , PCT_YEAR_END_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, PCT_YEAR_DAYS_CALC <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_PCT_PER_YEAR <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_AMOUNT_PER_YEAR <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_OVERHEAD_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_OVERHEAD_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_AMOUNT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_WITH_INF_AMOUNT_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_WITH_INF_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_PCT_AMOUNT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_WITH_PCT_AMOUNT_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> CALC_OVERHEADS_P <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> GET_DEBT_WITH_INF (p_debt_date_begin <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_debt_date_end <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_last_collection_date <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DEBT_WITH_INF_LIST_T; function GET_DEBT_WITH_INF_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_INF_AMOUNT_LIST_T; function GET_DEBT_WITH_INF_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T; function GET_DEBT_WITH_PCT_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_PCT_AMOUNT_LIST_T; function GET_DEBT_WITH_PCT_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span> CALC_OVERHEADS_P <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> GET_DEBT_WITH_INF (p_debt_date_begin <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_debt_date_end <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_last_collection_date <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DEBT_WITH_INF_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ret_value DEBT_WITH_INF_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a.ID, a.DEBT_DATE, a.DEBT_AMOUNT, a.PAYMENT_DATE, b.INF_MONTH, c.AVAL <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_RATE <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> DEBTS a <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">apply</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> add_months (trunc (a.PAYMENT_DATE, <span class="hljs-string"><span class="hljs-string">'month'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= months_between (trunc (p_last_collection_date, <span class="hljs-string"><span class="hljs-string">'month'</span></span>), trunc (a.PAYMENT_DATE, <span class="hljs-string"><span class="hljs-string">'month'</span></span>)) + <span class="hljs-number"><span class="hljs-number">1</span></span>) b <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> INFLATION c <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> c.ADATE = b.INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.TYP = <span class="hljs-string"><span class="hljs-string">'M'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a.DEBT_DATE <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> p_debt_date_begin <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> p_debt_date_end ) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE , <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> trunc (PAYMENT_DATE, <span class="hljs-string"><span class="hljs-string">'month'</span></span>) = INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PAYMENT_DATE) <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> trunc (p_last_collection_date, <span class="hljs-string"><span class="hljs-string">'month'</span></span>) = INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p_last_collection_date) <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> SKIP_INFLATION <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_WITH_INF_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_INF_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_INF_AMOUNT_LIST_T is ret_value DEBT_WITH_INF_AMOUNT_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION , <span class="hljs-keyword"><span class="hljs-keyword">exp</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ln</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> SKIP_INFLATION = <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> INF_RATE <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> INF_RATE / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unbounded</span></span> <span class="hljs-keyword"><span class="hljs-keyword">preceding</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>)) * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_RATE_ACCUMULATED <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (CALC_OVERHEADS_P.GET_DEBT_WITH_INF (p_debt_date_begin, p_debt_date_end, p_last_collection_date))) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION, INF_RATE_ACCUMULATED , (INF_RATE_ACCUMULATED - <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_COEF_ACCUMULATED , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> (((INF_RATE_ACCUMULATED - <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span>) * DEBT_AMOUNT, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_AMOUNT_ACCUMULATED <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_WITH_INF_AMOUNT_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION, INF_RATE_ACCUMULATED, INF_COEF_ACCUMULATED, INF_AMOUNT_ACCUMULATED , INF_AMOUNT_ACCUMULATED - lag (INF_AMOUNT_ACCUMULATED, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> INF_MONTH)) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_INF_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T is ret_value DEBT_OVERHEAD_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> , DEBT_DATE , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">exp</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ln</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> SKIP_INFLATION = <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> INF_RATE / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>))) - <span class="hljs-number"><span class="hljs-number">1</span></span>) * DEBT_AMOUNT, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_AMOUNT <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (CALC_OVERHEADS_P.GET_DEBT_WITH_INF (p_debt_date_begin, p_debt_date_end, p_last_collection_date)) <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_OVERHEAD_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, INF_AMOUNT) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_PCT_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_PCT_AMOUNT_LIST_T is ret_value DEBT_WITH_PCT_AMOUNT_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> DEBTS a <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">apply</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PAYMENT_DATE) + <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p_last_collection_date) - <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PAYMENT_DATE) + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> DEBT_DATE <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> p_debt_date_begin <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> p_debt_date_end ) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'31.12.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>) - <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'01.01.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_DAYS <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) , T3 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS , <span class="hljs-number"><span class="hljs-number">0.03</span></span> / PCT_YEAR_DAYS <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_PCT_PER_DAY <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2) , T4 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS, PCT_YEAR_PCT_PER_DAY , <span class="hljs-keyword"><span class="hljs-keyword">greatest</span></span> (PAYMENT_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'01.01.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD-MM-YYYY'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_BEGIN_DATE , <span class="hljs-keyword"><span class="hljs-keyword">least</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'31.12.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD-MM-YYYY'</span></span>), p_last_collection_date) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_END_DATE <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T3) , T5 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS, PCT_YEAR_PCT_PER_DAY, PCT_YEAR_BEGIN_DATE, PCT_YEAR_END_DATE , PCT_YEAR_END_DATE - PCT_YEAR_BEGIN_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_DAYS_CALC , (PCT_YEAR_END_DATE - PCT_YEAR_BEGIN_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span>) * PCT_YEAR_PCT_PER_DAY <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_PCT_PER_YEAR , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> ((PCT_YEAR_END_DATE - PCT_YEAR_BEGIN_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span>) * PCT_YEAR_PCT_PER_DAY * DEBT_AMOUNT, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_AMOUNT_PER_YEAR <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T4) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_WITH_PCT_AMOUNT_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS, PCT_YEAR_PCT_PER_DAY, PCT_YEAR_BEGIN_DATE, PCT_YEAR_END_DATE, PCT_YEAR_DAYS_CALC, PCT_YEAR_PCT_PER_YEAR, PCT_AMOUNT_PER_YEAR) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T5; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_PCT_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T is ret_value DEBT_OVERHEAD_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_OVERHEAD_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> (PCT_AMOUNT_PER_YEAR)) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (CALC_OVERHEADS_P.GET_DEBT_WITH_PCT_AMOUNT (p_debt_date_begin, p_debt_date_end, p_last_collection_date)) <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466401/">https://habr.com/ru/post/de466401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466379/index.html">F√ºhren Sie die Desktop-Software auf dem Mikrocontroller aus</a></li>
<li><a href="../de466381/index.html">Wie sich Era LED-Lampen im Jahr 2019 ver√§ndert haben</a></li>
<li><a href="../de466383/index.html">Cryptocurrency Ocean: √úberpr√ºfung der 50 besten Projekte mit CoinMarketCap</a></li>
<li><a href="../de466385/index.html">Nachrichtenbroker verstehen. Erlernen der Mechanismen des Messaging √ºber ActiveMQ und Kafka. Kapitel 1</a></li>
<li><a href="../de466397/index.html">Wir programmieren die Kassiererin neu und drucken darauf Keanu Reeves. Teil 2. PC-Software</a></li>
<li><a href="../de466403/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 35. Dynamisches DTP-Trunking-Protokoll</a></li>
<li><a href="../de466405/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 36. Kanalprotokoll STP</a></li>
<li><a href="../de466407/index.html">Rekrutierungskultur bei gro√üen Glassdoor-Statistikunternehmen</a></li>
<li><a href="../de466409/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 37. STP: Root Bridge-Auswahl, PortFast- und BPDU-Schutzfunktionen. Teil 1</a></li>
<li><a href="../de466413/index.html">Site Exchange f√ºr Bitrix und 1C: L√∂sung der Hauptprobleme</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>