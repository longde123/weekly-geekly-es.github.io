<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🌾 🧖 🍟 Ein bisschen Finanzmathematik: Berechnung von Inflation und Zinsen 🏗️ 👩🏿‍🤝‍👩🏻 🙌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor kurzem musste ich die Berechnungen der Stadtwerke überprüfen. Es gab ein kontroverses Problem, das nur durch korrekte Berechnungen gelöst werden k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein bisschen Finanzmathematik: Berechnung von Inflation und Zinsen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466401/"> Vor kurzem musste ich die Berechnungen der Stadtwerke überprüfen.  Es gab ein kontroverses Problem, das nur durch korrekte Berechnungen gelöst werden kann.  Mit Blick auf die Zukunft werde ich sagen, dass die öffentlichen Versorgungsunternehmen falsch denken.  Daher werden wir hier überlegen, wie die Inflationskosten und 3% pa ​​auf Schulden für Verpflichtungen gemäß dem Zivilgesetzbuch der Ukraine korrekt berechnet werden können. <br><br>  Der erste Teil beschreibt die Berechnung der Inflationskosten, dies ist spezifisch für die Ukraine. <br>  Der zweite (größere) Teil befasst sich mit der Berechnung von 3% pro Jahr.  Dies gilt auch für die Russische Föderation, Weißrussland und Kasachstan. In diesen Ländern ist der Zinssatz jedoch nicht festgelegt, sondern hängt vom Refinanzierungssatz der Zentralbank ab.  Der Rest des Landes sah nicht aus. <br><br>  Der zweite Teil ist sehr nahe an der Berechnung der Zinsen für normale Kreditgeschäfte (Kredite, Kredite, Kredite usw.). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/di/2q/9l/di2q9lbdqyzqzcywadgdnny0bgo.png" alt="Bild alt"></div><br>  Zuerst eine Theorie, am Ende ein kleiner Code. <br><br>  All dies unter dem Schnitt. <br><a name="habracut"></a><br>  Also kam ich in die Hände eines Dokuments der öffentlichen Versorgungsunternehmen "Erklärung über die Rückstellung von Inflationskosten und 3% pro Jahr".  Es wurde von mir überprüft und ich fand heraus, dass es mit dem falschen Algorithmus berechnet wurde und von Interesse ist, da es die Anforderungen des Artikels des Zivilgesetzbuches der Ukraine umsetzen muss. <br><br>  Was zu beachten ist, steht im Zivilgesetzbuch der Ukraine: <br><blockquote>  Artikel 625 des Zivilgesetzbuches der Ukraine.  "Verantwortung für die Verletzung einer Geldverpflichtung" <br>  (2) Ein Schuldner, der die Erfüllung einer Geldverpflichtung verzögert hat, ist auf Antrag des Gläubigers verpflichtet, den Betrag der Schuld unter Berücksichtigung des festgelegten Inflationsindex für den gesamten Verzögerungszeitraum sowie 3% pa ​​des überfälligen Betrags zu zahlen ... </blockquote>  Auf der Grundlage der Schuldenzahlen berechneten die öffentlichen Versorgungsunternehmen die Inflationskosten und 3% pro Jahr. <br><br><h2>  Inflationskosten </h2><br>  Weiter werde ich über den Berechnungsalgorithmus sprechen und nicht über bestimmte Zahlen. <br><br>  Die Inflation ist ein Prozess, der durch eine Abwertung der Währung gekennzeichnet ist, dh eine Abnahme ihrer Kaufkraft und einen allgemeinen Preisanstieg.  Ohne Inflation sind die Endergebnisse der Cashflow-Berechnungen sehr willkürlich. <br><br>  Inflationsindex (II) oder Verbraucherpreisindex (VPI), Verbraucherpreisindex (VPI) - eine der Arten von Preisindizes, die zur Messung des durchschnittlichen Preisniveaus für Waren und Dienstleistungen (Verbraucherkorb) für einen bestimmten Zeitraum in der Wirtschaft erstellt wurden. <br><br>  KI ist ein Indikator, der die Dynamik des allgemeinen Preisniveaus für Waren und Dienstleistungen kennzeichnet, die die Bevölkerung für den nicht produktiven Konsum erwirbt.  Dies ist der Wachstumsindex, der angibt, wie viel Prozent der durchschnittliche Preisanstieg im Berichtszeitraum beträgt. <br><br>  In der Ukraine sind KI und CPI synonym <br><br>  Da der Preisindex für aufeinanderfolgende Zeiträume ein Kettenindex ist, wird er durch Multiplikation der Indikatoren berechnet, z. B. 101% * 102% = (1,01 * 1,02) * 100% = 103,02%. <br><br>  AI wird vom Staatlichen Statistikausschuss der Ukraine berechnet und in offiziellen Zeitschriften veröffentlicht.  Diese Kennzahlen können zur Neuberechnung von Bargeldbeträgen verwendet werden. <br>  Was denken Gemeindearbeiter? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/5p/hv/ge5phvi9cjhbbz7kkx0jndzuyli.png" alt="Teil des abrechnungsbelegs"></div><br>  Der letzte Abrechnungstermin ist der 7. Dezember 2016. <br><br>  Mal sehen, wie die kommunalen Arbeiter Inflationskostenquoten bekamen? <br><br>  Mit bloßem Auge kann man sehen, dass in der dritten (und fünften Spalte) anstelle des ganzzahligen Teils 1 der ganzzahlige Teil 0 stehen sollte. Wie haben sie den Bruchteil erhalten? <br><br>  <strong>September 2016.</strong> Bruchteil 0.028.  Die Zahlungsfrist für September ist der 20. Oktober 2016. Der Bruchteil entspricht dem vom State Statistics Committee veröffentlichten Inflationsindex für Oktober 2016 - 102,8% <br><br>  <strong>August 2016.</strong> Bruchteil 0.0465.  Die Zahlungsfrist für August ist der 20. September 2016. Der Bruchteil entspricht dem Inflationsindex für September multipliziert mit II für Oktober: 101,8% * 102,8% = 104,65% oder in Aktien 1,018 * 1,028 = 1,046504.  Stadtwerke werden auf 1,0465 gerundet und drucken diese Zahl aus, obwohl die Einheit weggenommen werden sollte, da in der nächsten Spalte nur die Höhe der Inflationskosten und nicht der kumulierte Betrag angegeben werden. <br><br>  <strong>Juli 2016 und früher.</strong>  Ich habe diese Berechnungen durchgeführt und den Algorithmus wiederhergestellt.  Öffentliche Versorgungsunternehmen multiplizieren die Inflationsindizes ab dem Monat nach dem Monat der Leistungserbringung (Monat des Fälligkeitstermins) und endend mit Oktober 2016. <br><br>  <strong>Der Startpunkt ist</strong> nur teilweise wahr.  Wie ich später zeigen werde, muss die Berechnung im allgemeinen Fall wirklich ab diesem Monat beginnen, aber in unserem speziellen Fall sollte der erste Monat übersprungen werden (entspricht AI 100%). <br><br>  <strong>Der Endpunkt der</strong> Multiplikation.  Da der letzte Berechnungstag im Dezember liegt und Sie den Dezember beenden müssen, ist dies im Allgemeinen der Fall.  Wie ich später zeigen werde, muss in diesem speziellen Fall auch der Dezember übersprungen werden (entspricht auch AI 100%).  Und am 7. Dezember hatten die AIs im Dezember keine Zeit zum Veröffentlichen. <br><br>  Warum wird der November nirgendwo berücksichtigt?  Ich denke, sie haben einfach vergessen, es in das System einzugeben. <br><br>  Nun wollen wir sehen, wie der Inflationsindex berechnet wird.  Bei <strong>Bedarf</strong> - beschrieben im Informationsschreiben des Obersten Wirtschaftsgerichts der Ukraine Nr. 01-06 / 928/2012 vom 17.07.2012 [6]. <br><br>  Ich werde einen Teil des Absatzes geben: <br><blockquote>  Der vom 1. bis zum 15. Tag des Monats zu zahlende Schuldenbetrag wird unter Berücksichtigung dieses Monats indexiert. Wenn die Schulden vom 16. bis zum 31. Tag des Monats bezahlt werden sollen, beginnt die Berechnung mit dem nächsten Monat. <br><br>  Wenn eine Schuld von 1 bis 15 Tagen im Monat zurückgezahlt wurde, werden die Inflationskosten ohne Berücksichtigung dieses Monats berechnet, und wenn von 16 bis 31 Tagen im Monat die Inflationskosten unter Berücksichtigung dieses Monats berechnet werden. </blockquote>  In unserem Fall ist die Zahlungsfrist der 20. Tag des Monats, der auf den Monat der Leistungserbringung folgt, d. H.  Für die Erbringung von Dienstleistungen im September ist der Beginn der Abrechnung der 21. Oktober 2016 und die Frist der 7. Dezember 2016. <br><br>  Das heißt,  Es ist richtig, dies zu berücksichtigen: Berücksichtigen Sie bei der Erbringung von Dienstleistungen im September 2016 die Inflation für drei Monate (übergeben Sie den Cursor oder den Zyklus) von Oktober bis Dezember. Berücksichtigen Sie jedoch im ersten und letzten Monat die KI gleich 1 (100%) und berücksichtigen Sie nur den November. <br><br>  Im November 2016 betrug die KI 101,8%, d.h.  Der Koeffizient sollte 0,0180 und nicht 0,0280 betragen.  Ich habe vorher über die Lead Unit geschrieben. <br><br><h2>  3% pro Jahr </h2><br>  Mal sehen, wie die kommunalen Dienste Koeffizienten und Rückstellungsbeträge von 3% pro Jahr erhalten haben.  Dies ist die fünfte Spalte in der obigen Tabelle. <br><br>  Wie ich bereits geschrieben habe, sollte es keine führende Einheit geben, es sollte 0 sein. Wir betrachten den Bruchteil und stellen fest, dass er irgendwie verdächtig rund ist - jeder Vormonat ist 0,0025 mehr als der aktuelle Monat. <br><br>  Mit einfachen Berechnungen kann festgestellt werden, dass die öffentlichen Versorgungsunternehmen ohne weiteres 3% in 12 Monate aufgeteilt haben, 0,0025 oder 0,25% pro Monat erhalten haben und diesen Prozentsatz für jeden vollen und unvollständigen Monat der Verzögerung erhalten.  Ja, wenn Sie sich den Oktober 2016 ansehen, dessen Zahlungsfrist am 21. November lag und dessen Berechnungen am 7. Dezember durchgeführt wurden, dann zählten sie für einen unvollständigen Monat die gleichen 0,25%. <br><br>  Der Ansatz bewundert brutale Geradlinigkeit, aber wie ich später zeigen werde, kennt die Finanzmathematik einen solchen Algorithmus nicht. <br><br>  Die Gesetzgebung der Ukraine und die Finanzmathematik geben keine klare Antwort auf die Frage, wie 3% pro Jahr berechnet werden sollen.  Ich habe nach mehreren Büchern zu diesem Thema gesucht, aber Bücher sind uralt und stammen aus dem Jahr 2002.  Daher werden die Algorithmen aus den Büchern durch die Tatsache ergänzt, dass es möglich war, aus moderneren und westlicheren Artikeln zu googeln.  [1] wurde 2007 nachgedruckt, und neuere russischsprachige Bücher konnten nicht gefunden werden.  Vielleicht, weil die Finanzmathematik als Wissenschaft vor sehr langer Zeit, lange vor dem Aufkommen der Computer, ihren Ursprung hatte, entstanden vor einigen hundert Jahren Konzepte wie „Kredit“ und „Zins auf Kredit“.  Und die Algorithmen haben sich seit 2002 nicht viel geändert. <br><br>  Die westliche Sichtweise des Problems unterscheidet sich jedoch von der in russischsprachigen Büchern beschriebenen.  Ich werde zuerst Informationen aus russischsprachigen Büchern und dann aus westlichen Artikeln zitieren, aus denen hervorgeht, wo sie zusammenfallen. <br><br>  Was nachstehend geschrieben wird, bezieht sich auf den speziellen Fall, dass 3% pa ​​nachträglich anfallen, kann jedoch auf die Berechnung der Zinsen für andere Kreditbeziehungen verallgemeinert werden, wenn die Zinsen eher nach dem einfachen Zins- als nach dem Zinseszinsschema aufgelaufen sind. <br><br>  Nach Art.  625 Das Zivilgesetzbuch der Ukraine muss nach dem einfachen Zinsschema 3% pro Jahr anfallen.  Zur Berechnung des Zinsbetrags muss der Schuldenbetrag (oder im Allgemeinen der Kreditkörper) mit dem normalisierten jährlichen Zinssatz von 3% multipliziert und mit dem Bruchteil des Jahres (Dauer in Jahren) multipliziert werden, auf den sich die Verzögerung belief.  Dieser Anteil kann mehr als 1 betragen, wenn die Verzögerung mehr als ein Jahr beträgt. <br><br>  Die Verspätungsdauer wird in Tagen angegeben.  In einem allgemeineren Fall kann die Darlehenslaufzeit in Tagen ausgedrückt werden (die Situation, in der die Darlehenslaufzeit in Monaten und Jahren ausgedrückt wird, wird hier nicht berücksichtigt).  Und der jährliche Zinssatz von 3% ist der normalisierte einfache Zinssatz für das Jahr.  <strong>Daher müssen Sie in der Lage sein, die Dauer der Verzögerung (Gutschrift) in Tagen auf die Dauer in Jahren zu bringen.</strong>  <strong>Dies ist keine triviale Aufgabe, da die Länge des Jahres von seiner Anzahl abhängt.</strong> <br><br>  Die Dauer in Tagen ist ein eindeutig definiertes Maß für die Dauer von Kalenderlücken im Gegensatz zur Dauer in Jahren.  Die Definition des letzteren bedarf einer Klarstellung in Form einer Regel zur Umrechnung der Dauer in Tagen in die Dauer in Jahren.  Eine Reihe von Standardmethoden zur Umrechnung der Dauer in Tagen in die Dauer in Jahren basiert auf der Division der Anzahl der Tage durch den sogenannten <strong>„jährlichen Teiler“</strong> .  Die typischsten Werte des jährlichen Teilers sind 360 und 365 Tage.  Im einfachsten Fall ist der Divisor eine konstante und intervallunabhängige Zahl.  Die Anzahl der Tage in einem Zeitraum dient immer als Dividende (Zähler eines Bruchteils). <br>  Und Sie müssen sich für das Verfahren zur Berechnung der Bedingungen in Tagen entscheiden.  Betrachten wir zwei weit hergeholte Beispiele: <br><br><ol><li>  Der Kunde erhält vom 6. Dezember 2018 bis zum 7. Dezember 2018 ein kurzfristiges Darlehen von der Bank.  Was ist die Vertragslaufzeit und wie viele Tage brauche ich, um Zinsen zu erhalten?  Offensichtlich - 1 Tag. </li><li>  Der Teilnehmer bestellt den Dienst beim Telekommunikationsbetreiber mit einer zukünftigen Gültigkeitsdauer vom 6. Dezember 2018 bis zum 7. Dezember 2018 vor.  Was sind die Linien der Servicebereitstellung und für wie viele Tage muss ich eine Abonnementgebühr für den Service erheben?  Offensichtlich 2 Tage. </li></ol><br>  Was ist der Unterschied? <br><br>  Tatsache ist, dass der Tag kein Punkt auf der Zeitachse ist, sondern ein Intervall, das auf zwei Arten geschrieben werden kann (erinnern Sie sich, die eckige Klammer am Rand des Intervalls bedeutet, dass der Punkt im Intervall liegt, die Klammer ist der Punkt, der nicht im Intervall liegt): <br><br><ul><li>  [06.12.2018 00.00.00, 12/07/2018 00.00.00) - hier ist der rechte Rand des Intervalls nicht im Intervall enthalten, </li><li>  [06/12/2018 00.00.00, 12/06/2018 23.59.59] - hier ist der rechte Rand des Intervalls im Intervall enthalten. </li></ul><br>  Im ersten Fall (1) wird normalerweise die genaue Anzahl der Tage berechnet, einschließlich des ersten oder letzten Tages, jedoch nicht beider, wenn das Zeitintervall nicht explizit, sondern in Form eines Intervalls zwischen Daten angegeben wird.  [4] sagt dasselbe mit anderen Worten: "Der Tag der Kreditvergabe und der Rückzahlungstag gelten als ein Tag." <br><br>  Diese Methode bestimmt die sogenannte genaue Zeit.  Es kann auch leicht festgestellt werden, ob sich beide Daten auf dasselbe Jahr beziehen und ein Kalender mit der Seriennummer jedes Tages des Jahres verfügbar ist.  Dann reicht es aus, die Seriennummer des frühen Datums von der Seriennummer des späten Datums zu subtrahieren, und das Ergebnis gibt die Dauer des Zeitraums an.  In Oracle Database können Sie einfach Daten (Typ DATE), die auf einen Tag (mit verworfener Zeit) gekürzt wurden, voneinander subtrahieren. Der Unterschied ist eine ganzzahlige Anzahl von Tagen. <br><br>  Im zweiten Fall (2) sprechen wir über Tage, also zählen wir zwei Tage. <br><br>  Ferner gehe ich von der Tatsache aus, dass die Anzahl der Tage, die Sie bereits festgelegt haben, beispielsweise im Fall von kommunalen Diensten, wenn die Zahlungsfrist der 20. September ist (d. H. Dies ist der letzte akzeptable Zahlungstag) und am 21. September gezahlt wurde, d. H. Es ist offensichtlich, dass die Verzögerung 1 Tag betragen muss.  Wenn Sie mit einer Angabe des Intervalls ohne linken Rand konfrontiert werden, verschieben Sie den linken Rand einfach einen Tag nach rechts. <br><br>  Wie zählen wir die Anzahl der Tage und den Zähler eines Bruchs?  Es gibt eine genaue Berechnung und eine ungefähre Berechnung. <br><br><h3>  Genaue Zählung der Tage </h3><br><h4>  Russischsprachige Praxis </h4><br>  Der Text basiert weiter auf [1]. <br><br>  Die Wahl der genauen Anzahl von Tagen in einem Zeitraum als Teiler und die beiden häufigsten Regeln geben die häufigsten Regeln als Nenner an - ein jährlicher Teiler von 360 oder 365: <br><br>  <strong>Regel (R1) ACT / 365.</strong>  Für diese Regel wird die Dauer in Tagen durch die Zahl 365 geteilt. Ich stelle fest, dass die Länge eines Schaltjahres 366/365 = 1,00274 beträgt, was mehr als eins ist.  Der ACT / 365-Regelfehler ist umso größer, je mehr Schaltjahre in einem Zeitraum vorhanden sind.  Daher beträgt der durch diese Regel aufgelaufene Wert von 3% pro Jahr mehr als 3%. <br><br>  <strong>Regel (R2) ACT / 360.</strong>  Dies ist die sogenannte „Bankregel“, nach der die Dauer in Tagen durch 360 geteilt wird. Diese Regel erhöht die jährliche Länge der Lücken weiter.  Für ein Nicht-Schaltjahr beträgt seine Länge 365/360 = 1,01389 und für ein Schaltjahr 366/360 = 1,01667.  Je länger der Zeitraum ist, desto größer ist natürlich der Grad der „Dehnung“ in Jahren.  Diese Regel wird am häufigsten in Berechnungen verwendet, die sich auf den Geldmarkt beziehen, d. H.  kurzfristige Marktschulden wie Einlagen bei Banken, Wechsel, Commercial Papers, Einlagenzertifikate usw. Der Wert von 3% pro Jahr für das Jahr ist sogar noch höher als bei Verwendung der vorherigen Regel. <br><br>  Für den Fall, dass der jährliche Teiler in Höhe von 360 Tagen akzeptiert wird, werden die mit einem solchen Teiler erzielten Zinsen als <strong>gewöhnlich</strong> oder <strong>kommerziell bezeichnet</strong> .  Wenn der Divisor gleich 365 oder, wie ich später zeigen werde, 366 Tage angenommen wird, wird das Interesse als genau bezeichnet. <br><br>  Offensichtlich sind gewöhnliche Prozentsätze mehr als genau. <br><br>  Obwohl die erste Regel genauer ist als die zweite, sind beide nicht genau genug. <br><br>  Um die Auswirkung von Schaltjahren auf die Ergebnisse zu eliminieren, gibt es zwei weitere Regeln. <br><br>  <strong>Regel (R3) ACT / 365, Japan.</strong>  Die Berechnung wird auf die gleiche Weise wie für die ACT / 365-Regel durchgeführt, aber bei der Berechnung der Intervalldauer (Bruchzähler) werden Schaltdaten ausgeschlossen.  Der jährliche Teiler bleibt unverändert. <br><br>  Laut Wiki: <br><blockquote>  In vielen europäischen Ländern galt der 29. Februar bis zum 18. Jahrhundert als nicht existierender Tag, ein Datum, das keinen rechtlichen Status hat.  Oft wurden an diesem Tag keine Transaktionen getätigt, keine Zahlungen getätigt, keine Schulden gemacht usw., da es Schwierigkeiten mit der formalen Seite der Angelegenheit und der gerichtlichen Beilegung von Fällen gab. </blockquote><br><br>  Ein anderer Weg hängt mit der tatsächlichen Änderung des Divisors zusammen. <br><br>  <strong>Regel (R4) ACT / ACT basic.</strong>  Wir teilen den gewünschten Zeitraum in drei Teile: <br><br><ul><li>  der erste Teil vom Startdatum bis zum Ende des Jahres, in dem sich das Startdatum befindet, </li><li>  der dritte Teil - vom Beginn des Jahres, in dem sich das Enddatum befindet, bis zum Enddatum, </li><li>  der zweite Teil - 0 oder mehrere volle Kalenderjahre zwischen dem ersten und dritten Teil. </li></ul><br>  Die Dauer des ersten und dritten Teils ergibt sich aus der Division der Anzahl der Tage durch den jährlichen Teiler 365 oder 366, je nachdem, ob es sich um ein Schaltjahr handelt.  Die Dauer der zweiten Periode besteht per Definition aus einer Ganzzahl von vollen Kalenderjahren, unabhängig davon, ob es sich um einen Sprung handelt oder nicht.  Die Dauer in Jahren des gesamten Zeitraums ergibt sich aus der Summe der Dauer von drei Teilen, dargestellt durch drei Zahlen, von denen die zweite ein Ganzes ist und die erste und dritte gebrochen sind. <br><br>  <strong>Regel (R5) ACT / ACT „kurze“ Änderung für Zeiträume von weniger als einem Jahr.</strong>  In diesem Fall wird die Dauer in Tagen durch den jährlichen Teiler 365 oder 366 geteilt, je nachdem, ob es im Suchzeitraum ein Datum am 29. Februar gibt.  Ein Merkmal der kurzen ACT / ACT-Regel ist, dass die Anwendung der Grund- und Kurzregeln zu unterschiedlichen Ergebnissen führt, wenn das Intervall nicht in das Kalenderjahr passt (seine Enden gehören zu den Nachbarjahren). <br><br><h4>  Westliche Praxis </h4><br>  In der westlichen Praxis werden die Regeln unterschiedlich beschrieben.  Oft erhalten dieselben russischsprachigen Regeln unterschiedliche Namen und darüber hinaus nicht jeweils einen. <br><br>  Die Informationen basieren ferner auf [2].  Dies ist Vicki, ich habe alle Quellen überprüft und andere Google-Informationen verwendet: In Regeln mit einer genauen Anzahl von Tagen ist alles korrekt, aber in Regeln mit einer ungefähren Anzahl von Tagen gibt es andere Interpretationen der Regeln, und oft ändern sie sich im Laufe der Zeit, um die Regeln in die Praxis umzusetzen. Die ungefähre Anzahl der Tage, die dieser Artikel nicht ausreicht. <br><br>  <strong>Regel (W1) Tatsächliche / tatsächliche ISDA.</strong>  Diese Regel liefert das gleiche Ergebnis wie (R4) „ACT / ACT main“, ist jedoch unterschiedlich formuliert: Das Intervall wird in Schalt- und Nicht-Schaltjahre unterteilt, unabhängig davon, ob sie voll oder unvollständig sind, und die Summe der Tage, in die sie fallen Schaltjahre, geteilt durch 365, und die Summe der Tage in Nicht-Schaltjahren wird durch 366 geteilt, die beiden Zahlen werden summiert. <br><br>  Andere Namen der Regel in der westlichen Praxis: Actual / Actual, Act / Act, Actual / 365, Act / 365.  Ja, der Nachname ist derselbe wie die Regel (R1), obwohl das Wesen der Regel unterschiedlich ist. <br><br>  <strong>Regel (W2) Ist / 365 behoben.</strong>  Diese Regel wiederholt genau die Regel (R1) ACT / 365 - die Anzahl der Tage wird durch 365 geteilt. <br><br>  Andere Namen der Regel in der westlichen Praxis: Act / 365 Fixed, A / 365 Fixed, A / 365F, Englisch. <br><br>  <strong>Regel (W3) Ist / 360.</strong>  Diese Regel wiederholt (R2) ACT / 360 - die genaue Anzahl der Tage wird durch 360 geteilt. <br><br>  <strong>Regel (W4) Ist / 364.</strong>  Die Anzahl der Tage wird durch 364 geteilt. In der russischsprachigen Praxis gibt es kein Analogon. <br><br>  <strong>Regel (W5) Ist / 365L.</strong>  Es besteht aus zwei Verbesserungen: <br><ol><li>  Für jährliche Zahlungen.  Wenn das Datum innerhalb des Zeitraums der 29. Februar ist, wird die Anzahl der Tage in dem Zeitraum durch den jährlichen Teiler 366 geteilt, wenn nicht durch 365. In diesem Sinne stimmt dies mit der Regel (R5) ACT / ACT „kurze Änderung“ überein. </li><li>  Wenn die Häufigkeit der Zahlungen von der jährlichen abweicht.  Wenn das Enddatum in einem Schaltjahr liegt (und nicht unbedingt dem 29. Februar entspricht), beträgt der jährliche Teiler 366, andernfalls - 365. In der russischsprachigen Praxis gibt es kein Analogon. </li></ol><br>  Ein anderer Name ist ISMA-Jahr. <br><br>  <strong>Regel (W6) Tatsächliche / tatsächliche AFB.</strong>  Es besteht aus zwei Verbesserungen: <br><ol><li>  Die wichtigste für Zeiträume von weniger als einem Jahr: Wenn das Datum innerhalb des Zeitraums der 29. Februar ist, wird die Anzahl der Tage in dem Zeitraum durch den jährlichen Teiler 366, wenn nicht durch 365 geteilt. In diesem Sinne stimmt sie auch mit der R / ACT ACT / ACT-Regel „kurze Änderung“ überein . </li><li>  Erweitert für Zeiträume von mehr als einem Jahr: Ein ganzzahliges ganzes Jahr wird vom Enddatum bis zum Startdatum zurückgezählt.  Für einen Saldo von weniger als einem Jahr gilt die Hauptregel.  Die Anzahl der vollen Jahre und der Anteil des Jahres nach der Grundregel werden zusammengefasst. <br></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Countdown vor Jahren sind Nuancen verbunden, wenn der Countdown am 28. Februar durchgeführt wurde, und nach einer ganzen Reihe von vollen Jahren stellte sich heraus, dass das Jahr ein Schaltjahr war. </font><font style="vertical-align: inherit;">In diesem Fall sollte das Datum vor n Jahren am 29. Februar festgelegt werden. </font><font style="vertical-align: inherit;">Ich füge hinzu, dass sich die Frage auch stellt, ob der Countdown ab dem 29. Februar durchgeführt wurde und die Anzahl der vollen Jahre nicht ein Vielfaches von vier ist, und dementsprechend war das Vorjahr kein Schaltjahr. </font><font style="vertical-align: inherit;">Ich habe hier nicht auf Details eingegangen. </font><font style="vertical-align: inherit;">Sie können jedoch auf die Links aus [2] verweisen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und "Kirsche auf dem Kuchen", </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel (W7) 1/1. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anzahl der Tage wird durch den jährlichen Teiler 365,25 geteilt. </font><font style="vertical-align: inherit;">Wird für Inflationsberechnungen verwendet.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geschätzte Tage zählen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die oben aufgeführten Regeln basierten auf der genauen Dauer in Tagen von Kalenderperioden. Manchmal gibt es jedoch Schemata, die auf der sogenannten vereinfachten oder ungefähren Zählung von Tagen basieren. Die Idee dieser Systeme ist es, die Dauer aller Monate auf 30 Tage „auszugleichen“. Somit besteht das Jahr aus 12 Monaten von 30 Tagen, d.h. von 360 Tagen. Daher beträgt der jährliche Teiler (Nenner des Bruchs) für diese Regeln immer 360, und der Zähler wird auf spezielle Weise berechnet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die genaue Anzahl der Tage eines Kredits in den meisten Fällen, aber natürlich nicht immer, mehr als ungefähr ist (wie leicht durch die Bestimmung der durchschnittlichen Anzahl von Tagen in einem Monat für ein Jahr, die 30,44 beträgt), ergibt sich normalerweise die Zinsberechnungsmethode mit der genauen Anzahl von Tagen eines Kredits größeres Wachstum als ungefähr. [4]</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die einfachste Version dieser Regel, die sogenannte </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grundregel 30/360</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wird wie folgt beschrieben (im Folgenden die Informationen im Buch [1] - Russischsprachige Praxis): </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grundregel 30/360. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die ungefähre Anzahl der Tage zwischen den Daten beträgt</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 360 * (y2 - y1) + 30 * (m2 - m1) + (d2 - d1), </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wobei y, m, d - Jahr, Monat und Tag im zweiten und ersten Datum. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Regel trat vor der Erstellung der ersten Computergeräte auf und sparte die Kosten für Computeroperationen in der Finanzpraxis erheblich. </font><font style="vertical-align: inherit;">Obwohl jetzt die Notwendigkeit vereinfachter Methoden verschwunden ist, haben sie, nachdem sie in der Praxis Fuß gefasst haben, traditionell manchmal gegenwärtig verwendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Regel gilt mit einem obligatorischen Hinweis auf eine Änderung, die angibt, wie mit den letzten Tagen der Monate umzugehen ist:</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Russischsprachige Praxis </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gegeben von [1]. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel (R6) 30/360 ISDA. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn d1 = 31, dann ist d1 '= 30, andernfalls ist d1' = d1. </font><font style="vertical-align: inherit;">Wenn d2 = 31 und d1 '= 30, dann ist d2' = 30, andernfalls ist d2 '= d2. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel (R7) 30E / 360. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn d1 = 31, dann ist d1 '= 30, andernfalls ist d1' = d1. </font><font style="vertical-align: inherit;">Wenn d2 = 31, dann ist d2 '= 30, andernfalls ist d2' = d2. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Regel ist eine Variante der ISDA-Regel 30/360, die hauptsächlich in Europa verwendet wird, daher die Bezeichnung „E“ im Namen der Regel. </font><font style="vertical-align: inherit;">Es unterscheidet sich von der ISDA-Regel 30/360 nur, wenn das zweite Datum auch das 31. ist. </font><font style="vertical-align: inherit;">Die europäische Version konvertiert sie unabhängig vom ersten Datum immer in die 30. Nummer. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel (R8) 30/360 PSA. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn d1 = 31 oder d1 der letzte Tag im Februar ist, dann ist d1 '= 30, andernfalls ist d1' = d1. </font><font style="vertical-align: inherit;">Wenn d2 = 31 und d1 '= 30, dann ist d2' = 30, andernfalls ist d2 '= d2.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Beschreibung der 30/360 SIA-Regel in [1] ist höchstwahrscheinlich ein Fehler, daher werde ich sie hier nicht angeben. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Westliche Praxis </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gegeben nach [2]. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel (W8) 30/360 Anleihebasis.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gleich wie (R6) 30/360 ISDA. Anderer Name: 30A / 360. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel (W9) 30E / 360.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gleich wie (R7) 30E / 360. Andere Namen: 30/360 ICMA, 30S / 360, Eurobond-Basis (ISDA 2006), Spezialdeutsch. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel (W10) 30E / 360 ISDA.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn d1 der letzte Tag des Monats ist, ist d1 '= 30. Wenn d2 der letzte Tag von NICHT Februar ist, dann ist d2 '= 30. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere Namen: 30E / 360 ISDA, Eurobond-Basis (ISDA 2000), Deutsch. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel (W11) 30/360 SIA.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn d1 der letzte Tag im Februar und d2 der letzte Tag im Februar ist, dann ist d2 '= 30. Wenn d1 = 31 oder der letzte Tag im Februar ist, dann ist d1 '= 30, andernfalls ist d1' = d1. Wenn d1 '= 30 und d2 = 31, dann ist d2' = 30, andernfalls ist d2 '= d1.</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Regeln (R4) ACT / ACT, (W1) Actual / Actual ISDA, (W2) Actual / 365 Fixed werden auch als "English Practice" bezeichnet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Regeln (R2) ACT / 360 und (W3) Actual / 360 werden auch als „französische Praxis“ bezeichnet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regel (R7) 30E / 360, (W9) 30E / 360 und (W10) 30E / 360 ISDA werden auch als "deutsche Praxis" oder "deutsche Praxis" bezeichnet. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter Berücksichtigung des genauen und gewöhnlichen Interesses sowie der genauen und ungefähren Anzahl von Tagen für die Berechnung des Interesses erhalten wir vier Methoden zur Berechnung des einfachen Interesses (die Namen der Regeln sind in der russischsprachigen Praxis angegeben):</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Normales Interesse mit der genauen Anzahl von Tagen (ACT / 360 - Bankregel), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Genaue Prozentsätze mit der genauen Anzahl von Tagen (ACT / 365, ACT / ACT), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Normales Interesse mit einer ungefähren Anzahl von Tagen (30/360), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Genaue Prozentsätze mit einer ungefähren Anzahl von Tagen. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste am häufigsten verwendete Methode wird als Bankregel bezeichnet, seltener als zweite und dritte und fast nie als vierte [1]. Und [4] sagt: "... eine Berechnungsoption mit genauen Zinsen und einer ungefähren Anzahl von Darlehenstagen ist bedeutungslos und gilt nicht." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die obigen Berechnungen der ungefähren Dauer von Perioden in Bruchteilen eines Jahres zeigen die Nicht-Trivialität und Vielfalt der angewandten Regeln. Ihre Anwendung (sowie Herkunft) hängt von Land, Währung, Art des Finanzinstruments, Berufsverband und Vereinbarungen ab. [1] </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SCHLUSSFOLGERUNG:</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie zähle ich in meinem Fall 3% bei öffentlichen Versorgungsunternehmen in der Ukraine?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse der gerichtlichen Praxis der Anwendung von Art. 625 des Zivilgesetzbuches der Ukraine besagt, dass normalerweise die Methode (R1) ACT / 365 [3] angewendet wird, die jedoch nicht klar formuliert ist. Ich denke, dass Sie noch (R4) ACT / ACT anwenden müssen, und hier ist der Grund: Wenn Sie mit der ACT / 365-Methode 3% für ein volles Schaltjahr verdienen, entspricht der Zinsbetrag 3,008219%, was für Schulden (oder die Größe des Darlehensorgans) gilt. von 1 Million Geldeinheiten ergibt einen Überschuss von 82,19 WE über 3%, die durch den jährlichen standardisierten Zinssatz nach dem Gesetz festgelegt sind. Dies wird besonders wichtig mit der fortschreitenden Zinsabgrenzung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich würde mich über Kommentare freuen, insbesondere von Bankangestellten. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendete Quellen</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1) Bocharov, P. P., Kasimov, Yu. F. Financial Mathematics. Moskau: Gardariki, 2002 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) Tagzählkonvention,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Day_count_convention</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3) Analyse der Anwendung von Kunst. 625 des Zivilgesetzbuches der Ukraine in Zivilverfahren, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zib.com.ua/ua/74602-analiz_praktiki_zastosuvannya_st_625_civilnogo_kodeksu_ukrai.html</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4) Chetyrkin E.M. Finanzmathematik. Moskau: Rechtssache 2005 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tageszählungskonventionen</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Abgrenzungsfaktoren</font></a><font style="vertical-align: inherit;"> , </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">docs.fincad.com/support/developerfunc/mathref/Daycount.htm</font></a></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6) Informationsschreiben des Obersten Wirtschaftsgerichts der Ukraine Nr. 01-06 / 928/2012 vom 17.07.2012, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zakon.rada.gov.ua/laws/show/v_928600-12</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und jetzt ein kleiner Code zur Oracle-Datenbank: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein Paket, das ich für meinen speziellen Fall erstellt habe - es berechnet die Inflationskosten und 3% pro Jahr für die Ukraine.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Oracle Database gibt es keine Aggregatfunktion, die Inflationswerte multipliziert. </font><font style="vertical-align: inherit;">Daher verwende ich die Summation von Logarithmen.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_OVERHEAD_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, OVERHEAD_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_AMOUNT_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, DEBT_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PAYMENT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_MONTH <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_RATE <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, SKIP_INFLATION <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>), INF_RATE_ACCUMULATED <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> , INF_COEF_ACCUMULATED <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, INF_AMOUNT_ACCUMULATED <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, INF_AMOUNT_MONTH <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, DEBT_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PAYMENT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_MONTH <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_RATE <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, SKIP_INFLATION <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_PCT_AMOUNT_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, DEBT_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PAYMENT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, PCT_YEAR <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_DAYS <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_PCT_PER_DAY <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_BEGIN_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span> , PCT_YEAR_END_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, PCT_YEAR_DAYS_CALC <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_PCT_PER_YEAR <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_AMOUNT_PER_YEAR <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_OVERHEAD_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_OVERHEAD_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_AMOUNT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_WITH_INF_AMOUNT_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_WITH_INF_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_PCT_AMOUNT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_WITH_PCT_AMOUNT_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> CALC_OVERHEADS_P <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> GET_DEBT_WITH_INF (p_debt_date_begin <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_debt_date_end <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_last_collection_date <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DEBT_WITH_INF_LIST_T; function GET_DEBT_WITH_INF_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_INF_AMOUNT_LIST_T; function GET_DEBT_WITH_INF_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T; function GET_DEBT_WITH_PCT_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_PCT_AMOUNT_LIST_T; function GET_DEBT_WITH_PCT_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span> CALC_OVERHEADS_P <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> GET_DEBT_WITH_INF (p_debt_date_begin <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_debt_date_end <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_last_collection_date <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DEBT_WITH_INF_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ret_value DEBT_WITH_INF_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a.ID, a.DEBT_DATE, a.DEBT_AMOUNT, a.PAYMENT_DATE, b.INF_MONTH, c.AVAL <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_RATE <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> DEBTS a <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">apply</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> add_months (trunc (a.PAYMENT_DATE, <span class="hljs-string"><span class="hljs-string">'month'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= months_between (trunc (p_last_collection_date, <span class="hljs-string"><span class="hljs-string">'month'</span></span>), trunc (a.PAYMENT_DATE, <span class="hljs-string"><span class="hljs-string">'month'</span></span>)) + <span class="hljs-number"><span class="hljs-number">1</span></span>) b <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> INFLATION c <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> c.ADATE = b.INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.TYP = <span class="hljs-string"><span class="hljs-string">'M'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a.DEBT_DATE <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> p_debt_date_begin <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> p_debt_date_end ) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE , <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> trunc (PAYMENT_DATE, <span class="hljs-string"><span class="hljs-string">'month'</span></span>) = INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PAYMENT_DATE) <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> trunc (p_last_collection_date, <span class="hljs-string"><span class="hljs-string">'month'</span></span>) = INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p_last_collection_date) <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> SKIP_INFLATION <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_WITH_INF_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_INF_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_INF_AMOUNT_LIST_T is ret_value DEBT_WITH_INF_AMOUNT_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION , <span class="hljs-keyword"><span class="hljs-keyword">exp</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ln</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> SKIP_INFLATION = <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> INF_RATE <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> INF_RATE / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unbounded</span></span> <span class="hljs-keyword"><span class="hljs-keyword">preceding</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>)) * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_RATE_ACCUMULATED <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (CALC_OVERHEADS_P.GET_DEBT_WITH_INF (p_debt_date_begin, p_debt_date_end, p_last_collection_date))) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION, INF_RATE_ACCUMULATED , (INF_RATE_ACCUMULATED - <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_COEF_ACCUMULATED , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> (((INF_RATE_ACCUMULATED - <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span>) * DEBT_AMOUNT, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_AMOUNT_ACCUMULATED <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_WITH_INF_AMOUNT_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION, INF_RATE_ACCUMULATED, INF_COEF_ACCUMULATED, INF_AMOUNT_ACCUMULATED , INF_AMOUNT_ACCUMULATED - lag (INF_AMOUNT_ACCUMULATED, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> INF_MONTH)) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_INF_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T is ret_value DEBT_OVERHEAD_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> , DEBT_DATE , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">exp</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ln</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> SKIP_INFLATION = <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> INF_RATE / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>))) - <span class="hljs-number"><span class="hljs-number">1</span></span>) * DEBT_AMOUNT, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_AMOUNT <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (CALC_OVERHEADS_P.GET_DEBT_WITH_INF (p_debt_date_begin, p_debt_date_end, p_last_collection_date)) <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_OVERHEAD_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, INF_AMOUNT) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_PCT_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_PCT_AMOUNT_LIST_T is ret_value DEBT_WITH_PCT_AMOUNT_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> DEBTS a <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">apply</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PAYMENT_DATE) + <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p_last_collection_date) - <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PAYMENT_DATE) + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> DEBT_DATE <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> p_debt_date_begin <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> p_debt_date_end ) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'31.12.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>) - <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'01.01.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_DAYS <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) , T3 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS , <span class="hljs-number"><span class="hljs-number">0.03</span></span> / PCT_YEAR_DAYS <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_PCT_PER_DAY <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2) , T4 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS, PCT_YEAR_PCT_PER_DAY , <span class="hljs-keyword"><span class="hljs-keyword">greatest</span></span> (PAYMENT_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'01.01.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD-MM-YYYY'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_BEGIN_DATE , <span class="hljs-keyword"><span class="hljs-keyword">least</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'31.12.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD-MM-YYYY'</span></span>), p_last_collection_date) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_END_DATE <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T3) , T5 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS, PCT_YEAR_PCT_PER_DAY, PCT_YEAR_BEGIN_DATE, PCT_YEAR_END_DATE , PCT_YEAR_END_DATE - PCT_YEAR_BEGIN_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_DAYS_CALC , (PCT_YEAR_END_DATE - PCT_YEAR_BEGIN_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span>) * PCT_YEAR_PCT_PER_DAY <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_PCT_PER_YEAR , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> ((PCT_YEAR_END_DATE - PCT_YEAR_BEGIN_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span>) * PCT_YEAR_PCT_PER_DAY * DEBT_AMOUNT, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_AMOUNT_PER_YEAR <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T4) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_WITH_PCT_AMOUNT_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS, PCT_YEAR_PCT_PER_DAY, PCT_YEAR_BEGIN_DATE, PCT_YEAR_END_DATE, PCT_YEAR_DAYS_CALC, PCT_YEAR_PCT_PER_YEAR, PCT_AMOUNT_PER_YEAR) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T5; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_PCT_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T is ret_value DEBT_OVERHEAD_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_OVERHEAD_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> (PCT_AMOUNT_PER_YEAR)) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (CALC_OVERHEADS_P.GET_DEBT_WITH_PCT_AMOUNT (p_debt_date_begin, p_debt_date_end, p_last_collection_date)) <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466401/">https://habr.com/ru/post/de466401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466379/index.html">Führen Sie die Desktop-Software auf dem Mikrocontroller aus</a></li>
<li><a href="../de466381/index.html">Wie sich Era LED-Lampen im Jahr 2019 verändert haben</a></li>
<li><a href="../de466383/index.html">Cryptocurrency Ocean: Überprüfung der 50 besten Projekte mit CoinMarketCap</a></li>
<li><a href="../de466385/index.html">Nachrichtenbroker verstehen. Erlernen der Mechanismen des Messaging über ActiveMQ und Kafka. Kapitel 1</a></li>
<li><a href="../de466397/index.html">Wir programmieren die Kassiererin neu und drucken darauf Keanu Reeves. Teil 2. PC-Software</a></li>
<li><a href="../de466403/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 35. Dynamisches DTP-Trunking-Protokoll</a></li>
<li><a href="../de466405/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 36. Kanalprotokoll STP</a></li>
<li><a href="../de466407/index.html">Rekrutierungskultur bei großen Glassdoor-Statistikunternehmen</a></li>
<li><a href="../de466409/index.html">Schulung Cisco 200-125 CCNA v3.0. Tag 37. STP: Root Bridge-Auswahl, PortFast- und BPDU-Schutzfunktionen. Teil 1</a></li>
<li><a href="../de466413/index.html">Site Exchange für Bitrix und 1C: Lösung der Hauptprobleme</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>