<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∏üèΩ üñ±Ô∏è üïπÔ∏è Analisis kinerja VM di VMware vSphere. Bagian 2: Memori üë©‚Äçüëß‚Äçüëß üëÉ ‚õ∑Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian 1. Tentang CPU 
 Bagian 3. Tentang Penyimpanan 

 Dalam artikel ini, kita akan berbicara tentang penghitung kinerja RAM di vSphere. 
 Tampaknya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisis kinerja VM di VMware vSphere. Bagian 2: Memori</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dataline/blog/455820/"><img src="https://habrastorage.org/webt/el/am/7y/elam7yyhc6vrowmmrt5ofxgj-r0.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1. Tentang CPU</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3. Tentang Penyimpanan</a> <br><br>  Dalam artikel ini, kita akan berbicara tentang penghitung kinerja RAM di vSphere. <br>  Tampaknya memori lebih dan lebih tidak ambigu daripada dengan prosesor: jika ada masalah kinerja pada VM, sulit untuk tidak melihatnya.  Tetapi jika mereka muncul, berurusan dengan mereka jauh lebih sulit.  Tetapi hal pertama yang pertama. <a name="habracut"></a><br><br><h3>  Sedikit teori </h3><br>  RAM mesin virtual diambil dari memori server tempat VM menjalankan.  Ini cukup jelas :).  Jika RAM server tidak cukup untuk semua orang, ESXi mulai menerapkan teknik reklamasi memori.  Jika tidak, sistem operasi VM akan macet dengan kesalahan akses RAM. <br><br>  Teknik apa yang digunakan untuk memutuskan ESXi tergantung pada beban RAM: <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Status memori</b> <br></td><td>  <b>Perbatasan</b> <br></td><td>  <b>Tindakan</b> <br></td></tr><tr><td> Tinggi <br></td><td>  400% dari minFree <br></td><td>  Setelah mencapai batas atas, halaman memori besar dibagi menjadi yang kecil (TPS berfungsi dalam mode standar). <br></td></tr><tr><td>  Jelas <br></td><td>  100% dari minFree <br></td><td>  Halaman memori besar dibagi menjadi kecil, TPS bekerja secara paksa. <br></td></tr><tr><td>  Lembut <br></td><td>  64% dari minFree <br></td><td>  TPS + Balon <br></td></tr><tr><td>  Sulit <br></td><td>  32% dari minFree <br></td><td>  TPS + Kompres + Tukar <br></td></tr><tr><td>  Rendah <br></td><td>  16% dari minFree <br></td><td>  Kompres + Tukar + Blokir <br></td></tr></tbody></table></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a> <br><br>  minFree adalah RAM yang dibutuhkan agar hypervisor berfungsi. <br><br>  Sebelum ESXi 4.1 inklusif, minFree telah diperbaiki secara default - 6% dari RAM server (persentase dapat diubah melalui opsi Mem.MinFreePct pada ESXi).  Dalam versi yang lebih baru, karena peningkatan volume memori pada server minFree, mulai dihitung berdasarkan ukuran memori host, dan bukan sebagai nilai persentase tetap. <br><br>  Nilai minFree (default) dihitung sebagai berikut: <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Persentase memori yang dicadangkan untuk minFree</b> <br></td><td>  <b>Rentang memori</b> <br></td></tr><tr><td>  6% <br></td><td>  0-4 GB <br></td></tr><tr><td>  4% <br></td><td>  4-12 GB <br></td></tr><tr><td>  2% <br></td><td>  12-28 GB <br></td></tr><tr><td>  1% <br></td><td>  Memori yang tersisa <br></td></tr></tbody></table></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a> <br><br>  Misalnya, untuk server dengan 128 GB RAM, nilai MinFree adalah: <br>  MinFree = 245,76 + 327,68 + 327,68 + 1024 = 1925,12 MB = 1,88 GB <br>  Nilai aktual dapat berbeda beberapa ratus MB, tergantung pada server dan RAM. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Persentase memori yang dicadangkan untuk minFree</b> <br></td><td>  <b>Rentang memori</b> <br></td><td>  <b>Nilai untuk 128 GB</b> <br></td></tr><tr><td>  6% <br></td><td>  0-4 GB <br></td><td>  245,76 MB <br></td></tr><tr><td>  4% <br></td><td>  4-12 GB <br></td><td>  327,68 MB <br></td></tr><tr><td>  2% <br></td><td>  12-28 GB <br></td><td>  327,68 MB <br></td></tr><tr><td>  1% <br></td><td>  Memori yang tersisa (100 GB) <br></td><td>  1024 MB <br></td></tr></tbody></table></div><br><br>  Biasanya, untuk tegakan produktif, hanya Tinggi yang dapat dianggap normal.  Untuk tegakan uji dan pengembangan, kondisi Clear / Soft mungkin dapat diterima.  Jika ada kurang dari 64% MinFree RAM yang tersisa di host, maka VM yang menjalankannya pasti akan mengalami masalah kinerja. <br><br>  Di setiap negara, teknik reklamasi memori tertentu diterapkan dimulai dengan TPS, yang secara praktis tidak mempengaruhi kinerja VM, berakhir dengan Swapping.  Saya akan memberi tahu Anda lebih banyak tentang mereka. <br><br>  <b>Berbagi Halaman Transparan (TPS).</b>  TPS, secara umum, deduplikasi halaman RAM mesin virtual di server. <br><br>  ESXi mencari halaman identik dari RAM mesin virtual, menghitung dan membandingkan jumlah hash halaman, dan menghapus halaman duplikat, menggantinya dengan tautan ke halaman yang sama di memori fisik server.  Akibatnya, konsumsi memori fisik berkurang, dan beberapa langganan memori dapat dicapai dengan sedikit atau tanpa kehilangan kinerja. <br><br><img src="https://habrastorage.org/webt/ul/fz/1i/ulfz1i0bomyhsarceziylov-o6i.jpeg"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a> <br><br>  Mekanisme ini hanya berfungsi untuk 4 halaman kB (halaman kecil).  Halaman dengan ukuran 2 MB (halaman besar) yang hypervisor bahkan tidak mencoba untuk deduplicate: kesempatan untuk menemukan halaman yang identik dengan ukuran ini tidak besar. <br><br>  Secara default, ESXi mengalokasikan memori ke halaman besar.  Pemecahan halaman besar menjadi kecil dimulai ketika ambang negara tinggi tercapai dan dipaksa ketika negara jelas tercapai (lihat tabel negara hypervisor). <br><br>  Jika Anda ingin TPS mulai bekerja tanpa menunggu RAM host terisi, di Advanced Options ESXi Anda perlu mengatur nilai <i>"Mem.AllocGuestLargePage"</i> ke 0 (standarnya adalah 1).  Kemudian alokasi halaman memori yang besar untuk mesin virtual akan dinonaktifkan. <br><br>  Sejak Desember 2014, dalam semua rilis ESXi, TPS antara VM telah dinonaktifkan secara default, karena kerentanan telah ditemukan yang secara teoritis memungkinkan mengakses RAM VM lain dari satu VM.  Detail di sini.  Informasi tentang implementasi praktis dari eksploitasi kerentanan TPS yang belum saya temui. <br><br>  Kebijakan TPS dikendalikan melalui opsi lanjutan <i>"Mem.ShareForceSalting"</i> di ESXi: <br>  0 - TPS Inter-VM.  TPS berfungsi untuk laman berbagai VM; <br>  1 - TPS untuk VM dengan nilai yang sama "sched.mem.pshare.salt" di VMX; <br>  2 (standar) - TPS Intra-VM.  TPS berfungsi untuk halaman di dalam VM. <br><br>  Masuk akal untuk mematikan halaman besar dan mengaktifkan TPS Inter-VM di bangku tes.  Itu juga dapat digunakan untuk dudukan dengan sejumlah besar VM dari jenis yang sama.  Misalnya, saat berdiri dengan VDI, penghematan memori fisik dapat mencapai puluhan persen. <br><br>  <b>Memory Ballooning.</b>  Balon tidak lagi merupakan teknik yang tidak berbahaya dan transparan untuk sistem operasi VM seperti TPS.  Tetapi dengan penggunaan yang tepat dengan Ballooning Anda dapat hidup dan bahkan bekerja. <br><br>  Bersama dengan Vmware Tools, driver khusus diinstal pada VM, disebut Balloon Driver (alias vmmemctl).  Ketika hypervisor mulai kehabisan memori fisik dan memasuki kondisi lunak, ESXi meminta VM untuk mengembalikan RAM yang tidak digunakan melalui Driver Balon ini.  Pengemudi, pada gilirannya, bekerja pada level sistem operasi dan meminta memori bebas darinya.  Hypervisor melihat halaman mana dari memori fisik yang diambil oleh Driver Balon, mengambil memori dari mesin virtual, dan mengembalikannya ke host.  Tidak ada masalah dengan pengoperasian OS, karena pada level OS memori ditempati oleh Driver Balloon.  Secara default, Driver Balon dapat mengambil hingga 65% dari memori VM. <br><br>  Jika VMware Tools tidak diinstal pada VM atau Ballooning dinonaktifkan (saya tidak merekomendasikannya, tetapi ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KB</a> :), hypervisor segera beralih ke metode yang lebih ketat untuk menghapus memori.  Kesimpulan: pastikan bahwa VMware Tools pada VM adalah. <br><br><img src="https://habrastorage.org/webt/ey/pm/s1/eypms1ugdkmhr0r4odhga1locao.png"><br>  <i>Pengoperasian Balloon Driver dapat diperiksa dari OS melalui VMware Tools</i> . <br><br>  <b>Kompresi memori</b>  Teknik ini digunakan ketika ESXi mencapai Hard.  Seperti namanya, ESXi sedang mencoba untuk mengompres 4 KB halaman RAM menjadi 2 KB dan dengan demikian membebaskan beberapa ruang dalam memori fisik server.  Teknik ini secara signifikan meningkatkan waktu akses ke isi halaman-halaman memori RAM dari VM, karena halaman harus dibersihkan terlebih dahulu.  Terkadang tidak semua halaman dapat dikompres dan prosesnya sendiri membutuhkan waktu.  Karena itu, teknik ini tidak terlalu efektif dalam praktik. <br><br>  <b>Penukaran memori.</b>  Setelah fase singkat, Memory Compression ESXi hampir tidak terhindarkan (jika VM tidak pergi ke host lain atau mematikan) pergi ke Swapping.  Dan jika memori yang tersisa sangat sedikit (Status rendah), maka hypervisor juga berhenti mengalokasikan halaman memori VM, yang dapat menyebabkan masalah pada VM tamu. <br><br>  Beginilah cara Swapping bekerja.  Ketika Anda menghidupkan mesin virtual, file dengan ekstensi .vswp dibuat untuk itu.  Dalam ukurannya, ini sama dengan RAM non-cadangan dari VM: ini adalah perbedaan antara memori yang dikonfigurasi dan yang dipesan.  Saat bekerja dengan Swapping, ESXi menurunkan halaman memori mesin virtual ke dalam file ini dan mulai bekerja dengannya alih-alih memori fisik server.  Tentu saja, memori "RAM" seperti itu beberapa kali lipat lebih lambat dari memori sebenarnya, bahkan jika .vswp berada pada penyimpanan cepat. <br><br>  Tidak seperti Ballooning, ketika halaman yang tidak digunakan dipilih dari VM, halaman yang secara aktif digunakan oleh OS atau aplikasi di dalam VM dapat pergi ke disk selama Swapping.  Akibatnya, kinerja VM turun sampai hang.  VM secara resmi berfungsi dan setidaknya dapat dinonaktifkan dengan benar dari OS.  Jika Anda akan bersabar;) <br><br>  Jika VM telah beralih ke Swap, ini adalah situasi abnormal yang sebaiknya dihindari jika mungkin. <br><br><h3>  Penghitung kinerja memori mesin virtual dasar </h3><br>  Jadi kami sampai pada hal utama.  Untuk memantau status memori di VM, penghitung berikut tersedia: <br><br>  <b>Aktif</b> - menunjukkan jumlah RAM (Kbytes) tempat VM memperoleh akses pada periode pengukuran sebelumnya. <br><br>  <b>Penggunaannya</b> sama dengan Active, tetapi sebagai persentase dari memori VM yang dikonfigurasi.  Itu dihitung menggunakan rumus berikut: memory aktif ukuran mesin dikonfigurasi memori virtual. <br>  Penggunaan Tinggi dan Aktif, masing-masing, tidak selalu menunjukkan masalah kinerja VM.  Jika VM secara agresif menggunakan memori (setidaknya mendapatkan akses ke sana), ini tidak berarti bahwa tidak ada cukup memori.  Sebaliknya, ini adalah kesempatan untuk melihat apa yang terjadi di OS. <br>  Ada Alarm standar tentang Penggunaan Memori untuk VM: <br><br><img src="https://habrastorage.org/webt/8u/ca/n8/8ucan84mevajwvlnr-4ov9boyro.png"><br><br>  <b>Shared</b> - jumlah RAM dalam VM yang didupuplikasi menggunakan TPS (di dalam VM atau di antara VM). <br><br>  <b>Diberikan</b> - jumlah memori fisik host (Kbytes) yang diberikan kepada VM.  Termasuk Dibagikan. <br><br>  <b>Consumed</b> (Granted - Shared) - jumlah memori fisik (Kbytes) yang dikonsumsi VM dari host.  Tidak termasuk Dibagi. <br><br>  Jika bagian dari memori VM tidak dialokasikan dari memori fisik host, tetapi dari file swap atau memori diambil dari VM melalui Driver Balon, jumlah ini tidak diperhitungkan dalam Granted and Consumed. <br>  Nilai tinggi dari Granted dan Consumed sangat normal.  Sistem operasi secara bertahap mengambil memori dari hypervisor dan tidak memberikan kembali.  Seiring waktu, dengan VM yang berfungsi aktif, nilai-nilai penghitung ini mendekati jumlah memori yang dikonfigurasi, dan tetap ada. <br><br>  <b>Nol</b> - jumlah RAM dalam VM (Kbytes), yang berisi nol.  Memori tersebut dianggap sebagai hypervisor gratis dan dapat diberikan ke mesin virtual lainnya.  Setelah OS tamu menerimanya, ia menulis sesuatu ke memori nol, ia pergi ke Dikonsumsi dan tidak kembali. <br><br>  <b>Reserved Overhead</b> - jumlah RAM di VM, (Kbytes) dicadangkan oleh hypervisor agar VM berfungsi.  Ini jumlah yang kecil, tetapi harus tersedia di host, jika tidak VM tidak akan mulai. <br><br>  <b>Balon</b> - jumlah RAM (KB) yang disita dari VM menggunakan Driver Balon. <br><br>  <b>Compressed</b> - jumlah RAM (KB) yang dapat dikompres. <br><br>  <b>Swapped</b> - jumlah RAM (Kbytes), yang karena kurangnya memori fisik pada server dipindahkan ke disk. <br>  Balon dan teknik reklamasi memori lainnya adalah nol. <br><br>  Seperti inilah grafiknya dengan penghitung Memori dari VM yang biasanya berfungsi dengan 150 GB RAM. <br><br><img src="https://habrastorage.org/webt/0l/pp/w3/0lppw3nz9iqzcnuergtxiseb67s.png"><br><br>  Pada grafik di bawah ini, VM memiliki masalah yang jelas.  Grafik menunjukkan bahwa untuk VM ini semua teknik yang dijelaskan untuk bekerja dengan RAM digunakan.  Balon untuk VM ini jauh lebih besar daripada yang Dikonsumsi.  Faktanya, VM lebih mungkin mati daripada hidup. <br><br><img src="https://habrastorage.org/webt/f4/ic/xk/f4icxkpxpykxua_gp-sirlzuu_u.png"><br><br><h3>  ESXTOP </h3><br>  Seperti halnya CPU, jika Anda ingin dengan cepat mengevaluasi situasi pada host, serta dinamika dengan interval hingga 2 detik, ada baiknya menggunakan ESXTOP. <br><br>  Layar Memori ESXTOP disebut dengan tombol "m" dan terlihat seperti ini (bidang B, D, H, J, K, L, O dipilih): <br><br><img src="https://habrastorage.org/webt/rm/wj/4k/rmwj4krvvizdtcizkrid0zjuml8.png"><br><br>  Parameter berikut ini akan menarik bagi kami: <br><br>  <b>Mem overcommit avg</b> - nilai rata-rata dari memory over-berlangganan pada host selama 1, 5, dan 15 menit.  Jika di atas nol, maka ini adalah kesempatan untuk melihat apa yang terjadi, tetapi tidak selalu menjadi indikator adanya masalah. <br><br>  Pada baris <b>PMEM / MB</b> dan <b>VMKMEM / MB</b> - informasi tentang memori fisik server dan memori yang tersedia untuk VMkernel.  Dari yang menarik di sini Anda dapat melihat nilai minfree (dalam MB), keadaan host dari memori (dalam kasus kami, tinggi). <br><br>  Pada baris <b>NUMA / MB,</b> Anda dapat melihat distribusi RAM berdasarkan NUMA-node (soket).  Dalam contoh ini, distribusinya tidak merata, yang pada prinsipnya tidak terlalu baik. <br><br>  Berikut ini adalah ringkasan statistik server untuk teknik reklamasi memori: <br><br>  <b>PSHARE / MB</b> adalah statistik TPS; <br><br>  <b>SWAP / MB</b> - statistik tentang penggunaan Swap; <br><br>  <b>ZIP / MB</b> - statistik kompresi halaman memori; <br><br>  <b>MEMCTL / MB</b> - Statistik penggunaan Driver Balon. <br><br>  Untuk masing-masing VM, kami mungkin tertarik pada informasi berikut.  Saya menyembunyikan nama-nama VM agar tidak membuat malu penonton :).  Jika metrik ESXTOP sama dengan penghitung di vSphere, saya kutip penghitung yang sesuai. <br><br>  <b>MEMSZ</b> adalah jumlah memori yang dikonfigurasi pada VM (MB). <br>  MEMSZ = GRANT + MCTLSZ + SWCUR + tidak tersentuh. <br><br>  <b>GRANT</b> - Diberikan dalam MB. <br><br>  <b>TCHD</b> - Aktif dalam MB. <br><br>  <b>MCTL?</b>  - diinstal pada Driver VM Balloon. <br><br>  <b>MCTLSZ</b> - Balon dalam MB. <br><br>  <b>MCTLGT</b> adalah jumlah RAM (MB) yang ingin dihapus ESXi dari VM melalui Driver Balon (Target Memctl). <br><br>  <b>MCTLMAX</b> - jumlah maksimum RAM (MB) yang dapat dihapus ESXi dari VM melalui Driver Balon. <br><br>  <b>SWCUR</b> - jumlah RAM (MB) saat ini yang diberikan kepada VM dari file Swap. <br><br>  <b>SWGT</b> - jumlah RAM (MB) yang ingin diberikan ESXi dari file Swap (Swap Target). <br><br>  Juga melalui ESXTOP Anda dapat melihat informasi lebih rinci tentang topologi NUMA VM.  Untuk melakukan ini, pilih bidang D, G: <br><br><img src="https://habrastorage.org/webt/ff/7y/zd/ff7yzdsjedyntnpj4duwv0c731m.png"><br><br>  <b>NHN</b> - NUMA node tempat VM berada.  Di sini Anda dapat segera melihat vm lebar yang tidak sesuai pada satu NUMA node. <br><br>  <b>NRMEM</b> - berapa banyak megabita memori yang VM ambil dari simpul NUMA jarak jauh. <br><br>  <b>NLMEM</b> - berapa megabyte memori yang VM ambil dari simpul NUMA lokal. <br><br>  <b>N% L</b> - persentase memori VM pada simpul NUMA lokal (jika kurang dari 80%, masalah kinerja dapat terjadi). <br><br><h3>  Memori pada hypervisor </h3><br>  Jika penghitung CPU pada hypervisor biasanya tidak menarik, maka situasinya berlawanan dengan memori.  Penggunaan Memori yang tinggi pada VM tidak selalu menunjukkan masalah kinerja, tetapi Penggunaan Memori yang tinggi pada hypervisor hanya memulai teknisi manajemen memori dan menyebabkan masalah dengan kinerja VM.  Alarm Penggunaan Memori Host harus dipantau dan VM tidak diizinkan untuk masuk Swap. <br><br><img src="https://habrastorage.org/webt/h2/x_/59/h2x_59kddpe84yzudcq03fq1rmc.png"><br><br><img src="https://habrastorage.org/webt/oc/w7/c9/ocw7c9vmbrqogjhmtpbotng4-6y.png"><br><br><h3>  Unswap </h3><br>  Jika VM masuk ke Swap, kinerjanya sangat berkurang.  Balon dan jejak kompresi dengan cepat menghilang setelah munculnya RAM gratis di host, tetapi mesin virtual tidak terburu-buru untuk kembali dari Swap ke RAM server. <br>  Sebelum ESXi 6.0, satu-satunya cara yang andal dan cepat untuk mengeluarkan VM dari Swap adalah dengan me-reboot (lebih tepatnya, mematikan / mematikan wadah).  Dimulai dengan ESXi 6.0, cara yang tidak terlalu resmi, tetapi bekerja dan dapat diandalkan untuk mengeluarkan VM dari Swap.  Di salah satu konferensi, saya berhasil berbicara dengan salah satu insinyur VMware yang bertanggung jawab untuk Penjadwal CPU.  Dia menegaskan bahwa metode ini cukup berhasil dan aman.  Dalam pengalaman kami, masalah dengannya juga tidak diperhatikan. <br><br>  Perintah aktual untuk mengeluarkan VM dari Swap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dijelaskan oleh</a> Duncan Epping.  Saya tidak akan mengulangi uraian terperinci, cukup berikan contoh penggunaannya.  Seperti yang dapat dilihat pada tangkapan layar, beberapa saat setelah eksekusi perintah Swap yang ditentukan pada VM menghilang. <br><br><img src="https://habrastorage.org/webt/e5/lm/7e/e5lm7e0e6i_yxrrlm7dfwixptv0.png"><br><br><h3>  Kiat untuk mengelola RAM pada ESXi </h3><br>  Sebagai kesimpulan, saya akan memberikan beberapa tips untuk membantu Anda menghindari masalah dengan kinerja VM karena RAM: <br><br><ul><li>  Hindari kelebihan langganan RAM dalam kluster produktif.  Itu selalu disarankan untuk memiliki ~ 20-30% memori bebas di cluster, sehingga DRS (dan administrator) memiliki ruang untuk bermanuver, dan VM tidak pergi ke Swap selama migrasi.  Juga jangan lupa margin untuk toleransi kesalahan.  Tidak menyenangkan ketika, ketika satu server gagal dan VM di-reboot menggunakan HA, beberapa mesin juga masuk ke Swap. </li><li>  Dalam infrastruktur yang sangat terkonsolidasi, cobalah untuk TIDAK membuat VM dengan lebih dari setengah memori host.  Ini, sekali lagi, akan membantu DRS mendistribusikan mesin virtual di antara server cluster tanpa masalah.  Aturan ini, tentu saja, tidak universal :). </li><li>  Hati-hati dengan Alarm Penggunaan Memori Host. </li><li>  Jangan lupa untuk meletakkan VMware Tools di VM dan jangan mematikan Ballooning. </li><li>  Pertimbangkan untuk mengaktifkan TPS Inter-VM dan menonaktifkan Halaman Besar di VDI dan lingkungan pengujian. </li><li>  Jika VM mengalami masalah kinerja, periksa untuk melihat apakah itu menggunakan memori dari node NUMA jauh. </li><li>  Dapatkan VM dari Swap secepat mungkin!  Antara lain, jika VM ada di Swap, untuk alasan yang jelas, sistem penyimpanan menderita. </li></ul><br>  Itu saja untuk RAM.  Di bawah ini adalah artikel terkait untuk mereka yang ingin mempelajari detailnya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel selanjutnya</a> akan dikhususkan untuk cerita. <br><br><div class="spoiler">  <b class="spoiler_title">Tautan yang bermanfaat</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.yellow-bricks.com/2015/03/02/what-happens-at-which-vsphere-memory-state/</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.yellow-bricks.com/2013/06/14/how-does-mem-minfreepct-work-with-vsphere-5-0-and-up/</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.vladan.fr/vmware-transparent-page-sharing-tps-explained/</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.yellow-bricks.com/2016/06/02/memory-pages-swapped-can-unswap/</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://kb.vmware.com/s/article/1002586</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.vladan.fr/what-is-vmware-memory-ballooning/</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://kb.vmware.com/s/article/2080735</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://kb.vmware.com/s/article/2017642</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://labs.vmware.com/vmtj/vmware-esx-memory-resource-management-swap</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://blogs.vmware.com/vsphere/2013/10/understanding-vsphere-active-memory.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.vmware.com/support/developer/converter-sdk/conv51_apireference/memory_counters.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://docs.vmware.com/en/VMware-vSphere/6.5/vsphere-esxi-vcenter-server-65-monitoring-performance-guide.pdf</a> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455820/">https://habr.com/ru/post/id455820/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455800/index.html">Matriks 1.0 - Rilis Protokol Pesan Desentralisasi</a></li>
<li><a href="../id455802/index.html">Cara merakit Olimpiade melalui buletin email. Case Black Star</a></li>
<li><a href="../id455806/index.html">Kelahiran dan kematian album: kami memahami bagaimana format musik telah berubah selama 100 tahun terakhir</a></li>
<li><a href="../id455812/index.html">Membangun Arsitektur Layanan Mikro di Golang dan gRPC, Bagian 2 (buruh pelabuhan)</a></li>
<li><a href="../id455816/index.html">Cara membuat aksi keren untuk Google Assistant. Lifehacks dari Just AI</a></li>
<li><a href="../id455826/index.html">Penyiraman Otomatis yang dikendalikan dari jarak jauh</a></li>
<li><a href="../id455828/index.html">Para ilmuwan telah menemukan bentuk sinkronisasi baru yang eksotis</a></li>
<li><a href="../id455830/index.html">Pandangan melalui mata pengembang .NET. Minggu # 1</a></li>
<li><a href="../id455832/index.html">Sejarah investigasi SQL tunggal</a></li>
<li><a href="../id455834/index.html">Tolok ukur untuk server Linux: 5 alat terbuka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>