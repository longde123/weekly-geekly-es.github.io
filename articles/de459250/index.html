<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚅 👨🏿‍🎨 🏛️ WAL in PostgreSQL: 2. Protokoll aufzeichnen 🧘🏿 🧀 🤴🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Letztes Mal haben wir uns mit dem Gerät eines der wichtigsten Objekte des gemeinsamen Speichers getroffen, dem Puffercache. Die Möglichkeit, Informati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL in PostgreSQL: 2. Protokoll aufzeichnen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/459250/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Letztes Mal haben</a> wir uns mit dem Gerät eines der wichtigsten Objekte des gemeinsamen Speichers getroffen, dem Puffercache.  Die Möglichkeit, Informationen aus dem RAM zu verlieren, ist der Hauptgrund für die Notwendigkeit der Wiederherstellung nach einem Fehler.  Heute werden wir über diese Tools sprechen. <br><br><h1>  Magazin </h1><br>  Leider geschehen keine Wunder: Um den Informationsverlust im RAM zu überstehen, muss alles Notwendige rechtzeitig auf eine Festplatte (oder ein anderes nichtflüchtiges Gerät) geschrieben werden. <br><br>  Daher wurde dies getan.  Neben Datenänderungen wird auch ein <em>Tagebuch</em> dieser Änderungen geführt.  Wenn wir etwas auf einer Seite im Puffercache ändern, erstellen wir im Protokoll einen Datensatz über diese Änderung.  Der Datensatz enthält die Mindestinformationen, die ausreichen, damit die Änderung bei Bedarf wiederholt werden kann. <br><br>  Damit dies funktioniert, muss der Journaleintrag unbedingt auf die Festplatte verschoben werden, <em>bevor die</em> geänderte Seite dort ankommt.  Daher der Name: Write-Ahead-Protokoll. <br><br>  Wenn ein Fehler auftritt, befinden sich die Daten auf der Festplatte in einem inkonsistenten Zustand: Einige Seiten wurden früher geschrieben, andere später.  Es bleibt jedoch ein Journal übrig, das von den Vorgängen gelesen und erneut ausgeführt werden kann, die bereits vor dem Fehler abgeschlossen wurden, deren Ergebnis jedoch die Festplatte nicht erreicht hat. <br><a name="habracut"></a><br><blockquote>  Warum nicht erzwingen, dass die Datenseiten selbst auf die Festplatte geschrieben werden, warum stattdessen Doppeljobs ausführen?  Es stellt sich als so effektiv heraus. <br>  Zuallererst ist ein Protokoll ein sequentieller Datenstrom, der geschrieben werden soll.  Sogar Festplatten eignen sich sehr gut für sequentielle Aufnahmen.  Die Aufzeichnung der Daten selbst ist jedoch zufällig, da die Seiten mehr oder weniger zufällig über die Festplatte verteilt sind. <br>  Zweitens kann ein Journaleintrag viel kleiner als eine Seite sein. <br>  Drittens müssen Sie sich bei der Aufnahme nicht darum kümmern, dass die Daten auf der Festplatte zu einem beliebigen Zeitpunkt konsistent bleiben (diese Anforderung verkürzt die Lebensdauer erheblich). <br>  Und viertens kann das Journal (da es existiert), wie wir später sehen werden, nicht nur zur Wiederherstellung, sondern auch zur Sicherung und Replikation verwendet werden. <br></blockquote><br>  Sie müssen alle Vorgänge protokollieren, bei denen im Falle eines Fehlers die Gefahr von Inkonsistenzen auf der Festplatte besteht.  Insbesondere werden folgende Aktionen protokolliert: <br><br><ul><li>  Ändern von Seiten im Puffercache (in der Regel sind dies Tabellen und Indexseiten) - da die geänderte Seite nicht sofort auf die Festplatte verschoben wird; </li><li>  Festschreiben und Abbrechen von Transaktionen - Die Statusänderung erfolgt in den XACT-Puffern und erreicht die Festplatte auch nicht sofort. </li><li>  Dateivorgänge (Erstellen und Löschen von Dateien und Verzeichnissen, z. B. Erstellen von Dateien beim Erstellen einer Tabelle) - da diese Vorgänge gleichzeitig mit Datenänderungen ausgeführt werden müssen. </li></ul><br>  Nicht protokolliert: <br><br><ul><li>  Operationen mit nicht journalisierten (nicht protokollierten) Tabellen - ihr Name spricht für sich selbst; </li><li>  Operationen mit temporären Tabellen - dies ist nicht sinnvoll, da die Lebensdauer solcher Tabellen die Lebensdauer der Sitzung, in der sie erstellt wurden, nicht überschreitet. </li></ul><br>  Vor PostgreSQL 10 wurden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hash-Indizes</a> nicht protokolliert (sie dienten nur dazu, Hash-Funktionen verschiedenen Datentypen zuzuordnen), aber jetzt wurde dies behoben. <br><br><h1>  Logisches Gerät </h1><br><img src="https://habrastorage.org/webt/vx/vj/67/vxvj673dzyqmhumlxby7i8wt5q0.png"><br><br>  Ein Journal kann logischerweise als eine Folge von Datensätzen unterschiedlicher Länge betrachtet werden.  Jeder Datensatz enthält <em>Daten</em> zu einer bestimmten Operation, denen ein Standardheader vorangestellt ist.  Der Titel gibt unter anderem an: <br><br><ul><li>  Die Transaktionsnummer, zu der der Datensatz gehört. </li><li>  Ressourcenmanager - die Komponente des Systems, die für die Aufzeichnung verantwortlich ist; </li><li>  Prüfsumme (CRC) - Ermöglicht die Ermittlung von Datenbeschädigungen. </li><li>  Datensatzlänge und Link zum vorherigen Datensatz. </li></ul><br>  Die Daten selbst haben ein anderes Format und eine andere Bedeutung.  Sie können beispielsweise ein Fragment einer Seite darstellen, das mit einem bestimmten Versatz über den Inhalt geschrieben werden muss.  Der angegebene Ressourcenmanager „versteht“, wie die Daten in seinem Datensatz zu interpretieren sind.  Es gibt separate Manager für Tabellen, für jeden Indextyp, für den Transaktionsstatus usw. Eine vollständige Liste davon kann auf Wunsch des Befehls abgerufen werden <br><br><pre><code class="plaintext hljs">pg_waldump -r list</code> </pre> <br><h1>  Physisches Gerät </h1><br>  Auf der Festplatte wird das Protokoll als Dateien im Verzeichnis $ PGDATA / pg_wal gespeichert.  Jede Datei ist standardmäßig 16 MB groß.  Die Größe kann erhöht werden, um eine große Anzahl von Dateien in einem Verzeichnis zu vermeiden.  Vor PostgreSQL 11 war dies nur beim Kompilieren des Quellcodes möglich. Jetzt können Sie die Größe beim Initialisieren des Clusters angeben (den <code>--wal-segsize</code> ). <br><br>  Protokolleinträge fallen in die aktuell verwendete Datei.  Wenn es endet, wird das nächste verwendet. <br><br>  Für das Protokoll im gemeinsam genutzten Speicher des Servers werden spezielle Puffer zugewiesen.  Die Größe des <em>Journalcaches</em> wird durch den Parameter <em>wal_buffers festgelegt</em> (der Standardwert impliziert eine automatische Konfiguration: 1/32 des <em>Puffercaches</em> wird zugewiesen). <br><br>  Der Journal-Cache ist wie ein Puffer-Cache angeordnet, funktioniert jedoch hauptsächlich im Ringpuffer-Modus: Einträge werden dem "Kopf" hinzugefügt und vom "Ende" auf die Festplatte geschrieben. <br><br>  Die Positionen Aufnahme ("Schwanz") und Einfügen ("Kopf") zeigen die Funktionen pg_current_wal_lsn bzw. pg_current_wal_insert lsn: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_lsn(), pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_lsn | pg_current_wal_insert_lsn --------------------+--------------------------- 0/331E4E64 | 0/331E4EA0 (1 row)</code> </pre><br>  Um auf einen bestimmten Datensatz zu verweisen, wird der Datentyp pg_lsn (LSN = Protokollsequenznummer) verwendet. Dies ist eine 64-Bit-Nummer, die den Byte-Offset vor dem Datensatz relativ zum Protokollanfang darstellt.  LSN wird als zwei 32-Bit-Zahlen in hexadezimaler Schreibweise ausgegeben. <br><br>  Sie können herausfinden, in welcher Datei wir die gewünschte Position finden und mit welchem ​​Versatz vom Anfang der Datei: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> file_name, upper(to_hex(file_offset)) file_offset <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_walfile_name_offset(<span class="hljs-string"><span class="hljs-string">'0/331E4E64'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> file_name | file_offset --------------------------+------------- 000000010000000000000033 | 1E4E64 \ /\ /  0/331E4E64 </code> </pre><br>  Der Dateiname besteht aus zwei Teilen.  Die oberen 8 hexadezimalen Ziffern geben die Nummer des Zeitzweigs an (wird beim Wiederherstellen aus der Sicherung verwendet), der Rest entspricht den höchsten LSN-Ziffern (und die verbleibenden unteren LSN-Ziffern geben den Versatz an). <br><br>  Protokolldateien können im Dateisystem im Verzeichnis $ PGDATA / pg_wal / angezeigt werden. Ab PostgreSQL 10 können sie jedoch auch mit einer speziellen Funktion angezeigt werden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_ls_waldir() <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'000000010000000000000033'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> name | size | modification --------------------------+----------+------------------------ 000000010000000000000033 | 16777216 | 2019-07-08 20:24:13+03 (1 row)</code> </pre><br><h1>  Weiterleiten schreiben </h1><br>  Lassen Sie uns sehen, wie das Journaling erfolgt und wie proaktive Aufzeichnungen bereitgestellt werden.  Erstellen Sie eine Tabelle: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wal(id <span class="hljs-type"><span class="hljs-type">integer</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> wal <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Wir werden uns die Kopfzeile der Tabellenseite ansehen.  Dazu benötigen wir eine bereits bekannte Erweiterung: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect;</code> </pre><br>  Beginnen wir mit der Transaktion und merken uns die Einfügeposition im Protokoll: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F377C (1 row)</code> </pre><br>  Lassen Sie uns nun eine Operation ausführen, zum Beispiel die Zeile aktualisieren: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> wal <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> id = id + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Diese Änderung wurde im Protokoll aufgezeichnet, die Einfügeposition hat sich geändert: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F37C4 (1 row)</code> </pre><br>  Um sicherzustellen, dass die geänderte Datenseite nicht vor dem Journaleintrag auf die Festplatte übertragen wird, wird die LSN des letzten Journaleintrags für diese Seite im Seitenkopf gespeichert: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lsn <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'wal'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lsn ------------ 0/331F37C4 (1 row)</code> </pre><br>  Beachten Sie, dass das Journal dem gesamten Cluster gemeinsam ist und ständig neue Einträge in das Journal fallen.  Daher kann die LSN auf der Seite kleiner sein als der Wert, den die gerade zurückgegebene Funktion pg_current_wal_insert_lsn zurückgegeben hat.  In unserem System passiert jedoch nichts, daher sind die Zahlen gleich. <br><br>  Schließen Sie nun die Transaktion ab. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Der Festschreibungsdatensatz wird ebenfalls in das Protokoll aufgenommen, und die Position ändert sich erneut: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F37E8 (1 row)</code> </pre><br>  Commit ändert den Status einer Transaktion in einer Struktur namens XACT (wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits darüber gesprochen</a> ).  Status werden in Dateien gespeichert, sie verwenden jedoch auch einen eigenen Cache, der 128 Seiten im gemeinsam genutzten Speicher belegt.  Daher muss für XACT-Seiten die LSN des letzten Journaleintrags verfolgt werden.  Diese Informationen werden jedoch nicht auf der Seite selbst gespeichert, sondern im RAM. <br><br>  Irgendwann werden die erstellten Journaleinträge auf die Festplatte geschrieben.  In welchem ​​- wir werden ein anderes Mal reden, aber in unserem Fall ist dies bereits geschehen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_lsn(), pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_lsn | pg_current_wal_insert_lsn --------------------+--------------------------- 0/331F37E8 | 0/331F37E8 (1 row)</code> </pre><br>  Nach diesem Zeitpunkt können die Daten- und XACT-Seiten aus dem Cache verschoben werden.  Wenn sie jedoch früher erzwungen werden müssten, würde dies erkannt und die Journaleinträge müssten zuerst aufgezeichnet werden. <br><br>  Wenn Sie die beiden LSN-Positionen kennen, können Sie die Größe der Journaleinträge zwischen ihnen (in Bytes) ermitteln, indem Sie einfach eine Position von der anderen subtrahieren.  Sie müssen nur die Positionen in den Typ pg_lsn umwandeln: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'0/331F37E8'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/331F377C'</span></span>::pg_lsn;</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- 108 (1 row)</code> </pre><br>  In diesem Fall waren für die Zeilenaktualisierung und das Festschreiben 108 Byte im Protokoll erforderlich. <br><br>  Auf die gleiche Weise können Sie abschätzen, wie viele Journaleinträge vom Server pro Zeiteinheit bei einer bestimmten Last generiert werden.  Dies sind wichtige Informationen, die während des Setups benötigt werden (worüber wir beim nächsten Mal sprechen werden). <br><br>  Jetzt verwenden wir das Dienstprogramm pg_waldump, um die erstellten Protokolleinträge anzuzeigen. <br><br>  Das Dienstprogramm kann mit dem LSN-Bereich (wie in diesem Beispiel) arbeiten und Datensätze für die angegebene Transaktion auswählen.  Es sollte im Auftrag des Postgres-Betriebssystembenutzers ausgeführt werden, da dieser Zugriff auf die Protokolldateien auf der Festplatte benötigt. <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/331F377C -e 0/331F37E8 000000010000000000000033</code> </pre><pre> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 69/ 69, tx: 101085, lsn: 0/331F377C, prev 0/331F3014, desc: HOT_UPDATE off 1 xmax 101085 ; new off 2 xmax 0, blkref #0: rel 1663/16386/33081 blk 0</code> </pre><pre> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 34/ 34, tx: 101085, lsn: 0/331F37C4, prev 0/331F377C, desc: COMMIT 2019-07-08 20:24:13.945435 MSK</code> </pre><br>  Hier sehen wir die Überschriften der beiden Einträge. <br><br>  Die erste ist die Operation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HOT_UPDATE</a> , die sich auf den Heap-Ressourcenmanager bezieht.  Der Dateiname und die Seitenzahl werden im Feld blkref angezeigt und stimmen mit der aktualisierten Tabellenseite überein: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'wal'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/16386/33081 (1 row)</code> </pre><br>  Der zweite Eintrag ist COMMIT und bezieht sich auf den Transaction Resource Manager. <br><br>  Nicht das am besten lesbare Format, aber Sie können es bei Bedarf herausfinden. <br><br><h1>  Wiederherstellung </h1><br>  Wenn wir den Server starten, wird zuerst der Postmaster-Prozess gestartet, der wiederum den Startprozess startet, dessen Aufgabe es ist, die Wiederherstellung sicherzustellen, wenn ein Fehler auftritt. <br><br>  Um festzustellen, ob eine Wiederherstellung erforderlich ist, überprüft der Start die spezielle Steuerdatei $ PGDATA / global / pg_control und den Clusterstatus.  Wir können den Status selbst mit dem Dienstprogramm pg_controldata überprüfen: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | grep state</code> </pre><pre> <code class="plaintext hljs">Database cluster state: in production</code> </pre><br>  Ein ordentlich gestoppter Server hat den Status "Herunterfahren".  Wenn der Server nicht funktioniert und der Status "in Produktion" bleibt, bedeutet dies, dass das DBMS heruntergefallen ist und die Wiederherstellung automatisch durchgeführt wird. <br><br>  Zur Wiederherstellung liest der Startvorgang das Protokoll nacheinander und wendet bei Bedarf Einträge auf die Seiten an.  Sie können die Notwendigkeit überprüfen, indem Sie die LSN der Seite auf der Festplatte mit der LSN des Journaleintrags vergleichen.  Wenn die LSN der Seite größer ist, ist der Datensatz nicht erforderlich.  Tatsächlich ist dies jedoch nicht möglich, da die Aufzeichnungen für eine streng konsistente Anwendung ausgelegt sind. <br><br><blockquote>  Es gibt Ausnahmen.  Einige Datensätze werden als Ganzseitenbild (FPI, Ganzseitenbild) erstellt, und es ist klar, dass ein solches Bild in jedem Zustand auf eine Seite angewendet werden kann - es wird immer noch alles gelöscht, was dort war.  Eine weitere Änderung des Status einer Transaktion kann auf jede Version der XACT-Seite angewendet werden. Auf diesen Seiten muss daher keine LSN gespeichert werden. <br></blockquote><br>  Das Wechseln der Seiten während der Wiederherstellung erfolgt wie bei der normalen Arbeit im Puffercache - für diesen Postmaster werden die erforderlichen Hintergrundprozesse gestartet. <br><br>  Ebenso gelten Journaleinträge für Dateien: Wenn beispielsweise ein Datensatz angibt, dass die Datei vorhanden sein muss, aber nicht vorhanden ist, wird die Datei erstellt. <br><br>  Nun, ganz am Ende des Wiederherstellungsprozesses werden alle nicht journalisierten Tabellen mit "Dummies" aus ihren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Init-Ebenen</a> überschrieben. <br><br>  Dies ist eine sehr vereinfachte Darstellung des Algorithmus.  Insbesondere haben wir nichts darüber gesagt, wo mit dem Lesen von Journaleinträgen begonnen werden soll (diese Konversation muss verschoben werden, bis der Kontrollpunkt berücksichtigt wird). <br><br>  Und die letzte Klarstellung.  Der "klassische" Wiederherstellungsprozess besteht aus zwei Phasen.  In der ersten Phase (Rollforward) werden Journaleinträge gerollt, und der Server wiederholt alle während des Fehlers verlorenen Arbeiten.  Beim zweiten (Rollback) werden Transaktionen zurückgesetzt, die zum Zeitpunkt des Fehlers nicht festgeschrieben wurden.  PostgreSQL benötigt jedoch keine zweite Phase.  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits erwähnt</a> , müssen Transaktionen aufgrund der Besonderheiten der Implementierung von Transaktionen mit mehreren Versionen nicht physisch zurückgesetzt werden.  Es reicht aus, dass das Fixbit in XACT nicht gesetzt wird. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459250/">https://habr.com/ru/post/de459250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459240/index.html">10 Jahre in der IT mit Schizophrenie diagnostiziert, Überlebenstipps</a></li>
<li><a href="../de459242/index.html">Im Anschluss an die T + Conf 2019 Konferenz</a></li>
<li><a href="../de459244/index.html">Hinweise Produktmanager: Benutzerverhalten auf Spieleseiten im App Store. Wie lange dauert das Herunterladen eines Spiels?</a></li>
<li><a href="../de459246/index.html">Warum nimmt die Site-Conversion ab? Beispiele für 60 Design- und Usability-Fehler</a></li>
<li><a href="../de459248/index.html">Digitale Veranstaltungen in Moskau vom 9. bis 14. Juli</a></li>
<li><a href="../de459252/index.html">Sicherheitswoche 28: Ein Smart Home hacken</a></li>
<li><a href="../de459254/index.html">Noch bessere Reißverschlussbombe</a></li>
<li><a href="../de459256/index.html">Wie wir unser Themenkrankenhaus für verschiedene Plattformen optimiert haben</a></li>
<li><a href="../de459258/index.html">14.000 Meilen nicht haken</a></li>
<li><a href="../de459262/index.html">Mit 22 in den Ruhestand getreten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>