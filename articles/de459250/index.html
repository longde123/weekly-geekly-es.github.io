<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÖ üë®üèø‚Äçüé® üèõÔ∏è WAL in PostgreSQL: 2. Protokoll aufzeichnen üßòüèø üßÄ ü§¥üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Letztes Mal haben wir uns mit dem Ger√§t eines der wichtigsten Objekte des gemeinsamen Speichers getroffen, dem Puffercache. Die M√∂glichkeit, Informati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL in PostgreSQL: 2. Protokoll aufzeichnen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/459250/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Letztes Mal haben</a> wir uns mit dem Ger√§t eines der wichtigsten Objekte des gemeinsamen Speichers getroffen, dem Puffercache.  Die M√∂glichkeit, Informationen aus dem RAM zu verlieren, ist der Hauptgrund f√ºr die Notwendigkeit der Wiederherstellung nach einem Fehler.  Heute werden wir √ºber diese Tools sprechen. <br><br><h1>  Magazin </h1><br>  Leider geschehen keine Wunder: Um den Informationsverlust im RAM zu √ºberstehen, muss alles Notwendige rechtzeitig auf eine Festplatte (oder ein anderes nichtfl√ºchtiges Ger√§t) geschrieben werden. <br><br>  Daher wurde dies getan.  Neben Daten√§nderungen wird auch ein <em>Tagebuch</em> dieser √Ñnderungen gef√ºhrt.  Wenn wir etwas auf einer Seite im Puffercache √§ndern, erstellen wir im Protokoll einen Datensatz √ºber diese √Ñnderung.  Der Datensatz enth√§lt die Mindestinformationen, die ausreichen, damit die √Ñnderung bei Bedarf wiederholt werden kann. <br><br>  Damit dies funktioniert, muss der Journaleintrag unbedingt auf die Festplatte verschoben werden, <em>bevor die</em> ge√§nderte Seite dort ankommt.  Daher der Name: Write-Ahead-Protokoll. <br><br>  Wenn ein Fehler auftritt, befinden sich die Daten auf der Festplatte in einem inkonsistenten Zustand: Einige Seiten wurden fr√ºher geschrieben, andere sp√§ter.  Es bleibt jedoch ein Journal √ºbrig, das von den Vorg√§ngen gelesen und erneut ausgef√ºhrt werden kann, die bereits vor dem Fehler abgeschlossen wurden, deren Ergebnis jedoch die Festplatte nicht erreicht hat. <br><a name="habracut"></a><br><blockquote>  Warum nicht erzwingen, dass die Datenseiten selbst auf die Festplatte geschrieben werden, warum stattdessen Doppeljobs ausf√ºhren?  Es stellt sich als so effektiv heraus. <br>  Zuallererst ist ein Protokoll ein sequentieller Datenstrom, der geschrieben werden soll.  Sogar Festplatten eignen sich sehr gut f√ºr sequentielle Aufnahmen.  Die Aufzeichnung der Daten selbst ist jedoch zuf√§llig, da die Seiten mehr oder weniger zuf√§llig √ºber die Festplatte verteilt sind. <br>  Zweitens kann ein Journaleintrag viel kleiner als eine Seite sein. <br>  Drittens m√ºssen Sie sich bei der Aufnahme nicht darum k√ºmmern, dass die Daten auf der Festplatte zu einem beliebigen Zeitpunkt konsistent bleiben (diese Anforderung verk√ºrzt die Lebensdauer erheblich). <br>  Und viertens kann das Journal (da es existiert), wie wir sp√§ter sehen werden, nicht nur zur Wiederherstellung, sondern auch zur Sicherung und Replikation verwendet werden. <br></blockquote><br>  Sie m√ºssen alle Vorg√§nge protokollieren, bei denen im Falle eines Fehlers die Gefahr von Inkonsistenzen auf der Festplatte besteht.  Insbesondere werden folgende Aktionen protokolliert: <br><br><ul><li>  √Ñndern von Seiten im Puffercache (in der Regel sind dies Tabellen und Indexseiten) - da die ge√§nderte Seite nicht sofort auf die Festplatte verschoben wird; </li><li>  Festschreiben und Abbrechen von Transaktionen - Die Status√§nderung erfolgt in den XACT-Puffern und erreicht die Festplatte auch nicht sofort. </li><li>  Dateivorg√§nge (Erstellen und L√∂schen von Dateien und Verzeichnissen, z. B. Erstellen von Dateien beim Erstellen einer Tabelle) - da diese Vorg√§nge gleichzeitig mit Daten√§nderungen ausgef√ºhrt werden m√ºssen. </li></ul><br>  Nicht protokolliert: <br><br><ul><li>  Operationen mit nicht journalisierten (nicht protokollierten) Tabellen - ihr Name spricht f√ºr sich selbst; </li><li>  Operationen mit tempor√§ren Tabellen - dies ist nicht sinnvoll, da die Lebensdauer solcher Tabellen die Lebensdauer der Sitzung, in der sie erstellt wurden, nicht √ºberschreitet. </li></ul><br>  Vor PostgreSQL 10 wurden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hash-Indizes</a> nicht protokolliert (sie dienten nur dazu, Hash-Funktionen verschiedenen Datentypen zuzuordnen), aber jetzt wurde dies behoben. <br><br><h1>  Logisches Ger√§t </h1><br><img src="https://habrastorage.org/webt/vx/vj/67/vxvj673dzyqmhumlxby7i8wt5q0.png"><br><br>  Ein Journal kann logischerweise als eine Folge von Datens√§tzen unterschiedlicher L√§nge betrachtet werden.  Jeder Datensatz enth√§lt <em>Daten</em> zu einer bestimmten Operation, denen ein Standardheader vorangestellt ist.  Der Titel gibt unter anderem an: <br><br><ul><li>  Die Transaktionsnummer, zu der der Datensatz geh√∂rt. </li><li>  Ressourcenmanager - die Komponente des Systems, die f√ºr die Aufzeichnung verantwortlich ist; </li><li>  Pr√ºfsumme (CRC) - Erm√∂glicht die Ermittlung von Datenbesch√§digungen. </li><li>  Datensatzl√§nge und Link zum vorherigen Datensatz. </li></ul><br>  Die Daten selbst haben ein anderes Format und eine andere Bedeutung.  Sie k√∂nnen beispielsweise ein Fragment einer Seite darstellen, das mit einem bestimmten Versatz √ºber den Inhalt geschrieben werden muss.  Der angegebene Ressourcenmanager ‚Äûversteht‚Äú, wie die Daten in seinem Datensatz zu interpretieren sind.  Es gibt separate Manager f√ºr Tabellen, f√ºr jeden Indextyp, f√ºr den Transaktionsstatus usw. Eine vollst√§ndige Liste davon kann auf Wunsch des Befehls abgerufen werden <br><br><pre><code class="plaintext hljs">pg_waldump -r list</code> </pre> <br><h1>  Physisches Ger√§t </h1><br>  Auf der Festplatte wird das Protokoll als Dateien im Verzeichnis $ PGDATA / pg_wal gespeichert.  Jede Datei ist standardm√§√üig 16 MB gro√ü.  Die Gr√∂√üe kann erh√∂ht werden, um eine gro√üe Anzahl von Dateien in einem Verzeichnis zu vermeiden.  Vor PostgreSQL 11 war dies nur beim Kompilieren des Quellcodes m√∂glich. Jetzt k√∂nnen Sie die Gr√∂√üe beim Initialisieren des Clusters angeben (den <code>--wal-segsize</code> ). <br><br>  Protokolleintr√§ge fallen in die aktuell verwendete Datei.  Wenn es endet, wird das n√§chste verwendet. <br><br>  F√ºr das Protokoll im gemeinsam genutzten Speicher des Servers werden spezielle Puffer zugewiesen.  Die Gr√∂√üe des <em>Journalcaches</em> wird durch den Parameter <em>wal_buffers festgelegt</em> (der Standardwert impliziert eine automatische Konfiguration: 1/32 des <em>Puffercaches</em> wird zugewiesen). <br><br>  Der Journal-Cache ist wie ein Puffer-Cache angeordnet, funktioniert jedoch haupts√§chlich im Ringpuffer-Modus: Eintr√§ge werden dem "Kopf" hinzugef√ºgt und vom "Ende" auf die Festplatte geschrieben. <br><br>  Die Positionen Aufnahme ("Schwanz") und Einf√ºgen ("Kopf") zeigen die Funktionen pg_current_wal_lsn bzw. pg_current_wal_insert lsn: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_lsn(), pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_lsn | pg_current_wal_insert_lsn --------------------+--------------------------- 0/331E4E64 | 0/331E4EA0 (1 row)</code> </pre><br>  Um auf einen bestimmten Datensatz zu verweisen, wird der Datentyp pg_lsn (LSN = Protokollsequenznummer) verwendet. Dies ist eine 64-Bit-Nummer, die den Byte-Offset vor dem Datensatz relativ zum Protokollanfang darstellt.  LSN wird als zwei 32-Bit-Zahlen in hexadezimaler Schreibweise ausgegeben. <br><br>  Sie k√∂nnen herausfinden, in welcher Datei wir die gew√ºnschte Position finden und mit welchem ‚Äã‚ÄãVersatz vom Anfang der Datei: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> file_name, upper(to_hex(file_offset)) file_offset <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_walfile_name_offset(<span class="hljs-string"><span class="hljs-string">'0/331E4E64'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> file_name | file_offset --------------------------+------------- 000000010000000000000033 | 1E4E64 \ /\ /  0/331E4E64 </code> </pre><br>  Der Dateiname besteht aus zwei Teilen.  Die oberen 8 hexadezimalen Ziffern geben die Nummer des Zeitzweigs an (wird beim Wiederherstellen aus der Sicherung verwendet), der Rest entspricht den h√∂chsten LSN-Ziffern (und die verbleibenden unteren LSN-Ziffern geben den Versatz an). <br><br>  Protokolldateien k√∂nnen im Dateisystem im Verzeichnis $ PGDATA / pg_wal / angezeigt werden. Ab PostgreSQL 10 k√∂nnen sie jedoch auch mit einer speziellen Funktion angezeigt werden: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_ls_waldir() <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'000000010000000000000033'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> name | size | modification --------------------------+----------+------------------------ 000000010000000000000033 | 16777216 | 2019-07-08 20:24:13+03 (1 row)</code> </pre><br><h1>  Weiterleiten schreiben </h1><br>  Lassen Sie uns sehen, wie das Journaling erfolgt und wie proaktive Aufzeichnungen bereitgestellt werden.  Erstellen Sie eine Tabelle: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wal(id <span class="hljs-type"><span class="hljs-type">integer</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> wal <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Wir werden uns die Kopfzeile der Tabellenseite ansehen.  Dazu ben√∂tigen wir eine bereits bekannte Erweiterung: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect;</code> </pre><br>  Beginnen wir mit der Transaktion und merken uns die Einf√ºgeposition im Protokoll: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F377C (1 row)</code> </pre><br>  Lassen Sie uns nun eine Operation ausf√ºhren, zum Beispiel die Zeile aktualisieren: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> wal <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> id = id + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Diese √Ñnderung wurde im Protokoll aufgezeichnet, die Einf√ºgeposition hat sich ge√§ndert: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F37C4 (1 row)</code> </pre><br>  Um sicherzustellen, dass die ge√§nderte Datenseite nicht vor dem Journaleintrag auf die Festplatte √ºbertragen wird, wird die LSN des letzten Journaleintrags f√ºr diese Seite im Seitenkopf gespeichert: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lsn <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'wal'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lsn ------------ 0/331F37C4 (1 row)</code> </pre><br>  Beachten Sie, dass das Journal dem gesamten Cluster gemeinsam ist und st√§ndig neue Eintr√§ge in das Journal fallen.  Daher kann die LSN auf der Seite kleiner sein als der Wert, den die gerade zur√ºckgegebene Funktion pg_current_wal_insert_lsn zur√ºckgegeben hat.  In unserem System passiert jedoch nichts, daher sind die Zahlen gleich. <br><br>  Schlie√üen Sie nun die Transaktion ab. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Der Festschreibungsdatensatz wird ebenfalls in das Protokoll aufgenommen, und die Position √§ndert sich erneut: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F37E8 (1 row)</code> </pre><br>  Commit √§ndert den Status einer Transaktion in einer Struktur namens XACT (wir haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits dar√ºber gesprochen</a> ).  Status werden in Dateien gespeichert, sie verwenden jedoch auch einen eigenen Cache, der 128 Seiten im gemeinsam genutzten Speicher belegt.  Daher muss f√ºr XACT-Seiten die LSN des letzten Journaleintrags verfolgt werden.  Diese Informationen werden jedoch nicht auf der Seite selbst gespeichert, sondern im RAM. <br><br>  Irgendwann werden die erstellten Journaleintr√§ge auf die Festplatte geschrieben.  In welchem ‚Äã‚Äã- wir werden ein anderes Mal reden, aber in unserem Fall ist dies bereits geschehen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_lsn(), pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_lsn | pg_current_wal_insert_lsn --------------------+--------------------------- 0/331F37E8 | 0/331F37E8 (1 row)</code> </pre><br>  Nach diesem Zeitpunkt k√∂nnen die Daten- und XACT-Seiten aus dem Cache verschoben werden.  Wenn sie jedoch fr√ºher erzwungen werden m√ºssten, w√ºrde dies erkannt und die Journaleintr√§ge m√ºssten zuerst aufgezeichnet werden. <br><br>  Wenn Sie die beiden LSN-Positionen kennen, k√∂nnen Sie die Gr√∂√üe der Journaleintr√§ge zwischen ihnen (in Bytes) ermitteln, indem Sie einfach eine Position von der anderen subtrahieren.  Sie m√ºssen nur die Positionen in den Typ pg_lsn umwandeln: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'0/331F37E8'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/331F377C'</span></span>::pg_lsn;</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- 108 (1 row)</code> </pre><br>  In diesem Fall waren f√ºr die Zeilenaktualisierung und das Festschreiben 108 Byte im Protokoll erforderlich. <br><br>  Auf die gleiche Weise k√∂nnen Sie absch√§tzen, wie viele Journaleintr√§ge vom Server pro Zeiteinheit bei einer bestimmten Last generiert werden.  Dies sind wichtige Informationen, die w√§hrend des Setups ben√∂tigt werden (wor√ºber wir beim n√§chsten Mal sprechen werden). <br><br>  Jetzt verwenden wir das Dienstprogramm pg_waldump, um die erstellten Protokolleintr√§ge anzuzeigen. <br><br>  Das Dienstprogramm kann mit dem LSN-Bereich (wie in diesem Beispiel) arbeiten und Datens√§tze f√ºr die angegebene Transaktion ausw√§hlen.  Es sollte im Auftrag des Postgres-Betriebssystembenutzers ausgef√ºhrt werden, da dieser Zugriff auf die Protokolldateien auf der Festplatte ben√∂tigt. <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/331F377C -e 0/331F37E8 000000010000000000000033</code> </pre><pre> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 69/ 69, tx: 101085, lsn: 0/331F377C, prev 0/331F3014, desc: HOT_UPDATE off 1 xmax 101085 ; new off 2 xmax 0, blkref #0: rel 1663/16386/33081 blk 0</code> </pre><pre> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 34/ 34, tx: 101085, lsn: 0/331F37C4, prev 0/331F377C, desc: COMMIT 2019-07-08 20:24:13.945435 MSK</code> </pre><br>  Hier sehen wir die √úberschriften der beiden Eintr√§ge. <br><br>  Die erste ist die Operation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HOT_UPDATE</a> , die sich auf den Heap-Ressourcenmanager bezieht.  Der Dateiname und die Seitenzahl werden im Feld blkref angezeigt und stimmen mit der aktualisierten Tabellenseite √ºberein: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'wal'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/16386/33081 (1 row)</code> </pre><br>  Der zweite Eintrag ist COMMIT und bezieht sich auf den Transaction Resource Manager. <br><br>  Nicht das am besten lesbare Format, aber Sie k√∂nnen es bei Bedarf herausfinden. <br><br><h1>  Wiederherstellung </h1><br>  Wenn wir den Server starten, wird zuerst der Postmaster-Prozess gestartet, der wiederum den Startprozess startet, dessen Aufgabe es ist, die Wiederherstellung sicherzustellen, wenn ein Fehler auftritt. <br><br>  Um festzustellen, ob eine Wiederherstellung erforderlich ist, √ºberpr√ºft der Start die spezielle Steuerdatei $ PGDATA / global / pg_control und den Clusterstatus.  Wir k√∂nnen den Status selbst mit dem Dienstprogramm pg_controldata √ºberpr√ºfen: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | grep state</code> </pre><pre> <code class="plaintext hljs">Database cluster state: in production</code> </pre><br>  Ein ordentlich gestoppter Server hat den Status "Herunterfahren".  Wenn der Server nicht funktioniert und der Status "in Produktion" bleibt, bedeutet dies, dass das DBMS heruntergefallen ist und die Wiederherstellung automatisch durchgef√ºhrt wird. <br><br>  Zur Wiederherstellung liest der Startvorgang das Protokoll nacheinander und wendet bei Bedarf Eintr√§ge auf die Seiten an.  Sie k√∂nnen die Notwendigkeit √ºberpr√ºfen, indem Sie die LSN der Seite auf der Festplatte mit der LSN des Journaleintrags vergleichen.  Wenn die LSN der Seite gr√∂√üer ist, ist der Datensatz nicht erforderlich.  Tats√§chlich ist dies jedoch nicht m√∂glich, da die Aufzeichnungen f√ºr eine streng konsistente Anwendung ausgelegt sind. <br><br><blockquote>  Es gibt Ausnahmen.  Einige Datens√§tze werden als Ganzseitenbild (FPI, Ganzseitenbild) erstellt, und es ist klar, dass ein solches Bild in jedem Zustand auf eine Seite angewendet werden kann - es wird immer noch alles gel√∂scht, was dort war.  Eine weitere √Ñnderung des Status einer Transaktion kann auf jede Version der XACT-Seite angewendet werden. Auf diesen Seiten muss daher keine LSN gespeichert werden. <br></blockquote><br>  Das Wechseln der Seiten w√§hrend der Wiederherstellung erfolgt wie bei der normalen Arbeit im Puffercache - f√ºr diesen Postmaster werden die erforderlichen Hintergrundprozesse gestartet. <br><br>  Ebenso gelten Journaleintr√§ge f√ºr Dateien: Wenn beispielsweise ein Datensatz angibt, dass die Datei vorhanden sein muss, aber nicht vorhanden ist, wird die Datei erstellt. <br><br>  Nun, ganz am Ende des Wiederherstellungsprozesses werden alle nicht journalisierten Tabellen mit "Dummies" aus ihren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Init-Ebenen</a> √ºberschrieben. <br><br>  Dies ist eine sehr vereinfachte Darstellung des Algorithmus.  Insbesondere haben wir nichts dar√ºber gesagt, wo mit dem Lesen von Journaleintr√§gen begonnen werden soll (diese Konversation muss verschoben werden, bis der Kontrollpunkt ber√ºcksichtigt wird). <br><br>  Und die letzte Klarstellung.  Der "klassische" Wiederherstellungsprozess besteht aus zwei Phasen.  In der ersten Phase (Rollforward) werden Journaleintr√§ge gerollt, und der Server wiederholt alle w√§hrend des Fehlers verlorenen Arbeiten.  Beim zweiten (Rollback) werden Transaktionen zur√ºckgesetzt, die zum Zeitpunkt des Fehlers nicht festgeschrieben wurden.  PostgreSQL ben√∂tigt jedoch keine zweite Phase.  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits erw√§hnt</a> , m√ºssen Transaktionen aufgrund der Besonderheiten der Implementierung von Transaktionen mit mehreren Versionen nicht physisch zur√ºckgesetzt werden.  Es reicht aus, dass das Fixbit in XACT nicht gesetzt wird. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459250/">https://habr.com/ru/post/de459250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459240/index.html">10 Jahre in der IT mit Schizophrenie diagnostiziert, √úberlebenstipps</a></li>
<li><a href="../de459242/index.html">Im Anschluss an die T + Conf 2019 Konferenz</a></li>
<li><a href="../de459244/index.html">Hinweise Produktmanager: Benutzerverhalten auf Spieleseiten im App Store. Wie lange dauert das Herunterladen eines Spiels?</a></li>
<li><a href="../de459246/index.html">Warum nimmt die Site-Conversion ab? Beispiele f√ºr 60 Design- und Usability-Fehler</a></li>
<li><a href="../de459248/index.html">Digitale Veranstaltungen in Moskau vom 9. bis 14. Juli</a></li>
<li><a href="../de459252/index.html">Sicherheitswoche 28: Ein Smart Home hacken</a></li>
<li><a href="../de459254/index.html">Noch bessere Rei√üverschlussbombe</a></li>
<li><a href="../de459256/index.html">Wie wir unser Themenkrankenhaus f√ºr verschiedene Plattformen optimiert haben</a></li>
<li><a href="../de459258/index.html">14.000 Meilen nicht haken</a></li>
<li><a href="../de459262/index.html">Mit 22 in den Ruhestand getreten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>