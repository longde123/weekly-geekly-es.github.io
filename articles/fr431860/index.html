<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🎤 📖 🤷🏽 Sur les options du pilote Linux ou comment j'ai passé le week-end 🎀 🐴 👩🏼‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Nous sommes paresseux et curieux" 


 Cette fois, la raison de la publication était un article dans un bon magazine dédié au système d'exploitation L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sur les options du pilote Linux ou comment j'ai passé le week-end</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431860/"><h3>  "Nous sommes paresseux et curieux" </h3><br><img src="https://habrastorage.org/webt/sh/n6/_h/shn6_hdnwzoz1wv0ifrfabhtbpg.jpeg"><br><br>  Cette fois, la raison de la publication était un article dans un bon magazine dédié au système d'exploitation Linux (ci-après dénommé L), dans lequel "l'expert" attiré a félicité le pilote connectant l'écran LCD à la carte Raspbery.  Étant donné que de telles choses (connexion, pas le système d'exploitation) entrent dans le champ de mes intérêts professionnels, j'ai parcouru l'article avec attention, puis j'ai trouvé le texte réel du «pilote» et j'ai été légèrement surpris que l'informatique puisse être louée.  Eh bien, en général, le niveau d'expert peut être déterminé, ne serait-ce que parce qu'il a obstinément appelé le programme un pilote, malgré le fait que ce ne soit en aucun cas.  Il semblerait, et les figues avec lui, vous ne savez jamais ce que quelqu'un écrit pour lui-même, mais pour le publier dans le domaine public - "Je ne savais pas que c'était possible." <br><br>  Particulièrement satisfait du fait que l'adresse du périphérique sur le bus I2C a été directement définie dans le texte du programme et son changement a nécessité une recompilation (enfin, ce n'est pas tout le noyau).  Soit dit en passant, j'ai remarqué que sur les forums consacrés à L, la réponse la plus populaire à toute question concernant les problèmes logiciels est «reconstruire la dernière version du noyau».  Cette approche me semble un peu étrange, probablement, je ne sais pas quelque chose.  Mais, néanmoins, la question s'est posée de savoir comment le paramétrage du pilote est réellement implémenté (à l'intérieur, pas à l'extérieur - tout est simple et clair) dans A, la réponse à laquelle ce billet est consacré. <br><a name="habracut"></a><br>  Ce n'est pas que j'écrivais constamment des pilotes pour L, mais avec le processus dans son ensemble, je suis familier et Google a confirmé de vagues souvenirs qu'il existe un ensemble de macros qui devraient être utilisées lors de la création du code source du module afin de pouvoir lui transmettre des paramètres de fonctionnement, par exemple, l'adresse de l'appareil à au bus.  Néanmoins, la mécanique du processus lui-même n'a été décrite nulle part.  J'ai vu le même texte dans de nombreux liens (en passant, une question intéressante - pourquoi faire cela, c'est-à-dire placer le fragment du texte de quelqu'un d'autre sur ma ressource - je ne comprends pas vraiment la signification de cette opération), qui décrivait les macros ci-dessus.  Je n'ai pas trouvé une seule mention du mécanisme pour effectuer l'opération, pour un autre système d'exploitation bien connu (Windows), je devrais énoncer un fait et me limiter à cela, mais l'un des avantages de A est la disponibilité des textes sources et la possibilité de trouver une réponse à toute question sur sa structure interne, ce que nous ferons.  Je constate tout de suite que j'essaierai de ne pas dupliquer les informations que vous pouvez obtenir auprès d'autres sources, et je me limiterai seulement à ce qui est nécessaire à la compréhension du texte. <br><br>  Mais avant de regarder la source, nous allons d'abord réfléchir un peu, mais comment ferions-nous si nous obtenions une tâche similaire (et soudain, après ce post, ils m'inviteront chez les mineurs L, et vous ne refuserez pas).  Il y a donc la possibilité de créer un module - une certaine unité de programme spécialement conçue qui peut être chargée en mémoire pour être exécutée à l'aide d'un utilitaire système (insmode - ci-après I), tandis qu'une chaîne de caractères est transmise en tant que paramètres de lancement.  Cette ligne peut inclure des unités lexicales strictement définies, dont la description du format est spécifiée lors de la création du texte source du module, et ces unités contiennent des informations qui vous permettent de modifier la valeur des variables internes de ce module. <br><br>  Examinons plus attentivement la manière de décrire les unités lexicales ci-dessus, nous en avons besoin pour envisager différentes solutions.  L'unité d'analyse est déterminée en appelant la macro, qui est informée des informations nécessaires - le nom de la variable qui doit être modifiée pendant le processus de configuration, son nom externe (généralement le même que le précédent), le type de la variable de l'ensemble limité et les droits d'accès à la variable dans le style de rw-rw-rw.  De plus, une chaîne de texte (facultative) décrivant la variable peut être spécifiée.  De toute évidence, ces informations sont nécessaires et suffisantes (en conjonction avec les règles de conception des unités syntaxiques - séparateurs et jetons) pour construire l'analyseur de la liste de paramètres spécifiée sous la forme d'une chaîne de texte, mais laissent de la place pour la mise en œuvre de la distribution des fonctions entre le participant au processus. <br><br>  Pour configurer le module, nous avons besoin de: <br><br><ol><li>  formulaire (enfin, c'est au stade de la compilation, vous pouvez le faire comme vous le souhaitez, bien que ce soit toujours intéressant de voir comment) et stocker un tableau des paramètres ci-dessus </li><li>  analyser les paramètres d'entrée selon ce tableau et </li><li>  apporter des modifications à certaines zones de la mémoire en fonction du résultat de l'analyse d'une unité syntaxique. </li></ol><br>  Nous réfléchirons un peu dans le style de «si j'étais le réalisateur» et proposerons des implémentations possibles.  Comment nous pourrions implémenter le comportement similaire de l'utilitaire système et du module - nous commencerons l'analyse des options dans une complexité croissante. <br><br>  La première solution est que l'utilitaire And ne fait presque rien, appelle simplement le module qui lui est indiqué et lui transfère les paramètres restants dans le style de ligne de commande, et le module les analyse déjà, en s'appuyant sur les informations disponibles et en effectuant les modifications nécessaires.  Cette solution est simple, compréhensible et tout à fait réalisable, mais la circonstance suivante doit être prise en compte: en aucun cas l'analyse des paramètres ne doit être laissée à la volonté de l'auteur du module, car cela lui donnera un espace inacceptable, et après tout, deux programmeurs écriront toujours trois options d'analyseur.  Et donc nous sommes allés à sa rencontre, en lui permettant des paramètres de type indéfini, qui ont une chaîne de texte comme valeur. <br><br>  Par conséquent, un certain analyseur standard devrait être automatiquement inclus dans le texte du module, c'est facile à implémenter au niveau de la substitution de macro. <br><br>  Cette solution présente deux inconvénients: <br><br><ol><li>  on ne sait pas pourquoi nous en avons besoin. Et vous pouvez immédiatement appeler le module avec des paramètres à partir de la ligne de commande, </li><li>  le code du module (partie initialisation) doit contenir les trois sections des informations nécessaires, et ces informations sont nécessaires uniquement lorsque le module est démarré et n'est pas utilisé à l'avenir, et il prend toujours de la place.  Faites immédiatement une réservation que ces informations prennent nécessairement de la place dans le fichier, mais elles peuvent ne pas aller en mémoire lors du chargement du module, si tout est fait avec soin.  Pour ce faire, nous rappelons les directives _init et _initdata (au fait, mais comment elles fonctionnent, nous devrons le comprendre - c'est le sujet du prochain billet - vous attendez-vous avec impatience?).  Mais dans ce dernier cas, les sections 2 et 3 des informations du fichier sont clairement redondantes, car le même code sera présent dans de nombreux modules, violant malicieusement le principe DRY. </li></ol><br>  En raison des lacunes constatées, la mise en œuvre de cette option est hautement improbable.  De plus, on ne sait pas pourquoi dans la macro définir des informations sur le type de paramètre, car le module lui-même sait très bien ce qu'il modifie (bien que cela puisse être nécessaire pour l'analyseur lors de la vérification des paramètres).  L'évaluation globale de la probabilité d'une telle décision est de 2 à 3%. <br><br>  La digression nécessaire au sujet de l'inconvénient noté 2 - J'ai été formé en tant que spécialiste à l'époque où 256 kilo-octets de RAM étaient suffisants pour organiser 4 postes de travail, 56 kilo-octets avaient un système d'exploitation à double tâche et un système d'exploitation à tâche unique a commencé à fonctionner à 16 kilo-octets.  Eh bien, 650 ko, ce qui devrait être suffisant pour n'importe quel programme, étaient généralement quelque chose du domaine de la fiction non scientifique.  Par conséquent, j'ai l'habitude de penser que la RAM est une ressource rare et je désapprouve extrêmement son utilisation inutile, à moins qu'elle ne soit absolument nécessaire (en règle générale, les exigences de performance), et dans ce cas, je n'observe pas une telle situation.  Puisque la plupart de mes lecteurs se sont formés dans des réalités différentes, vous pouvez avoir vos propres évaluations de la préférence de telle ou telle option. <br><br>  La deuxième solution - l'analyseur lui-même est transféré vers AND, qui transfère les données extraites au module (sa partie d'initialisation) - le numéro et la valeur du paramètre.  Ensuite, nous préservons l'uniformité des paramètres et réduisons les exigences de taille du module.  La question demeure, comment fournir une liste ET de paramètres possibles, mais cela est fourni par des macros en créant une structure prédéterminée du module et l'emplacement du bloc à un endroit spécifique (fichier ou mémoire).  La solution est meilleure que la précédente, mais la mémoire excédentaire du module demeure.  En général, j'aime la solution, car mon analyseur (qui est pire que tous les autres programmeurs, j'ai mon propre analyseur, non sans défauts, mais certainement pas fatal) fonctionne selon ce schéma, renvoyant le numéro de la règle et la valeur identifiées au programme principal paramètre.  Néanmoins, la probabilité de mettre en œuvre cette option particulière n'est pas très élevée - 5%. <br><br>  Une sous-option de la deuxième solution consiste à transférer les paramètres extraits non pas vers la partie de départ du module, mais directement vers sa partie active chargée, par exemple via ioctl - les besoins en mémoire sont les mêmes.  Nous avons une opportunité unique de changer les paramètres "à la volée", ce qui n'est pas implémenté dans les autres versions.  Il n'est pas très clair pourquoi nous pourrions avoir besoin d'une telle fonctionnalité, mais elle est magnifique.  L'inconvénient est 1) vous devez réserver une partie de la zone de fonction à l'avance pour une demande éventuellement inutilisée, et 2) le code de modification doit être présent en mémoire en permanence.  Estimation de la probabilité de mise en œuvre - pourcentage 5. <br><br>  La troisième solution est de transférer vers Et aussi la modification des paramètres.  Ensuite, dans le processus de chargement du code binaire du module Et, il peut modifier les données dans la mémoire intermédiaire et charger le code du pilote avec les paramètres modifiés à l'emplacement de déploiement permanent, ou apporter ces modifications directement dans la zone de mémoire dans laquelle le binaire a été chargé, et la table des paramètres présente dans le fichier est en mémoire peut à la fois charger et ne pas l'occuper (rappelez-vous des directives).  La décision est responsable, elle nécessitera, comme la précédente, la présence d'une zone de communication prédéfinie entre le module et ET pour stocker la description des paramètres, mais elle réduit encore les exigences de mémoire excessive dans le module.  Immédiatement, on note le principal inconvénient d'une telle solution - l'incapacité à contrôler les valeurs des paramètres et leur cohérence, mais il n'y a rien à faire.  C'est une solution tout à fait normale, très probablement - 75%. <br><br>  Une variante de la troisième solution - les informations sur les paramètres ne sont pas stockées dans le module lui-même, mais dans un fichier auxiliaire, il n'y a tout simplement pas de mémoire excédentaire dans le module.  En principe, la même chose peut être faite dans la version précédente, lorsque le module contient la partie de configuration, qui est utilisée ET pendant le processus de démarrage, mais n'est pas chargée dans la RAM contenant la partie exécutable réelle du module.  Par rapport à la version précédente, un fichier supplémentaire a été ajouté et il n'est pas clair pour quoi nous payons, mais peut-être qu'ils ont fait des directives d'initialisation avant l'invention - 5%. <br><br>  Les 7% restants seront laissés à d'autres options que je n'ai pas pu trouver.  Eh bien, maintenant que notre fantaisie s'est épuisée (la mienne à coup sûr, s'il y a plus d'idées, veuillez demander dans le commentaire), nous allons commencer à étudier la source de L. <br><br>  Pour commencer, je note que, apparemment, l'art de distribuer des textes sources dans des fichiers a été perdu avec le système d'exploitation, qui tient dans 16 ko, car la structure des répertoires, leurs noms et noms de fichiers sont liés au contenu un peu plus que rien.  Étant donné la présence d'inclusions intégrées, l'étude classique des sources téléchargées avec l'aide d'un éditeur se transforme en une quête étrange et sera improductive.  Heureusement, il existe un charmant utilitaire Elixir, disponible en ligne, qui vous permet d'effectuer des recherches contextuelles, et avec lui, le processus devient beaucoup plus intéressant et fructueux.  J'ai effectué mes recherches complémentaires sur le site elixir.bootlin.com.  Oui, ce site n'est pas une collection officielle de fromages à noyau, contrairement à kernel.org, mais espérons que leur code source soit identique. <br><br>  Tout d'abord, regardons une macro pour déterminer les paramètres - premièrement, nous connaissons son nom, et deuxièmement, cela devrait être plus facile (ouais, maintenant).  Il se trouve dans le fichier moduleparam.h - c'est tout à fait raisonnable, mais c'est une agréable surprise, compte tenu de ce que nous verrons plus tard.  Macro <br><br><pre><code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">0</span></span>}module_param(name,type,perm)</code> </pre> <br>  est un wrapper sur <br><br><pre> <code class="cpp hljs"> {<span class="hljs-number"><span class="hljs-number">0</span></span>a}module_param_named(n,n,t,p)</code> </pre> <br>  - sucre syntaxique pour le cas le plus courant.  Dans le même temps, pour une raison quelconque, l'énumération des valeurs autorisées de l'un des paramètres, à savoir le type de la variable, est donnée dans les commentaires avant le texte de l'encapsuleur, et non dans la deuxième macro, qui fait vraiment le travail et peut être utilisée directement. <br><br>  La macro {0a} contient un appel à trois macros <br><br><pre> <code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">1</span></span>}param_check_#<span class="hljs-meta"><span class="hljs-meta">#t(n,&amp;v)</span></span></code> </pre> <br>  (il existe un ensemble de macros pour tous les types valides) <br><br><pre> <code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">2</span></span>}module_param_cb(n,&amp;op##t,&amp;v,p)</code> </pre> <br>  et <br><br><pre> <code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">3</span></span>}__MODULE_PARM_TYPE(n,t)</code> </pre> <br>  (faites attention aux noms, cependant, charme), et le premier d'entre eux est utilisé ailleurs, c'est-à-dire que les recommandations d'Occam et le principe KISS sont également hardiment négligés par les créateurs de A - apparemment, une sorte de travail préparatoire pour l'avenir.  Bien sûr, ce ne sont que des macros, mais elles ne coûtent rien, mais quand même ... <br><br>  La première des trois macros {1}, comme son nom l'indique, vérifie la correspondance des types de paramètres et encapsule <br><br><pre> <code class="cpp hljs">__param_check(n,p,t)</code> </pre> <br>  Notez qu'à la première étape de l'habillage, le niveau d'abstraction des macros diminue, et à la seconde, il augmente probablement d'une manière différente, et il me semble seulement que cela pourrait être plus simple et plus logique, d'autant plus que la macro moyenne n'est utilisée nulle part ailleurs.  D'accord, mettons une autre façon de vérifier les paramètres macro dans la tirelire et de continuer. <br><br>  Mais les deux macros suivantes génèrent en fait un élément de la table des paramètres.  Pourquoi ne demandez-vous pas deux, et pas un, j'ai depuis longtemps cessé de comprendre la logique des créateurs de L. Très probablement, en fonction de la différence de style de ces deux macros, à commencer par les noms, le second a été ajouté plus tard pour étendre les fonctionnalités et modifier la structure existante C'était impossible, car au départ, ils regrettaient d'attribuer une place pour indiquer l'option des paramètres.  La macro {2}, comme toujours, nous masque la macro <br><br><pre> <code class="cpp hljs">{<span class="hljs-number"><span class="hljs-number">2</span></span>a}_module_param_call(MODULE_PARAM_PREFIX,n,ops,arg,p,<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  (c'est drôle que cette macro ne soit appelée directement nulle part sauf 8250_core.c, où elle est appelée avec les mêmes paramètres supplémentaires), mais cette dernière produit déjà le code source. <br><br>  Une petite remarque - pendant la recherche, nous nous assurons que la navigation de texte fonctionne bien, mais il y a deux circonstances désagréables: la recherche par le fragment de nom ne fonctionne pas (check_param_ n'a pas été trouvé, bien que check_param_byte a été trouvé) et la recherche ne fonctionne que sur les déclarations d'objets (la variable n'est pas trouvée, puis est trouvé dans ce fichier par ctrF, mais la recherche intégrée par source n'est pas détectée).  Pas très encourageant, car nous aurons peut-être besoin de rechercher un objet en dehors du fichier courant, mais "au final, nous n'en avons pas d'autre". <br><br>  À la suite du travail de {1} dans le texte du module compilé en présence des deux lignes suivantes <br><br><pre> <code class="cpp hljs">module_param_named(name, c, byte, <span class="hljs-number"><span class="hljs-number">0x444</span></span>); module_param_named(name1, i, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">0x444</span></span>);</code> </pre> <br>  un fragment du type ci-dessous apparaît <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __param_str_name[] = <span class="hljs-string"><span class="hljs-string">"MODULE"</span></span> <span class="hljs-string"><span class="hljs-string">"."</span></span> <span class="hljs-string"><span class="hljs-string">"name"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kernel_param</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">param_name</span></span></span><span class="hljs-class"> \ __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute__</span></span></span><span class="hljs-class">((__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">used__</span></span></span><span class="hljs-class">)) \ __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute__</span></span></span><span class="hljs-class"> ((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unused</span></span></span><span class="hljs-class">,__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">section__</span></span></span><span class="hljs-class"> ("__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">param</span></span></span><span class="hljs-class">"),</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aligned</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sizeof</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> *)))) \ = {</span></span> __param_str_name, ((struct <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>), &amp;param_ops_byte, (<span class="hljs-number"><span class="hljs-number">0x444</span></span>), <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, { &amp;c } }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __UNIQUE_ID_nametype72[] \ __attribute__((__used__)) __attribute__((section(<span class="hljs-string"><span class="hljs-string">".modinfo"</span></span>), unused, aligned(<span class="hljs-number"><span class="hljs-number">1</span></span>))) \ = <span class="hljs-string"><span class="hljs-string">"parmtype"</span></span> <span class="hljs-string"><span class="hljs-string">"="</span></span> <span class="hljs-string"><span class="hljs-string">"name"</span></span> <span class="hljs-string"><span class="hljs-string">":"</span></span> <span class="hljs-string"><span class="hljs-string">"byte"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __param_str_name1[] = <span class="hljs-string"><span class="hljs-string">"MODULE"</span></span> <span class="hljs-string"><span class="hljs-string">"."</span></span> <span class="hljs-string"><span class="hljs-string">"name1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kernel_param</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">param_name1</span></span></span><span class="hljs-class"> \ __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute__</span></span></span><span class="hljs-class">((__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">used__</span></span></span><span class="hljs-class">)) \ __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attribute__</span></span></span><span class="hljs-class"> ((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unused</span></span></span><span class="hljs-class">,__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">section__</span></span></span><span class="hljs-class"> ("__</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">param</span></span></span><span class="hljs-class">"),</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aligned</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sizeof</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> *)))) \ = {</span></span> __param_str_name1, ((struct <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>), &amp;param_ops_int, (<span class="hljs-number"><span class="hljs-number">0x444</span></span>), <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, { &amp;i } }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __UNIQUE_ID_name1type73[] __attribute__((__used__)) \ __attribute__((section(<span class="hljs-string"><span class="hljs-string">".modinfo"</span></span>), unused, aligned(<span class="hljs-number"><span class="hljs-number">1</span></span>))) \ = <span class="hljs-string"><span class="hljs-string">"parmtype"</span></span> <span class="hljs-string"><span class="hljs-string">"="</span></span> <span class="hljs-string"><span class="hljs-string">"name1"</span></span> <span class="hljs-string"><span class="hljs-string">":"</span></span> <span class="hljs-string"><span class="hljs-string">"int"</span></span>;</code> </pre> <br>  (en fait, des fichiers sur une seule ligne y sont générés, je les ai divisés en lignes pour en faciliter l'examen) et nous pouvons immédiatement dire qu'il n'y a aucune allusion à l'inclusion d'une section de programme d'analyse ou d'un module pour attribuer des valeurs aux paramètres dans le texte source, donc les options 1 et 2 peuvent considéré comme exclu de tout examen ultérieur.  La présence d'attributs spéciaux pour l'éditeur de liens, pour ainsi dire, suggère l'existence d'une région de communication située à un endroit prédéterminé à travers lequel la description des paramètres est transmise.  Dans le même temps, nous constatons avec étonnement l'absence totale de toute description du bloc généré de paramètres possibles sous forme de texte qui pourrait être utilisé par le module analyseur.  Il est clair qu'un code bien écrit est auto-documenté, mais pas dans la même mesure que cela n'augmente pas la probabilité de l'option 1 ou 2, l'analyseur étant écrit par le développeur du module. <br><br>  La combinaison des attributs __used__ et inutilisés en même temps semble drôle dans la dernière ligne générée, surtout si vous regardez le prochain fragment de code de macro <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> GCC_VERSION &lt; 30300 # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __used __attribute__((__unused__)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __used __attribute__((__used__)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  Quel est le genre d'agilité que les développeurs de A fument, la manière douloureusement tortueuse de leurs pensées incarnée dans le code.  Je sais que vous pouvez utiliser les deux formes d'écriture d'attributs, mais pourquoi le faire sur la même ligne - je ne comprends pas. <br><br>  On peut noter une autre caractéristique intéressante du code résultant - la duplication d'informations sur le nom de la variable et son type.  On ne sait pas encore pourquoi cela a été fait, mais le fait lui-même ne fait aucun doute.  Bien sûr, ces informations sont cohérentes, car elles sont construites en mode automatique, et cette cohérence sera préservée lorsque le texte source change (et c'est bien), mais il est dupliqué (et c'est mauvais), peut-être plus tard nous comprendrons la nécessité d'une telle solution.  De plus, la nécessité de former un nom unique en utilisant le numéro de ligne du code source reste incertaine, car la première ligne générée s'en est sortie. <br><br>  Une autre note - comprendre exactement ce que la définition du paramètre se transforme n'était pas une tâche complètement triviale, mais grâce à MinGW, elle était toujours terminée.  Sous le capot, il y avait une stringification et un double collage des paramètres, la formation de noms uniques, ainsi que d'autres astuces délicates de travail avec les macros, mais je ne présente que les résultats.  Résumant le résultat intermédiaire, je peux dire que l'étude des macros A n'est pas ce dont je voudrais gagner ma vie, c'est seulement possible comme divertissement, mais nous continuons. <br><br>  Nous ne ferons pas avancer la compréhension des macros pour comprendre la tâche, nous nous tournons donc vers le code source de l'utilitaire And et essayons de comprendre ce qu'il fait. <br><br>  Tout d'abord, nous sommes étonnés de voir que les fromages requis ne sont pas inclus dans les sources du noyau.  Oui, je suis prêt à admettre que le I est un utilitaire et interagit avec le noyau via le point d'entrée pour charger le module, mais tout livre sur les pilotes L nous parle de cet utilitaire, donc l'absence d'une version «officielle» de sa source quelque part près de la source du noyau provoque me mal compris.  Bon, d'accord, Google ne nous a pas laissé tomber, et nous avons quand même pris le fromage. <br><br>  La deuxième chose étonnante est que cet utilitaire est formé à partir d'un package dont le nom n'est en aucun cas associé à son nom, il existe plus d'un de ces packages, et chacun est nommé à sa manière à différents endroits - pour le moins drôle.  Si vous avez installé L, alors avec la commande - vous pouvez découvrir à partir de quel package l'utilitaire I est construit, puis le rechercher, mais si nous effectuons des recherches théoriques (personnellement, je ne garde pas L sur mon ordinateur personnel pour plusieurs raisons, dont certaines que je J'ai énoncé mes posts, un tel boxeur théorique), alors cette méthode ne nous est pas accessible et il ne reste qu'une recherche sur Internet, heureusement, elle donne des résultats. <br><br>  Eh bien, la troisième chose étonnante est que le nom de l'utilitaire lui-même n'apparaît nulle part dans le code source, il n'est pas utilisé dans les noms de fichiers et se trouve uniquement dans le fichier make, je sais qu'en C, nous sommes obligés de nommer la fonction principale principale, et cela n'est pas discuté (je ne suis pas personnellement Je m'en réjouis, puisque Pascal est gâté, mais ils ne m'ont pas demandé mon avis lors de la conception du langage), mais au moins il serait possible d'écrire le nom externe de l'utilitaire dans les commentaires.  Remarque nécessaire - beaucoup de choses dans le langage C ont été faites sur le principe "c'est tellement habituel avec nous", il était probablement difficile de rendre les choses différentes parfois, voire impossibles, mais que pouvez-vous faire maintenant, en faisant glisser une valise sans poignée plus loin. <br><br>  Nous trouvons deux paquets contenant le texte source. Et, nous trouvons également les fromages sur github, nous voyons qu'ils sont identiques et nous croyons que c'est à cela que ressemble le code source de l'utilitaire.  Ensuite, nous étudions uniquement le fichier sur git, d'autant plus qu'il s'appelle ici insmod.c, et que pour commencer, il convertit la liste des paramètres en une longue chaîne terminée par un caractère nul, dans laquelle les éléments individuels sont séparés par des espaces.  Ensuite, il appelle deux fonctions, dont la première s'appelle grub_file et ouvre évidemment le binaire, tandis que la seconde a le nom init_module et prend un pointeur vers le fichier ouvert avec le module binaire et une chaîne de paramètres et s'appelle load_module, ce qui suggère le but de cette fonction comme chargement avec modification des paramètres. <br><br>  Nous passons au texte de la deuxième fonction, qui se trouve dans le fichier ... et voici une déception - pas dans aucun des fichiers du dépôt étudié sur le Geet (eh bien, c'est juste logique, cela fait partie du noyau et sa place n'est pas ici) ce n'est pas le cas.  Google à nouveau pressé d'aider et nous renvoie aux fromages en grains sous Elixir et au fichier module.c.  Il convient de noter que, de manière surprenante, le nom du fichier contenant les fonctions de travail avec les modules semble logique, je ne comprends même pas comment l'expliquer, cela est probablement arrivé par accident. <br><br>  Maintenant, il est devenu clair pour nous le manque de texte Et à côté du noyau - il ne fait pratiquement rien, il transfère uniquement les paramètres d'une forme à une autre et transfère le contrôle au noyau lui-même, il est donc même indigne de se trouver à côté de lui.  À partir de ce moment, il devient clair qu'il n'y a pas d'informations externes claires sur la structure des paramètres, car le noyau les a ignorés dans ses propres macros et sait tout à leur sujet parfaitement, et les autres n'ont besoin de rien savoir de la structure interne (à la lumière du fait que la source sont disponibles pour consultation, quelques commentaires ne feraient pas de mal, mais en principe c'est vraiment de plus en plus clair même sans eux), mais jusqu'à présent, il n'a presque jamais mis en lumière la mise en œuvre du mécanisme d'exécution lui-même. <br><br>  Remarque - concernant le transfert de contrôle vers le noyau, je suis un peu excité, car pour l'instant nous voyons l'utilisation de la fonction dans la source du noyau, si la partie binaire sera liée au module, ou si elle se trouve dans l'image du noyau elle-même, est encore inconnue.  Le fait que le point d'entrée vers le traitement de cette fonction soit encadré de manière particulière, via SYSCALL_DEFINE3, témoigne indirectement en faveur de la deuxième option, mais j'ai longtemps compris que mes idées sur le logique et l'illogique, l'acceptable et l'inacceptable, ainsi que le admissible et l'inacceptable, sont très significatives s'écarter de ceux des développeurs de L. <br><br>  Remarque - un caillou de plus dans le jardin de recherche intégré - lors de la recherche d'une définition pour cette macro, j'ai vu de nombreux endroits pour l'utiliser en tant que fonction, parmi lesquels la définition même de celle-ci en tant que macro s'est cachée très modestement. <br><br>  Par exemple, je ne comprends pas pourquoi un utilitaire externe est nécessaire pour traduire les paramètres du formulaire standard pour le système d'exploitation (agrc, argv) sous la forme d'une chaîne terminée par un zéro avec des espaces comme séparateurs, qui est ensuite traitée par le module système - cette approche dépasse quelque peu la mienne capacités cognitives.  Surtout, étant donné que l'utilisateur entre une chaîne de paramètres sous la forme d'une chaîne terminée par un zéro avec des espaces comme séparateurs, et l'utilitaire dans le noyau la convertit en une forme (argc, argv).  Rappelle fortement la vieille plaisanterie "Nous retirons la bouilloire du poêle, en versons de l'eau et obtenons un problème dont la solution est déjà connue."  Et puisque j'essaie d'adhérer au principe «Ne considérez pas votre interlocuteur plus stupide que vous, jusqu'à ce qu'il prouve le contraire.  Et même après cela, vous pouvez vous tromper », et en ce qui concerne les développeurs de A, la première phrase est définitivement valable, cela signifie que je me méprends sur quelque chose, mais je n'y suis pas habitué.  Si quelqu'un peut offrir une explication raisonnable du fait déclaré de la double conversion, alors je demande dans le commentaire.  Mais nous continuons l'enquête. <br><br>  Les perspectives de mise en œuvre des options 1 et 2 deviennent «très faiblement visibles» (un charmant libellé d'un article récent sur les perspectives de développement d'ADC domestiques à haut débit), car il serait très étrange de charger un module en mémoire à l'aide de la fonction noyau, puis de lui passer le contrôle pour implémenter le noyau fonction intégrée dans son corps.  Et pour sûr, dans le texte de la fonction load_module, nous trouvons assez rapidement l'appel parse_args - il semble que nous soyons sur la bonne voie.  Ensuite, nous passons rapidement en revue la chaîne d'appels (comme toujours, nous verrons les fonctions wrapper et les macros wrapper, mais nous sommes déjà habitués à fermer les yeux sur ces farces si mignonnes des développeurs) et nous trouvons la fonction parse_one, qui place le paramètre requis au bon endroit. <br><br>  Notez qu'il n'y a pas de contrôle sur la validité des paramètres, comme on pourrait s'y attendre, car le noyau, contrairement au module lui-même, ne sait rien de leur fonction.  Il y a des vérifications de syntaxe et le nombre d'éléments dans le tableau (oui, il peut y avoir un tableau d'entiers comme paramètre) et lorsque des erreurs de ce type sont détectées, le chargement du module s'arrête, mais rien de plus.  Cependant, tout n'est pas perdu, car après le chargement, le contrôle est transféré à la fonction init_module, qui peut effectuer la validation nécessaire des paramètres définis et, si la <s>sauvegarde est</s> nécessaire, mettre fin au processus de démarrage. <br><br>  Cependant, nous avons complètement ignoré la question de savoir comment les fonctions d'analyse accèdent à un tableau d'échantillons de paramètres, car sans cela, l'analyse est quelque peu difficile.  Un rapide coup d'œil au code montre qu'un hack sale a été appliqué, une astuce évidente - dans le fichier binaire, la fonction find_module_sections recherche la section nommée __param, divise sa taille par la taille de l'enregistrement (fait beaucoup plus) et renvoie les données nécessaires via la structure.  Je mettrais toujours les lettres p devant les noms des paramètres de cette fonction, mais c'est une question de goût. <br><br>  Tout semble être clair et compréhensible, la seule chose qui inquiète est le manque de l'attribut __initdata sur les données générées, peut-il vraiment rester en mémoire après l'initialisation, cet attribut est probablement décrit quelque part dans la partie générale, par exemple, dans les données de l'éditeur de liens, pour être honnête , paresseux à regarder, voir l'épigraphe. <br><br>  En résumé - le week-end a été utile, il était intéressant de comprendre le code source de L, de se souvenir de quelque chose et d'apprendre quelque chose, mais la connaissance n'est jamais superflue. <br>  Eh bien, dans mes hypothèses, je n'ai pas deviné, dans L, une option a été mise en œuvre qui s'est avérée être dans les 7% restants, mais ce n'était douloureusement pas évident. <br><br>  Eh bien, en conclusion, le cri de Yaroslavna (comment peut-on s'en passer) pourquoi dois-je chercher les informations nécessaires (je ne parle pas de la cuisine interne, mais de la présentation externe) de diverses sources qui n'ont pas de statut officiel, où un document similaire au livre <br>  «Logiciel d'un ordinateur.  Système d'exploitation fonctionnel. <br>  RAFOS.  Guide du programmeur système. ", Ou ne le font-ils plus? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431860/">https://habr.com/ru/post/fr431860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431848/index.html">Comme j'ai écrit le plus gros script pour Altium Designer</a></li>
<li><a href="../fr431850/index.html">Heisenbug 2018 Moscou: diffusion en ligne gratuite, fête et bien plus encore</a></li>
<li><a href="../fr431854/index.html">Cohérence des données dans les systèmes fortement chargés</a></li>
<li><a href="../fr431856/index.html">Extension de l'éditeur Unity avec la fenêtre de l'éditeur, l'objet scriptable et l'éditeur personnalisé</a></li>
<li><a href="../fr431858/index.html">Mitap Sbertekh à Rostov-sur-le-Don</a></li>
<li><a href="../fr431862/index.html">Mitap Sbertekh à Iekaterinbourg</a></li>
<li><a href="../fr431864/index.html">PVS-Studio ROI: comment ne pas perdre des millions (version provisoire de l'article)</a></li>
<li><a href="../fr431866/index.html">Idées fausses des programmeurs sur les noms - avec des exemples</a></li>
<li><a href="../fr431868/index.html">Heures sur les lampes à décharge (GRI), ce sont des horloges Nixie</a></li>
<li><a href="../fr431870/index.html">Un développeur de livres interactifs avec LED se plaint du vol d'idées par les employés de Google</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>