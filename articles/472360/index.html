<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüíª üî¢ üë©üèø‚Äçüöí Escaneando el c√≥digo de Orchard CMS en busca de errores üõï üë¨ üë≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo revisa los resultados de una segunda verificaci√≥n del proyecto Orchard con el analizador est√°tico PVS-Studio. Orchard es un sistema de g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escaneando el c√≥digo de Orchard CMS en busca de errores</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/472360/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/c02/394/ef5c023947badf157fb4c97b6562ab91.png" alt="Cuadro 6"></div><br>  Este art√≠culo revisa los resultados de una segunda verificaci√≥n del proyecto Orchard con el analizador est√°tico PVS-Studio.  Orchard es un sistema de gesti√≥n de contenido de c√≥digo abierto que se entrega como parte de la Galer√≠a de c√≥digo abierto ASP.NET bajo la Fundaci√≥n sin fines de lucro Outercurve.  La verificaci√≥n de hoy es especialmente interesante porque tanto el proyecto como el analizador han recorrido un largo camino desde la primera verificaci√≥n, y esta vez veremos nuevos mensajes de diagn√≥stico y algunos errores agradables. <br><a name="habracut"></a><br>  <b>Sobre Orchard CMS</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Verificamos</a> Orchard hace tres a√±os.  El analizador C # de PVS-Studio ha evolucionado enormemente desde entonces: hemos mejorado el an√°lisis del flujo de datos, agregado an√°lisis interprocedimiento y nuevos diagn√≥sticos, y corregido una serie de falsos positivos.  M√°s que eso, la segunda verificaci√≥n revel√≥ que los desarrolladores de Orchard hab√≠an reparado todos los errores reportados en el primer art√≠culo, lo que significa que hab√≠amos logrado nuestro objetivo, es decir, les hab√≠amos mejorado su c√≥digo. <br><br>  Espero que tambi√©n presten atenci√≥n a este art√≠culo y hagan las correcciones necesarias o, mejor a√∫n, adopten PVS-Studio para su uso regular.  Como recordatorio, ofrecemos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los</a> desarrolladores de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo abierto</a> una licencia gratuita.  Por cierto, hay otras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">opciones</a> que los proyectos propietarios tambi√©n pueden disfrutar. <br><br>  El c√≥digo fuente de Orchard est√° disponible para descargar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  La descripci√≥n completa del proyecto se encuentra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Si a√∫n no tiene una copia de PVS-Studio, puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descargar</a> la versi√≥n de prueba.  Utilic√© PVS-Studio 7.05 Beta e incluir√© algunas de sus advertencias en este art√≠culo.  Espero que esta revisi√≥n te convenza de que PVS-Studio es una herramienta √∫til.  Solo tenga en cuenta que est√° destinado a ser utilizado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">regularmente</a> . <br><br>  <b>Resultados de analisis</b> <br><br>  Estas son algunas de las cifras de la primera verificaci√≥n de Orchard para que no tenga que cambiar entre los dos art√≠culos para comparar. <br><br>  Durante la verificaci√≥n anterior, "hicimos el an√°lisis de todos los archivos de c√≥digo fuente (3739 elementos) con la extensi√≥n .cs.  En total, hab√≠a 214.564 l√≠neas de c√≥digo.  El resultado del control fue 137 advertencias.  Para ser m√°s precisos, hubo 39 advertencias de primer nivel (alto).  Tambi√©n hubo 60 advertencias de segundo nivel (medio) ". <br><br>  La versi√≥n actual de Orchard est√° compuesta por 2.767 archivos .cs, es decir, es aproximadamente mil archivos m√°s peque√±os.  La reducci√≥n y cambio de nombre del repositorio sugiere que los desarrolladores han aislado el n√∫cleo del proyecto ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">commit 966</a> ), que tiene 108,287 LOC de largo.  El analizador emiti√≥ 153 advertencias: 33 de primer nivel y 70 de segundo nivel.  Por lo general, no incluimos advertencias de tercer nivel, y voy a seguir con la tradici√≥n. <br><br>  <b>Mensaje de diagn√≥stico de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3110</a> Posible recursi√≥n infinita dentro del m√©todo 'TryValidateModel'.  PrefixedModuleUpdater.cs 48 <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryValidateModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> model, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> prefix</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TryValidateModel(model, Prefix(prefix)); }</code> </pre> <br>  Comencemos con un error de recursi√≥n infinita, como hicimos en el primer art√≠culo.  Esta vez, las intenciones exactas del desarrollador no est√°n claras, pero not√© que el m√©todo <i>TryValidateModel</i> ten√≠a una versi√≥n sobrecargada con un par√°metro: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryValidateModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> model</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _updateModel.TryValidateModel(model); }</code> </pre> <br>  Creo que, al igual que en el caso de la versi√≥n sobrecargada, el desarrollador pretend√≠a llamar al m√©todo a trav√©s de <i>_updateModel.</i>  El compilador no not√≥ el error;  <i>_updateModel</i> es de tipo <i>IUpdateModel</i> , y la clase actual tambi√©n implementa esta interfaz.  Dado que el m√©todo no incluye ninguna verificaci√≥n contra <i>StackOverflowException</i> , probablemente nunca se llam√≥, aunque no contar√≠a con eso.  Si mi suposici√≥n es correcta, la versi√≥n fija deber√≠a verse as√≠: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryValidateModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> model, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> prefix</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _updateModel.TryValidateModel(model, Prefix(prefix)); }</code> </pre> <br>  <b>Mensaje de diagn√≥stico de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3008</a> A la variable 'contenido' se le asignan valores dos veces seguidas.  Quiz√°s esto sea un error.  L√≠neas de verificaci√≥n: 197, 190. DynamicCacheTagHelper.cs 197 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... IHtmlContent content; .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { content = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> output.GetChildContentAsync(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { _cacheScopeManager.ExitScope(); } content = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ProcessContentAsync(output, cacheContext); .... }</code> </pre> <br>  El analizador detect√≥ dos asignaciones al <i>contenido de la</i> variable local <i>.</i>  <i>GetChildContentAsync</i> es un m√©todo de biblioteca que se usa muy raramente para que nos tomemos la molestia de examinarlo y anotarlo.  Entonces, me temo que ni nosotros ni el analizador sabemos nada sobre el objeto de retorno del m√©todo y los efectos secundarios.  Pero sabemos con certeza que asignar el valor de retorno al <i>contenido</i> no tiene sentido si no se usa m√°s en el c√≥digo.  Quiz√°s es solo una operaci√≥n redundante en lugar de un error.  No puedo decir c√≥mo se debe solucionar esto, as√≠ que se lo dejo a los desarrolladores. <br><br>  <b>Mensaje de diagn√≥stico de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3080</a> Posible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anulaci√≥n de</a> referencia.  Considere inspeccionar 'itemTag'.  CoreShapes.cs 92 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;IHtmlContent&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">List</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ItemTag....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> itemTagName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ItemTag != <span class="hljs-string"><span class="hljs-string">"-"</span></span>) { itemTagName = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(ItemTag) ? <span class="hljs-string"><span class="hljs-string">"li"</span></span> : ItemTag; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> itemTag = String.IsNullOrEmpty(itemTagName) ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : ....; .... itemTag.InnerHtml.AppendHtml(itemContent); listTag.InnerHtml.AppendHtml(itemTag); ++index; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listTag; }</code> </pre> <br>  El analizador detect√≥ una desreferencia insegura de <i>itemTag</i> .  Este fragmento es un buen ejemplo de c√≥mo una herramienta de an√°lisis est√°tico es diferente de un desarrollador humano que realiza una revisi√≥n de c√≥digo.  El m√©todo tiene un par√°metro llamado <i>ItemTag</i> y una variable local llamada <i>itemTag</i> .  ¬°No es necesario decirte que hace una gran diferencia para el compilador!  Estas son dos variables diferentes, aunque relacionadas.  La forma en que se relacionan es a trav√©s de una tercera variable, <i>itemTagName.</i>  Aqu√≠ est√° la secuencia de pasos que conducen a la posible excepci√≥n: si el argumento <i>ItemTag</i> es igual a "-", no se asignar√° ning√∫n valor a <i>itemTagName</i> , por lo que seguir√° siendo una referencia nula, y si es una referencia nula, entonces la variable local <i>itemTag</i> se convertir√° en una referencia nula tambi√©n.  En mi opini√≥n, es mejor lanzar una excepci√≥n despu√©s de la verificaci√≥n de la cadena. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;IHtmlContent&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">List</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ItemTag....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> itemTagName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ItemTag != <span class="hljs-string"><span class="hljs-string">"-"</span></span>) { itemTagName = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(ItemTag) ? <span class="hljs-string"><span class="hljs-string">"li"</span></span> : ItemTag; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> itemTag = ....; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(String.IsNullOrEmpty(itemTag)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> .... .... itemTag.InnerHtml.AppendHtml(itemContent); listTag.InnerHtml.AppendHtml(itemTag); ++index; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listTag; }</code> </pre> <br>  <b>Mensaje de diagn√≥stico de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3095</a> El objeto 'remoteClient' se us√≥ antes de que se verificara como nulo.  Verifique las l√≠neas: 49, 51. ImportRemoteInstanceController.cs 49 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;IActionResult&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Import</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ImportViewModel model</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> remoteClient = remoteClientList.RemoteClients.FirstOrDefault(....); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> apiKey = Encoding.UTF8.GetString(....(remoteClient.ProtectedApiKey)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remoteClient == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || ....) { .... } .... }</code> </pre> <br>  El analizador detect√≥ una desreferencia de <i>remoteClient</i> seguido de una verificaci√≥n nula un par de l√≠neas m√°s tarde.  De hecho, esta es una potencial <i>NullReferenceException</i> ya que el m√©todo <i>FirstOrDefault</i> puede devolver un valor predeterminado (que es <i>nulo</i> para los tipos de referencia).  Supongo que este fragmento se puede solucionar simplemente moviendo el cheque hacia arriba para que sea anterior a la operaci√≥n de desreferenciaci√≥n: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;IActionResult&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Import</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ImportViewModel model</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> remoteClient = remoteClientList.RemoteClients.FirstOrDefault(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remoteClient != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> apiKey = UTF8.GetString(....remoteClient.ProtectedApiKey); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... } .... }</code> </pre> <br>  O tal vez deber√≠a solucionarse reemplazando <i>FirstOrDefault</i> con <i>First</i> y eliminando la comprobaci√≥n por completo. <br><br>  <b>Advertencias de PVS-Studio 7.05 Beta:</b> <br><br>  Por ahora, hemos anotado todos los m√©todos de <i>LINQ</i> o <i>predeterminados</i> .  Esta informaci√≥n ser√° utilizada por el nuevo diagn√≥stico en el que estamos trabajando: detecta casos en los que los valores devueltos por estos m√©todos se desreferencian sin una verificaci√≥n previa.  Cada m√©todo <i>orDefault</i> tiene una contraparte que <i>genera</i> una excepci√≥n si no se ha encontrado ning√∫n elemento coincidente.  Esta excepci√≥n ser√° m√°s √∫til para rastrear el problema que la excepci√≥n <i>NullReferenceException</i> abstracta. <br><br>  No puedo dejar de compartir los resultados que obtuve de este diagn√≥stico en el proyecto Orchard.  Hay 27 puntos potencialmente peligrosos.  Aqu√≠ hay algunos de ellos: <br><br>  ContentTypesAdminNodeNavigationBuilder.cs 71: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> treeBuilder = treeNodeBuilders.Where(....).FirstOrDefault(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> treeBuilder.BuildNavigationAsync(childNode, builder, treeNodeBuilders);</code> </pre> <br>  ListPartDisplayDriver.cs 217: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentTypePartDefinition = ....Parts.FirstOrDefault(....); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contentTypePartDefinition.Settings....;</code> </pre> <br>  ContentTypesAdminNodeNavigationBuilder.cs 113: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> typeEntry = node.ContentTypes.Where(....).FirstOrDefault(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AddPrefixToClasses(typeEntry.IconClass);</code> </pre> <br>  <b>Mensaje de diagn√≥stico de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3080</a> Posible desreferencia nula del valor de retorno del m√©todo.  Considere inspeccionar: CreateScope ().  SetupService.cs 136 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetupInternalAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SetupContext context</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shellContext = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ....) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> shellContext.CreateScope().UsingAsync(....); } .... }</code> </pre> <br>  El analizador mencion√≥ una desreferencia del valor devuelto por el m√©todo <i>CreateScope</i> .  <i>CreateScope</i> es un m√©todo peque√±o, as√≠ que aqu√≠ est√° su implementaci√≥n completa: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ShellScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateScope</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_placeHolder) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ShellScope(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-comment"><span class="hljs-comment">// A new scope can be only used on a non released shell. if (!released) { return scope; } scope.Dispose(); return null; }</span></span></code> </pre> <br>  Como puede ver, hay dos casos en los que puede devolver <i>nulo</i> .  El analizador no sabe a qu√© rama seguir√° el flujo de ejecuci√≥n, por lo que es seguro e informa que el c√≥digo es sospechoso.  Si tuviera que escribir un c√≥digo como ese, escribir√≠a un cheque nulo de inmediato. <br><br>  Quiz√°s mi opini√≥n es parcial, pero creo que todos los m√©todos asincr√≥nicos deber√≠an estar protegidos de <i>NullReferenceException</i> tanto como sea posible porque la depuraci√≥n de este tipo de cosas est√° lejos de ser agradable. <br><br>  En este caso particular, el m√©todo <i>CreateScope</i> se llama cuatro veces: dos de esas llamadas van acompa√±adas de controles y las otras dos no.  Las √∫ltimas dos llamadas (sin controles) parecen ser clones de copiar y pegar (misma clase, mismo m√©todo, la misma forma de desreferenciar el resultado para llamar a UsingAsync).  La primera de esas dos llamadas se mostr√≥ arriba, y puede estar seguro de que la segunda activ√≥ la misma advertencia: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3080</a> Posible desreferencia nula del valor de retorno del m√©todo.  Considere inspeccionar: CreateScope ().  SetupService.cs 192 <br><br>  <b>Mensaje de diagn√≥stico de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3127</a> Se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">encontraron</a> dos fragmentos de c√≥digo similares.  Quiz√°s, este es un error tipogr√°fico y se debe usar la variable 'AccessTokenSecret' en lugar de 'ConsumerSecret' TwitterClientMessageHandler.cs 52 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureOAuthAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpRequestMessage request</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(settings.ConsumerSecret)) settings.ConsumerSecret = protrector.Unprotect(settings.ConsumerSecret); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(settings.ConsumerSecret)) settings.AccessTokenSecret = protrector.Unprotect(settings.AccessTokenSecret); .... }</code> </pre> <br>  Ese es un error cl√°sico de copiar y pegar.  <i>ConsumerSecret</i> se verific√≥ dos veces, mientras que <i>AccessTokenSecret</i> no se verific√≥ en absoluto.  Obviamente, esto se arregla de la siguiente manera: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureOAuthAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpRequestMessage request</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(settings.ConsumerSecret)) settings.ConsumerSecret = protrector.Unprotect(settings.ConsumerSecret); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(settings.AccessTokenSecret)) settings.AccessTokenSecret = protrector.Unprotect(settings.AccessTokenSecret); .... }</code> </pre> <br>  <b>Mensaje de diagn√≥stico de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3139</a> Dos o m√°s ramificaciones de casos realizan las mismas acciones.  SerialDocumentExecuter.cs 23 <br><br>  Otro error de copiar y pegar.  Para mayor claridad, aqu√≠ est√° la implementaci√≥n completa de la clase (es peque√±a). <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SerialDocumentExecuter</span></span> : <span class="hljs-title"><span class="hljs-title">DocumentExecuter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IExecutionStrategy ParallelExecutionStrategy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ParallelExecutionStrategy(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IExecutionStrategy SerialExecutionStrategy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerialExecutionStrategy(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IExecutionStrategy SubscriptionExecutionStrategy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SubscriptionExecutionStrategy(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IExecutionStrategy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectExecutionStrategy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (context.Operation.OperationType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Query: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SerialExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Mutation: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SerialExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Subscription: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SubscriptionExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; } } }</code> </pre> <br>  Al analizador no le gustaron las dos ramas de <i>caso</i> id√©nticas.  De hecho, la clase tiene tres entidades, mientras que la instrucci√≥n switch solo devuelve dos de ellas.  Si se pretende este comportamiento y la tercera entidad no est√° destinada a ser utilizada, el c√≥digo puede mejorarse eliminando la tercera rama que los fusion√≥ de la siguiente manera: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (context.Operation.OperationType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Query: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Mutation: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SerialExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Subscription: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SubscriptionExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; }</code> </pre> <br>  Si se trata de un error de copiar y pegar, el primero de los campos de retorno duplicados debe repararse de la siguiente manera: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (context.Operation.OperationType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Query: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParallelExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Mutation: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SerialExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Subscription: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SubscriptionExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; }</code> </pre> <br>  O deber√≠a ser la segunda rama del caso.  No conozco los detalles del proyecto y, por lo tanto, no puedo determinar la correlaci√≥n entre los nombres de los tipos y estrategias de operaci√≥n. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (context.Operation.OperationType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Query: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SerialExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Mutation: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParallelExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OperationType.Subscription: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SubscriptionExecutionStrategy; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; }</code> </pre> <br>  <b>Mensaje de diagn√≥stico de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3080</a> Posible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anulaci√≥n de</a> referencia.  Considere inspeccionar 'solicitud'.  GraphQLMiddleware.cs 148 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpContext context....</span></span></span><span class="hljs-function">)</span></span> { .... GraphQLRequest request = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HttpMethods.IsPost(context.Request.Method)) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HttpMethods.IsGet(context.Request.Method)) { .... request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQLRequest(); .... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> queryToExecute = request.Query; .... }</code> </pre> <br>  A la variable de <i>solicitud</i> se le asigna un valor diferente de <i>nulo</i> varias veces en el primer bloque <i>if</i> , pero cada vez con condiciones anidadas.  La inclusi√≥n de todas esas condiciones har√≠a que el ejemplo fuera demasiado largo, por lo que solo veremos las primeras, que verifican el tipo de m√©todo http <i>IsGet</i> o <i>IsPost</i> .  La clase <i>Microsoft.AspNetCore.Http.HttpMethods</i> tiene nueve m√©todos est√°ticos para verificar el tipo de consulta.  Por lo tanto, pasar, por ejemplo, una consulta <i>Eliminar</i> o <i>Establecer</i> al m√©todo <i>ExecuteAsync</i> conducir√≠a a generar una <i>NullReferenceException</i> .  Incluso si dichos m√©todos no son compatibles actualmente, ser√≠a aconsejable agregar un cheque de excepci√≥n.  Despu√©s de todo, los requisitos del sistema pueden cambiar.  Aqu√≠ hay un ejemplo de tal verificaci√≥n: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HttpContext context....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (request == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> queryToExecute = request.Query; .... }</code> </pre> <br>  <b>Mensaje de diagn√≥stico de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3080</a> Posible desreferencia nula del valor de retorno del m√©todo.  Considere inspeccionar: Obtenga &lt;ContentPart&gt; (...).  ContentPartHandlerCoordinator.cs 190 <br><br>  La mayor√≠a de las advertencias del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3080</a> son m√°s convenientes para ver dentro del entorno de desarrollo porque necesita la navegaci√≥n del m√©todo, el resaltado de tipo y la atm√≥sfera amigable del IDE.  Estoy tratando de reducir el texto de los ejemplos tanto como sea posible para mantenerlos legibles.  Pero si no lo estoy haciendo bien o si quieres probar tu habilidad de programaci√≥n y resolverlo por ti mismo, te recomiendo ver el resultado de este diagn√≥stico en cualquier proyecto de c√≥digo abierto o simplemente en tu propio c√≥digo. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadingAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">LoadContentContext context</span></span></span><span class="hljs-function">)</span></span> { .... context.ContentItem.Get&lt;ContentPart&gt;(typePartDefinition.Name) .Weld(fieldName, fieldActivator.CreateInstance()); .... }</code> </pre> <br>  El analizador informa esta l√≠nea.  Echemos un vistazo al m√©todo <i>Get</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> TElement Get&lt;TElement&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ContentElement contentElement....) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TElement : ContentElement { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (TElement)contentElement.Get(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TElement), name); }</code> </pre> <br>  Llama a su versi√≥n sobrecargada.  Vamos a verlo tambi√©n: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ContentElement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ContentElement contentElement....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementData = contentElement.Data[name] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> JObject; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elementData == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } .... }</code> </pre> <br>  Resulta que si obtenemos una entidad de un tipo incompatible con <i>JObject</i> de <i>datos</i> usando el indexador de <i>nombres</i> , el m√©todo <i>Get</i> devolver√° <i>nulo</i> .  No estoy seguro de qu√© tan probable es eso porque estos tipos son de la biblioteca <i>Newtonsoft.Json</i> , con la que no he trabajado mucho.  Pero el autor del c√≥digo sospechaba que el elemento buscado podr√≠a no existir, por lo que tambi√©n debemos tenerlo en cuenta al acceder al resultado de la operaci√≥n de lectura.  Personalmente, tendr√≠a una excepci√≥n lanzada en el primer <i>Get</i> si creemos que el nodo debe estar presente, o agregar una marca antes de la desreferencia si la inexistencia del nodo no cambia la l√≥gica general (por ejemplo, obtenemos un valor predeterminado). <br><br>  Soluci√≥n 1: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ContentElement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ContentElement contentElement....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementData = contentElement.Data[name] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> JObject; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elementData == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>.... } .... }</code> </pre> <br>  Soluci√≥n 2: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadingAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">LoadContentContext context</span></span></span><span class="hljs-function">)</span></span> { .... context.ContentItem.Get&lt;ContentPart&gt;(typePartDefinition.Name) ?.Weld(fieldName, fieldActivator.CreateInstance()); .... }</code> </pre> <br>  <b>Mensaje de diagn√≥stico de PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V3080</a> Posible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anulaci√≥n de</a> referencia.  Considere inspeccionar los "resultados".  ContentQueryOrchardRazorHelperExtensions.cs 19 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;IEnumerable&lt;ContentItem&gt;&gt; ContentQueryAsync(....) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> results = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> orchardHelper.QueryAsync(queryName, parameters); .... <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> results) { .... } .... }</code> </pre> <br>  Este es un ejemplo bastante simple en comparaci√≥n con el anterior.  El analizador sospecha que el m√©todo <i>QueryAsync</i> podr√≠a devolver una referencia nula.  Aqu√≠ est√° la implementaci√≥n del m√©todo: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;IEnumerable&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QueryAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">....</span></span></span><span class="hljs-function">)</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> query = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> queryManager.GetQueryAsync(queryName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (query == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } .... }</code> </pre> <br>  Dado que <i>GetQueryAsync</i> es un m√©todo de interfaz, no puede estar seguro de cada implementaci√≥n, especialmente si consideramos que el proyecto tambi√©n incluye la siguiente versi√≥n: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Query&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetQueryAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> document = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> GetDocumentAsync(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(document.Queries.TryGetValue(name, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> query)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> query; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Las m√∫ltiples llamadas a funciones externas y accesos a la memoria cach√© dificultan el an√°lisis de <i>GetDocumentAsync</i> , as√≠ que digamos que la verificaci√≥n es necesaria, sobre todo porque el m√©todo es asincr√≥nico. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;IEnumerable&lt;ContentItem&gt;&gt; ContentQueryAsync(....) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> results = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> orchardHelper.QueryAsync(queryName, parameters); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(results == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; .... <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> results) { .... } .... }</code> </pre> <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41f/fb1/e08/41ffb1e086795cd7ba94b22ed53ce33c.png" alt="Cuadro 14"></div><br><br>  <b>Conclusi√≥n</b> <br><br>  ¬°No puedo dejar de mencionar la alta calidad del c√≥digo de Orchard!  Es cierto que hubo otros defectos, que no discut√≠ aqu√≠, pero le mostr√© todos los errores m√°s graves.  Por supuesto, esto no quiere decir que verificar su c√≥digo fuente una vez cada tres a√±os sea suficiente.  Obtendr√° el m√°ximo rendimiento del an√°lisis est√°tico si lo usa con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">regularidad</a> porque esta es la forma en que se garantiza que detectar√° y corregir√° errores en las primeras etapas de desarrollo, donde la correcci√≥n de errores es m√°s barata y f√°cil. <br><br>  Aunque las comprobaciones √∫nicas no ayudan mucho, todav√≠a le recomiendo que descargue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PVS-Studio</a> y lo pruebe en su proyecto: qui√©n sabe, tal vez tambi√©n encuentre algunos errores interesantes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472360/">https://habr.com/ru/post/472360/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472350/index.html">C√≥mo Methodius se convirti√≥ en Anna: la experiencia de desarrollar y lanzar clasificadores de mensajes de voz. Parte 1</a></li>
<li><a href="../472352/index.html">TechnoText, episodio II. Contamos c√≥mo viven y trabajan los autores de Habr en art√≠culos</a></li>
<li><a href="../472354/index.html">Entre la silla y el monitor se encuentra la principal vulnerabilidad en el sistema: VAP-person</a></li>
<li><a href="../472356/index.html">Microsoft vs IBM: cambios importantes en el soporte de Java</a></li>
<li><a href="../472358/index.html">30 de octubre a las 17:00 seminario web "Implemente el cl√∫ster de Kubernetes en una hora en la nube CROC"</a></li>
<li><a href="../472362/index.html">Buscamos y analizamos errores en el c√≥digo Orchard CMS</a></li>
<li><a href="../472364/index.html">PostgreSQL y configuraci√≥n de consistencia de registro para cada conexi√≥n particular</a></li>
<li><a href="../472366/index.html">Nuevo algoritmo de Path Finder en Factorio</a></li>
<li><a href="../472368/index.html">Speech fishing: analizamos los m√©todos de ataque y los m√©todos de protecci√≥n contra ellos.</a></li>
<li><a href="../472372/index.html">Automatizaci√≥n de Android Gu√≠a s√∫per f√°cil para crear tu primera prueba de Espresso</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>