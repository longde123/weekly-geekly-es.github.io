<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏾 🧗 👨🏻‍🚀 Bagaimana porting game ke PSVita meningkatkan kinerja secara keseluruhan 👩🏽‍⚖️ 🤞🏻 💹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di level bisa ribuan musuh. 

 Quest Defender: Valley of the Forgotten DX selalu memiliki masalah lama dengan kecepatan, dan saya akhirnya berhasil me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana porting game ke PSVita meningkatkan kinerja secara keseluruhan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414135/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/937/148/2a1/9371482a13b17c628afe9e994e6df76f.jpg" alt="gambar"></div><br>  <i>Di level bisa ribuan musuh.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Quest Defender: Valley of the Forgotten DX</a> selalu memiliki masalah lama dengan kecepatan, dan saya akhirnya berhasil menyelesaikannya.  Insentif utama untuk peningkatan kecepatan besar-besaran adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">port</a> kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di PlayStation Vita</a> .  Gim ini sudah dirilis pada PC dan bekerja dengan baik, jika tidak sempurna, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Xbox One</a> dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PS4</a> .  Tetapi tanpa perbaikan besar pada game, kami tidak akan pernah bisa meluncurkannya di Vita. <br><br>  Ketika sebuah permainan melambat, komentator di Internet biasanya menyalahkan bahasa pemrograman atau mesin.  Memang benar bahwa bahasa seperti C # dan Java lebih mahal daripada C dan C ++, dan alat-alat seperti Unity memiliki masalah yang tidak dapat dipecahkan, seperti pengumpulan sampah.  Bahkan, orang-orang datang dengan penjelasan seperti itu karena bahasa dan mesin adalah sifat paling jelas dari perangkat lunak.  Tapi pembunuh kinerja sejati mungkin detail kecil yang bodoh yang tidak ada hubungannya dengan arsitektur. <br><a name="habracut"></a><br><h1>  0. Alat Pembuatan Profil </h1><br>  Hanya ada satu cara nyata untuk membuat game lebih cepat - untuk melakukan profiling.  Cari tahu apa yang menghabiskan terlalu banyak waktu di komputer dan membuatnya menghabiskan lebih sedikit waktu di atasnya, atau bahkan lebih baik, membuatnya tidak membuang waktu <em>sama sekali</em> . <br><br>  Alat profiling paling sederhana adalah monitor sistem Windows standar (monitor kinerja): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea3/b29/a69/ea3b29a690d6fe0ce9c6014abb6a9a62.png"></div><br>  Sebenarnya, ini adalah alat yang cukup fleksibel dan sangat mudah digunakan.  Cukup tekan Ctrl + Alt + Delete, buka "Task Manager" dan klik pada tab "Performance".  Namun, jangan menjalankan terlalu banyak program lain.  Jika Anda perhatikan lebih dekat, Anda dapat dengan mudah mendeteksi puncak dalam penggunaan CPU dan bahkan kebocoran memori.  Ini adalah cara yang tidak informatif, tetapi mungkin ini adalah langkah pertama dalam menemukan tempat yang lambat. <br><br>  Quest Defender ditulis dalam bahasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Haxe</a> tingkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tinggi</a> yang dikompilasi ke dalam bahasa lain (target utama saya adalah C ++).  Ini berarti bahwa alat apa pun yang mampu membuat profil C ++ juga dapat membuat profil kode C ++ Haxe yang saya hasilkan.  Jadi ketika saya ingin memahami penyebab masalah, saya meluncurkan Performance Explorer dari Visual Studio: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/999/a24/932/999a24932b41cd329e28bcb6c5076725.png"></div><br>  Selain itu, konsol yang berbeda memiliki alat profil mereka sendiri, yang sangat nyaman, tetapi karena NDA saya tidak dapat memberi tahu Anda tentang mereka.  Tetapi jika Anda memiliki akses ke mereka, tetapi pastikan untuk menggunakannya! <br><br>  Alih-alih menulis tutorial yang mengerikan tentang cara menggunakan alat profiling seperti Performance Explorer, saya hanya meninggalkan tautan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi</a> dan beralih ke topik utama - hal-hal menakjubkan yang menyebabkan peningkatan besar dalam produktivitas, dan bagaimana saya berhasil menemukannya ! <br><br><h1>  1. Deteksi Masalah </h1><br>  Kinerja game tidak hanya kecepatan itu sendiri, tetapi juga persepsinya.  Defender's Quest adalah game bergenre menara pertahanan yang dirender pada 60 FPS, tetapi dengan kecepatan gameplay bervariasi mulai dari 1 / 4x hingga 16x.  Terlepas dari kecepatan game, simulasi menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cap waktu tetap</a> dengan 60 pembaruan per detik dari waktu simulasi 1x.  Artinya, jika Anda menjalankan game dengan kecepatan 16x, maka logika pembaruan akan benar-benar bekerja dengan frekuensi <em>960 FPS</em> .  Jujur saja, ini permintaan terlalu tinggi untuk game!  Tapi akulah yang menciptakan mode ini, dan jika ternyata lambat, maka para pemain pasti akan menyadarinya. <br><br>  Dan di dalam game ada level <em>seperti itu</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed9/5e1/694/ed95e16941a18fe9a71b7333d537f1d9.png"></div><br>  Ini adalah pertempuran bonus terakhir "Endless 2", ini juga "mimpi buruk pribadi saya."  Tangkapan layar diambil dalam mode Game + Baru, di mana musuh tidak hanya jauh lebih kuat, tetapi juga memiliki fitur seperti memulihkan kesehatan.  Strategi favorit pemain di sini adalah untuk memompa naga ke tingkat Roar maksimum (serangan AOE yang membuat musuh tertegun), dan di belakang mereka taruh sejumlah ksatria dengan Knockback dipompa semaksimal mungkin untuk mendorong semua orang yang melewati naga kembali ke area aksi mereka.  Efek kumulatifnya adalah bahwa sekelompok besar monster tanpa henti tinggal di satu tempat, lebih lama daripada para pemain harus bertahan hidup jika mereka benar-benar membunuh mereka.  Karena pemain harus <em>menunggu</em> ombak dan tidak <em>membunuh</em> mereka untuk menerima hadiah dan prestasi, strategi seperti itu sangat efektif dan brilian - ini persis perilaku pemain yang saya distimulasi. <br><br>  Sayangnya, ini juga ternyata menjadi kasus <em>patologis</em> untuk kinerja, <em>terutama</em> ketika pemain ingin bermain dengan kecepatan 16x atau 8x.  Tentu saja, hanya pemain yang paling hardcore yang akan mencoba untuk mendapatkan pencapaian "Hundredth Wave" di Game Baru + di level Endless 2, tetapi mereka hanya mereka yang berbicara permainan paling keras, jadi saya ingin mereka bahagia. <br><br>  Ini hanya permainan 2D dengan banyak sprite, apa yang salah dengan itu? <br><br>  Dan memang.  Mari kita perbaiki. <br><br><h1>  2. Resolusi Tabrakan </h1><br>  Lihatlah screenshot ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/098/bd2/116/098bd2116180a0b3ea3c9a66339b7fa3.png"></div><br>  Lihat bagel ini di sekitar ranger?  Ini adalah area dampaknya - perhatikan bahwa ada juga zona mati yang tidak <em>dapat</em> mencapai target.  Setiap kelas memiliki area serangannya sendiri, dan setiap pemain bertahan memiliki area ukuran yang berbeda, tergantung pada tingkat dorongan dan parameter pribadi.  Dan setiap bek dalam teori dapat membidik musuh apa pun di bidang jangkauannya.  Hal yang sama berlaku untuk musuh jenis tertentu.  Mungkin ada 36 pembela di peta (tidak termasuk karakter utama Azru), tetapi tidak ada batas atas pada jumlah musuh.  Setiap bek dan musuh memiliki daftar target yang mungkin, dibuat berdasarkan panggilan untuk memeriksa area pada setiap langkah pembaruan (minus cut-off logis dari mereka yang tidak dapat menyerang saat ini, dan sebagainya). <br><br>  Saat ini, prosesor video sangat cepat - jika Anda tidak terlalu memaksakannya, maka mereka dapat memproses hampir semua jumlah poligon.  Tetapi bahkan CPU tercepat pun sangat mudah memiliki “bottleneck” dalam prosedur sederhana, terutama yang tumbuh secara eksponensial.  Itu sebabnya permainan 2D bisa menjadi lebih lambat daripada permainan 3D yang jauh lebih indah - bukan karena programmer tidak bisa mengatasinya (mungkin ini juga, setidaknya dalam kasus saya), tetapi pada prinsipnya karena logika kadang-kadang bisa lebih mahal, dari menggambar!  Pertanyaannya bukan berapa banyak objek yang ada di layar, tetapi apa yang mereka <em>lakukan</em> . <br><br>  Mari menjelajahi dan mempercepat pengenalan tabrakan.  Sebagai perbandingan, saya akan mengatakan bahwa sebelum optimasi, pengenalan tabrakan memakan waktu hingga ~ 50% dari waktu CPU dalam siklus pertempuran utama.  Setelah optimasi, kurang dari 5%. <br><br><h2>  Ini semua tentang pohon kuadran </h2><br>  Solusi utama untuk masalah pengenalan tabrakan lambat adalah dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membagi ruang</a> - dan sejak awal kami menggunakan implementasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pohon kuadran yang</a> berkualitas tinggi.  Pada dasarnya, ini secara efektif memisahkan ruang sehingga banyak pemeriksaan tabrakan opsional dapat dilewati. <br><br>  Di setiap frame, kami memperbarui seluruh pohon kuadran (QuadTree) untuk melacak posisi setiap objek, dan ketika musuh atau pembela ingin membidik seseorang, ia meminta QuadTree untuk daftar objek terdekat.  Tetapi profiler memberi tahu kami bahwa kedua operasi ini jauh lebih lambat dari yang seharusnya. <br><br>  Apa yang salah di sini? <br><br>  Ternyata - banyak. <br><br><h2>  Mengetik string </h2><br>  Karena saya menyimpan musuh dan pembela di satu pohon kuadran, saya harus menunjukkan apa yang saya cari, dan ini dilakukan seperti ini: <br><br> <code>var things:Array&lt;XY&gt; = _qtree.queryRange(zone.bounds, "e"); //"e" -   "enemy"</code> <br> <br>  Dalam jargon programmer, ini disebut kode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengetikan string</a> , dan, di antara alasan lain, ini buruk karena perbandingan string selalu lebih lambat daripada perbandingan integer. <br><br>  Saya segera mengambil konstanta integer dan mengganti kode dengan ini: <br><br> <code>var things:Array&lt;XY&gt; = _qtree.queryRange(zone.bounds, QuadTree.ENEMY);</code> <br> <br>  (Ya, mungkin layak menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Enum Abstract</a> untuk keamanan tipe maksimum, tapi saya sedang terburu-buru, dan saya perlu melakukan pekerjaan terlebih dahulu.) <br><br>  Perubahan ini sendiri memberikan kontribusi yang <em>sangat besar</em> , karena fungsi ini disebut <em>terus</em> - <em>menerus</em> dan secara rekursif, setiap kali seseorang membutuhkan daftar tujuan yang baru. <br><br><h2>  Array vs Vektor </h2><br>  Lihatlah ini: <br><br> <code>var things:Array&lt;XY&gt;</code> <br> <br>  Array Haxe sangat mirip dengan array ActionScript dan JS karena mereka adalah kumpulan objek yang dapat diubah ukurannya, tetapi di Haxe mereka sangat diketik. <br><br>  Namun, ada struktur data lain yang lebih efisien dengan bahasa target statis seperti cpp, yaitu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">haxe.ds.Vector</a> .  Vektor Haxe pada dasarnya sama dengan array, kecuali ketika mereka dibuat mereka mendapatkan ukuran tetap. <br><br>  Karena pohon kuadran saya sudah memiliki volume yang tetap, saya mengganti array dengan vektor untuk mencapai peningkatan kecepatan yang nyata. <br><br><h2>  Minta hanya apa yang Anda butuhkan </h2><br>  Sebelumnya, fungsi <code>queryRange</code> saya mengembalikan daftar objek, instance <code>XY</code> .  Mereka berisi koordinat x / y dari objek game yang direferensikan dan pengenal bilangan bulatnya yang unik (indeks pencarian di larik utama).  Objek game yang mengeksekusi permintaan menerima XY ini, mengekstraksi pengidentifikasi integer untuk mendapatkan targetnya, dan kemudian melupakan sisanya. <br><br>  Jadi mengapa saya harus meneruskan semua referensi ini ke objek XY untuk setiap node QuadTree <em>secara rekursif</em> , dan bahkan <em>960 kali per frame?</em>  Cukup bagi saya untuk mengembalikan daftar pengidentifikasi bilangan bulat. <br><br>  <strong><em>PETUNJUK PROFESIONAL: bilangan bulat jauh lebih cepat untuk dikirim daripada hampir semua tipe data lainnya!</em></strong> <br><br>  Dibandingkan dengan koreksi lain, ini cukup sederhana, tetapi pertumbuhan kinerja masih terlihat, karena loop internal ini digunakan dengan sangat aktif. <br><br><h2>  Optimasi rekursi ekor </h2><br>  Ada hal yang elegan yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">optimasi Tail-call</a> .  Sulit untuk dijelaskan, jadi saya akan menunjukkan kepada Anda sebuah contoh. <br><br>  Itu: <br><br> <code>nw.queryRange(Range, -1, result); <br> ne.queryRange(Range, -1, result); <br> sw.queryRange(Range, -1, result); <br> se.queryRange(Range, -1, result); <br> return result;</code> <br> <br>  Itu menjadi: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> se.queryRange(Range, <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>, sw.queryRange(Range, <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>, ne.queryRange(Range, <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>, nw.queryRange(Range, <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>, result))));</code> </pre> <br>  Kode mengembalikan hasil logis yang sama, tetapi menurut profiler, opsi kedua lebih cepat, setidaknya ketika menerjemahkan ke cpp.  Kedua contoh melakukan logika yang persis sama - mereka membuat perubahan pada struktur data "hasil" dan meneruskannya ke fungsi berikutnya sebelum kembali.  Ketika kita melakukan ini secara rekursif, kita dapat menghindari kompiler yang menghasilkan referensi sementara, karena ia dapat langsung mengembalikan hasil dari fungsi sebelumnya, daripada menempel padanya dalam langkah tambahan.  Atau sesuatu seperti itu.  Saya tidak sepenuhnya mengerti cara kerjanya, jadi baca posting di tautan di atas. <br><br>  (Menilai dari apa yang saya ketahui, versi saat ini dari kompiler Haxe tidak memiliki fungsi optimisasi rekursi ekor, yaitu, mungkin merupakan karya kompiler C ++ - jadi jangan heran jika trik ini tidak berfungsi ketika menerjemahkan kode Haxe bukan dalam cpp.) <br><br><h2>  Pooling Objek </h2><br>  Jika saya membutuhkan hasil yang akurat, maka saya harus menghancurkan dan membangun kembali QuadTree lagi dengan setiap panggilan pembaruan.  Membuat instance QuadTree baru adalah tugas yang cukup umum, tetapi dengan sejumlah besar objek AABB dan XY baru, QuadTrees yang bergantung padanya menyebabkan memori yang berlebihan.  Karena ini adalah objek yang sangat sederhana, akan logis untuk mengalokasikan banyak objek seperti itu di muka dan hanya terus menggunakannya kembali.  Ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">objek pool</a> . <br><br>  Dulu saya melakukan sesuatu seperti ini: <br><br> <code>nw = new QuadTree( new AABB( cx - hs2x, cy - hs2y, hs2x, hs2y) ); <br> ne = new QuadTree( new AABB( cx + hs2x, cy - hs2y, hs2x, hs2y) ); <br> sw = new QuadTree( new AABB( cx - hs2x, cy + hs2y, hs2x, hs2y) ); <br> se = new QuadTree( new AABB( cx + hs2x, cy + hs2y, hs2x, hs2y) );</code> <br> <br>  Tapi kemudian saya mengganti kode dengan ini: <br><br> <code>nw = new QuadTree( AABB.get( cx - hs2x, cy - hs2y, hs2x, hs2y) ); <br> ne = new QuadTree( AABB.get( cx + hs2x, cy - hs2y, hs2x, hs2y) ); <br> sw = new QuadTree( AABB.get( cx - hs2x, cy + hs2y, hs2x, hs2y) ); <br> se = new QuadTree( AABB.get( cx + hs2x, cy + hs2y, hs2x, hs2y) );</code> <br> <br>  Kami menggunakan kerangka kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HaxeFlixel</a> open source, jadi kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menerapkan</a> ini menggunakan kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FlxPool</a> HaxeFlixel.  Dalam hal optimasi yang sangat terspesialisasi, saya sering mengganti beberapa elemen Flixel dasar (misalnya, pengenalan tabrakan) dengan implementasi saya sendiri (seperti yang saya lakukan dengan QuadTrees), tetapi FlxPool lebih baik daripada semua yang saya tulis sendiri dan ia melakukan persis apa yang dibutuhkan. <br><br><h2>  Spesialisasi jika perlu </h2><br>  Objek <code>XY</code> adalah kelas sederhana yang memiliki properti <code>x</code> , <code>y</code> dan <code>int_id</code> .  Karena ini digunakan dalam loop internal yang sangat aktif digunakan, saya bisa menyimpan banyak perintah alokasi memori dan operasi dengan memindahkan semua data ini ke struktur data khusus yang menyediakan fungsi yang sama dengan <code>Vector&lt;XY&gt;</code> .  Saya memanggil kelas <code>XYVector</code> baru ini dan hasilnya dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Ini adalah aplikasi yang sangat khusus dan tidak fleksibel pada saat yang bersamaan, tetapi telah memberi kami beberapa peningkatan kecepatan. <br><br><h2>  Fungsi Bawaan </h2><br>  Sekarang, setelah kita menyelesaikan fase luas pengakuan tabrakan, kita perlu melakukan banyak pemeriksaan untuk mengetahui objek mana yang benar-benar bertabrakan.  Jika memungkinkan, saya mencoba membandingkan poin dan angka, bukan angka dan angka, tetapi kadang-kadang saya harus melakukan yang terakhir.  Bagaimanapun, semua ini memerlukan pemeriksaan khusus sendiri: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> static function _collide_circleCircle(a:Zone, b:Zone):Bool { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dx:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = a.centerX - b.centerX; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dy:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = a.centerY - b.centerY; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d2:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = (dx * dx) + (dy * dy); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r2:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = (a.radius2) + (b.radius2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d2 &lt; r2; }</code> </pre> <br><br>  Semua ini dapat ditingkatkan dengan satu <code>inline</code> : <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> function _collide_circleCircle(a:Zone, b:Zone):Bool { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dx:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = a.centerX - b.centerX; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dy:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = a.centerY - b.centerY; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d2:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = (dx * dx) + (dy * dy); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r2:<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> = (a.radius2) + (b.radius2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d2 &lt; r2; }</code> </pre> <br><br>  Ketika kita menambahkan sebaris ke suatu fungsi, kita memberitahu kompiler untuk menyalin dan menempelkan kode ini dan menempelkan variabel ketika digunakan, dan tidak membuat panggilan eksternal ke fungsi terpisah, yang mengarah ke biaya yang tidak perlu.  Penyematan tidak selalu berlaku (misalnya, ia mengembang jumlah kode), tetapi sangat ideal untuk situasi di mana fungsi kecil dipanggil berulang kali. <br><br><h2>  Kami mengingatkan konflik </h2><br>  Pelajaran sebenarnya di sini adalah bahwa di dunia nyata, optimisasi tidak selalu dari jenis yang sama.  Perbaikan semacam itu adalah campuran dari teknik-teknik canggih, peretasan murah, penerapan rekomendasi logis dan menghilangkan kesalahan bodoh.  Semua ini secara umum memberi kita dorongan kinerja. <br><br>  Tapi tetap saja - <em>ukur tujuh kali, potong satu!</em> <br><br>  Dua jam optimisasi fungsi yang hebat, yang disebut sekali setiap enam frame dan mengambil 0,001 ms, tidak sepadan dengan usaha, meskipun keburukan dan kebodohan kode. <br><br><h1>  3. Urutkan semuanya </h1><br>  Sebenarnya, itu adalah salah satu peningkatan terakhir saya, tetapi ternyata sangat menguntungkan sehingga pantas disebut judulnya sendiri.  Selain itu, itu adalah yang paling sederhana dan berulang kali membuktikan dirinya.  Profiler menunjukkan kepada saya prosedur yang tidak bisa saya perbaiki sama sekali - pengundian utama () loop, yang memakan waktu terlalu banyak.  Alasannya adalah fungsi yang mengurutkan semua elemen layar sebelum rendering - yaitu, <em>menyortir</em> semua sprite memakan waktu lebih lama daripada menggambar mereka! <br><br>  Jika Anda melihat tangkapan layar dari permainan, Anda akan melihat bahwa semua musuh dan pembela diurutkan terlebih dahulu oleh <code>y</code> , dan kemudian oleh <code>x</code> , sehingga elemen-elemen saling tumpang tindih dari belakang ke depan, dari kiri ke kanan, ketika kita bergerak dari kiri atas ke sudut kanan bawah layar. <br><br>  Salah satu cara untuk mengecoh penyortiran adalah dengan melewatkan rendering sortir melalui frame.  Ini adalah trik yang berguna untuk beberapa fungsi yang mahal, tetapi segera menyebabkan bug visual yang sangat nyata, jadi itu tidak cocok untuk kita. <br><br>  Akhirnya, keputusan datang dari salah satu pengelola HaxeFlixel, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jens Fisher</a> .  Dia bertanya: "Apakah Anda memastikan Anda menggunakan algoritma pengurutan yang cepat untuk array yang hampir diurutkan?" <br><br>  Tidak!  Ternyata tidak.  Saya menggunakan penyortiran array dari pustaka standar Haxe (saya pikir itu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggabungkan penyortiran</a> - pilihan yang baik untuk kasus-kasus umum. Tetapi saya memiliki kasus yang sangat <em>istimewa</em> . Ketika menyortir di setiap frame, posisi penyortiran hanya mengubah sejumlah kecil sprite, bahkan jika ada banyak. Saya mengganti panggilan sortir lama dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyortir dengan menyisipkan</a> , dan <em>boom!</em> - kecepatan langsung meningkat. <br><br><h1>  4. Masalah teknis lainnya </h1><br>  Pengenalan tabrakan dan penyortiran adalah kemenangan besar dalam logika <code>update()</code> dan <code>draw()</code> , tetapi banyak lagi jebakan yang disembunyikan dalam loop internal yang aktif digunakan. <br><br><h2>  Std.is () dan pemain </h2><br>  Dalam loop batin "panas" yang berbeda, saya memiliki kode yang sama: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Std.<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(something,<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>)) { var typed:<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = cast(something,<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>); }</code> </pre> <br><br>  Dalam bahasa Haxe, <code>Std.is()</code> memberi tahu kita apakah suatu objek termasuk tipe tertentu (Type) atau kelas (Class), dan <code>cast</code> mencoba untuk melemparkannya ke tipe tertentu selama eksekusi program. <br><br>  Ada versi <code>cast</code> yang aman dan tidak terlindungi yang menyebabkan penurunan kinerja, tetapi cast yang tidak terlindungi tidak. <br><br>  Aman: <code>cast(something, Type);</code> <br><br>  Tidak dilindungi: <code>var typed:Type = cast something;</code> <br><br>  Ketika upaya pemeran yang tidak aman gagal, kami mendapatkan nol, sementara pemeran yang aman melempar pengecualian.  Tetapi jika kita tidak akan menangkap pengecualian, lalu apa gunanya melakukan cast yang aman?  Tanpa tangkapan, operasinya masih gagal, tetapi kerjanya lebih lambat. <br><br>  Selain itu, tidak ada gunanya untuk mendahului gips yang aman dengan <code>Std.is()</code> .  Satu-satunya alasan untuk menggunakan pemeran aman adalah pengecualian yang dijamin, tetapi jika kami memeriksa jenis sebelum pemeran, kami sudah menjamin bahwa pemeran tidak akan gagal! <br><br>  Saya bisa mempercepat sedikit dengan pemain <code>Std.is()</code> setelah memeriksa <code>Std.is()</code> .  Tetapi mengapa kita perlu menulis ulang hal yang sama jika saya tidak perlu memeriksa jenis kelas sama sekali? <br><br>  Misalkan saya memiliki <code>CreatureSprite</code> , yang dapat menjadi turunan dari subclass dari <code>DefenderSprite</code> atau <code>EnemySprite</code> .  Alih-alih memanggil <code>Std.is(this,DefenderSprite)</code> kita bisa membuat bidang integer di <code>CreatureSprite</code> dengan nilai-nilai seperti <code>CreatureType.DEFENDER</code> atau <code>CreatureType.ENEMY</code> , yang diperiksa lebih cepat. <br><br>  Saya ulangi, perlu untuk memperbaikinya hanya di tempat-tempat di mana pelambatan signifikan dicatat dengan jelas. <br><br>  Ngomong-ngomong, Anda dapat membaca lebih lanjut tentang pemeran yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aman</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak terlindungi</a> dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manual Haxe</a> . <br><br><h2>  Serialisasi / Deserialisasi Semesta </h2><br>  Menjengkelkan menemukan tempat-tempat seperti itu dalam kode: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:SomeClass </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SomeClass.fromXML(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toXML()); }</code> </pre> <br>  Ya  Untuk menyalin suatu objek, kami membuat <em>serialisasi ke dalam XML</em> , dan kemudian <em>parsing semua XML ini</em> , setelah itu kami langsung membuang XML dan mengembalikan objek baru.  Ini mungkin cara paling lambat untuk menyalin suatu objek, selain itu, itu membebani memori.  Awalnya, saya menulis panggilan XML untuk menyimpan dan memuat dari disk, dan saya pikir saya terlalu malas untuk menulis prosedur penyalinan yang benar. <br><br>  Mungkin, semuanya akan beres jika fungsi ini jarang digunakan, tetapi panggilan ini muncul di tempat yang tidak pantas di tengah gameplay.  Jadi saya duduk dan mulai menulis dan menguji fungsi salin yang benar. <br><br><h2>  Katakan tidak pada Null </h2><br>  Pemeriksaan kesetaraan untuk null digunakan cukup sering, tetapi ketika menerjemahkan Haxe ke cpp, objek yang memungkinkan nilai tidak terbatas mengarah ke biaya yang tidak perlu yang tidak muncul jika kompilator dapat mengasumsikan bahwa objek tidak akan pernah menjadi nol.  Hal ini terutama berlaku untuk tipe dasar seperti <code>Int</code> - Haxe mengimplementasikan validitas nilai yang tidak ditentukan untuk mereka dalam sistem target statis dengan "pengepakan" mereka, yang terjadi tidak hanya untuk variabel yang secara eksplisit dinyatakan sebagai nol ( <code>var myVar:Null&lt;Int&gt;</code> ), tetapi juga untuk hal-hal seperti opsi pembantu ( <code>?myParam:Int</code> ).  Selain itu, pemeriksaan nol sendiri menyebabkan pemborosan yang tidak perlu. <br><br>  Saya dapat memperbaiki beberapa masalah ini hanya dengan melihat kode dan memikirkan alternatif - dapatkah saya melakukan pemeriksaan yang lebih sederhana, yang akan selalu benar ketika objeknya nol?  Bisakah saya menangkap nol lebih awal dalam rantai panggilan fungsi dan mengoper bilangan bulat sederhana atau boolean ke panggilan anak?  Bisakah saya menyusun semuanya sehingga nilainya <em>tidak pernah</em> dijamin menjadi nol?  Dan sebagainya.  Kami tidak dapat sepenuhnya menghilangkan cek nol dan nilai nullable, tetapi mengeluarkannya dari fungsi sangat membantu saya. <br><br><h1>  5. Waktu pengunduhan </h1><br>  Di PSVita, kami memiliki masalah serius khusus dengan waktu pemuatan beberapa adegan.  Ketika membuat profil, ternyata alasan utamanya adalah rasterisasi teks, perenderan perangkat lunak yang tidak perlu, perenderan tombol yang mahal, dan hal-hal lainnya. <br><br><h2>  Teks </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HaxeFlixel</a> didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenFL</a> , yang memiliki TextField luar biasa dan andal.  Tapi saya menggunakan objek FlxText dengan cara yang tidak sempurna - objek FlxText memiliki bidang teks OpenFL internal yang dirasterisasi.  Namun, ternyata saya tidak membutuhkan sebagian besar fungsi teks yang kompleks ini, tetapi karena cara bodoh mengatur sistem UI saya, bidang teks harus dirender sebelum semua objek lain ditemukan.  Ini menyebabkan lompatan kecil tapi nyata, misalnya, saat memuat jendela sembulan. <br><br>  Di sini saya membuat tiga koreksi - pertama, saya mengganti teks sebanyak mungkin dengan font raster.  Flixel memiliki dukungan bawaan untuk berbagai format font raster, termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BMFont AngelCode</a> , yang membuatnya mudah untuk bekerja dengan Unicode, style dan kerning, tetapi API teks raster sedikit berbeda dari API teks biasa, jadi saya harus menulis kelas pembungkus kecil untuk menyederhanakan transisi.  (Saya memberinya nama yang sesuai, <code>FlxUITextHack</code> ). <br><br>  Ini sedikit meningkatkan pekerjaan - font bitmap render dengan sangat cepat - tetapi sedikit meningkatkan kerumitan: Saya harus secara khusus menyiapkan set karakter terpisah dan menambahkan logika switching tergantung pada lokal, alih-alih hanya menyiapkan kotak teks yang melakukan semua pekerjaan. <br><br>  Perbaikan kedua adalah membuat objek UI baru yang merupakan tempat <em>penampung</em> sederhana untuk teks tetapi memiliki properti publik yang sama dengan teks.  Saya menyebutnya "area teks" dan membuat kelas baru untuk itu di perpustakaan UI saya sehingga sistem UI saya dapat menggunakan area teks ini dengan cara yang sama seperti bidang teks nyata, tetapi tidak membuat apa pun sampai menghitung ukuran dan posisi untuk yang lainnya.  Kemudian, ketika adegan saya disiapkan, saya memulai prosedur penggantian area teks ini dengan bidang teks nyata (atau bidang teks font bitmap). <br><br>  Koreksi ketiga menyangkut persepsi.  Jika ada jeda antara input dan reaksi bahkan dalam setengah detik, pemain menganggap ini sebagai pengereman.  Oleh karena itu, saya mencoba untuk menemukan semua adegan di mana terdapat keterlambatan dalam input hingga transisi berikutnya, dan menambahkan lapisan yang tembus cahaya dengan kata "Memuat ..." atau hanya lapisan tanpa teks.  Koreksi sederhana semacam itu sangat meningkatkan <em>persepsi</em> responsif permainan, karena sesuatu terjadi segera setelah pemain menyentuh kontrol, bahkan jika perlu beberapa saat untuk menampilkan menu. <br><br><h2>  Render perangkat lunak </h2><br>  Sebagian besar menu menggunakan kombinasi penskalaan perangkat lunak dan pengomposisian 9-slice.  Ini terjadi karena dalam versi PC ada UI resolusi-independen yang dapat bekerja dengan rasio aspek 4: 3 dan 16: 9, diskalakan sesuai.  Tetapi pada PSVita kita sudah <em>mengetahui</em> resolusi, yaitu, kita tidak membutuhkan semua sumber daya resolusi tinggi ekstra ini dan algoritma penskalaan waktu-nyata.  Kami hanya dapat melakukan pra-render sumber daya ke resolusi yang tepat dan menempatkannya di layar. <br><br>  Pertama, saya masuk ke markup UI untuk kondisi Vita yang mengubah permainan menggunakan sumber daya paralel.  Kemudian saya perlu membuat sumber daya ini disiapkan untuk satu izin.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Debugger HaxeFlixel</a> ternyata sangat berguna di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> - saya menambahkan skrip saya ke sana sehingga hanya menghapus cache raster ke disk.  Kemudian saya membuat konfigurasi build khusus untuk Windows yang mensimulasikan izin untuk Vita, membuka semua menu game secara bergantian, beralih ke debugger, dan meluncurkan perintah ekspor untuk versi sumber daya yang diskalakan sebagai PNG siap pakai.  Kemudian saya mengganti nama mereka dan menggunakannya sebagai sumber daya untuk Vita. <br><br><h2>  Tombol Rendering </h2><br>  Sistem UI saya memiliki masalah nyata dengan tombol - ketika mereka dibuat, tombol-tombol yang diberikan set sumber daya default, dan sesaat kemudian mereka mengubah ukuran (dan membuat lagi) kode boot UI, dan kadang-kadang bahkan <em>ketiga</em> kalinya, sebelum seluruh UI dimuat .  Saya memecahkan masalah ini dengan menambahkan opsi yang menunda rendering tombol ke tahap terakhir. <br><br><h2>  Pemindaian teks opsional </h2><br>  Majalah itu memuat sangat lambat.  Awalnya saya pikir masalahnya adalah pada bidang teks, tetapi tidak.  Teks majalah dapat berisi tautan ke halaman lain, yang ditunjukkan oleh karakter khusus yang tertanam dalam teks mentah itu sendiri.  Karakter-karakter ini kemudian dipotong dan digunakan untuk menghitung lokasi tautan. <br><br>  Ternyata.  bahwa saya memindai <em>setiap bidang teks</em> untuk menemukan dan mengganti karakter-karakter ini dengan tautan yang diformat dengan benar, bahkan tanpa memeriksa terlebih dahulu apakah ada karakter khusus dalam bidang teks ini!  Lebih buruk lagi, menurut desain, tautan <em>hanya</em> digunakan pada halaman konten, tapi saya memeriksanya di setiap kotak teks di setiap halaman. <br><br>  Saya berhasil menyiasati semua cek ini menggunakan if if dari bentuk "Apakah kotak teks ini menggunakan tautan sama sekali".  Jawaban atas pertanyaan ini biasanya tidak.  Akhirnya, halaman yang membutuhkan waktu paling lama untuk memuat ternyata adalah halaman indeks.  Karena tidak pernah berubah dalam menu jurnal, mengapa kita tidak menyimpannya? <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Memori profil </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kecepatan bukan hanya CPU. </font><font style="vertical-align: inherit;">Memori juga bisa menjadi masalah, terutama pada platform yang lemah seperti Vita. </font><font style="vertical-align: inherit;">Bahkan ketika Anda berhasil menghilangkan kebocoran memori terakhir, Anda mungkin masih memiliki masalah dengan penggunaan memori gigi gergaji di lingkungan pengumpulan sampah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa itu penggunaan memori gigi gergaji? </font><font style="vertical-align: inherit;">Pengumpul sampah berfungsi sebagai berikut: data dan objek yang tidak Anda gunakan menumpuk dari waktu ke waktu dan secara berkala dibersihkan. </font><font style="vertical-align: inherit;">Tetapi Anda tidak memiliki kontrol yang jelas kapan hal ini terjadi, sehingga grafik penggunaan memori terlihat seperti gergaji:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fc/d66/464/7fcd664644c9d2b8bbfe3ac82d60ae2b.png"></div><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buang sampah </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena pembersihan tidak instan, jumlah total RAM yang Anda gunakan biasanya lebih besar dari yang sebenarnya Anda butuhkan. Tetapi jika Anda </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melebihi</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jumlah total sistem RAM, satu dari dua hal dapat terjadi - pada PC, Anda mungkin hanya menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">file halaman</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yaitu, sementara mengubah sebagian ruang hard disk ke RAM virtual. Alternatif dalam lingkungan memori yang terbatas (seperti konsol) adalah untuk crash aplikasi, bahkan jika tidak ada cukup sepasang byte yang menyedihkan. Dan ini akan terjadi bahkan jika Anda tidak menggunakan byte ini dan pengumpulan sampah akan dilakukan di dalamnya segera!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hal yang baik tentang Haxe adalah bahwa itu sepenuhnya open source, yaitu, Anda tidak terkunci dalam kotak hitam yang tidak dapat Anda perbaiki, seperti halnya dengan Unity. </font><font style="vertical-align: inherit;">Dan backend hxcpp menyediakan manajemen pengumpulan sampah yang luas langsung dari API! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menggunakannya untuk menghapus memori secara instan setelah level besar agar tetap dalam batas yang diberikan: </font></font><br><br> <code>cpp.vm.Gc.run(false); //   (true/false - /  )</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda tidak boleh menggunakannya secara sukarela jika Anda tidak tahu apa yang Anda lakukan, tetapi nyaman jika ada alat seperti itu saat dibutuhkan.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Penanganan masalah melalui desain </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua peningkatan kinerja ini lebih dari cukup untuk mengoptimalkan permainan untuk PC, tetapi kami juga mencoba untuk merilis versi untuk PSVita, dan kami memiliki rencana jangka panjang untuk Nintendo Switch, jadi kami harus memeras segala sesuatu mulai dari kode hingga drop. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun seringkali ada "tunnel vision" ketika Anda hanya berfokus pada peretasan teknis dan lupa bahwa perubahan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desain yang</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sederhana dapat sangat memperbaiki situasi </font><font style="vertical-align: inherit;">.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mempercepat efek dengan kecepatan tinggi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada 16x, banyak efek terjadi begitu cepat sehingga pemain bahkan tidak melihatnya. Kami telah menggunakan satu trik - kilat Azra menjadi lebih mudah dengan kecepatan permainan, dan jumlah partikel untuk serangan AOE lebih rendah. Kami melengkapi teknik ini dengan menonaktifkan angka kerusakan berkecepatan tinggi dan trik serupa lainnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami juga menyadari bahwa pada titik tertentu, kecepatan 16x sebenarnya mungkin lebih </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lambat</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari kecepatan 8x ketika ada terlalu banyak objek di layar, jadi ketika jumlah musuh meningkat hingga batas tertentu, kami secara otomatis mengurangi kecepatan permainan menjadi 8x atau 4x. Dalam praktiknya, pemain cenderung melihat ini hanya di Endless Battle 2. Ini memungkinkan kinerja yang mulus dan rendering tanpa membebani CPU.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami juga menggunakan batasan khusus untuk platform. </font><font style="vertical-align: inherit;">Pada Vita, kami melewatkan efek kilat ketika Azra memicu atau mempercepat karakter, dan menggunakan trik serupa lainnya.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menyembunyikan tubuh </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan bagaimana dengan tumpukan besar musuh di sudut kanan bawah Endless Battle 2 - ada ratusan atau bahkan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ribuan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> musuh yang menggambar satu di atas yang lain. </font><font style="vertical-align: inherit;">Mengapa kita tidak melewatkan rendering yang tidak bisa kita lihat? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah trik desain licik yang membutuhkan pemrograman licik, karena kita membutuhkan algoritma pintar yang mendefinisikan objek tersembunyi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagian besar game ini digambar menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritme artis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - objek sebelumnya dalam daftar gambar diblokir oleh semua yang datang setelahnya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan membalik urutan rendering algoritme artis, Anda dapat membuat "peta penutup" dan mencari tahu apa yang harus disembunyikan. Saya menciptakan "kanvas" palsu dengan 8 tingkat "kegelapan" (hanya dua byte array) dengan resolusi yang jauh lebih rendah daripada medan perang nyata. Mulai dari </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akhir</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> daftar render, kami mengambil kotak pembatas dari setiap objek dan "menggambar" di kanvas, meningkatkan "kegelapan" dari titik dengan 1 untuk setiap "piksel" yang tercakup oleh kotak pembatas resolusi rendah. Pada saat yang sama, kita membaca "kegelapan" rata-rata dari daerah di mana kita akan menggambar. Bahkan, kami memperkirakan berapa banyak </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggambar ulang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> setiap objek akan mengalami dengan panggilan imbang nyata.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika jumlah redraw yang diprediksi cukup tinggi, maka saya menandai musuh sebagai "dikubur," dengan dua ambang batas - dikubur sepenuhnya, yaitu, sepenuhnya tidak terlihat, atau dikubur sebagian, yaitu, ia akan ditarik, tetapi tanpa membuat bilah kesehatan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Ngomong-ngomong, ini adalah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fungsi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pengecekan redraws.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar ini berfungsi dengan benar, Anda harus mengkonfigurasi dengan benar resolusi hide map. </font><font style="vertical-align: inherit;">Jika terlalu besar, maka kita harus melakukan banyak panggilan draw yang disederhanakan, jika terlalu kecil, maka kita akan menyembunyikan objek terlalu agresif dan mendapatkan bug visual. </font><font style="vertical-align: inherit;">Jika Anda memilih kartu dengan benar, efeknya hampir tidak terlihat, tetapi peningkatan kecepatan sangat terlihat - tidak ada cara untuk menggambar sesuatu lebih cepat daripada </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak menggambar sama sekali</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Preload yang lebih baik daripada rem </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di tengah-tengah perkelahian, saya perhatikan sering mengerem, yang, saya yakin, disebabkan oleh jeda dalam pengumpulan sampah. </font><font style="vertical-align: inherit;">Namun, profiling menunjukkan bahwa ini tidak benar. </font><font style="vertical-align: inherit;">Pengujian lebih lanjut mengungkapkan bahwa ini terjadi pada awal gelombang musuh, dan kemudian saya menemukan bahwa ini hanya terjadi ketika itu adalah gelombang musuh yang </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak ada sebelumnya</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jelas, beberapa kode konfigurasi musuh menyebabkan masalah, dan tentu saja, ketika membuat profil, fungsi "panas" ditemukan dalam pengaturan gambar. </font><font style="vertical-align: inherit;">Saya mulai bekerja pada pengaturan unduhan multi-utas yang kompleks, tetapi kemudian saya menyadari bahwa saya bisa memasukkan semua prosedur pemuatan grafik musuh ke dalam preload pertempuran. </font><font style="vertical-align: inherit;">Secara terpisah, ini adalah unduhan yang sangat kecil, bahkan pada platform paling lambat menambahkan kurang dari satu detik untuk total waktu pemuatan pertempuran, tetapi mereka menghindari pengereman yang sangat nyata selama bermain game.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami cadangan stok untuk nanti </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda bekerja di lingkungan dengan memori terbatas, maka Anda dapat menggunakan trik kuno industri kami - untuk mengalokasikan sebagian besar memori begitu saja, dan kemudian melupakannya sampai akhir proyek. Di akhir proyek, setelah menyia-nyiakan seluruh anggaran memori yang tersedia, Anda dapat diselamatkan berkat “telur sarang” ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menemukan diri kami dalam situasi seperti itu - kami hanya membutuhkan selusin byte untuk menyelamatkan perakitan untuk PSVita, tapi sial - kami lupa tentang trik ini dan karenanya macet! Satu-satunya pilihan yang tersisa adalah minggu operasi kode putus asa dan menyakitkan! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi tunggu sebentar! Salah satu optimisasi saya (gagal) memuat sumber daya sebanyak mungkin dan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abadi</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyimpannya dalam memori, karena saya keliru berasumsi bahwa waktu buka yang besar disebabkan oleh sumber daya membaca selama pelaksanaan program. </font><font style="vertical-align: inherit;">Ternyata ini tidak benar, sehingga hampir semua panggilan ekstra untuk preloading dan penyimpanan kekal ini dapat sepenuhnya dihapus, dan saya masih memiliki memori gratis!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menyingkirkan hal-hal yang tidak kami gunakan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat mengerjakan build untuk PSVita, kami sangat jelas bahwa ada banyak hal yang tidak kami butuhkan. Karena resolusi rendah, mode grafik sumber dan mode grafis HD tidak bisa dibedakan, jadi untuk semua sprite kami menggunakan grafik asli. Kami juga berhasil meningkatkan fungsi penggantian palet dengan bantuan pixel shader khusus (sebelumnya kami menggunakan fungsi rendering program). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh lain adalah peta pertempuran itu sendiri - pada PC dan konsol rumah, kami menumpuk banyak kartu ubin di atas satu sama lain untuk membuat peta multi-layer. Tapi karena peta tidak pernah berubah, pada Vita kita bisa memanggang semuanya menjadi satu gambar jadi sehingga akan dipanggil dalam satu panggilan undian.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain sumber daya tambahan, permainan memiliki banyak panggilan tambahan, misalnya, pembela dan musuh mengirimkan sinyal regenerasi di setiap frame, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bahkan ketika mereka tidak memiliki kemampuan untuk regenerasi</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jika UI terbuka untuk makhluk seperti itu, maka digambar ulang di </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setiap bingkai</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada setengah lusin contoh lain dari algoritma kecil yang menghitung sesuatu di dalam fungsi "panas", tetapi tidak pernah mengembalikan hasil di mana pun. </font><font style="vertical-align: inherit;">Biasanya ini adalah hasil dari menciptakan struktur pada tahap awal pengembangan, jadi kami hanya memotongnya.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NaNopocalypse </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kasus ini lucu. </font><font style="vertical-align: inherit;">Profiler melaporkan bahwa dibutuhkan banyak waktu untuk menghitung sudut. </font><font style="vertical-align: inherit;">Berikut adalah kode Haxe C ++ yang dihasilkan di profiler:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f4/387/7d5/4f43877d538fc9c44c34e5bfaa72bd45.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah salah satu fungsi yang mengambil nilai suka </font></font><code>-90</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan dikonversi ke </font></font><code>270</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Terkadang Anda mendapatkan nilai seperti </font></font><code>-724</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang dalam beberapa siklus dikurangi menjadi </font></font><code>4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk beberapa alasan, nilai diteruskan ke fungsi ini </font></font><code>-2147483648</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d8/6bc/9c8/7d86bc9c84d9e75a345b898ff44940a1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita lakukan perhitungan. Jika dalam setiap siklus kita menambahkan 360 ke -2147483648, maka akan dibutuhkan sekitar 5,965.233 iterasi hingga menjadi lebih besar dari 0 dan menyelesaikan siklus. Omong-omong, siklus ini dilakukan dengan setiap pembaruan (tidak di setiap </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frame</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - di setiap </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pembaruan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !) - setiap kali ketika proyektil (atau sesuatu yang lain) berubah sudutnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, itu adalah kesalahan saya, karena saya memberikan nilai </font></font><code>NaN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">nilai </font><font style="vertical-align: inherit;">khusus yang berarti "Bukan angka" (bukan angka), yang biasanya menandakan kesalahan yang sebelumnya terjadi dalam kode. Jika Anda membawanya ke integer tanpa terlebih dahulu memeriksa, maka hal-hal aneh seperti itu terjadi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai perbaikan sementara, saya menambahkan cek</font></font><code>Math.isNan()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang mengatur ulang sudut ketika peristiwa (agak jarang, tapi tak terhindarkan) terjadi. </font><font style="vertical-align: inherit;">Pada saat yang sama, saya terus mencari akar penyebab kesalahan, menemukannya, dan penundaan segera menghilang. </font><font style="vertical-align: inherit;">Ternyata jika Anda tidak melakukan 6 juta iterasi yang tidak berarti, maka Anda bisa mendapatkan peningkatan besar dalam kecepatan! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Perbaikan untuk kesalahan ini </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dimasukkan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke dalam HaxeFlixel sendiri).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jangan mengakali diri sendiri </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenFL dan HaxeFlixel didasarkan pada caching sumber daya. </font><font style="vertical-align: inherit;">Ini berarti bahwa ketika kita memuat sumber daya, waktu berikutnya sumber daya ini diterima, itu diambil dari cache, dan tidak dimuat ulang dari disk. </font><font style="vertical-align: inherit;">Perilaku ini dapat ditimpa, dan terkadang masuk akal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, saya masuk ke beberapa hal aneh yang dibuat-buat: Saya mengunduh sumber daya, secara eksplisit mengatakan kepada sistem </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk tidak</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> men- </font><font style="vertical-align: inherit;">cache hasil, karena saya benar-benar yakin dengan apa yang saya lakukan dan tidak ingin "membuang memori" pada cache. </font><font style="vertical-align: inherit;">Bertahun-tahun kemudian, panggilan "pintar" ini membuat saya memuat sumber daya yang sama berulang-ulang, memperlambat permainan dan membuang-buang memori yang berharga, yang saya "simpan" dengan meninggalkan cache.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Selain itu, mungkin tidak layak melakukan level seperti Endless Battle 2 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya, sangat bagus bahwa kami menerapkan semua trik kecil ini untuk meningkatkan kecepatan. Sejujurnya, kami tidak memperhatikan sebagian besar dari mereka sampai kami mulai memindahkan game ke sistem yang kurang kuat, ketika pada beberapa level masalahnya menjadi sangat tak tertahankan. Saya senang bahwa pada akhirnya kami berhasil meningkatkan kecepatan, tetapi saya pikir desain level patologis juga harus dihindari. Endless Battle 2 memberi terlalu banyak tekanan pada sistem, terutama dibandingkan dengan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semua level permainan lainnya</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahkan setelah semua perubahan ini, versi PSVita masih tidak dapat mengatasi desain Endless 2 yang asli, dan saya tidak ingin mengambil risiko kecepatan pada model dasar XB1 dan PS4, jadi saya mengubah keseimbangan untuk versi konsol Endless 2. Saya mengurangi jumlah musuh, tetapi menambah karakteristik mereka, tetapi menambah karakteristik mereka. sehingga levelnya memiliki kesulitan yang kira-kira sama. Selain itu, pada PSVita kami membatasi jumlah gelombang hingga seratus untuk menghindari risiko kegagalan memori, tetapi tidak menambahkan batasan pada PS4 dan XB1. Berkat ini, mencapai pencapaian ketahanan masih sama sulitnya di semua konsol. Dalam versi PC, desain level Endless Batlte 2 tetap tidak berubah.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua ini adalah pelajaran bagi kami, yang akan kami perhitungkan saat membuat Defender's Quest II - kami akan sangat memperhatikan level tanpa batas atas jumlah musuh di layar! </font><font style="vertical-align: inherit;">Tentu saja, misi "tanpa akhir" sangat menarik bagi penggemar Tower Defense, jadi saya tidak akan menyingkirkan mereka sepenuhnya, tetapi bagaimana dengan level dengan pos pemeriksaan di mana pemain HARUS menghancurkan segala sesuatu di layar sebelum pindah ke gelombang berikutnya? </font><font style="vertical-align: inherit;">Ini tidak hanya akan memungkinkan kita untuk membatasi jumlah musuh di layar, tetapi juga menyadari menyelamatkan di tengah level tanpa ribut-ribut dengan mengurutkan keadaan sup benda gila dalam pertempuran yang intens - itu akan cukup bagi kita untuk hanya menyimpan koordinat para pembela, meningkatkan level, dll.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. Pikiran dalam kesimpulan </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performa permainan adalah topik yang kompleks karena pemain seringkali tidak memahami apa itu, dan kita seharusnya tidak mengharapkan pemahaman seperti itu dari mereka. Tapi saya harap artikel ini sedikit mengklarifikasi bagi Anda bagaimana segala sesuatu terlihat di dalamnya, dan Anda telah belajar lebih banyak tentang bagaimana desain, pertukaran teknis dan keputusan bodoh memperlambat permainan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intinya adalah bahwa bahkan dalam game dengan desain bagus yang dikembangkan oleh tim yang berbakat, fragmen kode "berkarat" kecil seperti itu dapat ditemukan di </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mana-mana</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Namun dalam praktiknya, hanya sebagian kecil dari mereka yang benar-benar memengaruhi kinerja. Kemampuan untuk mendeteksi dan menghilangkannya sama-sama seni dan sains.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya senang bahwa kami akan memanfaatkan semua keuntungan ini dalam pengembangan Quest II dari Defender. </font><font style="vertical-align: inherit;">Jujur saja, jika kami belum membuat port untuk PSVita, maka saya mungkin tidak akan mencoba setengah dari optimasi ini. </font><font style="vertical-align: inherit;">Dan bahkan jika Anda tidak membeli game untuk PSVita, Anda dapat berterima kasih kepada konsol kecil ini, yang secara signifikan meningkatkan kecepatan Quest Defender.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414135/">https://habr.com/ru/post/id414135/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414125/index.html">Bagaimana kami menguji VMware vSAN ™: mengapa ia bekerja dalam praktik</a></li>
<li><a href="../id414127/index.html">Instal 3CX di hosting untuk 2,99 Euro / bulan. dalam 10 menit</a></li>
<li><a href="../id414129/index.html">Magister Ilmu Komputer Teoritis di St. Petersburg State University</a></li>
<li><a href="../id414131/index.html">Efek frekuensi sinyal pada energi tautan radio di ruang bebas</a></li>
<li><a href="../id414133/index.html">Desain game puzzle dengan contoh In The Shadows</a></li>
<li><a href="../id414137/index.html">Pengalaman pengembangan SPA di VueJS + Nuxt</a></li>
<li><a href="../id414139/index.html">Pelepasan proxy MTProto tidak resmi dengan Python, fitur protokol</a></li>
<li><a href="../id414141/index.html">7 aturan untuk mendesain papan sirkuit tercetak</a></li>
<li><a href="../id414149/index.html">Alasan buruknya suara sebagian besar smartphone Android</a></li>
<li><a href="../id414151/index.html">Intisari Fintech: bank akan melaporkan kerusakan akibat serangan peretas, Western Union menolak untuk bekerja dengan cryptocurrency</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>