<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ–ï¸ ğŸŒ™ ğŸ’ƒğŸ¾ Render grafik 3D dengan OpenGL ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸ’ ğŸ¥–</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Rendering grafik 3D bukanlah tugas yang mudah, tetapi sangat menarik dan mengasyikkan. Artikel ini diperuntukkan bagi mereka yang baru m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Render grafik 3D dengan OpenGL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467599/"><h2>  Pendahuluan </h2><br>  Rendering grafik 3D bukanlah tugas yang mudah, tetapi sangat menarik dan mengasyikkan.  Artikel ini diperuntukkan bagi mereka yang baru mulai berkenalan dengan OpenGL atau bagi mereka yang tertarik dengan cara kerja jalur pipa grafis dan seperti apa mereka.  Artikel ini tidak akan memberikan instruksi yang tepat tentang cara membuat konteks dan jendela OpenGL, atau cara menulis aplikasi jendela OpenGL pertama Anda.  Ini karena fitur dari setiap bahasa pemrograman dan pilihan pustaka atau kerangka kerja untuk bekerja dengan OpenGL (saya akan menggunakan C ++ dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GLFW</a> ), terutama karena mudah untuk menemukan tutorial di jaringan untuk bahasa yang Anda minati.  Semua contoh yang diberikan dalam artikel akan berfungsi dalam bahasa lain dengan semantik perintah yang sedikit berubah, mengapa demikian, saya akan ceritakan sedikit kemudian. <br><a name="habracut"></a><br><h2>  Apa itu OpenGL? </h2><br><p>  OpenGL adalah spesifikasi yang mendefinisikan antarmuka perangkat lunak platform-independen untuk menulis aplikasi menggunakan grafis komputer dua dimensi dan tiga dimensi.  OpenGL bukan implementasi, tetapi hanya menjelaskan set instruksi yang harus diimplementasikan, yaitu  adalah API. </p><br><p>  Setiap versi OpenGL memiliki spesifikasi sendiri, kami akan bekerja dari versi 3.3 hingga versi 4.6, karena  semua inovasi dari versi 3.3 memengaruhi aspek-aspek yang tidak terlalu penting bagi kami.  Sebelum Anda mulai menulis aplikasi OpenGL pertama Anda, saya sarankan Anda mencari tahu versi yang didukung driver Anda (Anda dapat melakukan ini di situs vendor kartu video Anda) dan memperbarui driver ke versi terbaru. </p><br><h3>  Perangkat OpenGL </h3><br><p>  OpenGL dapat dibandingkan dengan mesin negara besar, yang memiliki banyak status dan fungsi untuk mengubahnya.  Keadaan OpenGL pada dasarnya merujuk pada konteks OpenGL.  Saat bekerja dengan OpenGL, kami akan melalui beberapa fungsi yang mengubah keadaan yang akan mengubah konteks, dan melakukan tindakan tergantung pada kondisi OpenGL saat ini. </p><br><p>  Sebagai contoh, jika kita memberi OpenGL perintah untuk menggunakan baris alih-alih segitiga sebelum rendering, maka OpenGL akan menggunakan baris untuk semua rendering berikutnya sampai kita mengubah opsi ini atau mengubah konteks. </p><br><h3>  Objek di OpenGL </h3><br><p>  Pustaka OpenGL ditulis dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C</a> dan memiliki banyak API untuknya untuk bahasa yang berbeda, namun demikian pustaka C.  Banyak konstruksi dari C tidak diterjemahkan ke bahasa tingkat tinggi, jadi OpenGL dikembangkan menggunakan sejumlah besar abstraksi, salah satu abstraksi ini adalah objek. </p><br><p>  Objek di OpenGL adalah sekumpulan opsi yang menentukan statusnya.  Objek apa pun di OpenGL dapat dijelaskan oleh id dan serangkaian opsi yang menjadi tanggung jawabnya.  Tentu saja, setiap jenis objek memiliki opsi sendiri dan upaya untuk mengkonfigurasi opsi yang tidak ada untuk objek tersebut akan menyebabkan kesalahan.  Disinilah letak ketidaknyamanan menggunakan OpenGL: seperangkat opsi dijelaskan dengan struktur yang mirip C, pengenal yang sering berupa angka, yang tidak memungkinkan programmer menemukan kesalahan pada tahap kompilasi, karena  kode yang salah dan benar secara semantik tidak bisa dibedakan. </p><br><pre><code class="cpp hljs">glGenObject(&amp;objectId); glBindObject(GL_TAGRGET, objectId); glSetObjectOption(GL_TARGET, GL_CORRECT_OPTION, correct_option); <span class="hljs-comment"><span class="hljs-comment">//Ok glSetObjectOption(GL_TARGET, GL_WRONG_OPTION, wrong_option); //  , ..   </span></span></code> </pre> <br><p>  Anda akan menemukan kode seperti itu sangat sering, jadi ketika Anda terbiasa dengan apa itu seperti mengatur mesin negara, itu akan menjadi jauh lebih mudah bagi Anda.  Kode ini hanya menunjukkan contoh cara kerja OpenGL.  Selanjutnya, contoh nyata akan disajikan. </p><br><p>  Tapi ada plusnya.  Fitur utama dari objek-objek ini adalah bahwa kita dapat mendeklarasikan banyak objek dalam aplikasi kita, mengatur opsi-opsi mereka, dan setiap kali kita memulai operasi menggunakan keadaan OpenGL, kita hanya dapat mengikat objek dengan pengaturan pilihan kita.  Misalnya, ini mungkin objek dengan data model 3D atau sesuatu yang ingin kita gambar pada model ini.  Memiliki banyak objek memudahkan untuk beralih di antara mereka selama proses rendering.  Dengan pendekatan ini, kita dapat mengonfigurasi banyak objek yang diperlukan untuk rendering dan menggunakan status mereka tanpa kehilangan waktu yang berharga di antara frame. </p><br><p>  Untuk mulai bekerja dengan OpenGL Anda perlu berkenalan dengan beberapa objek dasar yang tanpanya kami tidak dapat menampilkan apa pun.  Menggunakan objek-objek ini sebagai contoh, kita akan mengerti bagaimana cara mengikat data dan instruksi yang dapat dieksekusi di OpenGL. </p><br><h2>  Objek dasar: Program shader dan shader. = </h2><br>  Shader adalah program kecil yang berjalan pada akselerator grafis (GPU) pada titik tertentu dalam pipa grafis.  Jika kita mempertimbangkan shader secara abstrak, kita dapat mengatakan bahwa ini adalah tahapan dari pipeline grafik, yang: <br><br><ol><li>  Ketahui di mana mendapatkan data untuk diproses. </li><li>  Ketahui cara memproses input data. </li><li>  Mereka tahu di mana harus menulis data untuk diproses lebih lanjut. </li></ol><br><p>  Tapi seperti apa grafik pipa itu?  Sangat sederhana, seperti ini: </p><br><img src="https://habrastorage.org/webt/vv/qi/au/vvqiaulrpglg1rnwq0woxh5xg_8.png"><br>  Sejauh ini, dalam skema ini, kami hanya tertarik pada vertikal utama, yang dimulai dengan Spesifikasi Vertex dan berakhir dengan Frame Buffer.  Seperti disebutkan sebelumnya, masing-masing shader memiliki parameter input dan output sendiri, yang berbeda dalam jenis dan jumlah parameter. <br>  Kami jelaskan secara singkat setiap tahap pipa untuk memahami apa yang dilakukannya: <br><br><ol><li>  Vertex Shader - diperlukan untuk memproses data koordinat 3D dan semua parameter input lainnya.  Paling sering, shader vertex menghitung posisi verteks relatif terhadap layar, menghitung normals (jika perlu) dan menghasilkan data input ke shader lain. </li><li>  Tessellation shader dan tessellation control shader - kedua shader ini bertanggung jawab untuk merinci primitif yang berasal dari vertex shader dan menyiapkan data untuk diproses dalam shader geometrik.  Sulit untuk menggambarkan apa yang mampu dilakukan oleh dua bayangan ini dalam dua kalimat, tetapi bagi pembaca untuk memiliki sedikit ide, saya akan memberikan beberapa gambar dengan tumpang tindih tingkat rendah dan tinggi: <br><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/webt/pm/hu/gy/pmhugylrqwhvqkwnia4eby4k0us.png"></td><td><img src="https://habrastorage.org/webt/_p/rs/dl/_prsdlb_pbwgitigom09fj5fju0.png"></td></tr></tbody></table></div><br>  Saya menyarankan Anda untuk membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> ini jika Anda ingin tahu lebih banyak tentang tessellation.  Dalam seri artikel ini kita akan membahas tessellation, tetapi tidak akan segera. </li><li>  Geometris shader - bertanggung jawab atas pembentukan primitif geometri dari hasil shading tessellation.  Dengan menggunakan shader geometris, Anda dapat membuat primitif baru dari primitif OpenGL dasar (GL_LINES, GL_POINT, GL_TRIANGLES, dll.), Misalnya, dengan menggunakan geometri shader, Anda dapat membuat efek partikel dengan menjelaskan partikel hanya dengan menggambarkan partikel hanya dengan warna, pusat cluster, jari-jari dan kepadatan. </li><li>  Shader rasterisasi adalah salah satu shader yang tidak dapat diprogram.  Berbicara dalam bahasa yang dapat dimengerti, itu menerjemahkan semua primitif grafis keluaran menjadi fragmen (piksel), yaitu  menentukan posisi mereka di layar. </li><li>  Shader fragmen adalah tahap terakhir dari pipa grafis.  Shader fragmen menghitung warna fragmen (piksel) yang akan ditetapkan dalam buffer bingkai saat ini.  Paling sering, dalam shader fragmen, bayangan dan pencahayaan fragmen, pemetaan tekstur dan peta normal dihitung - semua teknik ini memungkinkan Anda untuk mencapai hasil yang sangat indah. </li></ol><br><p>  OpenGL shaders ditulis dalam bahasa GLSL mirip C dari mana mereka dikompilasi dan dihubungkan ke program shader.  Sudah pada tahap ini, tampaknya menulis program shader adalah tugas yang sangat memakan waktu, karena  Anda perlu menentukan 5 langkah dari pipa grafis dan menghubungkannya bersama.  Untungnya, ini tidak demikian: tessellation dan geometri shader didefinisikan dalam pipa grafis secara default, yang memungkinkan kita untuk mendefinisikan hanya dua shader - vertex dan shader fragmen (kadang-kadang disebut pixel shader).  Yang terbaik untuk mempertimbangkan dua bayangan ini dengan contoh klasik: </p><br><div class="spoiler">  <b class="spoiler_title">Vertex shader</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 layout (location = 0) in vec3 vertexCords; layout (location = 1) in vec3 color; out vec3 Color; void main(){ gl_Position = vec4(vertexCords,1.0f) ; Color = color; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Shader fragmen</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 in vec3 Color; out vec4 out_fragColor; void main(){ out_fragColor = Color; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Contoh perakitan shader</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vShader = glCreateShader(GL_SHADER_VERTEX); <span class="hljs-comment"><span class="hljs-comment">//    glShaderSource(vShader,&amp;vShaderSource); //  glCompileShader(vShader); //  //        unsigned int shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vShader); //    glAttachShader(shaderProgram, fShader); //    glLinkProgram(shaderProgram); // </span></span></code> </pre><br></div></div><br><p>  Dua shader sederhana ini tidak menghitung apa-apa, mereka hanya melewatkan data ke dalam pipa.  Mari kita perhatikan bagaimana vertex dan fragmen shaders terhubung: di vertex shader, variabel Color dideklarasikan ke mana warna akan ditulis setelah fungsi utama dieksekusi, sementara di fragmen shader variabel yang sama persis dengan kualifikasi yang dinyatakan, yaitu.  seperti yang dijelaskan sebelumnya, shader fragmen menerima data dari verteks dengan cara mendorong data lebih jauh melalui pipa (tetapi sebenarnya tidak begitu sederhana). <br></p><blockquote>  Catatan: Jika Anda tidak mendeklarasikan dan menginisialisasi variabel tipe vec4 di shader fragmen, maka tidak ada yang akan ditampilkan di layar. </blockquote><br>  Pembaca yang penuh perhatian telah memperhatikan deklarasi variabel input tipe vec3 dengan kualifikasi tata letak yang aneh di awal vertex shader, logis untuk menganggap bahwa ini adalah input, tetapi dari mana kita mendapatkannya? <br><br><h2>  Objek Dasar: Buffer dan Array Vertex </h2><br>  Saya pikir tidak ada gunanya menjelaskan objek buffer, sebaiknya kita mempertimbangkan cara membuat dan mengisi buffer di OpenGL. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> vertices[] = { <span class="hljs-comment"><span class="hljs-comment">// // -0.8f, -0.8f, 0.0f, 1.0f, 0.0f, 0.0f, 0.8f, -0.8f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.8f, 0.0f, 0.0f, 0.0f, 1.0f }; unsigned int VBO; //vertex buffer object glGenBuffers(1,&amp;VBO); glBindBuffer(GL_SOME_BUFFER_TARGET,VBO); glBufferData(GL_SOME_BUFFER_TARGET, sizeof(vertices), vertices, GL_STATIC_DRAW);</span></span></code> </pre><br><p>  Tidak ada yang sulit dalam hal ini, kami lampirkan buffer yang dihasilkan ke target yang diinginkan (nanti kita akan menemukan yang mana) dan memuat data yang menunjukkan ukuran dan jenis penggunaannya. </p><br><blockquote>  GL_STATIC_DRAW - data dalam buffer tidak akan diubah. <br>  GL_DYNAMIC_DRAW - data dalam buffer akan berubah, tetapi tidak sering. <br>  GL_STREAM_DRAW - data dalam buffer akan berubah setiap panggilan undian. <br></blockquote><br><p>  Sangat bagus, sekarang data kami terletak di memori GPU, program shader dikompilasi dan dihubungkan, tetapi ada satu peringatan: bagaimana program tahu di mana mendapatkan data input untuk vertex shader?  Kami mengunduh data, tetapi tidak menunjukkan dari mana program shader akan mendapatkannya.  Masalah ini diselesaikan dengan jenis objek OpenGL yang terpisah - array vertex. </p><br><img src="https://habrastorage.org/files/106/418/e11/106418e1122b4101af438ce2c6762518.png" alt="gambar"><br><blockquote>  Gambar diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial</a> ini. </blockquote><br><p>  Seperti halnya buffer, array vertex paling baik dilihat menggunakan contoh konfigurasinya. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VBO, VAO; glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VBO); glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;EBO); glGenVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VAO); glBindVertexArray(VAO); <span class="hljs-comment"><span class="hljs-comment">//    glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); //     () glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), nullptr); //     () glEnableVertexAttribArray(1); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), reinterpret_cast&lt;void*&gt; (sizeof(float) * 3)); glBindBuffer(GL_ARRAY_BUFFER, 0); glBindVertexArray(0);</span></span></code> </pre><br><p>  Membuat array vertex tidak berbeda dengan membuat objek OpenGL lainnya, yang paling menarik dimulai setelah baris: </p><pre> <code class="plaintext hljs">glBindVertexArray(VAO);</code> </pre>  Vertex array (VAO) mengingat semua binding dan konfigurasi yang dilakukan dengannya, termasuk pengikatan objek buffer untuk pembongkaran data.  Dalam contoh ini, hanya ada satu objek seperti itu, tetapi dalam praktiknya bisa ada beberapa.  Setelah itu, atribut vertex dengan nomor tertentu dikonfigurasi: <p></p><br><pre> <code class="plaintext hljs"> glBindBuffer(GL_ARRAY_BUFFER, VBO); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), nullptr);</code> </pre><br>  Dari mana kami mendapatkan nomor ini?  Ingat kualifikasi tata letak untuk variabel input vertex shader?  Merekalah yang menentukan atribut vertex mana variabel input akan terikat.  Sekarang secara singkat membahas argumen fungsi sehingga tidak ada pertanyaan yang tidak perlu: <br><ol><li>  Nomor atribut yang ingin kita konfigurasi. </li><li>  Jumlah barang yang ingin kami ambil.  (Karena variabel input vertex shader dengan tata letak = 0 adalah tipe vec3, maka kita mengambil 3 elemen tipe float) </li><li>  Jenis barang. </li><li>  Apakah perlu untuk menormalkan elemen, jika itu adalah vektor. </li><li>  Offset untuk verteks berikutnya (karena kita memiliki koordinat dan warna terletak secara berurutan dan masing-masing memiliki tipe vec3, maka kita menggeser dengan 6 * sizeof (float) = 24 byte). </li><li>  Argumen terakhir menunjukkan offset apa yang harus diambil untuk verteks pertama.  (untuk koordinat, argumen ini adalah 0 byte, untuk warna 12 byte) </li></ol><br><p>  Sekarang kita siap untuk membuat gambar pertama kita </p><br><blockquote>  Ingatlah untuk mengikat VAO dan program shader sebelum memohon render. <br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">// your render loop glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES,0,3); //        }</span></span></code> </pre><br></blockquote><br><p>  Jika Anda melakukan semuanya dengan benar, maka Anda harus mendapatkan hasil ini: </p><br><img src="https://habrastorage.org/webt/nn/zt/w2/nnztw2prezwfkhm9dsx9viufl4m.png"><br><p>  Hasilnya mengesankan, tetapi dari mana asal gradien terisi dalam segitiga, karena kami hanya mengindikasikan 3 warna: merah, biru dan hijau untuk masing-masing simpul individu?  Ini adalah keajaiban shader rasterization: faktanya adalah bahwa nilai Color yang kita atur di vertex tidak masuk ke fragmen shader.  Kami mentransmisikan hanya 3 simpul, tetapi lebih banyak fragmen yang dihasilkan (jumlah fragmen persis sama banyaknya dengan piksel yang diisi).  Oleh karena itu, untuk setiap fragmen, rata-rata dari tiga nilai Warna diambil, tergantung pada seberapa dekat itu dengan masing-masing simpul.  Ini sangat baik terlihat di sudut-sudut segitiga, di mana fragmen mengambil nilai warna yang kami tunjukkan dalam data vertex. <br></p><blockquote>  Ke depan, saya akan mengatakan bahwa koordinat tekstur ditransmisikan dengan cara yang sama, yang membuatnya mudah untuk overlay tekstur pada primitif kami. </blockquote><br><p>  Saya pikir ini layak untuk menyelesaikan artikel ini, yang paling sulit adalah di belakang kita, tetapi yang paling menarik baru saja dimulai.  Jika Anda memiliki pertanyaan atau Anda melihat kesalahan dalam artikel, tulis tentang itu di komentar, saya akan sangat berterima kasih. </p><br><p>  Pada artikel selanjutnya, kita akan melihat transformasi, belajar tentang variabel yang berbeda, dan belajar bagaimana memaksakan tekstur pada primitif. </p><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467599/">https://habr.com/ru/post/id467599/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467589/index.html">Apa yang perlu Anda ketahui tentang GDPR pada tahun 2019</a></li>
<li><a href="../id467591/index.html">Bukti baru memecahkan perkiraan angka seperti pi</a></li>
<li><a href="../id467593/index.html">(Tidak relevan, diperbaiki) Catatan. Bagaimana Tele2 berbagi akses ke akun pribadi pelanggan baru</a></li>
<li><a href="../id467595/index.html">Bepergian melalui pusat data Selectel. Dinosaurus di Api, VMware, C2F5H dan Manusia Serigala Yang Tak Terlihat</a></li>
<li><a href="../id467597/index.html">Personalisasi Pedoman Produk Big Data dengan Vowpal Wabbit</a></li>
<li><a href="../id467605/index.html">Yang Anda butuhkan hanyalah URL</a></li>
<li><a href="../id467607/index.html">Pengakuan pembenci buruh pelabuhan</a></li>
<li><a href="../id467609/index.html">Membuat aplikasi seluler di React Native</a></li>
<li><a href="../id467611/index.html">Algoritma Deteksi Garis Besar Gambar</a></li>
<li><a href="../id467615/index.html">Cara membuat pembungkus Python dan tidak menjadi gila</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>