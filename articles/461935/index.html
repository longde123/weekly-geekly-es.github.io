<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≥ üßõüèª üÜí C√≥mo trabajar con Postgres en Go: pr√°cticas, caracter√≠sticas, matices üíµ üßëüèæ‚Äçü§ù‚ÄçüßëüèΩ ‚ôàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El comportamiento inesperado de la aplicaci√≥n en relaci√≥n con el trabajo con la base de datos conduce a una guerra entre el DBA y los desarrolladores:...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo trabajar con Postgres en Go: pr√°cticas, caracter√≠sticas, matices</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461935/"><p><img src="https://habrastorage.org/webt/yg/8e/hm/yg8ehmpmicsm7ye6fwju6kwog14.png"></p><br><p>  El comportamiento inesperado de la aplicaci√≥n en relaci√≥n con el trabajo con la base de datos conduce a una guerra entre el DBA y los desarrolladores: DBA grita: "Su aplicaci√≥n deja caer la base de datos", los desarrolladores - "¬°Pero todo funcion√≥ antes!"  Lo peor de todo es que DBA y los desarrolladores no pueden ayudarse entre s√≠: algunos no conocen los matices de la aplicaci√≥n y el controlador, otros no conocen las caracter√≠sticas relacionadas con la infraestructura.  Ser√≠a bueno evitar tal situaci√≥n. </p><br><p>  Tienes que entender, a menudo no es suficiente mirar a trav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">go-database-sql.org</a> .  Es mejor armarse con la experiencia de otras personas.  A√∫n mejor si es una experiencia ganada por sangre y dinero perdido. </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Uojy57I-xP0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Mi nombre es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ryabinkov Artemy</a> y este art√≠culo es una interpretaci√≥n gratuita de mi informe de la conferencia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Saints HighLoad 2019</a> . </p><br><h1 id="instrumenty">  Las herramientas </h1><br><p>  Puede encontrar la informaci√≥n m√≠nima necesaria sobre c√≥mo trabajar con cualquier base de datos similar a SQL en Go en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">go-database-sql.org</a> .  Si no lo ha le√≠do, l√©alo. </p><br><h2 id="sqlx">  sqlx </h2><br><p>  En mi opini√≥n, el poder de Go es la simplicidad.  Y esto se expresa, por ejemplo, en que es habitual que Go escriba consultas en SQL simple (ORM no es un honor).  Esto es tanto una ventaja como una fuente de dificultades adicionales. </p><br><p> Por lo tanto, tomando el paquete est√°ndar de <code>database/sql</code> lenguaje <code>database/sql</code> , querr√° expandir sus interfaces.  Una vez que eso suceda, eche un vistazo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/jmoiron/sqlx</a> .  D√©jame mostrarte algunos ejemplos de c√≥mo esta extensi√≥n puede simplificar tu vida. </p><br><p>  El uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">StructScan</a> elimina la necesidad de cambiar manualmente los datos de las columnas a las propiedades de la estructura. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Place <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Country <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> City sql.NullString TelephoneCode <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`db:"telcode"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p Place err = rows.StructScan(&amp;p)</code> </pre> <br><p>  El uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NamedQuery le</a> permite usar propiedades de estructura como marcadores de posici√≥n en una consulta. </p><br><pre> <code class="go hljs">p := Place{Country: <span class="hljs-string"><span class="hljs-string">"South Africa"</span></span>} sql := <span class="hljs-string"><span class="hljs-string">`.. WHERE country=:country`</span></span> rows, err := db.NamedQuery(sql, p)</code> </pre> <br><p>  El uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Get</a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Select le</a> permite deshacerse de la necesidad de escribir manualmente bucles que obtienen l√≠neas de la base de datos. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p Place <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pp []Place <span class="hljs-comment"><span class="hljs-comment">// Get   p     err = db.Get(&amp;p, ".. LIMIT 1") // Select   pp   . err = db.Select(&amp;pp, ".. WHERE telcode &gt; ?", 50)</span></span></code> </pre> <br><h1 id="drayvery">  Conductores </h1><br><p>  <code>database/sql</code> es un conjunto de interfaces para trabajar con la base de datos, y <code>sqlx</code> es su extensi√≥n.  Para que estas interfaces funcionen, necesitan una implementaci√≥n.  Los conductores son responsables de la implementaci√≥n. </p><br><p>  Conductores m√°s populares: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/lib/pq</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">controlador</a> <code>pure Go Postgres driver for database/sql.</code>  Este controlador ha permanecido durante mucho tiempo el est√°ndar predeterminado.  Pero hoy ha perdido su relevancia y no est√° siendo desarrollado por el autor. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/jackc/pgx</a> : <code>PostgreSQL driver and toolkit for Go.</code>  Hoy es mejor elegir esta herramienta. </li></ul><br><p>  <strong>github.com/jackc/pgx</strong> : este es el controlador que desea utilizar.  Por qu√© </p><br><ul><li>  Activamente <strong>apoyado y desarrollado</strong> . </li><li>  Puede ser m√°s <strong>productivo</strong> si se usa sin interfaces de <code>database/sql</code> . </li><li>  Soporte para m√°s de <strong>60 tipos de PostgreSQL</strong> que <code>PostgreSQL</code> implementa fuera del est√°ndar <code>SQL</code> . </li><li>  La capacidad de implementar convenientemente el <strong>registro</strong> de lo que sucede dentro del controlador. </li><li>  <code>pgx</code> <strong>errores legibles por humanos</strong> , mientras que solo <code>lib/pq</code> lanza ataques de p√°nico.  Si no se asusta, el programa se bloquear√°.  ( <em>No debe usar el p√°nico en Go, esto no es lo mismo que la excepci√≥n</em> ) <em>.</em> </li><li>  Con <code>pgx</code> , tenemos la capacidad de <strong>configurar de forma</strong> independiente <strong>cada conexi√≥n</strong> . </li><li>  Hay soporte <strong>para el protocolo de replicaci√≥n l√≥gica</strong> <code>PostgreSQL</code> . </li></ul><br><h2 id="4kb">  4KB </h2><br><p>  Por lo general, escribimos este bucle para obtener datos de la base de datos: </p><br><pre> <code class="go hljs">rows, err := s.db.QueryContext(ctx, sql) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() { err = rows.Scan(...) }</code> </pre> <br><p>  Dentro del controlador, obtenemos datos almacen√°ndolos en <strong>un b√∫fer de 4KB</strong> .  <code>rows.Next()</code> genera un viaje de red y llena el b√∫fer.  Si el b√∫fer no es suficiente, entonces vamos a la red para obtener los datos restantes.  M√°s visitas a la red, menos velocidad de procesamiento.  Por otro lado, dado que el l√≠mite del b√∫fer es 4KB, no olvidemos toda la memoria del proceso. </p><br><p>  Pero, por supuesto, quiero desenroscar el volumen del b√∫fer al m√°ximo para reducir el n√∫mero de solicitudes a la red y reducir la latencia de nuestro servicio.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Agregamos</a> esta oportunidad e intentamos descubrir la aceleraci√≥n esperada en <a href="">las pruebas sint√©ticas</a> : </p><br><pre> <code class="bash hljs">$ go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> -v -run=XXX -bench=. -benchmem goos: linux goarch: amd64 pkg: github.com/furdarius/pgxexperiments/bufsize BenchmarkBufferSize/4KB 5 315763978 ns/op 53112832 B/op 12967 allocs/op BenchmarkBufferSize/8KB 5 300140961 ns/op 53082521 B/op 6479 allocs/op BenchmarkBufferSize/16KB 5 298477972 ns/op 52910489 B/op 3229 allocs/op BenchmarkBufferSize/1MB 5 299602670 ns/op 52848230 B/op 50 allocs/op PASS ok github.com/furdarius/pgxexperiments/bufsize 10.964s</code> </pre> <br><p>  Se puede ver que no hay una gran diferencia en la velocidad de procesamiento.  Por qu√© </p><br><p>  Resulta que estamos limitados por el tama√±o del b√∫fer para enviar datos dentro de Postgres.  Este b√∫fer tiene un tama√±o <a href="">fijo</a> de 8 <strong>KB</strong> .  Con <code>strace</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puede ver</a> que el sistema operativo devuelve <code>8192</code> bytes en la llamada al sistema de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lectura</a> .  Y <code>tcpdump</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">confirma</a> esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">con el</a> tama√±o de los paquetes. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tom Lane</a> ( <em>uno de los principales desarrolladores del n√∫cleo de Postgres</em> ) <a href="">comenta</a> esto as√≠: </p><br><blockquote>  Tradicionalmente, al menos, ese era el tama√±o de los tampones de tuber√≠as en m√°quinas Unix, por lo que, en principio, este es el tama√±o de fragmento m√°s √≥ptimo para enviar datos a trav√©s de un z√≥calo Unix. </blockquote><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Andres Freund</a> ( <em>desarrollador de Postgres de EnterpriseDB</em> ) <a href="">cree</a> que un b√∫fer de 8 KB no es la mejor opci√≥n de implementaci√≥n hasta la fecha, y debe probar el comportamiento en diferentes tama√±os y con una configuraci√≥n de socket diferente. </p><br><p>  Tambi√©n debemos recordar que PgBouncer tambi√©n tiene un b√∫fer y su tama√±o se puede configurar con el par√°metro <code>pkt_buf</code> . </p><br><h2 id="oids">  OID </h2><br><p>  Otra caracter√≠stica del controlador pgx ( <em>v3</em> ): para cada conexi√≥n, realiza una solicitud a la base de datos para obtener informaci√≥n sobre el <strong>ID de objeto</strong> ( <em>OID</em> ). </p><br><p>  Estos identificadores se agregaron a Postgres para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">identificar de manera √∫nica</a> los objetos internos: filas, tablas, funciones, etc. </p><br><p>  El controlador utiliza el conocimiento de los <code>OIDs</code> para comprender qu√© columna de la base de datos en qu√© idioma primitivo agregar datos.  Para esto, <code>pgx</code> compatible con dicha tabla (la <em>clave es el nombre del tipo, el valor es el ID del objeto</em> ) </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]Value{ <span class="hljs-string"><span class="hljs-string">"_aclitem"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"_bool"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"_int4"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"_int8"</span></span>: <span class="hljs-number"><span class="hljs-number">55</span></span>, ... }</code> </pre> <br><p>  Esta implementaci√≥n lleva al hecho de que el controlador para cada conexi√≥n establecida con la base de datos realiza aproximadamente tres solicitudes para formar una tabla con un <code>Object ID</code> .  En el modo normal de funcionamiento de la base de datos y la aplicaci√≥n, el grupo de conexiones en Go le permite no generar nuevas conexiones a la base de datos.  Pero a la menor degradaci√≥n de la base de datos, el conjunto de conexiones en el lado de la aplicaci√≥n se agota y el n√∫mero de conexiones generadas por unidad de tiempo aumenta significativamente.  Las solicitudes de <code>OIDs</code> bastante pesadas, como resultado, el controlador puede llevar la base de datos a un estado cr√≠tico. </p><br><p>  Este es el momento en que tales solicitudes se vertieron en una de nuestras bases de datos: </p><br><p><img src="https://habrastorage.org/webt/lm/ra/vb/lmravbubtqb2ah8dvbvvpklbz8m.png"></p><br><p>  <strong>15 transacciones por minuto</strong> en modo normal, un salto de hasta <strong>6500 transacciones</strong> durante la degradaci√≥n. </p><br><p>  <strong>Que hacer</strong> </p><br><p>  En primer lugar, limite el tama√±o de su piscina desde arriba. </p><br><p>  Para la <code>database/sql</code> esto se puede hacer con la funci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DB.SetMaxOpenConns</a> .  Si abandona las interfaces de <code>database/sql</code> y usa <code>pgx.ConnPool</code> (el <em>grupo de conexiones implementado por el controlador</em> ), puede especificar <code>MaxConnections</code> (el <em>valor predeterminado es 5</em> ). </p><br><p>  Por cierto, al usar <code>pgx.ConnPool</code> controlador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reutilizar√° la</a> informaci√≥n sobre los <code>OIDs</code> recibidos y no realizar√° consultas a la base de datos para cada nueva conexi√≥n. </p><br><p>  Si no desea rechazar la <code>database/sql</code> , puede almacenar en cach√© la informaci√≥n sobre los <code>OIDs</code> usted mismo. </p><br><pre> <code class="go hljs">github.com/jackc/pgx/stdlib.OpenDB(pgx.ConnConfig{ CustomConnInfo: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *pgx.Conn)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*pgtype.ConnInfo, error)</span></span></span></span> { cachedOids = <span class="hljs-comment"><span class="hljs-comment">//  OIDs   . info := pgtype.NewConnInfo() info.InitializeDataTypes(cachedOids) return info, nil } })</span></span></code> </pre> <br><p>  Este es un m√©todo de trabajo, pero usarlo puede ser peligroso en dos condiciones: </p><br><ul><li>  usa enum o tipos de dominio en Postgres; </li><li>  Si el asistente falla, cambia la aplicaci√≥n a la r√©plica, que se vierte mediante la replicaci√≥n l√≥gica. </li></ul><br><p>  El cumplimiento de estas condiciones lleva al hecho de que los <code>OIDs</code> en cach√© se vuelven inv√°lidos.  Pero no podremos limpiarlos, porque no sabemos el momento de cambiar a una nueva base. </p><br><p>  En el mundo de <code>Postgres</code> , la replicaci√≥n f√≠sica generalmente se usa para organizar una alta disponibilidad, que copia las instancias de la base de datos poco a poco, por lo que los problemas con el almacenamiento en cach√© de <code>OIDs</code> rara vez se ven en la naturaleza.  ( <em>Pero es mejor consultar con su DBA c√≥mo funciona el modo de espera para usted</em> ). </p><br><p>  En la pr√≥xima versi√≥n principal del controlador <code>pgx</code> - <code>v4</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no habr√°</a> campa√±as para <code>OIDs</code> .  Ahora el controlador se basar√° solo en la lista de <code>OIDs</code> en el c√≥digo.  Para los tipos personalizados, tendr√° que tomar el control de la deserializaci√≥n en el lado de su aplicaci√≥n: el controlador simplemente entregar√° un trozo de memoria como una matriz de bytes. </p><br><h1 id="logirovanie-i-monitoring">  Registro y Monitoreo </h1><br><p>  El monitoreo y el registro ayudar√°n a notar problemas antes de que la base se bloquee. </p><br><p>  <code>database/sql</code> proporciona el m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DB.Stats ()</a> .  La instant√°nea de estado devuelta le dar√° una idea de lo que est√° sucediendo dentro del controlador. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DBStats <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MaxOpenConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// Pool State OpenConnections int InUse int Idle int // Counters WaitCount int64 WaitDuration time.Duration MaxIdleClosed int64 MaxLifetimeClosed int64 }</span></span></code> </pre> <br><p>  Si usa el grupo en <code>pgx</code> directamente, el m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ConnPool.Stat ()</a> le dar√° informaci√≥n similar: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ConnPoolStat <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MaxConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CurrentConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> AvailableConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> }</code> </pre> <br><p>  El registro es igualmente importante, y <code>pgx</code> permite hacer esto.  El controlador acepta la interfaz <code>Logger</code> , al implementar el cual, obtiene todos los eventos que ocurren dentro del controlador. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Logger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Log a message at the given level with data key/value pairs. // data may be nil. Log(level LogLevel, msg string, data map[string]interface{}) }</span></span></code> </pre> <br><p>  Lo m√°s probable es que ni siquiera tenga que implementar esta interfaz usted mismo.  En <code>pgx</code> para <code>pgx</code> , hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conjunto de adaptadores</a> para los registradores m√°s populares, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uber-go / zap</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sirupsen / logrus</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rs / zerolog</a> . </p><br><h1 id="infrastruktura">  La infraestructura </h1><br><p>  Casi siempre que <code>Postgres</code> con <code>Postgres</code> utilizar√°s un <strong>agrupador de conexiones</strong> , y ser√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PgBouncer</a> ( <em>u <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">odisea</a> , si eres Yandex</em> ). </p><br><p>  Por eso, puedes leer en el excelente art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">brandur.org/postgres- connections</a> .  En resumen, cuando el n√∫mero de clientes <strong>supera los 100, la</strong> velocidad de procesamiento de las solicitudes comienza a degradarse.  Esto sucede debido a las caracter√≠sticas de la implementaci√≥n de Postgres: el lanzamiento de un proceso separado para cada conexi√≥n, el mecanismo para eliminar instant√°neas y el uso de memoria compartida para la interacci√≥n, todo esto afecta. </p><br><p>  Aqu√≠ est√° el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">punto de referencia de</a> varias implementaciones de agrupadores de conexiones: <br><img src="https://habrastorage.org/webt/im/p1/-n/imp1-nuasdxn1wmve7l89rrvmbw.png"></p><br><p>  Y ancho de banda de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">referencia</a> con y sin PgBouncer. </p><br><p><img src="https://habrastorage.org/webt/jc/cp/21/jccp2150oefyeiixeu005lpsl_0.png"></p><br><p>  Como resultado, su infraestructura se ver√° as√≠: </p><br><p><img src="https://habrastorage.org/webt/bf/ee/ok/bfeeokt_cdojbuddo7_rhzddjis.png"></p><br><p>  Donde <code>Server</code> es el proceso que procesa las solicitudes de los usuarios.  Este proceso gira en <code>kubernetes</code> en 3 copias ( <em>al menos</em> ).  Por separado, en un servidor de hierro, hay <code>Postgres</code> , cubierto por <code>PgBouncer'</code> .  <code>PgBouncer</code> s√≠ <code>PgBouncer</code> solo subproceso, por lo que lanzamos varios <code>HAProxy</code> cuyo tr√°fico equilibramos con <code>HAProxy</code> .  Como resultado, obtenemos dicha cadena de ejecuci√≥n de consultas en la base de datos: <code>   ‚Üí HAProxy ‚Üí PgBouncer ‚Üí Postgres</code> . </p><br><p>  <code>PgBouncer</code> puede funcionar en tres modos: </p><br><ul><li>  <strong>Agrupaci√≥n de sesiones</strong> : para cada sesi√≥n, se emite una conexi√≥n y se le asigna durante toda la vida √∫til. </li><li>  <strong>Agrupaci√≥n de transacciones</strong> : la conexi√≥n vive mientras se ejecuta la transacci√≥n.  Tan pronto como se complete la transacci√≥n, <code>PgBouncer</code> toma esta conexi√≥n y la devuelve a otra transacci√≥n.  Este modo permite una muy buena eliminaci√≥n de compuestos. </li><li>  <strong>Agrupaci√≥n de instrucciones</strong> : modo <strong>obsoleto</strong> .  Fue creado solo para soportar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PL / Proxy</a> . </li></ul><br><p>  Puede ver la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">matriz</a> de qu√© propiedades est√°n disponibles en cada modo.  Elegimos <strong>Transaction Pooling</strong> , pero tiene limitaciones para trabajar con <code>Prepared Statements</code> . </p><br><h2 id="transaction-pooling--prepared-statements">  Agrupaci√≥n de transacciones + extractos preparados </h2><br><p>  Imaginemos que queremos preparar una solicitud y luego ejecutarla.  En alg√∫n momento, comenzamos una transacci√≥n en la que enviamos una solicitud de preparaci√≥n, y obtenemos la identificaci√≥n de la solicitud preparada de la base de datos. </p><br><p><img src="https://habrastorage.org/webt/pb/tu/bq/pbtubqa7cvmly0ntnhs0dwc9etc.png"></p><br><p>  Luego, en cualquier otro momento, generamos otra transacci√≥n.  En √©l, pasamos a la base de datos y queremos cumplir con la solicitud utilizando el identificador con los par√°metros especificados. </p><br><p><img src="https://habrastorage.org/webt/uy/ci/h4/uycih4iuh8aasw43aqodbsxolac.png"></p><br><p>  En el modo de <strong>Agrupaci√≥n de</strong> transacciones, se pueden ejecutar dos transacciones en diferentes conexiones, pero el <strong>ID de estado de cuenta</strong> solo <strong>es</strong> v√°lido dentro de una conexi√≥n.  Obtenemos una <code>prepared statement does not exist</code> error al intentar ejecutar una solicitud. </p><br><p>  Lo m√°s desagradable: dado que durante el desarrollo y las pruebas la carga es peque√±a, <code>PgBouncer</code> menudo emite la misma conexi√≥n y todo funciona correctamente.  Pero tan pronto como nos lanzamos a la producci√≥n, las solicitudes comienzan a caer con un error. </p><br><p>  Ahora encuentre <code>Prepared Statements</code> en este c√≥digo: </p><br><pre> <code class="go hljs">sql := <span class="hljs-string"><span class="hljs-string">`select * from places where city = ?`</span></span> rows, err := s.db.Query(sql, city)</code> </pre> <br><p>  ¬°No lo ver√°s!  La preparaci√≥n de la consulta se producir√° impl√≠citamente dentro de la <code>Query()</code> .  Al mismo tiempo, la preparaci√≥n y ejecuci√≥n de la solicitud se realizar√° en diferentes transacciones y recibiremos completamente todo lo que describ√≠ anteriormente. </p><br><p>  <strong>Que hacer</strong> </p><br><p>  La primera opci√≥n m√°s f√°cil es <strong>cambiar <code>PgBouncer</code> a la <code>Session pooling</code></strong> .  Se asigna una conexi√≥n a la sesi√≥n, todas las transacciones comienzan a realizarse en esta conexi√≥n y las solicitudes preparadas funcionan correctamente.  Pero en este modo, la eficiencia de la utilizaci√≥n de compuestos deja mucho que desear.  Por lo tanto, esta opci√≥n no se considera. </p><br><p>  La segunda opci√≥n es <strong>preparar una solicitud en el lado del cliente</strong> .  No quiero hacer esto por dos razones: </p><br><ul><li>  Posibles vulnerabilidades de SQL.  El desarrollador puede olvidar o hacer un escape incorrecto. </li><li>  Escapar de los par√°metros de consulta cada vez que tenga que escribir con las manos. </li></ul><br><p>  Otra opci√≥n es <strong>ajustar expl√≠citamente cada solicitud en una transacci√≥n</strong> .  Despu√©s de todo, mientras dure la transacci√≥n, <code>PgBouncer</code> no retoma la conexi√≥n.  Esto funciona, pero, adem√°s de la verbosidad en nuestro c√≥digo, tambi√©n recibimos m√°s llamadas de red: Comenzar, Preparar, Ejecutar, Confirmar.  Total de 4 llamadas de red por solicitud.  La latencia est√° creciendo. </p><br><p>  Pero lo quiero de manera segura, conveniente y eficiente.  ¬°Y hay tal opci√≥n!  Puede decirle expl√≠citamente al controlador que desea <strong>usar el modo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Consulta</a> simple</strong> .  En este modo, no habr√° preparaci√≥n y toda la solicitud pasar√° en una llamada de red.  En este caso, el controlador realizar√° el blindaje de cada uno de los par√°metros (las cadenas de conformaci√≥n <em><code>standard_conforming_strings</code> deben activarse en el nivel base o al establecer una conexi√≥n</em> ). </p><br><pre> <code class="go hljs">cfg := pgx.ConnConfig{ ... RuntimeParams: <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{ <span class="hljs-string"><span class="hljs-string">"standard_conforming_strings"</span></span>: <span class="hljs-string"><span class="hljs-string">"on"</span></span>, }, PreferSimpleProtocol: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }</code> </pre> <br><h1 id="otmena-zaprosov">  Cancelar solicitudes </h1><br><p>  Los siguientes problemas est√°n relacionados con la cancelaci√≥n de solicitudes en el lado de la aplicaci√≥n. </p><br><p>  Echa un vistazo a este c√≥digo.  ¬øD√≥nde est√°n las trampas? </p><br><pre> <code class="go hljs">rows, err := s.db.QueryContext(ctx, ...)</code> </pre> <br><p>  Go tiene un m√©todo para controlar el flujo de ejecuci√≥n del programa: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">context.Context</a> .  En este c√≥digo, pasamos el <code>ctx</code> controlador para que cuando se cierre el contexto, el controlador cancele la solicitud en el nivel de la base de datos. </p><br><p>  Al mismo tiempo, se espera que ahorremos recursos cancelando solicitudes que nadie est√° esperando.  Pero al cancelar una solicitud, <code>PgBouncer</code> versi√≥n <em>1.7</em> env√≠a informaci√≥n a la conexi√≥n de que esta conexi√≥n est√° lista para su uso, y luego la devuelve al grupo.  Este comportamiento de <code>PgBouncer'</code> error al controlador que, al enviar la siguiente solicitud, recibe al instante <code>ReadyForQuery</code> en respuesta.  Al final, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">detectamos errores inesperados de ReadyForQuery</a> . </p><br><p>  A <code>PgBouncer</code> versi√≥n <em>1.8 de</em> <code>PgBouncer</code> <em>,</em> este comportamiento se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ha solucionado</a> .  Use la versi√≥n actual de <code>PgBouncer</code> . </p><br><p>  Y, aunque, en este caso, los errores desaparecer√°n, permanecer√° un comportamiento interesante.  En algunos casos, nuestra aplicaci√≥n puede recibir respuestas no a su solicitud, sino a la vecina (lo principal es que las solicitudes coinciden con el tipo y el orden de los datos solicitados).  Es decir, por ejemplo, a la consulta <code>where user_id = 2</code> , se devolver√° la respuesta de la consulta <code>where user_id = 42</code> .  Esto se debe al procesamiento de solicitudes de cancelaci√≥n en diferentes niveles: a nivel del grupo de controladores y el grupo de rebotes. </p><br><h3 id="otlozhennaya-otmena">  Cancelaci√≥n retrasada </h3><br><p>  Para cancelar la solicitud, necesitamos crear una nueva conexi√≥n a la base de datos y solicitar una cancelaci√≥n.  <code>Postgres</code> crea un proceso separado para cada conexi√≥n.  Enviamos un comando para cancelar la solicitud <strong>actual</strong> en un proceso espec√≠fico.  Para hacer esto, cree una nueva conexi√≥n y transfiera la ID de proceso (PID) que nos interese.  Pero mientras el comando de cancelaci√≥n vuela a la base, la solicitud cancelada puede finalizar por s√≠ sola. </p><br><p><img src="https://habrastorage.org/webt/us/xf/v_/usxfv_i0ze_axpmjtlir183reiu.png"></p><br><p>  <code>Postgres</code> ejecutar√° el comando y cancelar√° la solicitud <strong>actual</strong> en el proceso dado.  Pero la solicitud actual no ser√° la que quer√≠amos cancelar inicialmente.  Debido a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este comportamiento</a> cuando se trabaja con <code>Postgres</code> con <code>PgBouncer</code> m√°s seguro no cancelar la solicitud en el nivel del controlador.  Para hacer esto, puede configurar la <code>CustomCancel</code> , que no cancelar√° la solicitud, incluso si <code>context.Context</code> utiliza <code>context.Context</code> . </p><br><pre> <code class="go hljs">cfg := pgx.ConnConfig{ ... CustomCancel: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_ *pgx.Conn)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }, }</code> </pre> <br><h1 id="cheklist-po-rabote-s-postgres">  Lista de verificaci√≥n de Postgres </h1><br><p>  En lugar de conclusiones, decid√≠ hacer una lista de verificaci√≥n para trabajar con Postgres.  Esto deber√≠a ayudar al art√≠culo a caber en mi cabeza. </p><br><ul><li>  Use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/jackc/pgx</a> como controlador para trabajar con Postgres. </li><li>  Limite el tama√±o del grupo de conexiones desde arriba. </li><li>  <code>OIDs</code> cach√© o use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pgx.ConnPool</a> si est√° trabajando con <code>pgx</code> versi√≥n 3. </li><li>  Recopile m√©tricas del grupo de conexiones utilizando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DB.Stats ()</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ConnPool.Stat ()</a> . </li><li>  Registre lo que est√° sucediendo en el controlador. </li><li>  Use el modo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Consulta</a> simple para evitar problemas con la preparaci√≥n de consultas en el modo transaccional <code>PgBouncer</code> . </li><li>  Actualiza <code>PgBouncer</code> a la √∫ltima versi√≥n. </li><li>  Tenga cuidado con la cancelaci√≥n de solicitudes de la aplicaci√≥n. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461935/">https://habr.com/ru/post/461935/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461919/index.html">Reutilizando formularios en React</a></li>
<li><a href="../461921/index.html">HDMI-LVDS. Desarrollo en TSUMV59 de MStar</a></li>
<li><a href="../461923/index.html">Jornada de Puertas Abiertas de JetBrains en San Petersburgo: video</a></li>
<li><a href="../461927/index.html">Aprendizaje de clasificaci√≥n activa</a></li>
<li><a href="../461929/index.html">Supervisi√≥n y comprobaci√≥n del estado de SSD en Linux</a></li>
<li><a href="../461937/index.html">Ley de Parkinson y c√≥mo romperla</a></li>
<li><a href="../461939/index.html">A√±o de aventuras con grafeno-pit√≥n</a></li>
<li><a href="../461941/index.html">Masajearlo</a></li>
<li><a href="../461945/index.html">El resumen de eventos para profesionales de recursos humanos en el campo de TI para agosto de 2019</a></li>
<li><a href="../461949/index.html">AppCode 2019.2: Swift 5.1, an√°lisis de cobertura de c√≥digo por pruebas, visualizaci√≥n de c√≥digo desmontado y m√°s</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>