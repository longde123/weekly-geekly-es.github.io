<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêö üí∑ üßñ Ivan Tulup: ass√≠ncrono em JS sob o cap√¥ üë©‚Äçüë©‚Äçüë¶‚Äçüë¶ üöª ü§∑üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Voc√™ conhece Ivan Tulup? Provavelmente sim, voc√™ ainda n√£o sabe que tipo de pessoa √© essa e precisa cuidar muito do estado do sistema cardiovascular d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ivan Tulup: ass√≠ncrono em JS sob o cap√¥</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/417461/">  Voc√™ conhece Ivan Tulup?  Provavelmente sim, voc√™ ainda n√£o sabe que tipo de pessoa √© essa e precisa cuidar muito do estado do sistema cardiovascular dele. <br><br>  Sobre isso e como o assincronismo funciona no JS, como o Event Loop funciona nos navegadores e no Node.js, existem diferen√ßas e talvez coisas semelhantes foram contadas por <strong>Mikhail Bashurov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">SaitoNakamura</a> ) em seu relat√≥rio sobre o RIT ++.  Temos o prazer de compartilhar com voc√™ a transcri√ß√£o desta apresenta√ß√£o informativa. <br><br><img src="https://habrastorage.org/webt/mv/fj/ah/mvfjah-dahl8fndi-w8rt4qkbxw.jpeg"><br><br>  <strong>Sobre o palestrante:</strong> Mikhail Bashurov √© um desenvolvedor web fullstack em JS e .NET da Luxoft.  Ele adora uma bela interface do usu√°rio, testes ecol√≥gicos, transpila√ß√£o, compila√ß√£o, compilador que permite a t√©cnica e melhora a experi√™ncia do desenvolvedor. <br><br>  <strong>Nota do editor:</strong> o relat√≥rio de Mikhail foi acompanhado n√£o apenas por slides, mas por um projeto de demonstra√ß√£o no qual voc√™ pode clicar nos bot√µes e assistir de forma independente √† execu√ß√£o de embaralhamento.  A melhor op√ß√£o seria abrir a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">apresenta√ß√£o</a> em uma guia adjacente e consult√°-la periodicamente, mas o texto tamb√©m fornecer√° links para p√°ginas espec√≠ficas.  E agora passamos a palavra ao orador, aproveite a leitura. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bUx8wk4LdoY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h2>  Av√¥ Ivan Tulup </h2><br>  Eu tive uma candidatura para Ivan Tulup. <br><br><img src="https://habrastorage.org/webt/hl/8x/lx/hl8xlx_fubycz-ivega_hinmhp0.png"><br><br>  Mas eu decidi seguir um caminho mais conformista, ent√£o conhe√ßa o av√¥ Ivan Tulup! <br><br><img src="https://habrastorage.org/webt/qd/jc/dn/qdjcdntndkzeyiuw3zpwt4vos74.png"><br><br>  De fato, apenas duas coisas precisam ser conhecidas sobre ele: <br><br><ol><li>  Ele gosta de jogar cartas. </li><li>  Ele, como todas as pessoas, tem um cora√ß√£o e bate. </li></ol><br><h2>  Fatos de ataque card√≠aco </h2><br>  Voc√™ j√° deve ter ouvido falar que os casos de doen√ßas card√≠acas e mortalidade deles recentemente se tornaram mais frequentes.  Provavelmente a doen√ßa card√≠aca mais comum √© um ataque card√≠aco, ou seja, um ataque card√≠aco. <br><br>  O que √© interessante sobre ataque card√≠aco? <br><br><ul><li>  Na maioria das vezes, ocorre na segunda-feira de manh√£. </li><li>  Em pessoas solteiras, o risco de um ataque card√≠aco √© duas vezes maior.  Aqui, talvez, o ponto esteja apenas na correla√ß√£o, e n√£o em um relacionamento causal.  Infelizmente (ou felizmente), no entanto, √© assim. </li><li>  Dez condutores morreram de ataque card√≠aco durante a condu√ß√£o (trabalho aparentemente muito nervoso!). </li><li>  Um ataque card√≠aco √© uma necrose do m√∫sculo card√≠aco causada pela falta de fluxo sangu√≠neo. </li></ul><br>  Temos uma art√©ria coron√°ria que traz sangue para o m√∫sculo (mioc√°rdio).  Se o sangue come√ßa a fluir mal para ele, o m√∫sculo morre gradualmente.  Naturalmente, isso tem um efeito extremamente negativo sobre o cora√ß√£o e seu trabalho. <br><br>  O av√¥ Ivan Tulup tamb√©m tem um cora√ß√£o e bate.  Mas nosso cora√ß√£o bombeia sangue, e o cora√ß√£o de Ivan Tulup bombeia nosso c√≥digo e nossas tristezas. <br><br><h2>  Tasky: um grande c√≠rculo de circula√ß√£o sangu√≠nea <br></h2><br>  O que s√£o tarefas?  O que geralmente pode ser pregui√ßoso em um navegador?  Por que eles s√£o necess√°rios? <br><br>  Por exemplo, executamos c√≥digo de um script.  Este √© um batimento card√≠aco e agora temos fluxo sangu√≠neo.  Clicamos no bot√£o e assinamos o evento - o manipulador de eventos desse evento cuspiu - o retorno de chamada que enviamos.  Eles definiram Timeout, o retorno de chamada funcionou - outra tarefa.  E assim, em partes, um batimento card√≠aco √© uma tarefa. <br><br><img src="https://habrastorage.org/webt/vz/sb/0z/vzsb0znwotnkpldqmb2chhwblxs.png"><br><br>  Existem muitas fontes diferentes de repolho, de acordo com a especifica√ß√£o, existem muitas.  Nosso cora√ß√£o continua batendo e, enquanto bate, est√° tudo bem conosco. <br><br><h3>  Loop de eventos no navegador: vers√£o simplificada <br></h3><br>  Isso pode ser representado em um diagrama muito simples. <br><br><img src="https://habrastorage.org/webt/hy/zf/2p/hyzf2pktcyzag0oroich978odpa.png"><br><br><ul><li>  H√° uma tarefa, n√≥s a conclu√≠mos. </li><li>  Em seguida, executamos a renderiza√ß√£o do navegador. </li></ul><br>  Mas, na verdade, isso n√£o √© necess√°rio, porque em alguns casos o navegador pode n√£o renderizar entre duas tarefas. <br><br>  Isso pode acontecer, por exemplo, se o navegador pode decidir agrupar v√°rios tempos limite ou v√°rios eventos de rolagem.  Ou, em algum momento, algo d√° errado, e o navegador decide, em vez de 60 qps (a taxa de quadros usual para que tudo corra bem e suavemente), para mostrar 30 qps.  Assim, ele ter√° muito mais tempo para executar seu c√≥digo e outros trabalhos √∫teis, e poder√° executar v√°rios choques. <br><br>  Portanto, a renderiza√ß√£o n√£o √© realmente executada ap√≥s cada tarefa. <br><br><h3>  Tasky: classifica√ß√£o <br></h3><br>  Existem dois tipos de opera√ß√µes em potencial: <br><br><ol><li>  Liga√ß√£o de E / S; </li><li>  CPU ligado. </li></ol><br>  <strong>CPU bound</strong> √© o nosso trabalho √∫til que fazemos (acredite, mostre, etc.) <br><br>  <strong>Os limites de E / S</strong> s√£o os pontos nos quais podemos compartilhar nossas tarefas.  Pode ser: <br><br><ul><li>  Timeout </li></ul>  Criamos setTimeout 5000 ms e esperamos apenas esses 5000 ms, mas podemos fazer outro trabalho √∫til.  Somente quando esse tempo passa, recebemos o retorno de chamada e fazemos algum trabalho nele. <br><br><ul><li>  xhr / buscar. </li></ul>  Fomos online.  Enquanto aguardamos uma resposta da rede, estamos apenas aguardando, mas tamb√©m podemos fazer algo √∫til. <br><br><ul><li>  Rede (OBD). </li></ul>  Ou, por exemplo, vamos ao Network BD.  Tamb√©m estamos falando sobre o Node.js, inclusive, e se quisermos acessar a rede a partir do Node.js. - esta √© a mesma tarefa potencial de E / S vinculada (entrada / sa√≠da). <br><br><ul><li>  Arquivo </li></ul>  Leia o arquivo - potencialmente n√£o √© uma tarefa vinculada √† CPU.  No Node.js, ele √© executado no pool de encadeamentos devido a uma API Linux ligeiramente torta, para ser sincero. <br><br>  Ent√£o CPUbound √©: <br><br><ul><li>  Por exemplo, quando fazemos um loop for de / for (;;) ou passamos pela matriz de alguma forma usando m√©todos adicionais: filtro, mapa etc. </li><li>  JSON.parse ou JSON.stringify, ou seja, serializa√ß√£o / desserializa√ß√£o de mensagens.  Tudo isso √© feito na CPU, n√£o podemos esperar que tudo seja executado magicamente em algum lugar. </li><li>  Contagem de hashes, ou seja, por exemplo, minera√ß√£o de criptografia. </li></ul><br>  Claro, a criptografia tamb√©m pode ser extra√≠da na GPU, mas eu acho - GPU, CPU - voc√™ entende essa analogia. <br><br><h3>  Tasky: arritmia e trombo </h3><br>  Como resultado, verifica-se que o nosso cora√ß√£o bate: faz uma tarefa, a segunda, a terceira - at√© que fa√ßamos algo errado.  Por exemplo, passamos por uma matriz de 1 milh√£o de elementos e contamos a soma.  Parece que isso n√£o √© t√£o dif√≠cil, mas pode levar um tempo tang√≠vel.  Se tomarmos constantemente um tempo tang√≠vel sem liberar tarefas, nossa renderiza√ß√£o n√£o poder√° ser executada.  Ele pairava nesse desejo, e toda a arritmia come√ßa. <br><br>  Acho que todo mundo entende que a arritmia √© uma doen√ßa card√≠aca bastante desagrad√°vel.  Mas voc√™ ainda pode morar com ele.  O que acontece se voc√™ colocar uma tarefa que simplesmente trava o Loop de Eventos inteiro em um loop sem fim?  Voc√™ meio que coloca um co√°gulo de sangue na coron√°ria ou em alguma outra art√©ria, e tudo ficar√° completamente triste.  Infelizmente, nosso av√¥ Ivan Tulup vai morrer. <br><br><h3>  Ent√£o, o av√¥ Ivan morreu ... <br></h3><br><img src="https://habrastorage.org/webt/8t/nq/gc/8tnqgc8lygwpsdvts0b3xpqgtta.png"><br><br>  Para n√≥s, isso significa que a guia inteira congela completamente - voc√™ n√£o pode clicar em nada e o Chrome diz: "Ah, Snap!" <br><br>  Isso √© muito pior do que os erros do site quando algo deu errado.  Mas se tudo travou, e mesmo, provavelmente, a CPU foi carregada e o usu√°rio geralmente travou, o mais prov√°vel √© que ele nunca volte ao seu site. <br><br>  Portanto, a id√©ia √© a seguinte: temos uma tarefa e n√£o precisamos ficar nessa tarefa por muito tempo.  Precisamos liber√°-lo rapidamente, para que o navegador, se houver, possa renderizar (se quiser).  Se voc√™ n√£o quiser - √≥timo, dance! <br><br><h2>  Philip Roberts Demo: Lupa por Philip Roberts <br></h2><br>  Considere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um exemplo</a> : <br><br><pre><code class="javascript hljs">$.on(<span class="hljs-string"><span class="hljs-string">'button'</span></span>, <span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'click'</span></span>); }); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span> log(<span class="hljs-string"><span class="hljs-string">"timeout"</span></span>); }. <span class="hljs-number"><span class="hljs-number">5000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(‚ÄúHello world<span class="hljs-string"><span class="hljs-string">");</span></span></code> </pre> <br>  A ess√™ncia √© a seguinte: temos um bot√£o, assinamos (addEventListener), o Timeout √© chamado por 5 segundos e imediatamente no console.log, escrevemos ‚ÄúOl√°, mundo!‚Äù. Em setTimeout, escrevemos Timeout, em onClick, escrevemos Click. <br><br>  O que acontecer√° se a rodarmos e clicarmos muitas vezes no bot√£o - quando o Timeout ser√° realmente executado?  Vamos ver a demonstra√ß√£o: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bUx8wk4LdoY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  O c√≥digo come√ßa a executar, entra na pilha, o Timeout continua.  Enquanto isso, clicamos no bot√£o.  Na parte inferior da fila, v√°rios eventos foram adicionados.  Enquanto o Click est√° sendo executado, o Tempo limite aguarda, embora cinco segundos tenham se passado. <br><br>  Aqui, o onClick √© r√°pido, mas se voc√™ colocar uma tarefa mais longa, tudo congelar√°, como j√° explicado.  Este √© um exemplo muito simplificado.  Aqui est√° uma vez, mas nos navegadores, de fato, nem tudo √© assim. <br><br>  Em que ordem os eventos s√£o executados - o que a especifica√ß√£o HTML diz? <br><br>  Ela diz o seguinte: temos 2 conceitos: <br><br><ol><li>  fonte de tarefas; </li><li>  fila de tarefas. </li></ol><br>  A fonte da tarefa √© um tipo de tarefa.  Pode ser a intera√ß√£o do usu√°rio, ou seja, onClick, onChange - algo com o qual o usu√°rio interage;  ou timers, ou seja, setTimeout e setInterval, ou PostMessages;  ou mesmo tipos completamente selvagens, como a origem da tarefa Serializa√ß√£o do Canvas Blob - tamb√©m um tipo separado. <br><br>  A especifica√ß√£o diz que, para a mesma tarefa, as tarefas de origem ter√£o a garantia de serem executadas na ordem em que forem adicionadas.  Para todo o resto, nada √© garantido, porque pode haver um n√∫mero ilimitado de filas de tarefas.  O navegador decide quantos haver√°.  Com a ajuda da fila de tarefas e sua cria√ß√£o, o navegador pode priorizar determinadas tarefas. <br><br><h3>  Prioridades do navegador e filas de tarefas <br></h3><br><img src="https://habrastorage.org/webt/xv/fu/s9/xvfus9kn-18e_oxy00s_xwm6vdq.png"><br><br>  Imagine que temos 3 linhas: <br><br><ol><li>  intera√ß√£o do usu√°rio; </li><li>  timeouts </li><li>  postar mensagens. </li></ol><br>  O navegador come√ßa a obter tarefas dessas filas: <br><br><ul><li>  Primeiro, ele assume a intera√ß√£o do usu√°rio do <strong>Focus</strong> - isso √© muito importante - um batimento card√≠aco se foi. <br></li><li>  Ent√£o ele pega <strong>postMessages</strong> - bem, postMessages √© uma prioridade bastante alta, legal! <br></li><li>  O pr√≥ximo, <strong>onChange,</strong> tamb√©m √© novamente da intera√ß√£o do usu√°rio em prioridade. <br></li><li>  O pr√≥ximo <strong>onClick √©</strong> enviado.  A fila de intera√ß√£o do usu√°rio terminou, exibimos para o usu√°rio tudo o que √© necess√°rio. <br></li><li>  Ent√£o pegamos <strong>setInterval</strong> , adicionamos postMessages. <br></li><li>  <strong>setTimeout executar√° apenas os mais recentes</strong> .  Ele estava em algum lugar no final da linha. <br></li></ul><br>  Este √© novamente um exemplo muito simplificado e, infelizmente, <strong>ningu√©m pode garantir como isso funcionar√° nos navegadores</strong> , porque eles mesmos decidem tudo isso.  Voc√™ precisa testar isso sozinho se quiser descobrir o que √©. <br><br>  Por exemplo, postMessages tem preced√™ncia sobre setTimeout.  Voc√™ pode ter ouvido falar em setImmediate, que, por exemplo, nos navegadores IE, era apenas nativo.  Mas existem polyfiles que s√£o baseados principalmente n√£o no setTimeout, mas na cria√ß√£o de um canal postMessages e na assinatura dele.  Isso geralmente funciona mais r√°pido porque os navegadores a priorizam. <br><br>  Bem, essas tarefas s√£o realizadas.  Em que ponto conclu√≠mos nossa tarefa e entendemos que podemos dar o pr√≥ximo, ou que podemos renderizar? <br><br><h3>  Stack </h3><br>  A pilha √© uma estrutura de dados simples que funciona com o princ√≠pio de "√∫ltimo a entrar - primeiro a sair", ou seja,  "Coloque o √∫ltimo - voc√™ recebe o primeiro <strong>.</strong> "  A contraparte mais pr√≥xima, provavelmente real, √© um baralho de cartas.  Portanto, nosso av√¥ Ivan Tulup adora jogar cartas. <br><br><img src="https://habrastorage.org/webt/5b/03/dh/5b03dh5di0r9oktsyvekmflkey4.png"><br><br>  O exemplo acima, no qual existe algum c√≥digo, o mesmo exemplo pode ser cutucado na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">apresenta√ß√£o</a> .  Em algum lugar que chamamos handleClick, digite console.log, chame showPopup e window.  confirmar.  Vamos formar uma pilha. <br><br><ul><li>  Ent√£o, primeiro pegamos o handleClick e enviamos a chamada para essa fun√ß√£o para a pilha - √≥timo! </li><li>  Ent√£o n√≥s entramos no corpo dele e o executamos. </li><li>  Colocamos console.log na pilha e a executamos imediatamente, porque tudo existe para execut√°-la. </li><li>  Em seguida, colocamos showConfirm - esta √© uma chamada de fun√ß√£o - √≥timo. </li><li>  Colocamos fun√ß√µes na pilha - colocamos seu corpo, ou seja, window.confirm. </li></ul><br>  N√£o temos mais nada - estamos fazendo isso.  Uma janela ser√° exibida: ‚ÄúVoc√™ tem certeza?‚Äù, Clique em ‚ÄúSim‚Äù e tudo sair√° da pilha.  Agora terminamos o corpo showConfirm e o corpo handleClick.  Nossa pilha √© limpa e podemos passar para a pr√≥xima tarefa.  Pergunta: OK, agora eu sei que voc√™ precisa dividir tudo em peda√ßos pequenos.  Como posso, por exemplo, fazer isso no caso mais elementar? <br><br><h3>  Particionando uma matriz em peda√ßos e processando-os de forma ass√≠ncrona </h3><br>  Vejamos o exemplo mais "testa".  Eu o aviso imediatamente: por favor, n√£o tente repetir isso em casa - ele n√£o ser√° compilado. <br><br><img src="https://habrastorage.org/webt/on/a4/kz/ona4kz7lojjan82vfis4dkoxvh0.png"><br><br>  Temos uma matriz grande e grande e queremos calcular algo com base nela, por exemplo, para analisar alguns dados bin√°rios.  Podemos simplesmente dividi-lo em peda√ßos: processar essa pe√ßa, isso e isso.  Selecionamos o tamanho do peda√ßo, por exemplo, 10 mil elementos, e consideramos quantos peda√ßos teremos.  Temos uma fun√ß√£o parseData que entra no limite da CPU e pode realmente fazer algo pesado.  Em seguida, dividimos o array em partes, setTimeout (() =&gt; parseData (slice), 0). <br><br>  Nesse caso, o navegador poder√° priorizar novamente a intera√ß√£o do usu√°rio e renderizar no meio.  Ou seja, voc√™ pelo menos libera seu Loop de Eventos, e ele continua funcionando.  Seu cora√ß√£o continua batendo, e isso √© bom. <br><br>  Mas este √© realmente um exemplo muito "frontal".  Existem muitas APIs nos navegadores para ajud√°-lo a fazer isso de uma maneira mais especializada. <br><br>  Al√©m de setTimeout e setInterval, existem APIs que ultrapassam os limites, como, por exemplo, requestAnimationFrame e requestIdleCallback. <br><br>  Provavelmente muitos est√£o familiarizados com <strong>requestAnimationFrame</strong> e at√© j√° o usam.  √â executado antes da renderiza√ß√£o.  Seu charme √© que, em primeiro lugar, ele tenta executar a cada 60 fps (ou 30 fps) e, em segundo lugar, tudo isso √© feito imediatamente antes da cria√ß√£o do CSS Object Model, etc. <br><br><img src="https://habrastorage.org/webt/0-/hy/qt/0-hyqtkge9dm9ayeciqrrzgjors.png"><br><br>  Portanto, mesmo se voc√™ tiver v√°rios requestAnimationFrame, eles realmente agrupar√£o todas as altera√ß√µes e o quadro ser√° conclu√≠do.  No caso de setTimeout, voc√™ certamente n√£o pode obter essa garantia.  Um setTimeout mudar√° uma coisa, a outra outra, e entre a renderiza√ß√£o poder√° escorregar - voc√™ ter√° uma sacudida na tela ou outra coisa.  RequestAnimationFrame √© √≥timo para isso. <br><br>  Al√©m disso, tamb√©m h√° <strong>requestIdleCallback.</strong>  Talvez voc√™ tenha ouvido falar que ele √© usado no React v16.0 (Fiber).  O RequestIdleCallback funciona de tal forma que, se o navegador entender que h√° tempo entre os quadros (60 fps) para fazer algo √∫til e, ao mesmo tempo, eles j√° fizeram tudo - eles executaram a tarefa, requestAnimationFrame - parece legal, ent√£o pode produzir pequenos quanta, digamos, 50 ms cada, para que voc√™ possa fazer alguma coisa (modo IDLE). <br><br>  N√£o est√° no diagrama acima, porque n√£o est√° localizado em nenhum local espec√≠fico.  O navegador pode decidir coloc√°-lo antes do quadro, ap√≥s o quadro, entre o requestAnimationFrame e a renderiza√ß√£o, ap√≥s a tarefa, antes da tarefa.  Ningu√©m pode garantir isso. <br><br>  √â garantido a voc√™ que, se voc√™ tiver um trabalho que n√£o esteja relacionado √† altera√ß√£o do DOM (porque requestAnimationFrame √© anima√ß√£o e assim por diante), embora n√£o seja uma super prioridade, mas tang√≠vel, requestIdleCallback √© a sua sa√≠da. <br><br>  Portanto, se tivermos uma opera√ß√£o longa vinculada √† CPU, podemos tentar dividi-la em peda√ßos. <br><br><ul><li>  Se for uma altera√ß√£o do DOM, use <strong>requestAnimationFrame.</strong> <br></li><li>  Se esta for uma tarefa n√£o priorit√°ria, de curta dura√ß√£o e n√£o dif√≠cil, que n√£o <strong>sobrecarregar√° a</strong> CPU, <strong>requestIdleCallback.</strong> <br></li><li>  Se tivermos uma tarefa grande e poderosa que precisa ser executada constantemente, vamos al√©m do Event Loop e usaremos os WebWorkers.  N√£o h√° outro caminho. <br></li></ul><br>  <strong>Tarefas nos navegadores:</strong> <br><br><ol><li>  Esmague tudo em pequenas tarefas. </li><li>  Existem muitos tipos de tarefas. </li><li>  As tarefas s√£o priorizadas por esses tipos atrav√©s de filas de especifica√ß√£o. </li><li>  Muito √© decidido pelos navegadores, e a √∫nica maneira de entender como funciona √© simplesmente verificar se um ou outro c√≥digo est√° em execu√ß√£o. </li><li>  Mas a especifica√ß√£o nem sempre √© respeitada! </li></ol><br>  O problema √© que nosso Ivan Tulup √© um av√¥ antigo, porque as implementa√ß√µes do Event Loop nos navegadores tamb√©m s√£o realmente muito antigas.  Eles foram criados antes da especifica√ß√£o ser escrita, portanto, infelizmente, a especifica√ß√£o √© respeitada na medida em que.  Mesmo se voc√™ ler como deve ser a especifica√ß√£o, ningu√©m garante que todos os navegadores sejam compat√≠veis.  Portanto, verifique nos navegadores como isso realmente funciona. <br><br>  O av√¥ Ivan Tulup nos navegadores √© uma pessoa pouco previs√≠vel, com alguns recursos interessantes, voc√™ precisa se lembrar disso. <br><br><h2>  Terminator Santa: la√ßo de mascote no Node.js <br></h2><br>  O Node.js √© mais parecido com algu√©m assim. <br><br><img src="https://habrastorage.org/webt/bb/5u/bx/bb5ubx5cvdgtu2lilmk-rfmeajc.png"><br><br>  Porque, por um lado, √© o mesmo av√¥ com barba, mas ao mesmo tempo tudo √© distribu√≠do em fases e √© claramente pintado onde √© feito. <br><br>  <strong>Fases do loop de eventos no Node.js:</strong> <br><br><ul><li>  temporizadores; <br></li><li>  retorno de chamada pendente; <br></li><li>  ocioso, prepare-se; <br></li><li>  sondagem; <br></li><li>  cheque; <br></li><li>  fechar retornos de chamada. <br></li></ul><br>  Tudo, exceto o √∫ltimo, n√£o est√° muito claro do que isso significa.  As fases t√™m nomes t√£o estranhos, porque sob o cap√¥, como j√° sabemos, temos Libuv para governar todos: <br><br><ul><li>  <em>Linux -</em> epoll / POSIX AIO; <br></li><li>  <em>BSD -</em> kqueue; <br></li><li>  <em>Windows -</em> IOCP; <br></li><li>  <em>Solaris -</em> portas de eventos. <br></li></ul><br>  Milhares de todos eles! <br><br>  Al√©m disso, o Libuv tamb√©m fornece o mesmo loop de eventos.  Ele n√£o possui as especificidades do Node.js, mas existem fases, e o Node.js apenas as utiliza.  Mas, por algum motivo, ela pegou os nomes de l√°. <br><br>  Vamos ver o que cada fase realmente significa. <br><br><h4>  A fase Timers executa: <br></h4><br><ul><li>  Temporizadores prontos para retorno de chamada; <br></li><li>  setTimeout e setInterval; <br></li><li>  Mas <strong>N√ÉO</strong> setImmediate √© uma fase diferente. <br></li></ul><br><h4>  Fase de retorno de chamada pendente <br></h4><br>  Antes disso, a fase de documenta√ß√£o denominava retornos de chamada de E / S.  Mais recentemente, essa documenta√ß√£o foi corrigida e deixou de se contradizer.  Antes disso, em um local estava escrito que os retornos de chamada de E / S eram executados nesta fase, em outra - na fase de pesquisa.  Mas agora tudo est√° escrito l√° inequivocamente e bem, ent√£o leia a documenta√ß√£o - algo se tornar√° muito mais compreens√≠vel. <br><br>  Na fase de retorno de chamada pendente, retornos de chamada de algumas opera√ß√µes do sistema (erro TCP) s√£o executados.  Ou seja, se no Unix houver um erro no soquete TCP, nesse caso, ele n√£o deseja descart√°-lo imediatamente, mas no retorno de chamada, que ser√° executado exatamente nesta fase.  √â tudo o que precisamos saber sobre ela.  Praticamente n√£o estamos interessados ‚Äã‚Äãnisso. <br><br><h4>  Fase Inativa, preparar <br></h4><br>  Nesta fase, n√£o podemos fazer nada, por isso vamos esquecer isso em princ√≠pio. <br><br><img src="https://habrastorage.org/webt/xa/6l/n-/xa6ln-ao3qbubxteqecnh8lm5ke.png"><br><br><h4>  Fase de vota√ß√£o <br></h4><br>  Esta √© a fase mais interessante do Node.js, porque realiza o principal trabalho √∫til: <br><br><ul><li>  Executa retornos de chamada de E / S (sem fase de retorno de chamada pendente!). </li><li>  Aguardando eventos de E / S; </li><li>  √â legal fazer setImmediate; </li><li>  Sem temporizadores; </li></ul><br>  No futuro, o setImmediate ser√° executado na pr√≥xima fase de verifica√ß√£o, isto √©, garantida antes dos temporizadores. <br><br>  E tamb√©m a fase de pesquisa controla o fluxo do loop de eventos.  Por exemplo, se n√£o tivermos temporizadores, n√£o haver√° setImmediate, ou seja, ningu√©m ligou o timer, setImmediate, apenas bloqueamos nesta fase e aguardamos o evento de E / S, se algo acontecer conosco, se houver algum retorno de chamada se nos inscrevemos em alguma coisa. <br><br>  Como √© implementado um modelo sem bloqueio?  Por exemplo, no mesmo Epoll, podemos assinar um evento - abrir um soquete e aguardar que algo seja escrito nele.  Al√©m disso, o segundo argumento √© o tempo limite, ou seja,  aguardaremos o Epoll, mas se o tempo limite terminar e o evento de E / S n√£o chegar, o tempo limite ser√° encerrado.  Se um evento vier da rede (algu√©m escreve no soquete), ele vir√°. <br><br>  Portanto, a fase de pesquisa recupera o primeiro retorno de chamada do heap (o heap √© uma estrutura de dados que permite entrega e entrega bem classificadas), gasta o tempo limite, grava esse tempo limite e libera tudo.  Assim, mesmo que ningu√©m nos escreva no soquete, o tempo limite funcionar√°, retornar√° √† fase de pesquisa e o trabalho continuar√°. <br><br><blockquote>  √â importante observar que, na fase de pesquisa, h√° um limite no n√∫mero de retornos de chamada por vez. <br></blockquote><br>  √â triste que nas demais fases n√£o seja.  Se voc√™ adicionar 10 bilh√µes de tempo limite, voc√™ adicionar√° 10 bilh√µes de tempo limite.  Portanto, a pr√≥xima fase √© a fase de verifica√ß√£o. <br><br><h4>  Fase de verifica√ß√£o </h4><br>  √â aqui que o setImmediate √© executado.  A fase √© bonita nesse setImmediate, chamado na fase de pesquisa, √© garantido para executar mais cedo que o timer.  Porque o cron√¥metro s√≥ estar√° no pr√≥ximo tick no in√≠cio e antes da fase de pesquisa.  Portanto, n√£o podemos ter medo de competir com outros cron√¥metros e usar essa fase para coisas que n√£o queremos, por algum motivo, executar em um retorno de chamada. <br><br><h4>  Retorno de chamada de fase </h4><br>  Essa fase n√£o executa todos os nossos retornos de chamada de fechamento de soquete e outros tipos: <br><br><pre> <code class="javascript hljs">socket.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, ‚Ä¶).</code> </pre><br>  Ela os executa apenas se esse evento ocorreu inesperadamente, por exemplo, algu√©m do outro lado enviou: "Tudo - feche a tomada - v√° daqui, Vasya!"  Ent√£o essa fase funcionar√°, porque o evento √© inesperado.  Mas isso n√£o nos afeta particularmente. <br><br><h3>  Processamento ass√≠ncrono incorreto de chunks no Node.js </h3><br>  O que acontecer√° se colocarmos o mesmo padr√£o que adotamos nos navegadores com setTimeout no Node.js - isto √©, dividiremos a matriz em partes, para cada parte que fizermos setTimeout - 0. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bigArray = [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>_000_000] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chunks = getChunks(bigArray) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parseData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">slice</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">// parse binary data for (chunk of chunks) { setTimeout(() =&gt; parseData(slice), 0) }</span></span></code> </pre><br>  Voc√™ acha que h√° algum problema com isso? <br><br>  Eu j√° corri um pouco √† frente quando disse que se voc√™ adicionar 10 mil tempos limite (ou 10 bilh√µes!), Haver√° 10 mil temporizadores na fila e ele os obter√° e executar√° - n√£o h√° prote√ß√£o contra isso: obtenha - execute, obtenha - cumprir e assim por diante ad infinitum. <br><br>  Somente na fase de pesquisa, se obtemos constantemente um evento de E / S, o tempo todo algu√©m escreve algo no soquete para que possamos executar pelo menos timers e setImmediate, ele tem prote√ß√£o de limite e depende do sistema.  Ou seja, ser√° diferente em diferentes sistemas operacionais. <br><br>  Infelizmente, outras fases, incluindo temporizadores e setImmediate, <strong>n√£o possuem essa prote√ß√£o.</strong>  Portanto, se voc√™ fizer como no exemplo, tudo ir√° congelar e n√£o atingir√° a fase de vota√ß√£o por um per√≠odo muito longo. <br><br>  Mas voc√™ acha que algo mudar√° se substituirmos setTimeout (() =&gt; parseData (fatia), 0) por setImmediate (() =&gt; parseData (fatia))?  - Naturalmente, n√£o, tamb√©m n√£o h√° prote√ß√£o na fase de verifica√ß√£o l√°. <br><br>  Para resolver esse problema, voc√™ pode chamar o <strong>processamento recursivo</strong> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parseData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">slice</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">// parse binary data const recursiveAsyncParseData = (i) =&gt; { parseData(getChunk(i)) setImmediate(() =&gt; recursiveAsyncParseData(i + 1)) } recursiveAsyncParseData(0)</span></span></code> </pre><br>  A conclus√£o √© que pegamos a fun√ß√£o parseData e escrevemos sua chamada recursiva, mas n√£o apenas a n√≥s mesmos, mas atrav√©s de setImmediate.  Quando voc√™ chama isso na fase setImmediate, ele passa para o pr√≥ximo tick, e n√£o para o atual.  Portanto, isso liberar√° o loop de eventos, al√©m de um c√≠rculo.  Ou seja, temos recursiveAsyncParseData, onde passamos um determinado √≠ndice, obtemos o peda√ßo por esse √≠ndice, o analisamos - e depois colocamos a fila setImmediate no pr√≥ximo √≠ndice.  Chegar√° ao nosso pr√≥ximo tick e podemos processar recursivamente tudo isso. <br><br>  √â verdade que o problema √© que isso ainda √© algum tipo de tarefa vinculada √† CPU.  Talvez ela ainda de alguma forma pese e gaste tempo no Event Loop.  Provavelmente voc√™ deseja que seu Node.js seja puramente vinculado a E / S. <br>  Portanto, √© melhor usar outras coisas, por exemplo, conjunto de <strong>bifurca√ß√£o / thread de processo.</strong> <br><br>  Agora sabemos sobre o Node.js que: <br><br><ul><li>  tudo √© distribu√≠do em fases - bem, n√≥s sabemos disso claramente; <br></li><li>  existe prote√ß√£o contra a fase de vota√ß√£o muito longa, mas n√£o o resto; <br></li><li>  padr√µes de processamento recursivo podem ser aplicados para n√£o bloquear o loop de eventos; </li><li>  Mas √© melhor usar o fork do processo, o pool de threads, o processo filho </li></ul><br>  Voc√™ tamb√©m deve ter cuidado com o pool de encadeamentos, porque o Node.js inicia as tarefas l√° em cima, em particular a resolu√ß√£o de DNS, porque para Linux, por algum motivo, a fun√ß√£o de resolu√ß√£o de DNS n√£o √© ass√≠ncrona.  Portanto, ele deve ser executado no ThreadPool.  No Windows, felizmente, n√£o √© assim.  Mas voc√™ pode ler arquivos de forma ass√≠ncrona.  No Linux, infelizmente, √© imposs√≠vel. <br><br>  Na minha opini√£o, o limite padr√£o √© de 4 processos no ThreadPool.  Portanto, se voc√™ fizer algo ativamente l√°, ele competir√° com todos os outros - com fs e outros.  Voc√™ pode considerar aumentar o ThreadPool, mas tamb√©m com muito cuidado.  Ent√£o, leia algo sobre este t√≥pico. <br><br><h2>  Microtask: circula√ß√£o pulmonar </h2><br>  Temos tarefas no Node.js e tarefas nos navegadores.  Voc√™ j√° deve ter ouvido falar em microtask.  Vamos ver o que √© e como eles funcionam e come√ßar com os navegadores. <br><br><h3>  Microtask em navegadores <br></h3><br>  Para entender como o microtask funciona, passamos ao algoritmo do loop de eventos de acordo com o padr√£o whatwg, ou seja, vamos √† especifica√ß√£o e ver como tudo se parece. <br><br><img src="https://habrastorage.org/webt/cb/kj/76/cbkj76j9xqsivioo2demagbbfty.png"><br><br>  Traduzindo para a linguagem humana, parece algo como isto: <br><br><ul><li>  Fa√ßa a tarefa gratuita da nossa linha </li><li>  N√≥s realizamos </li><li>  Realizamos o ponto de verifica√ß√£o microtask - OK, ainda n√£o sabemos o que √©, mas nos lembramos. </li><li>  Atualizamos a renderiza√ß√£o (se necess√°rio) e retornamos √† estaca zero. </li></ul><br><img src="https://habrastorage.org/webt/1h/rs/ce/1hrsceluhstlxrdjjr7ig2wh9l0.png"><br><br>  Eles s√£o realizados no local indicado no diagrama e em v√°rios outros locais, sobre os quais aprenderemos em breve.  Ou seja, a tarefa terminou, microtask √© executado. <br><br><h3>  Fontes de microtucks </h3><br><ul><li>  <strong>Promessa.</strong> </li></ul><br>  Importante - n√£o a pr√≥pria Promessa, ou seja, Promessa.  O retorno de chamada que foi colocado ent√£o √© uma microtask.  Se voc√™ ligou para 10 ent√£o - voc√™ tem 10 microcarros, 10 mil ent√£o - 10 mil microcarros. <br><br><ul><li>  <strong>Observador de muta√ß√µes.</strong> <br></li><li>  <strong>Object.observe</strong> , que est√° obsoleto e ningu√©m precisa. <br></li></ul><br>  Quantos usam o observador da Muta√ß√£o? <br><br>  Eu acho que poucos usam o observador da Muta√ß√£o.  Muito provavelmente, Promise.then √© usado mais, √© por isso que o consideraremos no exemplo. <br><br>  <strong>Recursos do ponto de verifica√ß√£o microtask:</strong> <br><br><ul><li>  <strong>Fazemos tudo</strong> - isso significa que executamos todas as microtaks que temos na fila at√© o final.  N√£o abandonamos nada - apenas pegamos e fazemos tudo o que √©, eles devem ser micro, certo? </li><li>  Voc√™ ainda pode gerar uma nova microtask no processo, e elas ser√£o executadas no mesmo ponto de verifica√ß√£o da microtask. </li><li>  O que tamb√©m √© importante - eles s√£o executados n√£o apenas ap√≥s a execu√ß√£o da tarefa, mas tamb√©m ap√≥s a limpeza da pilha. </li></ul><br>  Este √© um ponto interessante.  Acontece que √© poss√≠vel gerar novas microtarefas e todos n√≥s as cumpriremos at√© o fim.  O que isso pode nos levar? <br><br><img src="https://habrastorage.org/webt/yr/i_/i9/yri_i9mhp2jz-6nyyj7pvfwl6yg.png"><br>  N√≥s temos dois cora√ß√µes.  Eu animei o primeiro cora√ß√£o com anima√ß√£o JS e o segundo com anima√ß√£o CSS.  H√° outro √≥timo recurso chamado starveMicrotasks.  Chamamos Promise.resolve e, em seguida, colocamos a mesma fun√ß√£o. <br>  Veja na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">apresenta√ß√£o o</a> que acontece se voc√™ chamar esta fun√ß√£o. <br><br>  Sim, o cora√ß√£o do JS ir√° parar, porque adicionamos uma microtask e, em seguida, adicionamos uma microtask e, em seguida, adicionamos uma microtask ... E assim infinitamente. <br><br>  Ou seja, a chamada recursiva dos microtucks vai travar tudo.  Mas parece que eu tenho tudo ass√≠ncrono!  Deve ser liberado, chamei setTimeout l√°.  N√£o!  Infelizmente, voc√™ precisa ter cuidado com o microtask; portanto, se voc√™ usar uma chamada recursiva de alguma forma, tenha cuidado - poder√° bloquear tudo. <br><br>  Al√©m disso, como lembramos, o microtask √© executado no final da limpeza da pilha.  Lembramos o que √© uma pilha.  Acontece que, assim que sa√≠mos do nosso c√≥digo, o retorno de chamada setTimeout foi executado - √© isso - as microtasks foram para l√°.  Isso pode levar a efeitos colaterais interessantes. <br><br>  Considere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um exemplo</a> . <br><br><img src="https://habrastorage.org/webt/kf/e-/tq/kfe-tqsysmprki74ayahty-n9ke.png"><br><br>  H√° um bot√£o e um recipiente cinza no qual est√° localizado.  Assinamos o clique do bot√£o e do cont√™iner.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eventos, como sabemos, surgem, ou seja, eles aparecem l√° e ali. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos manipuladores, fazemos duas coisas:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Promise.resolve; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . em que console.log ('RO') √© inserido </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, no pr√≥prio manipulador, entramos em ‚ÄúFUS‚Äù e no manipulador no cont√™iner - ‚ÄúDAH!‚Äù </font><font style="vertical-align: inherit;">(quando o nosso evento aparecer). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que voc√™ acha que aparecer√° no nosso console? </font><font style="vertical-align: inherit;">Essas mensagens t√™m uma pequena dica e, curiosamente, ele exibir√° "FUS RO DAH!"</font></font> √ìtimo!  ,   . <br><br><img src="https://habrastorage.org/webt/3g/b6/w3/3gb6w3gi4es-fzxcicyk2batfm8.png"><br><br>       ,            ,        .   ‚Äì  . , -   ? <br><br><img src="https://habrastorage.org/webt/uo/-t/dx/uo-tdxdjrfwgt0vvse4a6vuqips.png"><br><br>  !         . <br><br><img src="https://habrastorage.org/webt/yk/ob/w3/ykobw30-vcw5h6t6vvlitwk-y2a.png"><br><br>  ,   . <br><br> ,      ,     ,     .  ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a> . <br><br><ul><li>         ‚Äî buttonHandleClick,    . </li><li>    Promise.resolve.     .   ,      console.log('RO')  .   . </li><li>      console.log('FUS'). </li><li>   buttonHandleClick       .        . </li><li>   ,      (divHandleClick)    ,  ¬´DAH!¬ª. </li><li> HandleClick . </li></ul><br>  ,     .         ?     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a> : <br><br><ul><li>  button.click().     . </li><li>   button HandleClick. </li><li>  Promise.resolve  then.      , Promise.resolve . </li><li>    console.log   ¬´FUS¬ª. </li><li>    buttonHandleClick    ,    . </li></ul><br>     (click)  ,       ,    .     divHandleClick , ,  console.log('DAH!') .        ,      . <br><br>   , ,    button.click   . <br>        .   , ,   .  ,    ,    . <br><br>    :     ()       (  ).   - ,      ,   stopPropagation.  ,     ,  ,  ,   -   ,  . <br><br>  ,  -   ( junior-)     ‚Äî      ¬´¬ª,    promise,  ,    then  ,  -  .    ,  <strong>    ,    </strong> :   ,    ,  .   .        ,   -       . <br><br>    (  4)    ,        .     ,   ,  ,   ,      -   .           . <br><br> <strong>     , :</strong> <br><br><ul><li>      Event Loop.  Isso √© desagrad√°vel. </li><li>         ,   . </li></ul><br>           ,    .  ‚Äî   ,     ,  . <br><br><h2>   Node.js <br></h2><br>   Node.js  Promise.then  process.nextTick.      ,    ‚Äî    .   ,   , ,   , . <br><br><h3> process.nextTick <br></h3><br> ,     process.nextTick,   setImmediate?      Node.js  ? <br><br>    .     createServer,   EventEmitter,    ,     listen (  ),      . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createServer = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> evEmitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">listen</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">port</span></span></span><span class="hljs-function"> =&gt;</span></span> { evEmitter.emit(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>, port) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evEmitter } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = createServer().listen(<span class="hljs-number"><span class="hljs-number">8080</span></span>) server.on(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>, () =&gt; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>))</code> </pre><br>    ,  ,   8080,    listening   console.log  - . <br><br>  ,       ,      - . <br><br>    createServer,    .       listen,      ,        .        . <br><br>  ,    ,    .   ?   process.nextTick:  evEmitter.emit('listening', port)  process.nextTick(() =&gt; evEmitter.emit('listening', port)). <br><br>   ,  <strong>process.nextTick     ,    </strong> .    EventEmitter,     . ,   ,      API,       .    process.nextTick,   emit    ,  userland  .      createServer,  ,  listen,    listening.     ‚Äî    process.nextTick ‚Äî !  ,     ,  . <br><br>     process.nextTick  .     ,         . <br><br>   ,  process.nextTick    ,  Promise.then  .     process.nextTick ,     ‚Äî    ,   Event Loop,  Node.js. , ,   . <br><br> <strong> process.nextTick    </strong> ,   ghbvtybnm  setImmediate   ,        C++  ..  process.nextTick       . <br><br><h2> Async/await </h2><br>      API ‚Äî async/await, - .    .    , async/await   Promise,     Event Loop      .     ,          . <br><br><h2>   </h2><br><ul><li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Philip Roberts. What the heck is the event loop anyway?</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bert Belder. Everything you need to know about Node.js event loop.</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jake Archibald. In the Loop</a> . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Node.js Event Loop, Timers, and process.nextTick()</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WHATWG Specification event loop processing model</a> <br></li></ul><br> <strong>,     !</strong> <br><br><blockquote>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Frontend Conf</a>     ‚Äî 4  5   ,  .    ,        : <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Grid Layout    </a> /   ( .) <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Building decentralised apps with JS</a> /   (ING) <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> /   () <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">StoreWars (ngxs, redux, vuex)</a> /  ,   (Cinimex) <br></li></ul><br>  Venha, vai ser interessante! <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt417461/">https://habr.com/ru/post/pt417461/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt417449/index.html">Mundo Jur√°ssico: Podemos Realmente Ressuscitar Dinossauros?</a></li>
<li><a href="../pt417451/index.html">Cinco erros comuns para iniciantes</a></li>
<li><a href="../pt417453/index.html">Organiza√ß√£o de est√°gios para estudantes: truques e truques</a></li>
<li><a href="../pt417457/index.html">Frontend Conf Moscow - entrada e sa√≠da do cliente</a></li>
<li><a href="../pt417459/index.html">Conhe√ßa o seu JIT: mais perto do carro</a></li>
<li><a href="../pt417463/index.html">Uma reuni√£o inesperada. Cap√≠tulo 17</a></li>
<li><a href="../pt417465/index.html">Uma vis√£o geral dos m√©todos de vincula√ß√£o de texto</a></li>
<li><a href="../pt417469/index.html">Cinco raz√µes ego√≠stas para trabalhar de forma reproduz√≠vel</a></li>
<li><a href="../pt417471/index.html">Solda simples MK936 SMD. Esta√ß√£o de solda DIY para componentes SMD</a></li>
<li><a href="../pt417473/index.html">Armazenamento confi√°vel com DRBD9 e Proxmox (parte 1: NFS)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>