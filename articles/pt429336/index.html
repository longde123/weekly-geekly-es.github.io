<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∏üèæ üë©üèª‚Äç‚úàÔ∏è ‚òÆÔ∏è Comunica√ß√£o entre driver e dispositivo pelo m√©todo _HID ACPI usando o GPIO do controlador Lynxpoint como exemplo üëáüèª üë®‚Äçüöí ü§¥üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Declara√ß√£o do problema 
 O Linux possui uma interface padr√£o para trabalhar com o GPIO atrav√©s do sysfs. A documenta√ß√£o para isso pode ser encontrada ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comunica√ß√£o entre driver e dispositivo pelo m√©todo _HID ACPI usando o GPIO do controlador Lynxpoint como exemplo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429336/"><h3>  Declara√ß√£o do problema </h3><br>  O Linux possui uma interface padr√£o para trabalhar com o GPIO atrav√©s do sysfs.  A documenta√ß√£o para isso pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Em resumo, existem arquivos "exportar" e "n√£o exportar" na pasta "/ sys / class / gpio".  Ao escrever o n√∫mero X no arquivo de exporta√ß√£o, voc√™ pode abrir a interface no espa√ßo do usu√°rio para controlar o GPIOX <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    user space   GPIO12 $ echo 12 &gt; /sys/class/gpio/export</span></span></code> </pre> <br>  Ap√≥s abrir a interface, a pasta / sys / class / gpio / gpioX / aparecer√° na qual existir√£o arquivos como "value" ou "direction", escrevendo "in" ou "out" no arquivo "direction" e escrevendo 1 ou 0 no arquivo "Valor" pode controlar a sa√≠da GPIO diretamente da linha de comando. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  GPIO   $ echo "out" &gt; /sys/class/gpio/gpio12/direction #  1   GPIO $ echo 1 &gt; /sys/class/gpio/gpio12/value</span></span></code> </pre> <br>  Para que o comando ‚Äúecho X&gt; / sys / class / gpio / export‚Äù crie a pasta ‚ÄúgpioX‚Äù, o driver do controlador GPIO deve ser registrado no kernel, que abre a interface para as linhas GPIO. <br><br>  Aconteceu que estou trabalhando na portabilidade do coreboot para uma placa personalizada baseada no processador Intel Haswell i7 [Para quem n√£o sabe, o coreboot √© um c√≥digo aberto do projeto BIOS de c√≥digo aberto ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.coreboot.org/</a> ) ]  A ponte sul do LynxpointLP, na qual existem 94 linhas GPIO, est√° embutida no meu processador.  E eu queria abri-los no sysfs ... <br><a name="habracut"></a><br><h3>  Solu√ß√£o de problemas (comunica√ß√£o de driver e dispositivo no Linux) </h3><br>  Ap√≥s uma breve pesquisa no c√≥digo do kernel, descobri que esse driver j√° foi gravado, est√° localizado no arquivo "drivers \ gpio \ gpio-lynxpoint.c" e √© ativado usando o Kconfig <br><br><pre> <code class="hljs pgsql">config GPIO_LYNXPOINT tristate "Intel Lynxpoint GPIO support" <span class="hljs-keyword"><span class="hljs-keyword">depends</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ACPI &amp;&amp; X86 <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> GPIOLIB_IRQCHIP help driver <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GPIO functionality <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> Intel Lynxpoint PCH chipset Requires ACPI device enumeration code <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> up a platform device.</code> </pre> <br>  A op√ß√£o GPIO_LYNXPOINT foi ativada no kernel com o qual eu estava trabalhando, no entanto, n√£o havia uma √∫nica pasta "gpiochipN" para o controlador GPIO na pasta "/ sys / class / gpio /" (que deveria ser), e mesmo esse script n√£o exportou nenhum linhas <br><br><pre> <code class="bash hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {0..255}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$i</span></span> &gt; /sys/class/gpio/<span class="hljs-built_in"><span class="hljs-built_in">export</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Observando o c√≥digo de inicializa√ß√£o principal ou a documenta√ß√£o dessa ponte sul, √© poss√≠vel ver que o controlador GPIO n√£o √© um dispositivo PCI separado.  Faz parte de outro dispositivo PCI: LPC Interface Bridge.  Usando os registros do espa√ßo de configura√ß√£o PCI deste dispositivo, voc√™ deve ativar o controlador GPIO e atribu√≠-lo BASE_ADDRESS no espa√ßo de E / S.  Isso abrir√° uma janela no espa√ßo de E / S de 1KV.  Ao escrever / ler bytes nesta janela, voc√™ pode controlar as linhas GPIO. <br><br>  O que podemos ver no c√≥digo coreboot: <br><br>  southbridge \ intel \ lynxpoint \ pch.h: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEFAULT_GPIOBASE 0x1400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEFAULT_GPIOSIZE 0x400 ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_BASE 0x48 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* LPC GPIO Base Address Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_CNTL 0x4C </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* LPC GPIO Control Register */</span></span></span><span class="hljs-meta"> ... </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PCI Configuration Space (D31:F0): LPC */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PCH_LPC_DEV PCI_DEV(0, 0x1f, 0)</span></span></code> </pre><br>  southbridge \ intel \ lynxpoint \ early_pch.c: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Setup GPIO Base Address */</span></span> pci_write_config32(PCH_LPC_DEV, GPIO_BASE, DEFAULT_GPIOBASE|<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Enable GPIO functionality. */</span></span> pci_write_config8(PCH_LPC_DEV, GPIO_CNTL, <span class="hljs-number"><span class="hljs-number">0x10</span></span>);</code> </pre> <br>  Se olharmos para os registros de dispositivos LPC no Linux atrav√©s de "lspci -xxx", veremos que os dados gravados por n√≥s est√£o nesses registros.  Ent√£o, tudo parece estar configurado como deveria. <br><br>  Continuando a examinar o c√≥digo do driver, notei que o driver do Linux se comunica com o dispositivo atrav√©s do campo .acpi_match_table.  Como nosso dispositivo n√£o pode ser enumerado (ele n√£o est√° localizado no barramento PCI ou USB), ele precisa de um driver de plataforma, e a conex√£o desse driver com o dispositivo √© via tabelas ACPI.  O caso usual do x86, no caso do ARM, registrar√≠amos nosso dispositivo no DeviceTree ou usar√≠amos os c√≥digos antigos no kernel. <br><br>  drivers \ gpio \ gpio-lynxpoint.c: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">acpi_device_id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lynxpoint_gpio_acpi_match</span></span></span><span class="hljs-class">[] = {</span></span> { <span class="hljs-string"><span class="hljs-string">"INT33C7"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"INT3437"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { } }; MODULE_DEVICE_TABLE(acpi, lynxpoint_gpio_acpi_match); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">platform_driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lp_gpio_driver</span></span></span><span class="hljs-class"> = {</span></span> .probe = lp_gpio_probe, .remove = lp_gpio_remove, .driver = { .name = <span class="hljs-string"><span class="hljs-string">"lp_gpio"</span></span>, .pm = &amp;lp_gpio_pm_ops, .acpi_match_table = ACPI_PTR(lynxpoint_gpio_acpi_match), }, };</code> </pre><br>  Funciona assim: se o kernel, ao analisar a tabela ACPI, vir um dispositivo com o identificador _HID "INT33C7", ele tentar√° encontrar o driver da plataforma para ele com identificadores correspondentes nos campos da estrutura ".driver-&gt; acpi_match_table". <br><br>  Quando uma correspond√™ncia √© encontrada, o Linux executa a fun√ß√£o do driver .probe. <br><br>  Como se viu, o c√≥digo ACPI para este dispositivo foi apresentado no coreboot, acabei de comentar.  Comentou devido ao fato de que para este dispositivo o Windows n√£o conseguiu encontrar o driver e exibiu "Dispositivo desconhecido" no gerenciador de dispositivos.  Mais sobre isso abaixo. <br><br>  Ent√£o, estamos interessados ‚Äã‚Äãnas informa√ß√µes do arquivo <br>  src \ southbridge \ intel \ lynxpoint \ acpi \ serialio.asl (o c√≥digo √© um pouco simplificado): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     * src\southbridge\intel\lynxpoint\pch.h * #define DEFAULT_GPIOBASE 0x1400 * #define DEFAULT_GPIOSIZE 0x400 */</span></span> Scope (\_SB) { Device (PCI0) { ... Device (GPIO) { <span class="hljs-comment"><span class="hljs-comment">// GPIO Controller Name (_HID, "INT33C7") Name (_CID, "INT33C7") Name (_UID, 1) Name (RBUF, ResourceTemplate() { DWordIo (ResourceProducer, MinFixed, // IsMinFixed MaxFixed, // IsMaxFixed PosDecode, // Decode EntireRange, // ISARanges 0x00000000, // AddressGranularity 0x00000000, // AddressMinimum 0x00000000, // AddressMaximum 0x00000000, // AddressTranslation 0x00000001, // RangeLength , // ResourceSourceIndex , // ResourceSource BAR0) Interrupt (ResourceConsumer, Level, ActiveHigh, Shared, , , ) {14} }) Method (_CRS, 0, NotSerialized) { CreateDwordField (^RBUF, ^BAR0._MIN, BMIN) CreateDwordField (^RBUF, ^BAR0._MAX, BMAX) CreateDwordField (^RBUF, ^BAR0._LEN, BLEN) Store (DEFAULT_GPIOSIZE, BLEN) Store (DEFAULT_GPIOBASE, BMIN) Store (Subtract (Add (DEFAULT_GPIOBASE, DEFAULT_GPIOSIZE), 1), BMAX) Return (RBUF) } Method (_STA, 0, NotSerialized) { Return (0xF) } } ... } }</span></span></code> </pre><br>  Para entender esse c√≥digo em detalhes, voc√™ deve se familiarizar com a sintaxe ASL na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">especifica√ß√£o ACPI</a> . <br><br>  Mas, em resumo, esse c√≥digo cria um dispositivo com o identificador "INT33C7", que possui 2 recursos: <br><br><pre> <code class="hljs mel">I/O <span class="hljs-keyword"><span class="hljs-keyword">memory</span></span>: <span class="hljs-number"><span class="hljs-number">1400</span></span><span class="hljs-number"><span class="hljs-number">-17</span></span>ff; IRQ: <span class="hljs-number"><span class="hljs-number">14</span></span>;</code> </pre> <br>  Dentro de sua fun√ß√£o .probe Linux, o driver recebe os recursos do dispositivo acima da seguinte maneira: <br><br><pre> <code class="cpp hljs">io_rc = platform_get_resource(pdev, IORESOURCE_IO, <span class="hljs-number"><span class="hljs-number">0</span></span>); irq_rc = platform_get_resource(pdev, IORESOURCE_IRQ, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Com base nesses dados, o c√≥digo do driver preencher√° a estrutura gpio_chip e registrar√° o controlador gpio no sistema, o que o tornar√° acess√≠vel atrav√©s da interface sysfs. <br><br>  Ap√≥s devolver o c√≥digo ASL do dispositivo e recompilar a imagem do BIOS, o sistema conseguiu acessar o GPIO por meio de sysfs. <br><br>  Para come√ßar, a pasta ‚Äúgpiochip162‚Äù apareceu em / sys / class / gpio.  Esta pasta cont√©m o arquivo "base" e "ngpio".  O arquivo base √© respons√°vel pelo n√∫mero do primeiro GPIO deste controlador, ngpio pelo n√∫mero. <br><br><pre> <code class="bash hljs">$ cat /sys/class/gpio/gpiochip162/base 162 $ cat /sys/class/gpio/gpiochip162/ngpio 94</code> </pre> <br>  Assim, tudo foi exportado como deveria.  Executamos o script: <br><br><pre> <code class="bash hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {162..255}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$i</span></span> &gt; /sys/class/gpio/<span class="hljs-built_in"><span class="hljs-built_in">export</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Depois disso, as subpastas gpioN aparecer√£o na pasta / sys / class / gpio /, dentro da qual haver√° arquivos para controlar o status da linha. <br><br>  Alguns coment√°rios: <br><br><ul><li>  A pasta / sys / class / gpio162 / √© respons√°vel pelo gerenciamento do GPIO0, a pasta / sys / class / gpio163 / √© respons√°vel pelo GPIO1  Essa mudan√ßa ocorreu devido ao fato de o driver durante a inicializa√ß√£o da estrutura de controle ‚Äústruct gpio_chip" atribuir "gc-&gt; base = -1;".  Ou seja, eu deixei o kernel para escolher os n√∫meros pessoalmente.  Isso geralmente n√£o √© cr√≠tico, mas vale a pena lembrar. </li><li>  O acesso √© concedido apenas √†s linhas GPIO configuradas como GPIO, e n√£o como nenhum recurso nativo da Southbridge.  Para essas linhas, o driver exibe informa√ß√µes em dmesg: "gpio% d reservado para ACPI".  No caso do coreboot, o GPIO √© configurado no arquivo ‚Äúgpio.h‚Äù na pasta da placa-m√£e. </li><li>  O dispositivo e o driver tamb√©m podem ser mapeados usando o m√©todo _CID (Compatible ID), e a documenta√ß√£o para nosso t√≥pico no kernel √© apresentada no documento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúEnumera√ß√£o de dispositivos baseados em ACPI‚Äù</a> </li></ul><br>  Vale ressaltar que o dispositivo INT33C7 n√£o possui 2 placas-m√£e propriet√°rias no mesmo chipset (do IBASE e DFI) nas tabelas ACPI.  √â verdade que as linhas GPIO provavelmente n√£o s√£o exibidas (eu n√£o olhei a documenta√ß√£o naquele momento em detalhes). <br><br><h3>  Identificador "INT33C7" </h3><br>  Depois de aumentar a funcionalidade do sysfs, tive uma pergunta: de onde veio o n√∫mero de identifica√ß√£o ‚ÄúINT33C7‚Äù? <br><br>  Depois de examinar a documenta√ß√£o do m√©todo _HID, ficou claro que vale a pena examinar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://www.uefi.org/PNP_ACPI_Registry</a> <br><br><div class="spoiler">  <b class="spoiler_title">_HID (ID do hardware)</b> <div class="spoiler_text">  <b>_HID (ID do hardware)</b> <br>  Este objeto √© usado para fornecer ao OSPM a ID PNP ou ACPI ID do dispositivo * <br>  Ao descrever uma plataforma, o uso de qualquer objeto _HID √© opcional.  No entanto, um objeto _HID deve ser <br>  usado para descrever qualquer dispositivo que ser√° enumerado pelo OSPM.  OSPM enumera apenas um dispositivo <br>  quando nenhum enumerador de barramento puder detectar o ID do dispositivo.  Por exemplo, os dispositivos em um barramento ISA s√£o <br>  enumerados pelo OSPM.  Use o objeto _ADR para descrever dispositivos enumerados por enumeradores de barramento <br>  diferente do OSPM. <br><br>  <b>Argumentos:</b> <br>  Nenhuma <br><br>  <b>Valor de retorno:</b> <br>  Um n√∫mero inteiro ou string contendo o HID <br>  Um objeto _HID √© avaliado como um ID do tipo EISA num√©rico compactado de 32 bits ou uma sequ√™ncia de caracteres.  Se um <br>  string, o formato deve ser um ID alfanum√©rico de PNP ou ACPI sem asterisco ou outro <br>  caracteres. <br><br>  Um ID PNP v√°lido deve estar no formato "AAA ####", em que A √© uma letra mai√∫scula e # √© um hexadecimal <br>  d√≠gito.  Um ID de ACPI v√°lido deve estar no formato "NNNN ####", em que N √© uma letra mai√∫scula ou um <br>  d√≠gito ('0' - '9') e # √© um d√≠gito hexadecimal.  Esta especifica√ß√£o reserva a cadeia "ACPI" para uso apenas <br>  com lista de dispositivos definidos.  Al√©m disso, reserva todas as seq√º√™ncias que representam 4 d√≠gitos HEX para <br>  uso exclusivo com IDs de fornecedor atribu√≠dos ao PCI. <br><br>  * -PNP ID e ACPI ID Registry est√£o em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://www.uefi.org/PNP_ACPI_Registry</a> <br></div></div><br>  Existem 3 pontos neste link: <br><br><ul><li>  todos os tipos de identificadores de tr√™s letras (PNP ID) s√£o indicados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> </li><li>  Os IDs de PNP iniciados por "PNP" reservados pela Microsoft s√£o indicados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui.</a> <br></li><li>  todos os tipos de identificadores de quatro letras (ACPI ID) s√£o indicados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> </li></ul><br>  N√£o est√° muito claro por que, mas na lista de IDs do PNP, voc√™ pode descobrir que os identificadores "INT" est√£o reservados na INTERPHASE CORPORATION: <br><br><pre> <code class="hljs pgsql">INTERPHASE CORPORATION <span class="hljs-type"><span class="hljs-type">INT</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>/<span class="hljs-number"><span class="hljs-number">29</span></span>/<span class="hljs-number"><span class="hljs-number">1996</span></span></code> </pre> <br>  Aparentemente, uma lista √∫nica de identificadores completos de dispositivo (parte da letra + digital) n√£o √© publicada.  Mas, com a ajuda do Google, foi poss√≠vel encontrar listas de dispositivos e seus _HID, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ou <a href="">aqui</a> . <br><br>  Eles indicam: <br><br><pre> <code class="hljs pgsql">INT33C7=Intel <span class="hljs-type"><span class="hljs-type">Serial</span></span> I/O GPIO Host Controller</code> </pre> <br>  E, julgando pelo restante das linhas desta lista, todos os dispositivos INTxxxx s√£o dispositivos Intel (agora parece bastante √≥bvio, mas a conex√£o com a INTERPHASE CORPORATION ainda n√£o est√° clara; tamb√©m n√£o est√° muito claro por que a numera√ß√£o come√ßa com n√∫meros t√£o grandes, mas √© vis√≠vel em Discri√ß√£o da Intel). <br><br><h3>  Driver e dispositivo de comunica√ß√£o no Windows </h3><br>  Tendo satisfeito minha curiosidade, decidi baixar o Windows na minha placa.  Como esperado, o sistema n√£o conseguiu encontrar um driver para o dispositivo.  N√£o houve ajuda dos drivers para as placas IBASE e DFI, o que √© compreens√≠vel, porque no BIOS dessas placas este dispositivo n√£o √© indicado. <br><br>  Consegui encontrar um driver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no site da Microsoft</a> <br><br>  No entanto, esse driver √© apresentado apenas para o Windows 8.1 e superior.  Ainda estou trabalhando com o Windows 7. <br><br>  No entanto, tentei baixar um dos drivers e especificar sua pasta ao procurar um driver para o meu dispositivo desconhecido. <br><br>  No entanto, o expedidor n√£o p√¥de mapear o driver para o dispositivo.  Embora o arquivo inf contenha claramente informa√ß√µes sobre o dispositivo INT33C7. <br><br><pre> <code class="hljs mel">[Manufacturer] %INTEL%=Intel,NTamd64<span class="hljs-number"><span class="hljs-number">.6</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span> [Intel.NTamd64<span class="hljs-number"><span class="hljs-number">.6</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span>] %iaLPSS_GPIO.DeviceDesc_LPT%=iaLPSS_GPIO_Device, ACPI\INT33C7 %iaLPSS_GPIO.DeviceDesc_WPT%=iaLPSS_GPIO_Device, ACPI\INT3437</code> </pre> <br>  No processo de an√°lise do arquivo INF, verificou-se que a se√ß√£o [Fabricante] indicava claramente que n√£o era para o meu sistema: <br><br>  O que significa Intel.NTamd64.6.3 pode ser entendido a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">partir da descri√ß√£o</a> : <br><br><pre> <code class="hljs powershell">nt[<span class="hljs-type"><span class="hljs-type">Architecture</span></span>][<span class="hljs-type"><span class="hljs-type">.</span></span>[<span class="hljs-type"><span class="hljs-type">OSMajorVersion</span></span>][<span class="hljs-type"><span class="hljs-type">.</span></span>[<span class="hljs-type"><span class="hljs-type">OSMinorVersion</span></span>] <span class="hljs-type"><span class="hljs-type">OSMajorVersion</span></span>=<span class="hljs-number"><span class="hljs-number">6</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>/<span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-number"><span class="hljs-number">8.1</span></span>/<span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-type"><span class="hljs-type">Server</span></span> <span class="hljs-number"><span class="hljs-number">2012</span></span> <span class="hljs-type"><span class="hljs-type">R2</span></span>/<span class="hljs-type"><span class="hljs-type">...</span></span> <span class="hljs-type"><span class="hljs-type">OSMinorVersion</span></span>=<span class="hljs-number"><span class="hljs-number">3</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-number"><span class="hljs-number">8.1</span></span>/<span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-type"><span class="hljs-type">Server</span></span> <span class="hljs-number"><span class="hljs-number">2012</span></span> <span class="hljs-type"><span class="hljs-type">R2</span></span></code> </pre> <br>  Tentando empurrar o driver do Windows 7, substituindo Intel.NTamd64.6.3 por Intel.NTamd64.6.1, para dizer o m√≠nimo, falhou, pois me deu uma tela azul da morte e um sistema operacional n√£o inicializ√°vel, e por isso tive que fazer uma recupera√ß√£o. <br><br>  O driver do Win7 foi encontrado apenas em um site incompreens√≠vel na Internet e, em seguida, o dispositivo no gerenciador de dispositivos √© exibido com um ponto de exclama√ß√£o. <br><br>  Percebendo sua impot√™ncia, decidi testar a funcionalidade no Windows 10. Houve uma surpresa agrad√°vel.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O software de dispositivo de chipset Intel (Utilit√°rio de atualiza√ß√£o INF)</a> instalou o driver do meu controlador sem problemas. <br><br><img src="https://habrastorage.org/webt/xb/28/jq/xb28jqet9w3tieq0atau1f2aoum.png"><br><br>  Como voc√™ pode ver, este dispositivo possui os recursos indicados por n√≥s. <br><br><img src="https://habrastorage.org/webt/2o/fs/p0/2ofsp055fsxm4smnghgxc3eye8u.png"><br><br>  Em teoria, depois de instalar o driver com o controlador GPIO, provavelmente ser√° poss√≠vel trabalhar com as fun√ß√µes IOCTL ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">como neste documento)</a> . <br><br>  No entanto, como n√£o havia tarefa de programa√ß√£o GPIO no Windows, a busca por um documento semelhante para o meu chipset foi adiada. <br><br><hr><br><h3>  Conclus√£o: </h3><br>  Este artigo examinou a conex√£o entre o driver e o dispositivo usando o m√©todo _HID ACPI.  Essa comunica√ß√£o pode ser necess√°ria em um sistema x86 para dispositivos que n√£o podem ser enumerados. <br><br><ul><li>  No caso do Linux, a comunica√ß√£o com o driver √© via .acpi_match_table </li><li>  No caso do Windows, a comunica√ß√£o com o driver √© feita atrav√©s de um arquivo INF </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt429336/">https://habr.com/ru/post/pt429336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt429322/index.html">nanoCAD Mechanics 9.0: o b√°sico do design moderno</a></li>
<li><a href="../pt429324/index.html">Lan√ßamento do Unreal Engine 4.21</a></li>
<li><a href="../pt429326/index.html">A App Store n√£o liga. Ou como eu fiz meu aplicativo, mas ele n√£o alcan√ßar√° os usu√°rios</a></li>
<li><a href="../pt429328/index.html">M√≥dulo de software para digitaliza√ß√£o de documentos danificados</a></li>
<li><a href="../pt429330/index.html">Mitos e lendas do Agile - dos fara√≥s at√© os dias atuais</a></li>
<li><a href="../pt429338/index.html">Armazenamento Android: Interno, Externo, Remov√≠vel. Parte 1/3</a></li>
<li><a href="../pt429340/index.html">Pense duas vezes antes de usar o Helm.</a></li>
<li><a href="../pt429342/index.html">Angular 6+ √© um guia completo de inje√ß√£o de depend√™ncia. fornecida em vs provedores: []</a></li>
<li><a href="../pt429344/index.html">Leitura de fim de semana: Recursos de ajuste de √°udio e design de alto-falante</a></li>
<li><a href="../pt429346/index.html">Para o programa de mestrado sem exames: uma nova dire√ß√£o "Big Data" nas Olimp√≠adas "Eu sou um Profissional"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>