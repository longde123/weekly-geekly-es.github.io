<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧛🏾 👩🏽 💂🏼 Comment visiter l'Université de Corée avec le système de fichiers réseau 🎻 👩🏻‍✈️ 👆🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Préface 


 Il était une fois au début des années 2000, beaucoup étaient amusés par le fait qu'ils `` scannaient '' régulièrement les réseaux de leur ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment visiter l'Université de Corée avec le système de fichiers réseau</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444382/"><p><img src="https://habrastorage.org/webt/yv/yo/g3/yvyog3c-gz4kkanb5hdlhenybg8.png"></p><br><h2 id="predislovie">  Préface </h2><br><p>  Il était une fois au début des années 2000, beaucoup étaient amusés par le fait qu'ils `` scannaient '' régulièrement les réseaux de leur fournisseur, et parfois des cibles encore plus éloignées, afin de détecter les machines et ressources Windows sur celles-ci (SMB), disponibles en lecture (écriture).  Le processus de recherche était primitif: une plage d'adresses IP ou un masque de réseau ont été définis, et grâce à divers outils - LANguard Network Scanner, xIntruder et similaires - les adresses ont été analysées et les serveurs ont été localisés.  Souvent, les machines détectées se sont avérées disponibles pour la lecture, moins souvent pour l'écriture, diverses ressources réseau (disques, imprimantes, répertoires).  Grâce à une session anonyme, via IPC $ et l'utilisateur «Guest», il était possible de transférer des ressources sur la machine, parfois il y avait des membres des «Administrateurs» sans mot de passe, et parfois, après un effet plus «actif» sur les machines détectées, il était possible de trouver des serveurs exécutant Windows NT 4.0 ou Windows 2000 Server.  Si la chance a daigné trouver des machines avec Windows 98 alors répandu, alors cela est devenu plus facile - à cette époque, le système d'exploitation spécifié contenait de nombreuses vulnérabilités différentes, y compris la mise en œuvre de l'utilisation de SMB, la bruteforce pour l'accès à la ressource a été effectuée en quelques minutes, même sur une ligne commutée connexions.  Pour ceux qui veulent plonger dans les temps anciens, il est écrit en détail sur «l'accès» à Windows 9x - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hacking Exposed: Network Security Secrets &amp; Solutions.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chapitre 4: Piratage de Windows 95/98 et moi</a> .  Mais le reste de l'article n'est pas là-dessus. </p><a name="habracut"></a><br><p>  Je n'aurais jamais pensé qu'en 2019, un tel "divertissement" est possible.  La similitude réside dans la facilité de trouver les ressources disponibles des autres pour tous les curieux.  De plus, nous ne nous concentrerons pas sur une tendance populaire au cours des 2 dernières années - la recherche de bases de données MongoDB ou Elasticsearch ouvertes à l'accès - mais sur un service légèrement plus terre-à-terre. </p><br><p>  <em>En outre, je propose de ne pas évaluer l'ensemble de la procédure, leur norme éthique, je note que ce message n'est pas un appel à des actions qui peuvent être attribuées à certains articles du Code pénal de la Fédération de Russie ou à des normes similaires des lois d'autres États.</em> </p><br><h2 id="network-file-system-nfs">  Système de fichiers réseau (NFS) </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Wikipédia">Network File System (NFS)</a> - un protocole d'accès réseau aux systèmes de fichiers, vous permet de connecter (monter) des systèmes de fichiers distants via un réseau, offre aux utilisateurs un accès aux fichiers, vous permet de travailler avec ces fichiers de la même manière qu'avec les fichiers locaux. </p><br><p>  Bien entendu, la plupart des NAS (NAS) disponibles sur le marché prennent en charge NFS et permettent d'accéder aux ressources locales ainsi qu'à tout serveur doté d'un système d'exploitation sur lequel il est possible de déployer le service NFS. </p><br><p>  Les paramètres d'accès aux ressources du serveur depuis n'importe quel système d'exploitation Ubuntu et l'adresse IP 192.168.1.1 sont contenus dans le fichier / etc / exports et sont des entrées du formulaire: </p><br><ul><li>  / data / place1 192.168.1.0/255.255.255.0(rw,no_subtree_check,nohide,async) 192.168.101.0/255.255.255.0(rw,no_subtree_check,nohide,async) </li><li>  data / place2 192.168.1.0/255.255.255.0(rw,no_subtree_check,nohide,async) 192.168.101.0/255.255.255.0(rw,no_subtree_check,nohide,async) </li></ul><br><p>  Dans ce cas, l'accès NFS au serveur et à ses ressources / données / place1 est possible pour les clients avec des adresses IP des réseaux 192.168.1.0/255.255.255.0, 192.168.101.0/255.255.255.0. </p><br><p> Montez la ressource distante dans un répertoire local, par exemple, / home / user / example, si le client est sur un sous-réseau autorisé et que le client pour NFS est installé, c'est possible via la commande (Ubuntu): <br> <code>mount -t nfs 192.168.1.1:/data/place1 /home/user/example</code> </p> <br><p>  Si au lieu des adresses IP * ou (tout le monde) est indiqué, alors souvent, n'importe quel client peut monter une ressource distante dans son système. </p><br><p>  L'utilisateur (par exemple, sous Ubuntu) a juste besoin de taper dans le terminal: showmount -e ip-target et obtenir des informations sur les ressources disponibles sur le serveur (liste d'exportation du serveur). </p><br><p>  Par exemple: <br> <code>showmount -e 81.24..</code> <br> <code>Export list for 81.24..:</code> <br> <code>/home/admin 192.168.52.1/24</code> </p> <br><p>  Ainsi, le scénario suivant est formé: pour détecter les serveurs exécutant NFS, déterminer les ressources disponibles sur les serveurs, consolider le résultat dans un formulaire de sortie unique, puis procéder selon la situation. </p><br><p>  Ce qui peut être sur les ressources - évidemment, n'importe quoi: </p><br><ul><li>  les fichiers personnels des utilisateurs d'Internet, par exemple, dans le cas d'appareils NAS "ouverts"; </li><li>  répertoires contenant des fichiers d'entreprises entières, des bases de données, des archives de bases de données; </li><li>  souvent des répertoires avec des adresses / home / * (parfois avec des clés en .ssh et en écriture); </li><li>  répertoires contenant des fichiers de systèmes de vidéosurveillance; </li><li>  autre ... </li></ul><br><h2 id="poluchenie-ip-adresov">  Obtenir des adresses IP </h2><br><p>  En ce qui concerne la découverte de serveurs avec NFS sur Internet mondial, il y a 2 façons: indépendamment, en utilisant divers outils, et des résultats d'analyse, des bases de données et des services tiers prêts à l'emploi.  En fait, tout se résume à obtenir une liste d'adresses IP.  Dans le réseau local, je pense que l'option est évidente - agir de manière indépendante. </p><br><p>  Les ports TCP ouverts 111, 2049 peuvent servir de preuve du fonctionnement du service NFS. <br>  Pour obtenir indépendamment une liste d'adresses IP de serveur, il suffit d'analyser la plage d'adresses ou le sous-réseau entier pour la présence des ports ouverts indiqués.  N'importe quel outil convient à cela: nmap, masscan, etc. </p><br><p>  Par exemple, avec la commande <code>masscan -p111,2049 200.26.1XX.0/24 —rate=10000</code> réseau 200.26.1XX.0 / 24 sera analysé pendant plusieurs secondes pour les ports ouverts 111, 2049: <br> <code>Scanning 256 hosts [2 ports/host]</code> <br> <code>Discovered open port 2049/tcp on 200.26.1XX.28</code> <br> <code>Discovered open port 111/tcp on 200.26.1XX.15</code> <br> <code>Discovered open port 111/tcp on 200.26.1XX.20</code> <br> <code>Discovered open port 111/tcp on 200.26.1XX.28</code> <br>  En plus de chacune des adresses IP détectées, il est possible d'appliquer la commande: <br> <code>showmount --no-headers -e 200.26.1XX.28</code> <br>  Résultat: <br> <code>/usr/common *</code> <br>  De toute évidence, il est possible de scanner vous-même des millions d'adresses IP de l'espace Internet, mais ce n'est pas le moyen le plus rapide, puis le merveilleux service <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shodan</a> peut être la solution à la sous-tâche, il y en a bien sûr d'autres, mais celui-ci avec une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">syntaxe</a> et une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API</a> très pratiques.  Plonger dans la description des capacités du service n'est pas le but de l'article.  En bref - le service permet une recherche avancée des appareils connectés à Internet.  Les critères de recherche peuvent être des identifiants de réseau et d'autres métadonnées: numéros de série de certificats et similaires.  Shodan possède de nombreuses fonctionnalités pour la recherche ciblée, mais je n'ai pas trouvé de recherche distincte sur NFS, car, par exemple, il existe un critère de produit avec un nom de produit: mongodb, élastique ou apache.  Par conséquent, via Web NFS, il est possible de rechercher les requêtes suivantes: nfs, tcp 2049, tcp 111, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Portmap: 2049</a> et ainsi de suite, comme vous le souhaitez. </p><br><p><img src="https://habrastorage.org/webt/am/n2/hq/amn2hqii1_gsemlxivnffoawgek.png"></p><br><p>  Ou installez le client Shodan (CLI), initialisez votre API KEY au service et appelez une recherche à partir de la ligne de commande, par exemple: </p><br><ol><li>  recherche shodan --fields ip_str, port Portmap: 2049 </li><li>  recherche shodan --fields ip_str, port --separator, nfs <br>  Résultat: <br>  139.196.154.23.111, <br>  198.27.116.37.111, <br>  95.211.192.96.111, <br>  80.23.66.122.111, <br>  210.116.82.97.111, <br>  192.198.82.3.111, <br>  165.227.67.242.111, <br>  116.12.48.9.111, <br>  85.34.250.102.111, <br>  182.75.249.197.111, <br>  192.151.212.175,111, <br>  119.216.107.127.111, <br>  217.59.68.2.111, <br>  178.159.12.97.111, <br>  ... </li></ol><br><p>  Ainsi, comment obtenir les listes d'adresses IP des appareils avec un service NFS valide est compréhensible. </p><br><h2 id="poluchenie-informacii-o-dostupnyh-resursah-sluzhby-nfs-na-konkretnyh-serverah">  Récupérez des informations sur les ressources NFS disponibles sur des serveurs spécifiques. </h2><br><p>  Il existe de nombreuses façons de résoudre ce problème en masse: écrire des scripts bash, organiser un pipeline délicat à partir d'une chaîne de commandes avec un appel à showmount, et d'autres options - qui aime quoi. </p><br><p>  Dans mes recherches, j'ai résolu ce problème en Python, et de deux manières différentes.  Le premier se connecte via ssh à votre serveur personnel sur Ubuntu avec un client NFS, puis invoque la commande showmount dessus avec le pool d'adresses IP souhaité.  La deuxième solution est en Python pur. </p><br><p>  Je suppose qu'une question peut se poser: pourquoi est-ce si difficile, pourquoi en Python? </p><br><p>  Car, comme dans mon précédent article sur Habr, j'utiliserai l'outil Lampyre, sur lequel le 26 février ils ont publié une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API</a> qui vous permet d'écrire vos modules sur la plateforme en Python. </p><br><div class="spoiler">  <b class="spoiler_title">Lampyre</b> <div class="spoiler_text"><p>  <em>En bref sur Lampyre - une plate-forme logicielle pour OSINT et l'analyse de données avec un client "épais" pour Windows, un analogue de l'outil bien connu et populaire dans le même but - Maltego.</em>  <em>Comme à Maltego, Lampyre «out of the box» fournit un ensemble de demandes pour divers services.</em>  <em>Les requêtes sont conceptuellement équivalentes aux transformations d'un produit mieux connu.</em>  <em>S'il manque quelque chose, il est désormais possible d'écrire vos propres demandes.</em>  <em>Les demandes fournies avec Lampyre sont exécutées sur l'infrastructure de la plate-forme, écrites indépendamment - sur la machine.</em>  <em>Autrement dit, l'utilisateur doit avoir installé Python et toutes les bibliothèques nécessaires utilisées dans le code.</em> </p></div></div><br><p>  J'ai décidé de tester les capacités de l'API.  Le point clé est que Lampyre a déjà plusieurs «demandes» à Shodan, d'autant plus que l'utilisateur n'a pas besoin d'avoir son API KEY du service.  Ainsi, avec une seule demande, vous pouvez obtenir des listes d'adresses IP avec le service NFS déclenché, et avec la deuxième demande, le module que j'ai écrit vérifiera les ressources disponibles et visualisera le résultat avec les caractéristiques des ressources sur le même graphique. </p><br><h2 id="prichem-tut-koreya">  Et ici la Corée </h2><br><p>  Lors de la recherche à partir de Shodan et du test du module, il est devenu intéressant de voir la situation avec la qualité et la quantité des résultats de numérisation par le service Shodan dans les pays asiatiques, comment les choses se passent avec des ressources précaires.  Le choix s'est porté sur la République de Corée, je pense qu'il n'est pas nécessaire de dire que la Corée du Sud est un pays très avancé technologiquement, et j'ai suggéré que vous puissiez trouver quelque chose d'intéressant dans ses réseaux. </p><br><p>  Recherche par Shodan, dans Requête: <strong>nfs</strong> , dans Pays: République de Corée code, <strong>kr</strong> </p><br><p><img src="https://habrastorage.org/webt/o0/e8/fy/o0e8fya-deqqydh5uaetrbgsvqe.png"></p><br><p>  Le résultat ne tarde pas à venir (dans l'image ci-dessous, seulement une partie du schéma général). </p><br><p><img src="https://habrastorage.org/webt/z1/-4/ir/z1-4ir1uwvo7buc3ie46qfcuuo0.png"></p><br><p>  Liste d'hôtes: </p><br><ul><li>  psi.kaist.ac.kr </li><li>  hulk.kaist.ac.kr </li><li>  messi.kaist.ac.kr </li><li>  marvel.kaist.ac.kr </li><li>  kaist.ac.kr </li><li>  ai1.kaist.ac.kr </li><li>  jarvis3.kaist.ac.kr </li><li>  baraddur.kaist.ac.kr </li><li>  rho.kaist.ac.kr </li><li>  jarvis.kaist.ac.kr </li></ul><br><p>  Tous, comme on peut le voir sur le graphique et dans les noms, sont répertoriés comme AS1781 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Kaist">Korea Advanced Institute of Science and Technology</a> </p><br><p><img src="https://habrastorage.org/webt/ci/ez/nd/ciezndaw7a3brrrrxmcbe1wppak.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Wikipédia">Korea Advanced Technology Institute</a> - la principale université universitaire et de recherche de Corée du Sud située à Daejeon, est sur la deuxième ligne du classement national en Corée du Sud.  L'université est systématiquement incluse dans 5% des meilleurs établissements d'enseignement en Corée du Sud. </p><br><p>  Nous utilisons les adresses IP spécifiées comme arguments d'entrée dans le module écrit «Explore: NFS (SSH)» et par conséquent: </p><br><p><img src="https://habrastorage.org/webt/u2/dm/ur/u2dmurykafqs9yqdor1s06hg0wc.png"></p><br><p>  J'ai rapidement élaboré un tel schéma pour afficher les résultats d'un tableau dans un graphique (sur les schémas et les principes de construction de graphiques plus loin dans l'article). </p><br><p><img src="https://habrastorage.org/webt/ev/v4/44/evv444hbsakygnttrnhxuinlmq0.png"></p><br><p>  Le résultat de la combinaison avec un schéma Shodan </p><br><p><img src="https://habrastorage.org/webt/ys/pk/ij/yspkijyrvwhazpwjrzvfr5daabs.png"></p><br><p>  Lors de l'analyse des sommets et des relations du graphique, il devient évident à quelles adresses la ressource / home est disponible, accessible à tous (*). </p><br><p>  Pour une meilleure perception visuelle, modifiez les propriétés des objets graphiques et d'autres paramètres du diagramme: </p><br><p><img src="https://habrastorage.org/webt/nl/j5/9z/nlj59zv9p321nvnavqgin6krc1q.png"></p><br><p>  Bien sûr, j'ai monté à tour de rôle une partie des ressources sur l'un de mes serveurs et j'ai commencé à étudier.  Il s'est avéré presque le même partout - répertoires d'utilisateurs: asm, hoo, hyshin, jay, jiwon, jkhee110, jokangjin, kmh603, ksm782, lee, linus, lost + found, marvel_guest, pie, qwe, scloud, seokmin, sgim, thrlek, yoosj, ysha, zinnia7. </p><br><p>  Presque tous les répertoires contenant des fichiers ont été lus et écrits.  Certains utilisateurs de .ssh disposaient de fichiers authorized_keys avec un accès en écriture à ceux-ci. </p><br><p>  J'ai généré ma clé, l'ai copiée sur les clés autorisées de l'un des utilisateurs et je me suis connecté au serveur via ssh sur le port 2222, j'ai reçu le numéro de port des données de Shodan. </p><br><p>  <em>Utilisateurs, paramètres réseau:</em> </p><br><p><img src="https://habrastorage.org/webt/i4/gr/i5/i4gri5enls82hjdxe6hwtq-xqpq.png"></p><br><p>  <em>Hôtes sur le réseau:</em> </p><br><p><img src="https://habrastorage.org/webt/bz/sg/y3/bzsgy3oti0hescz1uxmcud7krpa.png"></p><br><p>  <em>Le fichier / etc / exports et les lecteurs:</em> </p><br><p><img src="https://habrastorage.org/webt/1v/sk/7e/1vsk7eluqu93suzw5gxo65kbzg8.png"></p><br><p>  <em>Fichier / etc / fstab et OS:</em> </p><br><p><img src="https://habrastorage.org/webt/uh/iv/cp/uhivcpdgcfzx1pezrbi_aguvgz4.png"></p><br><p>  Je crois qu'il s'agit d'un réseau d'un département pour les étudiants diplômés ou les étudiants, et ils effectuent une sorte de calculs sur les serveurs, car il existe de nombreuses sources Python différentes, quelque chose en rapport avec le GPU et la distribution Anaconda, etc.  Je n'ai pas tout étudié et j'ai commencé à penser quoi faire avec tout cela, bien sûr, je pouvais "marcher" pour la plupart des nœuds <em>(peut-être que je pourrais penser à quelque chose de plus exotique)</em> , mais cela ne m'a pas beaucoup intéressé.  Et j'ai pensé ce qui suit: puisque l'institut est scientifique et avancé, il devrait y avoir des domaines de la sécurité de l'information.  En effet, même un laboratoire entier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="softsec.kaist.ac.kr">Software Security Lab</a> et son chef, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sang Kil Cha</a> <br>  J'ai décidé de lui écrire une lettre, et ils disent donc que permettre à tout le monde de connecter des ressources NFS avec des autorisations de lecture et d'écriture à Internet est très dangereux, apparemment, vous devez réparer quelque chose, joindre des captures d'écran et envoyer. </p><br><div class="spoiler">  <b class="spoiler_title">Lettre 1</b> <div class="spoiler_text"><blockquote>  <strong><em>Cher Sang Kil Cha,</em></strong> <strong><em><br></em></strong>  <strong><em>Je vous écris, car sur le site kaist.ac.kr, vous êtes considéré comme le principal laboratoire SoftSec de KAIST, et je crois que la question suivante vous préoccupe.</em></strong> <strong><em><br></em></strong>  <strong><em>Lors de nos recherches dans le domaine de la sécurité informationnelle, involontairement et par hasard les serveurs suivants ont été détectés:</em></strong> <strong><em><br></em></strong>  <strong><em>143.248.247.131 - psi.kaist.ac.kr</em></strong> <strong><em><br></em></strong>  <strong><em>143.248.247.4 - jarvis3.kaist.ac.kr</em></strong> <strong><em><br></em></strong>  <strong><em>143.248.247.169</em></strong> <strong><em><br></em></strong>  <strong><em>143.248.247.223</em></strong> <strong><em><br></em></strong>  <strong><em>143.248.247.235</em></strong> <strong><em><br></em></strong>  <strong><em>143.248.247.251 - marvel.kaist.ac.kr</em></strong> <strong><em><br></em></strong>  <strong><em>143.248.247.239 - jarvis.kaist.ac.kr</em></strong> <strong><em><br></em></strong>  <strong><em>143.248.247.194 - hulk.kaist.ac.kr</em></strong> <strong><em><br></em></strong>  <strong><em>143.248.2.23</em></strong> <strong><em><br></em></strong>  <strong><em>Tous ces serveurs ont le service NFS (Network File System) opérationnel.</em></strong> <strong><em><br></em></strong>  <strong><em>Le niveau de sécurité d'accès à ces serveurs est incroyablement bas.</em></strong> <strong><em><br></em></strong>  <strong><em>Les répertoires personnels de ces serveurs avec tout leur contenu sont accessibles à toute personne utilisant Internet.</em></strong> <strong><em><br></em></strong>  <strong><em>Par exemple, les paramètres nfs - / etc / exports 143.248.247.251 -&gt; / home <em>ou pour 143.248.247.239</em></em></strong> <strong><em><em><br></em></em></strong>  <strong><em><em>showmount -e 143.248.247.239</em></em></strong> <strong><em><em><br></em></em></strong>  <strong><em><em>Exporter la liste pour 143.248.247.239:</em></em></strong> <strong><em><em><br></em></em></strong>  <strong><em><em>/ données</em></em></strong> <strong><em><br></em></strong>  <strong><em>/ home <em>/ appl</em></em></strong> <strong><em><br></em></strong>  <strong><em>Les répertoires utilisateur de la plupart des serveurs sont accessibles en lecture et en écriture, y compris leurs sous-répertoires, qui contiennent des clés d'accès ssh publiques et privées.</em></strong> <strong><em><br></em></strong>  <strong><em>L'édition de fichiers permet d'ajouter de nouvelles clés d'accès et d'accéder à distance ssh aux serveurs, puis - à certains sous-réseaux KAIST internes.</em></strong> <strong><em><br></em></strong>  <strong><em>Uniquement pour tester un tel accès peu profond a été obtenu, aucune modification n'a été apportée, aucune donnée n'a été éditée, copiée ou supprimée, aucun dommage n'a été causé à l'infrastructure.</em></strong> <strong><em><br></em></strong>  <strong><em>Veuillez consulter les fichiers joints pour une sorte de reconnaissance et de preuve.</em></strong> <strong><em><br></em></strong>  <strong><em>Je n'ai aucune exigence ni réclamation, mais je recommande d'améliorer considérablement le niveau de sécurité de votre réseau.</em></strong> </blockquote></div></div><br><p>  Bientôt, ils m'ont répondu, traduction gratuite: merci, nous transmettrons à tout le monde. </p><br><div class="spoiler">  <b class="spoiler_title">Réponse 1</b> <div class="spoiler_text"><blockquote>  <strong><em>Merci de m'avoir prévenu!</em></strong>  <strong><em>Je transmettrai cet e-mail à un responsable du réseau et de la sécurité.</em></strong>  <strong><em>Meilleur, Sang Kil</em></strong> </blockquote></div></div><br><p>  Avant de publier cet article, j'ai décidé de vérifier, voir ce qui a changé: </p><br><p><img src="https://habrastorage.org/webt/ia/w5/tv/iaw5tvajx2s5sw8l5rmed42cs2m.png"></p><br><p>  En effet, l'accès aux ressources n'était autorisé qu'à partir des machines du réseau interne, mais qu'en est-il du serveur 143.248.247.251.  Selon les entrées du tableau, les ressources hôte dans les paramètres NFS restent *.  J'ai esquissé une autre version du «mappage» du tableau dans un graphique: </p><br><p><img src="https://habrastorage.org/webt/p0/fy/xu/p0fyxuck0k1mza0y-ebciyk9tik.png"></p><br><p>  Quels sont les changements dans le «mappage»: les objets NFS «collent maintenant» avec 2 attributs identiques - IP et chemin NFS.  L'objet Status est créé uniquement lorsque l'attribut value, qui contient le contenu de la colonne d'enregistrement brut, contient la valeur " <strong>*</strong> " <br>  Et le graphique sur le tableau apparaît sous une nouvelle forme: </p><br><p><img src="https://habrastorage.org/webt/zb/ht/k0/zbhtk0swvgaxzkogph-tlqn88_g.png"></p><br><p>  Maintenant, en passant, l'adressage du réseau interne est devenu clairement visible, et sur le serveur 143.248.247.251, il est également possible de modifier le contenu des répertoires utilisateur, des fichiers;  en principe, les possibilités sont restées les mêmes qu'auparavant. </p><br><p>  Et j'écris donc une deuxième lettre à M. Sang Kil Cha, avec un premier contenu similaire, notant que certains des événements seront présentés dans un article sur la populaire ressource habr.com: </p><br><div class="spoiler">  <b class="spoiler_title">Lettre 2</b> <div class="spoiler_text"><blockquote>  <strong><em>Cher Sang Kil Cha, bonne journée à toi.</em></strong> <strong><em><br></em></strong>  <strong><em>J'ai décidé de vérifier si quelque chose avait changé après mon e-mail et en effet, les paramètres d'accès ont été modifiés.</em></strong>  <strong><em>Mais apparemment, les ingénieurs en sécurité ont omis l'adresse IP 143.248.247.251 et ses paramètres sont restés les mêmes.</em></strong>  <strong><em>Veuillez également sécuriser cette adresse IP afin qu'aucun étranger ne puisse y accéder.</em></strong> <strong><em><br></em></strong>  <strong><em>J'écris un article sur le sujet de la sécurité de l'information et je le publierai sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://habr.com</a> .</em></strong>  <strong><em>Il s'agit d'un site Web très populaire en Russie.</em></strong>  <strong><em>L'article comprendra quelques passages sur la question de la faible qualité des paramètres d'accès NFS avec quelques exemples de cas avec vos serveurs.</em></strong>  <strong><em>Je vous enverrai le lien vers mon article lorsqu'il sera publié.</em></strong> </blockquote></div></div><br><h2 id="kak-ispolzovat-api-lampyre-i-napisat-svoy-modul">  Comment utiliser l'API Lampyre et écrire votre module </h2><br><p>  Le module devra accepter une liste d'adresses IP ou une liste de sous-réseaux sous la forme 192.168.0 / 24 en entrée - à ce stade, il sera nécessaire de valider les données d'entrée sur l'implication des chaînes dans les adresses IP indépendamment dans le code, dans le cas d'un sous-réseau - convertir en liste IP. </p><br><p>  L'étape suivante, via la bibliothèque Python <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">paramiko</a> , sera accessible au serveur ssh personnel et séquentielle (il y a une tentative d'asynchronie dans le code concept du module) la commande est appelée: <br> <code>timeout {timeouts} showmount --no-headers -e {ip}</code> <br>  La sortie du résultat sera analysée via le code Python dans la structure de sortie, table: une liste de dictionnaires en Python. <br>  Clés dans le dictionnaire: </p><br><ul><li>  current_day - date de demande de l'utilisateur </li><li>  host_query - IP pour laquelle les informations sont reçues </li><li>  shared_path - ressource NFS </li><li>  status_ip - informations sur l'accès à la ressource, si les adresses IP sont répertoriées via ",", la chaîne du dictionnaire est dupliquée dans la liste. </li></ul><br><p>  En outre, selon le concept du concept, une tentative primitive est effectuée pour analyser la valeur de la clé status_ip dans le sujet: adresse IP, enregistrement d'hôte, les valeurs "*" ou "tout le monde" </p><br><p>  Selon la documentation de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API</a> et les explications du support Lampyre.io - chaque module doit renvoyer des données à la table, une ou plusieurs, mais la table doit être décrite comme faisant partie de l'API (en-têtes de tâche, en-tête de table).  En fait, c'est le résultat principal du module. <br>  Ainsi, le résultat final, en tenant compte des clés du dictionnaire, sera un tableau: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NFSHeader</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(metaclass=Header)</span></span></span><span class="hljs-class">:</span></span> display_name = <span class="hljs-string"><span class="hljs-string">'Search data from NFS services'</span></span> current_day = Field(<span class="hljs-string"><span class="hljs-string">'Date'</span></span>, ValueType.Datetime) host_query = Field(<span class="hljs-string"><span class="hljs-string">'Search ip'</span></span>, ValueType.String) shared_path = Field(<span class="hljs-string"><span class="hljs-string">'NFS path'</span></span>, ValueType.String) ip = Field(<span class="hljs-string"><span class="hljs-string">'ip address'</span></span>, ValueType.String) network = Field(<span class="hljs-string"><span class="hljs-string">'network address'</span></span>, ValueType.String) host = Field(<span class="hljs-string"><span class="hljs-string">'host'</span></span>, ValueType.String) status = Field(<span class="hljs-string"><span class="hljs-string">'raw record'</span></span>, ValueType.String)</code> </pre> <br><p>  Les valeurs (légèrement modifiées) de l'analyse du résultat de la commande showmount sur le serveur seront écrites dans la table.  Les noms des champs de la classe parlent d'eux-mêmes; dans la colonne d'enregistrement brut, les informations sur l'accès à la ressource seront stockées.  Dans un sens, cette analyse des données sur les ressources NFS peut également être considérée comme un OSINT, les informations sur un accès possible à partir de diverses adresses IP donnent une idée des propriétaires de la ressource ou de l'adressage au sein du réseau de ressources.  Par exemple, l'adresse IP du serveur avec NFS est située en Ukraine et l'adresse IP autorisée pour l'accès est en Allemagne: </p><br><p><img src="https://habrastorage.org/webt/hp/mf/mr/hpmfmro1juiiepv15asjt1-wjuo.png"></p><br><p>  Et si vous développez l'étude de cet exemple, il y a immédiatement confirmation de la connexion des serveurs non seulement via NFS, mais également via un certificat aux adresses: 77.120.103.9, 138.201.202.135 et le domaine * .aniart.com.ua: </p><br><p><img src="https://habrastorage.org/webt/1u/vv/cx/1uvvcxp71ezvhzbvjplr57agbtm.png"></p><br><p>  Comment transférer des données vers un module et écrire dans une table: <br>  Créez votre propre classe SearchDataNFS à partir de la classe Task: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SearchDataNFS</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Task)</span></span></span></span></code> </pre> <br><p>  Dans la méthode <code>get_id</code> , <code>get_id</code> retournons un UUID aléatoire unique: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_id</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'bf51fd57-3fec-4416-9d07-905935a484b4'</span></span></code> </pre> <br><p>  Dans la méthode <code>get_display_name</code> spécifiez comment la tâche sera appelée, et dans la méthode <code>get_description</code> , selon le nom, la description de la tâche: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_display_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Explore: NFS(SSH)'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_description</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Explore NFS resourses'</span></span></code> </pre> <br><p>  Dans la méthode <code>get_headers</code> spécifiez les tables que nous utiliserons: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_headers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NFSHeader</code> </pre> <br><p>  La méthode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">get_enter_params</a> déterminera l'apparence de la fenêtre d'entrée.  D'après le code, il est évident qu'une liste de chaînes est fournie à l'entrée, qui sera ensuite convertie en adresses IP indépendamment: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_enter_params</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> ep_coll = EnterParamCollection() ep_coll.add_enter_param(<span class="hljs-string"><span class="hljs-string">'ips'</span></span>, <span class="hljs-string"><span class="hljs-string">'IP'</span></span>, ValueType.String, is_array=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, value_sources=[Attributes.System.IPAddress], description=<span class="hljs-string"><span class="hljs-string">'IPs, networks'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ep_coll</code> </pre> <br><p>  Dans la méthode d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exécution</a> , l'exécution de la tâche principale a lieu: </p><br><pre> <code class="python hljs">ips = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> input_ip <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> set(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> z: z.strip(), enter_params.ips)): ips.extend(reparse_ip_hosts(input_ip))</code> </pre> <br><p>  Les paramètres d'entrée sont accessibles via enter_params.ips.  Dans la méthode <code>reparse_ip_hosts</code> , une validation auto-implémentée des chaînes en adresses IP se produit. </p><br><pre> <code class="python hljs">targets = ((ip, port) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ip <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ips <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> port <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ports) lines = thread_async_nfs_one_client(targets) info = reparse_result_rows(lines) fields_table = NFSHeader.get_fields() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> data_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> info: tmp = NFSHeader.create_empty() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> field <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> fields_table: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> field <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data_id: tmp[fields_table[field]] = data_id[field] result_writer.write_line(tmp, header_class=NFSHeader)</code> </pre> <br><p>  La fonction <code>thread_async_nfs_one_client</code> connecte au serveur avec ssh (l'adresse IP, le nom d'utilisateur et le mot de passe sont définis par le code dur) et showmount est exécuté, comme indiqué précédemment, le résultat est analysé, puis il est à nouveau modifié dans la fonction <code>reparse_result_rows</code> .  Il est important de noter que info est une liste composée de dictionnaires, dans chaque dictionnaire les clés sont nommées en tant que champs de la classe NFSHeader.  Autrement dit, le dictionnaire ressemble à ceci: </p><br><pre> <code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">'current_day'</span></span>: datetime.datetime(<span class="hljs-number"><span class="hljs-number">2019</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>), <span class="hljs-string"><span class="hljs-string">'host_query'</span></span>: <span class="hljs-string"><span class="hljs-string">'192.168.1.1'</span></span>, <span class="hljs-string"><span class="hljs-string">'shared_path'</span></span>: <span class="hljs-string"><span class="hljs-string">'/volume1/workspace'</span></span>, <span class="hljs-string"><span class="hljs-string">'ip'</span></span>: <span class="hljs-string"><span class="hljs-string">'192.168.10.10'</span></span>, <span class="hljs-string"><span class="hljs-string">'network'</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'host'</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'status'</span></span>: <span class="hljs-string"><span class="hljs-string">'192.168.10.10'</span></span> }</code> </pre> <br><p>  Il est important d'observer les types de données dans le dictionnaire, ils doivent être les mêmes que dans la description du tableau. <br>  Plus loin dans la boucle, l'itération à travers les éléments de la liste et leur écriture via la méthode API ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">result_writer.write_line</a> ) dans une table NFSHeader spécifique se produit. <br>  Pour une description plus détaillée, vous devriez lire la documentation. <br>  Fondamentalement, le module est prêt à être ajouté à Lampyre. </p><br><h2 id="ispolzovanie-svoego-modulya-v-lampyre">  Utiliser votre module à Lampyre </h2><br><p>  Étant donné que ssh est utilisé et l'exécution de la commande showmount, vous devez bien sûr avoir accès à votre serveur via ssh.  Pour mes tests, ce rôle a été joué par la machine virtuelle dans Virtualbox avec Ubuntu et le client NFS installé dessus. </p><br><p>  Pour travailler avec des modules natifs sur la machine d'un utilisateur, Python 3.6 est requis, le chemin d'accès à l'interpréteur doit être dans les variables système ou le chemin d'accès doit être spécifié dans le <code>Lampyre\config\appSettings.config</code> .  Par défaut, la clé pythonPath est mise en commentaire dans les paramètres. </p><br><p>  Le chargement d'un module dans Lampyre s'effectue selon les étapes suivantes: </p><br><ol><li>  Dans la fenêtre Scripts, chargez le fichier Lampyre \ user_tasks \ ontology.py (fourni avec l'application) </li><li>  Dans la même fenêtre, chargez votre module, dans ce cas nfs_via_ssh.py.  En cas de problème, le bouton <em>Détails</em> devrait vous aider </li><li>  Après le chargement, dans la fenêtre <em>Liste des demandes</em> de l'onglet <em>Tâches</em> , la <em>section Tâches locales</em> apparaîtra (dans le code du module vous pouvez l'appeler différemment), elle a le nom <em>Explorer: NFS (SSH)</em> : <br><br><img src="https://habrastorage.org/webt/5j/q2/6w/5jq26wc0brfodioawferz1_mu-8.png"><br>  Fenêtre Liste des demandes mise à jour: <br><br><img src="https://habrastorage.org/webt/gv/gs/tb/gvgstbglshazcckwnl6wevpjlla.png"></li><li>  Les adresses IP des serveurs avec NFS, comme je l'ai dit plus tôt, sont mieux obtenues en exécutant d'abord une requête de <em>recherche Shodan</em> avec les paramètres <em>Query: tcp 2049</em> (vous pouvez simplement spécifier <em>nfs</em> ).  Le paramètre <em>Page ou plage</em> , défini par défaut sur 1, signifie que 1 page de réponses du service Shodan sera retournée, sur une page il y a généralement 100 résultats (lignes). <br>  Le résultat de l'exécution de Shodan: <br><br><img src="https://habrastorage.org/webt/zb/ui/uw/zbuiuww94uf18wbzhh9pm2aomoe.png"></li><li>  Copiez les adresses IP du tableau ou du diagramme dans le presse-papiers et collez-les dans la fenêtre du module IP Explore: NFS (SSH).  Exécutez et attendez le résultat: <br><br><img src="https://habrastorage.org/webt/t8/2h/vz/t82hvzwegvfjmbjcfch662vx7nk.png"></li></ol><br><p>  Bien sûr, vous devez prendre en compte la bande passante de vos propres serveurs et des serveurs étrangers, ainsi que le délai d'expiration, qui sont définis de manière rigide dans le code du module. </p><br><p>  Le résultat est obtenu sous la forme d'un tableau, mais vous pouvez continuer et combiner le résultat du tableau avec le graphique des résultats de l'exécution de la recherche Shodan.  Ce sera quelque peu difficile à percevoir au début. </p><br><h2 id="vizualizaciya-tablicy-s-rezultatom">  Visualisation du tableau avec le résultat </h2><br><p>  Commençons.  Il y a une table avec un ensemble de colonnes avec des valeurs de l'exécution du module utilisateur.  Mais si vous faites attention au bouton Schéma de la fenêtre Demandes - il est inactif.  Parce que le mappage de la table sur le graphique n'est pas défini et doit être défini. </p><br><p>  <em><strong>Schéma 1 (pas le meilleur)</strong></em> <br>  Avec le tableau ouvert, à partir du résultat du module, dans le coin inférieur droit se trouve un élément d'interface «Ajouter un modèle de création», en cliquant sur lequel la fenêtre «Modèle de création» apparaît.  En cela, vous pouvez spécifier le mappage des lignes de tableau aux objets graphiques, je ne décrirai pas le processus en détail dans l'article, le lien sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Tutoriel Lampyre - Analyse financière">le canal de la plate-forme</a> sur Youtube montre comment le faire, dans l'article je me limiterai aux images de ce qui devrait arriver: </p><br><p><img src="https://habrastorage.org/webt/qj/vd/ju/qjvdjurktmgvg17ymyrv_flbohu.png"></p><br><p>  Modèle de graphique: </p><br><p><img src="https://habrastorage.org/webt/am/n_/od/amn_odxussgaxfxuw_yzwwyu5ee.png"></p><br><p>  Il est important de noter que les objets IP, Domain sont en Lampyre, et j'ai créé des objets NFS et Network.     ,    «»  . ,      ,    —     «»   — ,  —    - ,          . ,   NFS –  2 , NFS path  Status,   — NFS path.      —     .   «»        —    <em>Schema</em>  . <br>  : </p><br><p><img src="https://habrastorage.org/webt/vy/al/oj/vyaloj8xba0pbjl7iiobalahaqy.png"></p><br><p>      : </p><br><p><img src="https://habrastorage.org/webt/ix/3u/jr/ix3ujruec1bbtfbbbi3i6ru_3mu.png"></p><br><p>      «»               — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">i2 (IBM i2 Analyst's Notebook)</a> : </p><br><p><img src="https://habrastorage.org/webt/w7/sr/dn/w7srdn9y0ko8jwqi2viop0uj4l8.png"></p><br><p>      «»  ,     :   IP-   IP-  ,    ,    NFS  ,          IP.     (      ). </p><br><p> <em><strong> 2</strong></em> </p><br><p><img src="https://habrastorage.org/webt/iy/y7/wt/iyy7wtjyjeb4onmq0vcjjxb50gu.png"></p><br><p>  .      —     ,    IP-    : </p><br><p><img src="https://habrastorage.org/webt/n5/zw/sb/n5zwsbgrorkn2-vucszn1hulsgk.png"></p><br><p>           ,         ,       (csv)  .   ,     «»      .    «»         ,         . </p><br><p>       Shodan  NFS    Shodan search,   add to active tab          —  : </p><br><p><img src="https://habrastorage.org/webt/qq/e-/3p/qqe-3p5p8bdbogvruzlqs8pypze.png"></p><br><p>  : </p><br><p><img src="https://habrastorage.org/webt/8w/uj/az/8wujazcvenzdsalorp1nh5mfas8.png"></p><br><p>    Lampyre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,          ssh. </p><br><p>   — ,      NFS   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444382/">https://habr.com/ru/post/fr444382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444370/index.html">De quoi le format Mini PCI-e est-il capable?</a></li>
<li><a href="../fr444372/index.html">Orientation longue distance de la machine grâce à un apprentissage renforcé</a></li>
<li><a href="../fr444374/index.html">Effet hipster: pourquoi les non-conformistes se ressemblent souvent</a></li>
<li><a href="../fr444376/index.html">L'économie de l'attention est presque morte</a></li>
<li><a href="../fr444378/index.html">USPACE - Espace unique pour les avions avec et sans pilote</a></li>
<li><a href="../fr444384/index.html">Livre "Analyse des données textuelles appliquées en Python"</a></li>
<li><a href="../fr444386/index.html">Mission lunaire "Bereshit" - la quatrième manœuvre s'est terminée avec succès, les préparatifs sont en cours pour entrer dans l'orbite lunaire</a></li>
<li><a href="../fr444388/index.html">Modems légendaires du passé: les meilleurs détenteurs de connexion dans les conditions des échanges domestiques</a></li>
<li><a href="../fr444390/index.html">Système DeviceLock 8.3 DLP: un an s'est écoulé, Billy, mais vous n'avez pas changé du tout</a></li>
<li><a href="../fr444392/index.html">Rayonnement: risques, sécurité, protection</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>