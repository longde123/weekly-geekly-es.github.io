<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüëß‚Äçüëß üë©üèæ‚Äçüîß ü¶Ñ Singleton colocando objetos en ROM y variables est√°ticas (C ++ usando el microcontrolador Cortex M4 como ejemplo) üíî üßîüèø üêá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En un art√≠culo anterior, ¬øD√≥nde se almacenan sus constantes en un microcontrolador CortexM (usando el compilador C ++ IAR como ejemplo) , se discuti√≥ ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Singleton colocando objetos en ROM y variables est√°ticas (C ++ usando el microcontrolador Cortex M4 como ejemplo)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455477/"><img src="https://habrastorage.org/webt/4e/6g/sw/4e6gswsjjz0liihmy5ptbivomuu.jpeg" alt="imagen"><br><br>  En un art√≠culo anterior, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øD√≥nde se almacenan sus constantes en un microcontrolador CortexM (usando el compilador C ++ IAR como ejemplo)</a> , se discuti√≥ la cuesti√≥n de c√≥mo colocar objetos constantes en la ROM.  Ahora, quiero decirte c√≥mo puedes usar el patr√≥n generador solitario para crear objetos en ROM. <br><a name="habracut"></a><br><br><h3>  Introduccion </h3><br>  Ya se ha escrito mucho sobre Singleton (en lo sucesivo, Singleton), sus lados positivo y negativo.  Pero a pesar de sus deficiencias, tiene muchas propiedades √∫tiles, especialmente en el contexto del firmware para microcontroladores. <br><br>  Para empezar, para un software de microcontrolador confiable, no se recomienda crear objetos din√°micamente y, por lo tanto, no es necesario eliminarlos.  A menudo, los objetos se crean una vez y viven desde el momento en que se inicia el dispositivo, hasta que se apaga.  Tal objeto incluso puede ser una pata de puerto, a la que se conecta un LED, se crea una vez y, ciertamente, no ir√° a ning√∫n lado mientras se ejecuta la aplicaci√≥n, y obviamente puede ser Singleton.  Alguien deber√≠a crear tales objetos y podr√≠a ser Singleton. <br><br>  Singleton tambi√©n le dar√° una garant√≠a de que el mismo objeto que describe el tramo de babor no se crear√° dos veces si se usa repentinamente en varios lugares. <br><br>  Otra, en mi opini√≥n, una propiedad notable de Singleton es su facilidad de uso.  Por ejemplo, como en el caso del controlador de interrupciones, un ejemplo con el que se encuentra al final del art√≠culo.  Pero por ahora, trataremos con el propio Singleton. <br><br><h3>  Singleton creando objetos en RAM </h3><br>  En general, ¬øse han escrito muchos art√≠culos sobre ellos, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Singleton (Loner) o una clase est√°tica?</a>  , o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tres a√±os del patr√≥n Singleton</a> .  Por lo tanto, no me enfocar√© en lo que es Singleton y describir√© todas las opciones para su implementaci√≥n.  En cambio, me centrar√© en dos opciones que se pueden usar en el firmware. <br>  Para empezar, aclarar√© cu√°l es la diferencia entre el firmware para el microcontrolador y el por qu√© algunas implementaciones de singleton para este software son "mejores" que otras.  Algunos criterios provienen de los requisitos para el firmware, y algunos solo de mi experiencia: <br><br><ul><li>  En el firmware no se recomienda crear objetos din√°micamente. </li><li>  A menudo, en el firmware, un objeto se crea est√°ticamente y nunca se destruye. </li><li>  Bueno, si la ubicaci√≥n del objeto se conoce en la etapa de compilaci√≥n </li></ul><br>  En base a estos supuestos, consideramos dos variantes de Singleton con objetos creados est√°ticamente, y probablemente el m√°s famoso y com√∫n es Meyers Singleton, por cierto, aunque deber√≠a ser seguro para subprocesos seg√∫n el est√°ndar C ++, los compiladores para firmware lo hacen as√≠ (por ejemplo, IAR), solo cuando la opci√≥n especial est√° habilitada: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T instance ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance ; } Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; } ;</code> </pre> <br>  Utiliza inicializaci√≥n retrasada, es decir  La inicializaci√≥n de un objeto ocurre solo la primera vez que <code>GetInstance()</code> llama a <code>GetInstance()</code> ; consid√©relo como una inicializaci√≥n din√°mica. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   Timer1      auto&amp; objRef = Singleton&lt;Timer1&gt;::GetInstance(); //  ,      auto&amp; objRef1 = Singleton&lt;Timer1&gt;::GetInstance(); return 0; }</span></span></code> </pre> <br>  Y Singleton sin inicializaci√≥n retrasada: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance ; } Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T instance ; <span class="hljs-comment"><span class="hljs-comment">//      } ;</span></span></code> </pre> <br>  Ambos Singleton crean objetos en RAM, la diferencia es que para el segundo, la inicializaci√≥n ocurre inmediatamente despu√©s de que se inicia el programa, y ‚Äã‚Äãel primero se inicializa en la primera llamada. <br><br>  ¬øC√≥mo se pueden usar en la vida real?  De acuerdo con la vieja tradici√≥n, intentar√© mostrar esto usando el ejemplo de un LED.  Entonces, supongamos que necesitamos crear un objeto de la clase <code>Led1</code> , que en realidad es solo un alias de la clase <code>Pin&lt;PortA, 5&gt;</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GreenLed = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; Led1 myLed ; <span class="hljs-comment"><span class="hljs-comment">//        RAM constexpr GreenLed greenLed ; //        ROM int main() { static GreenLed myGreenLed ; //     RAM Led1 led1; //     myGreenLed.Toggle(); led1.Toggle() ; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Por si acaso, las clases de puerto y pin se ven as√≠</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> OdrAddrShift = <span class="hljs-number"><span class="hljs-number">20U</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Port</span></span></span><span class="hljs-class"> {</span></span> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bit)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*&gt;(addr ) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bit) ; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// Singleton   ,     friend class Singleton&lt;Pin&gt; ; public: __forceinline inline void Toggle() const { T::Toggle(pinNum) ; } //  = const Pin &amp; operator=(const Pin &amp;) = delete ; private: // ,      constexpr Pin() {} ; //  ,      //   ,      constexpr Pin(const Pin &amp;) = default ; } ;</span></span></code> </pre> <br></div></div><br>  En el ejemplo, cre√© hasta 4 objetos diferentes del mismo tipo en RAM y ROM, que realmente funcionan con la misma salida del puerto A. Lo cual no es muy bueno aqu√≠: <br>  Bueno, lo primero es que aparentemente olvid√© que <code>GreenLed</code> y <code>Led1</code> son del mismo tipo y cre√© varios objetos id√©nticos que ocupan espacio en diferentes direcciones.  De hecho, incluso olvid√© que ya hab√≠a creado globalmente objetos de las <code>GreenLed</code> <code>Led1</code> y <code>GreenLed</code> , y tambi√©n los cre√© localmente. <br><br>  Segundo, declarar objetos globales en general no es bienvenido, <br><br><div class="spoiler">  <b class="spoiler_title">Pautas de programaci√≥n para una mejor optimizaci√≥n del compilador</b> <div class="spoiler_text">  <i>Las variables locales del m√≥dulo (variables declaradas est√°ticas) son preferibles a</i> <i><br></i>  <i>variables globales (no est√°ticas).</i>  <i>Tambi√©n evite tomar la direcci√≥n de variables est√°ticas a las que se accede con frecuencia.</i> <i><br></i> </div></div><br>  y los objetos locales solo est√°n disponibles en el √°mbito de la funci√≥n main (). <br><br>  Por lo tanto, reescribimos este ejemplo usando Singleton: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GreenLed = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        GreenLed //   GreenLed&amp; myGreenLed = Singleton&lt;GreenLed&gt;::GetInstance(); //            Led1&amp; led1 = Singleton&lt;Led1&gt;::GetInstance(); myGreenLed.Toggle() ; led1.Toggle() ; //  , Singleton&lt;Led1&gt;::GetInstance().Toggle() }</span></span></code> </pre> <br>  En este caso, no importa lo que olvide, mis enlaces siempre apuntar√°n al mismo objeto.  Y puedo obtener este enlace en cualquier parte del programa, en cualquier m√©todo, incluido, por ejemplo, en el m√©todo est√°tico del controlador de interrupciones, pero m√°s sobre eso m√°s adelante.  Para ser justos, debo decir que el c√≥digo no hace nada, y el error en la l√≥gica del programa no ha desaparecido.  Bueno, de acuerdo, averig√ºemos d√≥nde y c√≥mo, en general, se ubic√≥ este objeto est√°tico creado por Singleton y c√≥mo se inicializ√≥. <br><br><h3>  Objeto est√°tico </h3><br>  Antes de descubrirlo, ser√≠a bueno entender qu√© es un objeto est√°tico. <br><br>  Si declara miembros de clase con la palabra clave est√°tica, esto significa que los miembros de clase simplemente no est√°n vinculados a instancias de clase, son variables independientes y puede acceder a dichos campos sin crear un objeto de clase.  Nada amenaza sus vidas desde el momento en que nacen hasta que se lanza el programa. <br><br>  Cuando se usa en una declaraci√≥n de objeto, el especificador est√°tico determina solo la vida √∫til del objeto.  En t√©rminos generales, la memoria para dicho objeto se asigna cuando se inicia el programa y se libera cuando finaliza el programa; cuando se inicia, tambi√©n se lleva a cabo su inicializaci√≥n.  Las excepciones son solo objetos est√°ticos locales que, aunque "mueren" solo al final del programa, esencialmente "nacen", o m√°s bien, se inicializan la primera vez que pasan por su declaraci√≥n. <br><br><blockquote>  La inicializaci√≥n din√°mica de una variable local con almacenamiento est√°tico se realiza por primera vez en el momento del primer paso a trav√©s de su declaraci√≥n;  dicha variable se considera inicializada al finalizar su inicializaci√≥n.  Si un subproceso pasa por una declaraci√≥n variable en el momento de su inicializaci√≥n por otro subproceso, entonces debe esperar a que se complete la inicializaci√≥n. </blockquote><br>  En las siguientes llamadas, la inicializaci√≥n no ocurre.  Todo lo anterior se puede reducir a una frase, <u>solo puede existir una instancia de un objeto est√°tico.</u> <br><br>  Dichas dificultades conducen al hecho de que el uso de variables y objetos est√°ticos locales en el firmware generar√° una sobrecarga adicional.  Puede verificar esto con un simple ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test1</span></span></span><span class="hljs-class">{</span></span> Test1(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value): j(value) {} <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; } ; <span class="hljs-function"><span class="hljs-function">Test1 &amp;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Test1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; ++i) { foo().j ++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Aqu√≠, la primera vez que se llama a la funci√≥n <code>foo()</code> , el compilador debe verificar que el objeto est√°tico local <code>test1</code> a√∫n no se haya inicializado y llamar al constructor del objeto <code>Test1(10)</code> , y en el segundo y posteriores pases, debe asegurarse de que el objeto ya est√© inicializado y omitir este paso. yendo directamente a la <code>return test</code> . <br><br>  Para hacer esto, el compilador simplemente agrega un indicador de protecci√≥n adicional <code>foo()::static guard for test 0x00100004 0x1 Data Lc main.o</code> e inserta el c√≥digo de verificaci√≥n.  En la primera declaraci√≥n de una variable est√°tica, este indicador de protecci√≥n no se establece y, por lo tanto, el objeto debe inicializarse llamando al constructor; durante la pr√≥xima pasada, este indicador ya est√° establecido, por lo que ya no hay necesidad de inicializaci√≥n y se omite la llamada del constructor.  Adem√°s, esta verificaci√≥n se realizar√° continuamente en el bucle for. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/gb/aq/r1/gbaqr1fpbmihpghun28epsnvoou.png"></a> <br><br>  Y si habilita la opci√≥n que le garantizar√° la inicializaci√≥n en aplicaciones de subprocesos m√∫ltiples, habr√° a√∫n m√°s c√≥digo ... (consulte la llamada para capturar y liberar un recurso durante la inicializaci√≥n est√° subrayada en naranja) <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/rq/5y/ko/rq5ykodk6pngj1esrz8bgx5-79u.png" alt="imagen"></a> <br><br>  Por lo tanto, el precio de usar una variable u objeto est√°tico en el firmware aumenta tanto en tama√±o de RAM como en tama√±o de c√≥digo.  Y este hecho ser√≠a bueno tener en cuenta y considerar al desarrollar. <br><br>  Otra desventaja es el hecho de que el indicador de protecci√≥n nace junto con la variable est√°tica, su vida √∫til es igual a la vida √∫til del objeto est√°tico, es creado por el compilador y no tiene acceso a √©l durante el desarrollo.  Es decir  si de repente por alguna raz√≥n <br><br><div class="spoiler">  <b class="spoiler_title">ver accidente aleatorio</b> <div class="spoiler_text">  Las causas de los errores aleatorios son: (1) part√≠culas alfa resultantes del proceso de descomposici√≥n, (2) neutrones, (3) una fuente externa de radiaci√≥n electromagn√©tica y (4) diafon√≠a interna. <br></div></div><br>  Si el indicador de 1 va a 0, se llama nuevamente a la inicializaci√≥n con el valor inicial.  Esto no es bueno, y tambi√©n hay que tenerlo en cuenta.  Para resumir las variables est√°ticas: <br><blockquote>  Para cualquier objeto est√°tico (ya sea una variable local o un atributo de clase), la memoria se asigna una vez y no cambiar√° en toda la aplicaci√≥n. <br><br>  Las variables est√°ticas locales se inicializan durante el primer paso a trav√©s de una declaraci√≥n de variable. <br><br>  Los atributos de clase est√°ticos, as√≠ como las variables globales est√°ticas, se inicializan inmediatamente despu√©s de que se inicia la aplicaci√≥n.  Adem√°s, este orden no est√° definido </blockquote>  Ahora de vuelta a Singleton. <br><br><h3>  Singleton colocando objeto en ROM </h3><br>  De todo lo anterior, podemos concluir que para nosotros, Singleton Mayers puede tener las siguientes desventajas: costos adicionales de RAM y ROM, un indicador de seguridad no controlado y la imposibilidad de colocar un objeto en ROM debido a la inicializaci√≥n din√°mica. <br><br>  Pero tiene una ventaja maravillosa: controlas el tiempo de inicializaci√≥n del objeto.  Solo el desarrollador mismo llama a <code>GetInstance()</code> primera vez en el momento en que lo necesita. <br><br>  Para deshacerse de las tres primeras deficiencias, es suficiente usar <br><br><div class="spoiler">  <b class="spoiler_title">Singleton sin inicializaci√≥n retrasada</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enable</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T instance ; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class">&lt;T,Enable&gt;:</span></span>:instance ;</code> </pre><br></div></div><br>  Aqu√≠, por supuesto, hay otro problema, no podemos controlar el tiempo de inicializaci√≥n del objeto de <code>instance</code> , y de alguna manera debemos proporcionar una inicializaci√≥n muy transparente.  Pero este es un problema separado, no nos detendremos en √©l ahora. <br><br>  Este Singleton se puede volver a hacer para que la inicializaci√≥n del objeto sea completamente est√°tica en el momento de la compilaci√≥n y se cree una instancia del objeto <code>T</code> en la ROM utilizando <code>static constexpr T instance</code> lugar de <code>static T instance</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance ; } Singleton() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; Singleton(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">// constexpr  constexpr   //           T static constexpr T instance{T()}; } ; template&lt;typename T&gt; constexpr T Singleton&lt;T&gt;::instance ;</span></span></code> </pre><br>  Aqu√≠, la creaci√≥n e inicializaci√≥n del objeto ser√° realizada por el compilador en la etapa de compilaci√≥n y el objeto caer√° en el segmento .readonly.  Es cierto que la clase en s√≠ misma debe cumplir las siguientes reglas: <br><blockquote><ul><li>  La inicializaci√≥n de un objeto de esta clase debe ser est√°tica.  (El constructor debe ser constexpr) </li><li>  La clase debe tener un constructor de copia constexpr </li><li>  Los m√©todos de clase de un objeto de clase no deber√≠an cambiar los datos de un objeto de clase (todos los m√©todos const) </li></ul></blockquote><br>  Por ejemplo, esta opci√≥n es bastante posible: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class">&lt;A&gt;;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test2.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ test.SetB(v); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: B&amp; test; <span class="hljs-comment"><span class="hljs-comment">//    RAM const C&amp; test2; //    ROM //      constexpr A(const A &amp;) = default ; //     RAM  ROM,  Singleton constexpr A() : test(Singleton&lt;B&gt;::GetInstance()), test2(Singleton&lt;C&gt;::GetInstance()) { } }; int main() { //      ROM auto&amp; myObject = Singleton&lt;A&gt;::GetInstance() ; //           myObject.Set(myObject.Get()) ; cout&lt;&lt;"Singleton&lt;A&gt; - address: "&lt;&lt; &amp;myObject &lt;&lt;std::endl; }</span></span></code> </pre><br>  Genial, puedes usar Singleton para crear objetos en ROM, pero ¬øqu√© pasa si algunos objetos deber√≠an estar en la RAM?  Obviamente, debe mantener de alguna manera dos especializaciones para Singleton, una para objetos RAM y la otra para objetos en ROM.  Puede hacerlo ingresando, por ejemplo, para todos los objetos que se deben colocar en la clase base ROM: <br><br><div class="spoiler">  <b class="spoiler_title">Especializaci√≥n para Singleton creando objetos en ROM y RAM</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,     ROM class RomObject{}; //  ROM  template&lt;typename T&gt; class Singleton&lt;T, typename std::enable_if_t&lt;std::is_base_of&lt;RomObject, T&gt;::value&gt;&gt; { public: Singleton(const Singleton&amp;) = delete; Singleton&amp; operator = (const Singleton&amp;) = delete; Singleton() = delete; static constexpr const T&amp; GetInstance() { return instance; } private: static constexpr T instance{T()}; }; template&lt;typename T&gt; constexpr T Singleton&lt;T, typename std::enable_if_t&lt;std::is_base_of&lt;RomObject, T&gt;::value&gt;&gt;::instance ; //  RAM  template&lt;typename T, class Enable = void&gt; class Singleton { public: Singleton(const Singleton&amp;) = delete; Singleton&amp; operator = (const Singleton&amp;) = delete; Singleton() = delete; constexpr static T&amp; GetInstance() { return instance; } private: static T instance ; }; template&lt;typename T, class Enable&gt; T Singleton&lt;T,Enable&gt;::instance ;</span></span></code> </pre><br></div></div><br>  En este caso, puede usarlos as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      RAM,   SetB()    (j) class B { friend class Singleton&lt;B&gt;; public: const B &amp; operator=(const B &amp;) = delete ; void SetB(int value) { j = value ; } private: // ,        B(const B &amp;) = default ; B() = default; int j = 0; } //      ROM class A: public RomObject{ friend class Singleton&lt;A&gt;; public: const A &amp; operator=(const A &amp;) = delete ; int Get() const { return test2.Get(); } //     B,    void Set(int v) const { test.SetB(v); } private: B&amp; test; //    RAM const C&amp; test2; //    ROM //        A(const A &amp;) = default ; //     RAM  ROM,  Singleton constexpr A() : test(Singleton&lt;B&gt;::GetInstance()), test2(Singleton&lt;C&gt;::GetInstance()) { } }; int main() { //      ROM auto&amp; romObject = Singleton&lt;A&gt;::GetInstance() ; //    B  RAM auto&amp; ramObject = Singleton&lt;B&gt;::GetInstance() ; //           ramObject.SetB(romObject.Get()) ; cout&lt;&lt;"Singleton&lt;A&gt; - address: "&lt;&lt; &amp;romObject &lt;&lt;std::endl; cout&lt;&lt;"Singleton&lt;B&gt; - address: "&lt;&lt; &amp;ramObject &lt;&lt;std::endl; }</span></span></code> </pre> <br>  ¬øC√≥mo puedes usar un Singleton as√≠ en la vida real? <br><br><h3>  Ejemplo Singleton </h3><br>  Intentar√© mostrar esto en el ejemplo del funcionamiento del temporizador y el LED.  La tarea es simple, parpadea el LED en el temporizador.  El temporizador se puede configurar. <br><br>  El principio de funcionamiento ser√° el siguiente: cuando se llama a la interrupci√≥n, se llama al m√©todo <code>OnInterrupt()</code> del temporizador, que a su vez llamar√° al m√©todo de conmutaci√≥n de LED a trav√©s de la interfaz del suscriptor. <br><br>  Obviamente, el objeto LED debe estar en la ROM, ya que no tiene sentido crearlo en la RAM, ni siquiera hay datos en √©l.  En principio, ya lo he descrito anteriormente, as√≠ que solo agregue la herencia de <code>RomObject</code> , cree un constructor constexpr y tambi√©n herede la interfaz para procesar eventos desde el temporizador. <br><br><div class="spoiler">  <b class="spoiler_title">Objeto LED</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      class ITimerSubscriber { public: virtual void OnTimeOut() const = 0; } ; template &lt;typename T, std::uint8_t pinNum&gt; class Pin: public RomOject, public ITimerSubscriber { // Singleton   ,     friend class Singleton&lt;Pin&gt; ; public: __forceinline inline void Toggle() const { T::Toggle(pinNum) ; } //       __forceinline inline void OnTimeOut() const override { Toggle() ; } //  = const Pin &amp; operator=(const Pin &amp;) = delete ; private: // ,      constexpr Pin() = default ; Pin(const Pin &amp;) = default ; } ;</span></span></code> </pre> </div></div><br>  Pero har√© el temporizador espec√≠ficamente en RAM con una peque√±a hoja de ruta, almacenar√© un enlace a la estructura <code>TIM_TypeDef</code> , un punto y un enlace de suscriptor, y configurar√© el temporizador en el constructor (aunque ser√≠a posible hacer que el temporizador tambi√©n vaya a ROM): <br><br><div class="spoiler">  <b class="spoiler_title">Temporizador de clase</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Timer &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Timer &amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPeriod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ period = value ; timer.PSC = TimerClockSpeed / <span class="hljs-number"><span class="hljs-number">1000U</span></span> - <span class="hljs-number"><span class="hljs-number">1U</span></span> ; timer.ARR = value ; } <span class="hljs-comment"><span class="hljs-comment">//      __forceinline inline void OnInterrupt() { if ((timer.SR &amp; TIM_SR_UIF) &amp;&amp; (timer.DIER &amp; TIM_DIER_UIE)) { //   ,     OnTimeOut //       Toggle() subscriber-&gt;OnTimeOut() ; timer.SR &amp;=~ TIM_SR_UIF ; } } //    TimeOut  ,   ITimerSubscriber,   __forceinline inline void Subscribe(const ITimerSubscriber&amp; obj) { subscriber = &amp;obj ; } inline void Start() { timer.CR1 |= TIM_CR1_URS ; timer.DIER |= TIM_DIER_UIE ; SetPeriod(period) ; timer.CR1 &amp;=~TIM_CR1_OPM ; timer.EGR |= TIM_EGR_UG ; timer.CR1 |= TIM_CR1_CEN ; } protected: // ,         explicit Timer(TIM_TypeDef&amp; tim): timer{tim} {}; const ITimerSubscriber * subscriber = nullptr ; TIM_TypeDef&amp; timer ; std::uint16_t period = 1000; } ;</span></span></code> </pre> <br></div></div><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       class BlinkTimer: public Timer { friend class Singleton&lt;BlinkTimer&gt; ; public: const BlinkTimer &amp; operator=(const BlinkTimer &amp;) = delete ; private: BlinkTimer(const BlinkTimer &amp;) = default ; inline BlinkTimer(): Timer{*TIM2} { } } ; int main() { BlinkTimer &amp; blinker = Singleton&lt;BlinkTimer&gt;::GetInstance() ; using Led1 = Pin&lt;PortA, 5&gt; ; // Led1,   ROM,      blinker.Subscribe(Singleton&lt;Led1&gt;::GetInstance()) ; blinker.Start() ; }</span></span></code> </pre><br>  En este ejemplo, un objeto de la clase <code>BlinkTimer</code> se encuentra en la RAM y un objeto de la clase <code>Led1</code> se encuentra en la ROM.  No hay objetos globales adicionales en el c√≥digo.  En el lugar donde se necesita la instancia de clase, simplemente llamamos a <code>GetInstance()</code> para esta clase <br><br>  Queda por agregar un controlador de interrupci√≥n a la tabla de vectores de interrupci√≥n.  Y aqu√≠, es muy conveniente usar Singleton.  En el m√©todo est√°tico de la clase responsable de manejar las interrupciones, puede llamar al m√©todo del objeto envuelto en Singleton. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __iar_program_start(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InterruptHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DummyHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) {} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer2Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   BlinkTimer Singleton&lt;BlinkTimer&gt;::GetInstance().OnInterrupt(); } }; using tIntFunct = void(*)(); using tIntVectItem = union {tIntFunct __fun; void * __ptr;}; #pragma segment = "CSTACK" #pragma location = ".intvec" const tIntVectItem __vector_table[] = { { .__ptr = __sfe( "CSTACK" ) }, //    __iar_program_start, //      InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, 0, 0, 0, 0, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, 0, InterruptHandler::DummyHandler, InterruptHandler::DummyHandler, //External Interrupts InterruptHandler::DummyHandler, //Window Watchdog InterruptHandler::DummyHandler, //PVD through EXTI Line detect/EXTI16 .... InterruptHandler::Timer2Handler, //      BlinkTimer InterruptHandler::DummyHandler, //TIM3 ... InterruptHandler::DummyHandler, //SPI 5 global interrupt }; extern "C" void __cmain(void) ; extern "C" __weak void __iar_init_core(void) ; extern "C" __weak void __iar_init_vfp(void) ; #pragma required = __vector_table void __iar_program_start(void) { __iar_init_core() ; __iar_init_vfp() ; __cmain() ; }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Un poco sobre la mesa en s√≠, c√≥mo funciona todo:</b> <div class="spoiler_text">  Inmediatamente despu√©s del encendido o despu√©s de un reinicio, un reinicio se interrumpe con el <i>n√∫mero -8</i> , en la tabla es un elemento cero, de acuerdo con la se√±al de reinicio, el programa cambia al vector del elemento cero, donde el puntero a la parte superior de la pila se inicializa primero.  Esta direcci√≥n se toma de la ubicaci√≥n del segmento STACK que configur√≥ en la configuraci√≥n del vinculador.  Inmediatamente despu√©s de inicializar el puntero, vaya al punto de entrada del programa, en este caso, a la direcci√≥n de la funci√≥n <code>__iar_program_start</code> .  A continuaci√≥n, el c√≥digo se inicializa inicializando sus variables globales y est√°ticas, inicializando el coprocesador con un punto flotante, si se incluy√≥ en la configuraci√≥n, etc.  Si ocurre una interrupci√≥n, el controlador de interrupci√≥n por el n√∫mero de interrupci√≥n en la tabla va a la direcci√≥n del manejador de interrupciones.  En nuestro caso, este es <code>InterruptHandler::Timer2Handler</code> , que, a trav√©s de Singleton, llama al m√©todo <code>OnInterrupt()</code> de nuestro temporizador de parpadeo, que, a su vez, <code>OnTimeOut()</code> m√©todo <code>OnTimeOut()</code> la pata de puerto. <br></div></div><br>  En realidad eso es todo, puedes ejecutar el programa.  Un ejemplo de trabajo para IAR 8.40 se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">encuentra aqu√≠</a> . <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠</a> puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">encontrar</a> un ejemplo m√°s detallado del uso de Singleton para objetos en ROM y RAM. <br><br>  Enlaces de documentaci√≥n: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GOST R mek61508-7‚Äî2012</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a de desarrollo de C / C ++ para EWARM</a> </li></ul><br>  PD: En la imagen al comienzo del art√≠culo, de todos modos, Singleton no es ROM, sino WHISKY. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455477/">https://habr.com/ru/post/455477/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455467/index.html">Si no est√° escribiendo un programa, no use un lenguaje de programaci√≥n</a></li>
<li><a href="../455469/index.html">Para ser una pila completa y no ser</a></li>
<li><a href="../455471/index.html">Traducci√≥n del uso de Google Analytics con R (Michal Brys)</a></li>
<li><a href="../455473/index.html">Gen√©ricos en TypeScript: Reuni√©ndose</a></li>
<li><a href="../455475/index.html">Food Design Digest, mayo de 2019</a></li>
<li><a href="../455479/index.html">C√≥mo implementamos la navegaci√≥n desde Jetpack a una aplicaci√≥n de combate. Yandex.Food Report</a></li>
<li><a href="../455481/index.html">Tres historias sobre la caza salvaje</a></li>
<li><a href="../455483/index.html">Artista Ai-Da: robot humanoide se prepara para su primera exposici√≥n individual</a></li>
<li><a href="../455485/index.html">Check Point Scripts: ejecute scripts directamente desde Smart Console</a></li>
<li><a href="../455487/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. D√≠a 10. Cambiar modos de funcionamiento del puerto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>