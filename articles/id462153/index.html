<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤±ğŸ¾ ğŸŒµ ğŸª Unity Interactive Map Shaders ğŸ‡ ğŸ‘©ğŸ¾â€ğŸ”§ ğŸ¬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tutorial ini adalah tentang peta interaktif dan membuatnya di Unity menggunakan shader. 

 Efek ini dapat berfungsi sebagai dasar untuk teknik yang le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity Interactive Map Shaders</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462153/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/511/6a1/e02/5116a1e02debfaa58afe0cddf3b4c6c9.png" alt="gambar"></div><br>  Tutorial ini adalah tentang <strong>peta interaktif</strong> dan membuatnya di Unity menggunakan shader. <br><br>  Efek ini dapat berfungsi sebagai dasar untuk teknik yang lebih kompleks, seperti proyeksi holografik atau bahkan meja pasir dari film "Black Panther". <br><br>  Sebuah inspirasi untuk tutorial ini adalah tweet yang diterbitkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Baran Kahyaoglu</a> , menunjukkan contoh apa yang ia buat untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Mapbox</a> . <br><a name="habracut"></a><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1118609807844442112"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-1" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1118610439049494540"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Adegan (tidak termasuk peta) diambil dari demo Spaceship Grafik Efek Visual Unity (lihat di bawah), yang dapat diunduh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">sini</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rqMcPZoEc3U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Bagian 1. Vertex Offset </h2><br><h2>  Efek anatomi </h2><br>  Hal pertama yang Anda dapat segera perhatikan adalah bahwa peta geografis <em>datar</em> : jika mereka digunakan sebagai tekstur, maka mereka tidak memiliki tiga dimensi yang dimiliki oleh model 3D nyata dari area peta yang sesuai. <br><br>  Anda dapat menerapkan solusi ini: membuat model 3D dari area yang diperlukan dalam game, dan kemudian menerapkan tekstur dari peta ke sana.  Ini akan membantu menyelesaikan masalah, tetapi butuh banyak waktu dan tidak akan memungkinkan untuk mewujudkan efek "bergulir" dari video Baran Kahyaoglu. <br><br>  Jelas, pendekatan yang lebih teknis adalah yang terbaik.  Untungnya, shader dapat digunakan untuk mengubah geometri model 3D.  Dengan bantuan mereka, Anda dapat mengubah pesawat apa pun menjadi lembah dan pegunungan di wilayah yang kami butuhkan. <br><br>  Dalam tutorial ini kita menggunakan peta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Chillot</a> , Chilli, terkenal dengan bukit-bukit khasnya.  Gambar di bawah ini menunjukkan tekstur wilayah diplot pada jala bundar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/b64/0a6/5a7b640a60ca2ce42c9d4ee3f5c95150.png" width="797" height="346"></div><br>  Meskipun kita melihat bukit dan gunung, mereka masih benar-benar datar.  Ini menghancurkan ilusi realisme. <br><br><h2>  Normal ekstrusi </h2><br>  Langkah pertama untuk menggunakan shader untuk mengubah geometri adalah teknik yang disebut <strong>ekstrusi normal</strong> .  Dia membutuhkan <strong>pengubah simpul</strong> : fungsi yang dapat memanipulasi simpul individu dari model 3D. <br><br>  Cara modifier vertex digunakan tergantung pada jenis shader yang digunakan.  Dalam tutorial ini, kita akan mengubah <strong>Surface Standard Shader</strong> - salah satu jenis shader yang dapat Anda buat di Unity. <br><br>  Ada banyak cara untuk memanipulasi simpul dari model 3D.  Salah satu metode pertama yang dijelaskan dalam sebagian besar tutorial vertex shader adalah <strong>mengekstrusi normals</strong> .  Ini terdiri dari mendorong setiap titik "keluar" ( <em>mengekstrusi</em> ), yang memberikan model 3D tampilan yang lebih besar.  "Di luar" berarti bahwa setiap titik bergerak sepanjang arah normal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/275/3e4/fe3/2753e4fe3502d77d46d7205e1ec81809.png"></div><br>  Untuk permukaan yang halus, ini bekerja dengan sangat baik, tetapi pada model dengan koneksi titik yang buruk, metode ini dapat membuat artefak aneh.  Efek ini dijelaskan dengan baik dalam salah satu tutorial pertama saya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">A Gentle Introduction to Shaders</a> , di mana saya menunjukkan cara <strong>mengusir</strong> dan <strong>mengganggu</strong> model 3D. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a8/668/0e5/5a86680e5ab92b536d4999e693aed8cb.gif" width="485" height="278"></div><br>  Menambahkan normal diekstrusi ke permukaan shader sangat mudah.  Setiap shader permukaan memiliki <code>#pragma</code> , yang digunakan untuk mengirimkan informasi dan perintah tambahan.  Salah satu perintah tersebut adalah <code>vert</code> , yang berarti bahwa fungsi <code>vert</code> akan digunakan untuk memproses setiap simpul dari model 3D. <br><br>  Shader yang diedit adalah sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Standard fullforwardshadows addshadow vertex:vert ... float _Amount; ... void vert(inout appdata_base v) { v.vertex.xyz += v.normal * _Amount; }</span></span></code> </pre> <br>  Karena kita mengubah posisi simpul, kita juga perlu menggunakan <code>addshadow</code> jika kita ingin model untuk membuat bayangan dengan benar. <br><br><div class="spoiler">  <b class="spoiler_title">Apa itu appdata_base?</b> <div class="spoiler_text">  Seperti yang Anda lihat, kami telah menambahkan fungsi pengubah simpul ( <code>vert</code> ), yang mengambil sebagai parameter <em>struktur yang</em> disebut <code>appdata_base</code> .  Struktur ini menyimpan informasi tentang masing-masing simpul individu model 3D.  Ini tidak hanya berisi <em>posisi titik</em> ( <code>v.vertex</code> ), tetapi juga bidang lain, misalnya <em>, arah normal</em> ( <code>v.normal</code> ) dan <em>informasi tekstur yang</em> terkait dengan titik ( <code>v.texcoord</code> ). <br><br>  Dalam beberapa kasus, ini tidak cukup dan kita mungkin memerlukan properti lain, seperti <em>warna titik</em> ( <code>v.color</code> ) dan <em>arah garis singgung</em> ( <code>v.tangent</code> ).  Pengubah Vertex dapat ditentukan menggunakan berbagai struktur <code>appdata_tan</code> lainnya, termasuk <code>appdata_tan</code> dan <code>appdata_full</code> , yang menyediakan informasi lebih lanjut dengan biaya <code>appdata_full</code> kinerja rendah.  Anda dapat membaca lebih lanjut tentang <code>appdata</code> (dan variasinya) di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">wiki Unity3D</a> . </div></div><br><div class="spoiler">  <b class="spoiler_title">Bagaimana nilai dikembalikan dari vert?</b> <div class="spoiler_text">  Fungsi teratas tidak memiliki nilai balik.  Jika Anda terbiasa dengan bahasa C #, Anda harus tahu bahwa struktur dilewatkan oleh nilai, yaitu, ketika <code>v.vertex</code> berubah <code>v.vertex</code> ini hanya memengaruhi salinan <code>v</code> , ruang lingkup yang dibatasi oleh badan fungsi. <br><br>  Namun, <code>v</code> juga dideklarasikan sebagai <code>inout</code> , yang artinya digunakan untuk input dan output.  Setiap perubahan yang Anda lakukan, ubah variabel itu sendiri, yang kami sampaikan ke <code>vert</code> .  Kata kunci <code>out</code> dan <code>out</code> sangat sering digunakan dalam grafik komputer, dan secara kasar dapat dikorelasikan dengan <code>ref</code> dan <code>out</code> dalam C #. </div></div><br><h2>  Mengekstrusi normals dengan tekstur </h2><br>  Kode yang kami gunakan di atas berfungsi dengan benar, tetapi jauh dari efek yang ingin kami capai.  Alasannya adalah bahwa kami tidak ingin mengekstrusi semua simpul dengan jumlah yang sama.  Kami ingin permukaan model 3D agar sesuai dengan lembah dan pegunungan di wilayah geografis yang sesuai.  Pertama, kita perlu menyimpan dan mengambil informasi tentang seberapa banyak setiap titik pada peta dinaikkan.  Kami ingin ekstrusi dipengaruhi oleh tekstur tempat ketinggian lanskap dikodekan.  Tekstur seperti itu sering disebut <strong>pemetaan ketinggian</strong> , tetapi sering juga disebut <strong>pemetaan kedalaman</strong> , tergantung pada konteksnya.  Setelah menerima informasi tentang ketinggian, kami akan dapat memodifikasi ekstrusi pesawat berdasarkan peta ketinggian  Seperti yang ditunjukkan dalam diagram, ini akan memungkinkan kita untuk mengontrol kenaikan dan penurunan area. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f3/223/118/0f32231186763ee73f27bde4a1d2c5bf.png"></div><br>  Sangat sederhana untuk menemukan gambar satelit dari area geografis yang Anda minati dan peta ketinggian terkait.  Di bawah ini adalah peta satelit Mars (di atas) dan peta ketinggian (di bawah) yang digunakan dalam tutorial ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b80/468/176/b804681769208dfc72ec69441d9f0986.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/266/f0c/b59/266f0cb59bb01a7f875d3323d526372a.png"></div><br>  Saya berbicara secara terperinci tentang konsep peta mendalam dalam serangkaian tutorial lain yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">"Foto 3D Facebook dari dalam: parallax shaders"</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan</a> ke HabrÃ©]. <br><br>  Dalam tutorial ini, kita akan mengasumsikan bahwa peta ketinggian disimpan sebagai gambar dalam skala abu-abu, di mana hitam dan putih sesuai dengan ketinggian yang lebih rendah dan lebih tinggi.  Kita juga perlu nilai-nilai ini untuk skala <em>secara linear</em> , yaitu, perbedaan warna, misalnya, pada <code>0.1</code> sesuai dengan perbedaan tinggi antara <code>0</code> dan <code>0.1</code> atau antara <code>0.9</code> dan <code>1.0</code> .  Untuk peta kedalaman, ini tidak selalu benar, karena banyak dari mereka menyimpan informasi kedalaman pada <em>skala logaritmik</em> . <br><br>  Untuk mengambil sampel tekstur, diperlukan dua elemen informasi: tekstur itu sendiri dan <strong>koordinat UV dari</strong> titik yang ingin kita sampel.  Yang terakhir dapat diakses melalui bidang <code>texcoord</code> , disimpan dalam struktur <code>appdata_base</code> .  Ini adalah koordinat UV yang terkait dengan simpul saat ini sedang diproses.  Pengambilan sampel tekstur pada <em>fungsi permukaan</em> dilakukan menggunakan <code>tex2D</code> , namun ketika kita berada dalam <code> </code> , <code>tex2Dlod</code> diperlukan. <br><br>  Dalam cuplikan kode di bawah ini, tekstur yang disebut <code>_HeightMap</code> digunakan untuk mengubah nilai ekstrusi yang dilakukan untuk setiap simpul: <br><br><pre> <code class="cpp hljs">sampler2D _HeightMap; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ fixed height = tex2Dlod(_HeightMap, float4(v.texcoord.xy, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += v.normal * height * _Amount; }</code> </pre> <br>  Mengapa tex2D tidak dapat digunakan sebagai fungsi vertex? <br>  Jika Anda melihat kode yang dihasilkan Unity untuk Standard Surface Shader, Anda akan melihat bahwa itu sudah berisi contoh cara sampel tekstur.  Secara khusus, sampel <em>tekstur utama</em> (disebut <code>_MainTex</code> ) dalam <em>fungsi permukaan</em> (disebut <code>surf</code> ) menggunakan fungsi <code>tex2D</code> . <br><br>  Dan pada kenyataannya, <code>tex2D</code> digunakan untuk sampel piksel dari suatu tekstur, terlepas dari apa yang disimpan di dalamnya, warna atau ketinggian.  Namun, Anda mungkin memperhatikan bahwa <code>tex2D</code> tidak dapat digunakan dalam fungsi vertex. <br><br>  Alasannya adalah bahwa <code>tex2D</code> <em>tidak hanya</em> membaca piksel dari tekstur.  Dia juga memutuskan versi tekstur yang akan digunakan, tergantung pada jarak ke kamera.  Teknik ini disebut <strong>mipmapping</strong> : memungkinkan Anda untuk memiliki versi yang lebih kecil dari satu tekstur yang dapat secara otomatis digunakan pada jarak yang berbeda. <br><br>  Dalam fungsi permukaan, shader sudah tahu <strong>tekstur MIP</strong> mana yang digunakan.  Informasi ini mungkin belum tersedia dalam fungsi vertex, dan karena itu <code>tex2D</code> tidak dapat digunakan dengan penuh keyakinan.  Berbeda dengan itu, fungsi <code>tex2Dlod</code> dapat melewati dua parameter tambahan, yang dalam tutorial ini dapat memiliki nilai nol. <br><br>  Hasilnya terlihat jelas pada gambar di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/b64/0a6/5a7b640a60ca2ce42c9d4ee3f5c95150.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0b/dbf/dad/c0bdbfdadf38764dd3d75ffb69d07dea.png"></div><br>  Dalam hal ini, satu penyederhanaan dapat dibuat.  Kode yang kami ulas sebelumnya dapat bekerja dengan geometri apa pun.  Namun, kita dapat mengasumsikan bahwa permukaannya benar-benar rata.  Faktanya, kami benar-benar ingin menerapkan efek ini pada pesawat. <br><br>  Oleh karena itu, Anda dapat menghapus <code>v.normal</code> dan menggantinya dengan <code>float3(0, 1, 0)</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ float3 normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); fixed height = tex2Dlod(_HeightMap, float4(v.texcoord.xy, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += normal * height * _Amount; }</code> </pre> <br>  Kita bisa melakukan ini karena semua koordinat di <code>appdata_base</code> disimpan dalam <strong>ruang model</strong> , yaitu, mereka diatur relatif ke pusat dan orientasi model 3D.  Transisi, rotasi, dan penskalaan dengan <em>transformasi</em> dalam Unity mengubah posisi, rotasi, dan skala objek, tetapi tidak memengaruhi model 3D asli. <br><br><h2>  Bagian 2. Efek Menggulir </h2><br>  Semua yang kami lakukan di atas bekerja dengan sangat baik.  Sebelum melanjutkan, kami akan mengekstrak kode yang diperlukan untuk menghitung ketinggian simpul baru ke dalam fungsi <code>getVertex</code> terpisah: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float4 vertex, float2 texcoord)</span></span></span><span class="hljs-function"> </span></span>{ float3 normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); fixed height = tex2Dlod(_HeightMap, float4(texcoord, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += normal * height * _Amount; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vertex; }</code> </pre> <br>  Maka seluruh fungsi <code>vert</code> akan memiliki bentuk: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ vertex = getVertex(v.vertex, v.texcoord.xy); }</code> </pre> <br>  Kami melakukan ini karena di bawah ini kami perlu menghitung ketinggian beberapa titik.  Karena kenyataan bahwa fungsi ini akan berada dalam fungsinya sendiri yang terpisah, kode akan menjadi lebih sederhana. <br><br><h2>  Perhitungan koordinat UV </h2><br>  Namun, ini membawa kita ke masalah lain.  Fungsi <code>getVertex</code> tidak hanya bergantung pada posisi vertex saat ini (v.vertex), tetapi juga pada koordinat UV-nya ( <code>v.texcoord</code> ). <br><br>  Ketika kami ingin menghitung ketinggian vertex yang sedang diproses fungsi <code>vert</code> , kedua elemen data tersedia di struktur <code>appdata_base</code> .  Namun, apa yang terjadi jika kita perlu mengambil sampel posisi titik tetangga?  Dalam hal ini, kita dapat mengetahui posisi xyz di <strong>ruang model</strong> , tetapi kita tidak memiliki akses ke koordinat UV-nya. <br><br>  Ini berarti bahwa sistem yang ada hanya dapat menghitung tinggi offset hanya untuk verteks saat ini.  Pembatasan seperti itu tidak akan memungkinkan kita untuk melanjutkan, jadi kita perlu menemukan solusi. <br><br>  Cara termudah adalah menemukan cara untuk menghitung koordinat UV dari objek 3D, mengetahui posisi verteksnya.  Ini adalah tugas yang sangat sulit, dan ada beberapa teknik untuk menyelesaikannya (salah satu yang paling populer adalah <strong>proyeksi triplanar</strong> ).  Tetapi dalam kasus khusus ini, kita tidak perlu mencocokkan UV dengan geometri.  Jika kita mengasumsikan bahwa shader akan selalu diterapkan pada flat mesh, maka tugasnya menjadi sepele. <br><br>  Kita dapat menghitung <em>koordinat UV</em> (gambar bawah) dari <em>posisi simpul</em> (gambar atas) karena fakta bahwa keduanya ditumpangkan secara linear pada mesh datar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/147/614/a7a/147614a7a05ba08700aef85be89f3a53.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/ff8/c42/02fff8c42dae9fa7de4f7e9598843afe.png" width="359" height="210"></div><br>  Ini berarti bahwa untuk menyelesaikan masalah kita, kita perlu mengubah <em>komponen XZ dari</em> <em>posisi vertex</em> menjadi <em>koordinat UV yang</em> sesuai. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48a/607/6b0/48a6076b06650e1074dd5b0f2f7ed023.png" width="363" height="393"></div><br>  Prosedur ini disebut <strong>interpolasi linier</strong> .  Itu dibahas secara rinci di situs web saya (misalnya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Rahasia Interpolasi Warna</a> ). <br><br>  Dalam kebanyakan kasus, nilai-nilai UV berada dalam kisaran dari <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMAIN-30" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-1"> 0 </script>  sebelumnya <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 1 </script>  ;  Sebaliknya, koordinat masing-masing simpul berpotensi tidak terbatas.  Dari sudut pandang matematika, untuk konversi dari XZ ke UV, kita hanya perlu nilai batasnya: <br><br><ul><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.153ex" height="2.419ex" viewBox="0 -780.1 2218.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>X</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-3"> X_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>k</mi><mi>s</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.096ex" height="2.419ex" viewBox="0 -780.1 2624.8 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6B" x="1408" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-73" x="1929" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>X</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>k</mi><mi>s</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-4"> X_ {maks} </script></li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>Z</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.816ex" height="2.419ex" viewBox="0 -780.1 2073.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-5A" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>Z</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-5"> Z_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>Z</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>k</mi><mi>s</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.76ex" height="2.419ex" viewBox="0 -780.1 2479.8 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-5A" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6B" x="1408" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-73" x="1929" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>Z</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>k</mi><mi>s</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-6"> Z_ {maks} </script></li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>U</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.816ex" height="2.419ex" viewBox="0 -780.1 2073.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>U</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-7"> U_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>U</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>k</mi><mi>s</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.76ex" height="2.419ex" viewBox="0 -780.1 2479.8 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6B" x="1408" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-73" x="1929" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>U</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>k</mi><mi>s</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-8"> U_ {maks} </script></li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>V</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.584ex" height="2.419ex" viewBox="0 -780.1 1973.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-56" x="0" y="0"></use><g transform="translate(583,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>V</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-9"> V_ {min} </script>  , <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>V</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>k</mi><mi>s</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.527ex" height="2.419ex" viewBox="0 -780.1 2379.8 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-56" x="0" y="0"></use><g transform="translate(583,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6B" x="1408" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-73" x="1929" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>V</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>k</mi><mi>s</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-10"> V_ {maks} </script></li></ul><br>  yang ditunjukkan di bawah ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87a/520/05c/87a52005ccc02b02403068fd3e075864.png" width="359" height="210"></div><br>  Nilai-nilai ini bervariasi tergantung pada mesh yang digunakan.  Pada bidang Unity, <em>koordinat UV</em> berada dalam kisaran dari <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMAIN-30" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-11"> 0 </script>  sebelumnya <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-12"> 1 </script>  , dan <em>koordinat simpul</em> berada dalam kisaran dari <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>&amp;#x2212;</mo><mn>5</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMAIN-2212" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMAIN-35" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>âˆ’</mo><mn>5</mn></math></span></span><script type="math/tex" id="MathJax-Element-13"> -5 </script>  sebelumnya <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>+</mo><mn>5</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMAIN-2B" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMAIN-35" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>+</mo><mn>5</mn></math></span></span><script type="math/tex" id="MathJax-Element-14"> + 5 </script>  . <br><br>  Persamaan untuk mengubah XZ ke UV adalah: <br><br>  (1) <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d2/e5c/a22/7d2e5ca229d8fc1c135aaa42e863fc9c.svg" alt="gambar"></div><br><br><div class="spoiler">  <b class="spoiler_title">Bagaimana mereka ditampilkan?</b> <div class="spoiler_text">  Jika Anda tidak terbiasa dengan konsep interpolasi linier, maka persamaan ini mungkin tampak cukup menakutkan. <br><br>  Namun, mereka ditampilkan dengan cukup sederhana.  Mari kita lihat contoh saja. <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>U</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.783ex" height="2.074ex" viewBox="0 -772.3 767.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-55" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>U</mi></math></span></span><script type="math/tex" id="MathJax-Element-15"> U </script>  .  Kami memiliki dua interval: satu memiliki nilai dari <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.153ex" height="2.349ex" viewBox="0 -772.3 2218.6 1011.3" role="img" focusable="false" style="vertical-align: -0.555ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>X</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-16"> X_ {min} </script>  sebelumnya <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>k</mi><mi>s</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.096ex" height="2.349ex" viewBox="0 -772.3 2624.8 1011.3" role="img" focusable="false" style="vertical-align: -0.555ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6B" x="1408" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-73" x="1929" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>X</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>k</mi><mi>s</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-17"> X_ {maks} </script>  lain dari <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>U</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.816ex" height="2.349ex" viewBox="0 -772.3 2073.6 1011.3" role="img" focusable="false" style="vertical-align: -0.555ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>U</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-18"> U_ {min} </script>  sebelumnya <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>U</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>k</mi><mi>s</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.76ex" height="2.349ex" viewBox="0 -772.3 2479.8 1011.3" role="img" focusable="false" style="vertical-align: -0.555ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6B" x="1408" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-73" x="1929" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>U</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>k</mi><mi>s</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-19"> U_ {maks} </script>  .  Data yang masuk untuk koordinat <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.98ex" height="2.074ex" viewBox="0 -772.3 852.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-58" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi></math></span></span><script type="math/tex" id="MathJax-Element-20"> X </script>  adalah koordinat dari simpul saat ini sedang diproses, dan output akan menjadi koordinat <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>U</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.783ex" height="2.074ex" viewBox="0 -772.3 767.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-55" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>U</mi></math></span></span><script type="math/tex" id="MathJax-Element-21"> U </script>  digunakan untuk sampel tekstur. <br><br>  Kita perlu mempertahankan sifat proporsionalitas antara <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.98ex" height="2.074ex" viewBox="0 -772.3 852.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-58" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi></math></span></span><script type="math/tex" id="MathJax-Element-22"> X </script>  dan intervalnya, dan <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-23-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>U</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.783ex" height="2.074ex" viewBox="0 -772.3 767.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-55" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>U</mi></math></span></span><script type="math/tex" id="MathJax-Element-23"> U </script>  dan intervalnya.  Misalnya, jika <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.98ex" height="2.074ex" viewBox="0 -772.3 852.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-58" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi></math></span></span><script type="math/tex" id="MathJax-Element-24"> X </script>  penting 25% dari intervalnya <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-25-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>U</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.783ex" height="2.074ex" viewBox="0 -772.3 767.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-55" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>U</mi></math></span></span><script type="math/tex" id="MathJax-Element-25"> U </script>  juga akan berpengaruh 25% dari intervalnya. <br><br>  Semua ini ditunjukkan pada diagram berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/784/da1/22a784da18e327b20b872699a901f0ec.png" width="292" height="202"></div><br>  Dari sini kita dapat menyimpulkan bahwa proporsi yang terdiri dari segmen merah sehubungan dengan merah muda harus sama dengan proporsi antara segmen biru dan biru: <br><br>  (2) <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcc/9e1/49e/bcc9e149ea65e83dd70345dd92784788.png" height="39" width="232"></div><br>  Sekarang kita bisa mengubah persamaan yang ditunjukkan di atas untuk mendapatkan <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-26-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>U</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.783ex" height="2.074ex" viewBox="0 -772.3 767.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-55" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>U</mi></math></span></span><script type="math/tex" id="MathJax-Element-26"> U </script>  : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/737/266/0fe/7372660fe877b0780e4cebc97a6f22f2.png" height="85" width="388"></div><br>  dan persamaan ini memiliki bentuk yang persis sama seperti yang ditunjukkan di atas (1). </div></div><br>  Persamaan ini dapat diimplementasikan dalam kode sebagai berikut: <br><br><pre> <code class="cpp hljs">float2 _VertexMin; float2 _VertexMax; float2 _UVMin; float2 _UVMax; <span class="hljs-function"><span class="hljs-function">float2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vertexToUV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float4 vertex)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (vertex.xz - _VertexMin) / (_VertexMax - _VertexMin) * (_UVMax - _UVMin) + _UVMin; }</code> </pre> <br>  Sekarang kita dapat memanggil fungsi <code>getVertex</code> tanpa harus meneruskan <code>v.texcoord</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float4 vertex)</span></span></span><span class="hljs-function"> </span></span>{ float3 normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); float2 texcoord = vertexToUV(vertex); fixed height = tex2Dlod(_HeightMap, float4(texcoord, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += normal * height * _Amount; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vertex; }</code> </pre> <br>  Kemudian seluruh fungsi <code>vert</code> mengambil bentuk: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ v.vertex = getVertex(v.vertex); }</code> </pre> <br><h3>  Efek gulir </h3><br>  Berkat kode yang kami tulis, seluruh peta ditampilkan di mesh.  Jika kita ingin meningkatkan tampilan, maka kita perlu melakukan perubahan. <br><br>  Mari kita memformalkan kode sedikit lagi.  Pertama, kita mungkin perlu memperbesar bagian peta yang terpisah, daripada melihatnya secara keseluruhan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b5/1c3/bcd/0b51c3bcd59365527d3659564768b01b.png" width="530" height="309"></div><br>  Area ini dapat didefinisikan oleh dua nilai: ukurannya ( <code>_CropSize</code> ) dan lokasi pada peta ( <code>_CropOffset</code> ), diukur dalam <em>ruang simpul</em> (dari <code>_VertexMin</code> ke <code>_VertexMax</code> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Cropping float2 _CropSize; float2 _CropOffset;</span></span></code> </pre> <br>  Setelah menerima kedua nilai ini, kami dapat sekali lagi menggunakan interpolasi linier sehingga <code>getVertex</code> dipanggil bukan untuk posisi saat ini di bagian atas model 3D, tetapi untuk titik yang diskalakan dan ditransfer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0c/620/418/c0c620418088c383addcaa54328fe0fc.png" width="529" height="589"></div><br>  Kode yang relevan: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ float2 croppedMin = _CropOffset; float2 croppedMax = croppedMin + _CropSize; <span class="hljs-comment"><span class="hljs-comment">// v.vertex.xz: [_VertexMin, _VertexMax] // cropped.xz : [croppedMin, croppedMax] float4 cropped = v.vertex; cropped.xz = (v.vertex.xz - _VertexMin) / (_VertexMax - _VertexMin) * (croppedMax - croppedMin) + croppedMin; v.vertex.y = getVertex(cropped); }</span></span></code> </pre> <br>  Jika kita ingin menggulir, maka cukup untuk memperbarui <code>_CropOffset</code> melalui skrip.  Karena ini, area pemotongan akan bergerak, sebenarnya menggulir lanskap. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MoveMap</span></span></span><span class="hljs-class"> :</span></span> MonoBehaviour { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Material Material; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 Speed; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 Offset; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CropOffsetID; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CropOffsetID = Shader.PropertyToID(<span class="hljs-string"><span class="hljs-string">"_CropOffset"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Material.SetVector(CropOffsetID, Speed * Time.time + Offset); } }</code> </pre> <br>  Agar ini berfungsi, sangat penting untuk mengatur <strong>Mode Bungkus</strong> semua tekstur menjadi <strong>Ulangi</strong> .  Jika ini tidak dilakukan, maka kita tidak akan dapat mengulangi tekstur. <br><br>  Untuk efek zoom / zoom, cukup mengubah <code>_CropSize</code> . <br><br><h2>  Bagian 3. Naungan medan </h2><br><h2>  Naungan datar </h2><br>  Semua kode yang kami tulis berfungsi, tetapi memiliki masalah serius.  Model bayangan entah bagaimana aneh.  Permukaannya melengkung dengan benar, tetapi bereaksi terhadap cahaya seolah-olah datar. <br><br>  Ini sangat jelas terlihat pada gambar di bawah ini.  Gambar atas menunjukkan shader yang ada;  bagian bawah menunjukkan cara kerjanya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0b/dbf/dad/c0bdbfdadf38764dd3d75ffb69d07dea.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/511/6a1/e02/5116a1e02debfaa58afe0cddf3b4c6c9.png"></div><br>  Memecahkan masalah ini bisa menjadi tantangan besar.  Tapi pertama-tama, kita perlu mencari tahu apa kesalahannya. <br><br>  Operasi ekstrusi normal mengubah geometri umum dari pesawat yang kami gunakan awalnya.  Namun, Unity hanya mengubah posisi simpul, tetapi tidak arah normal mereka.  <strong>Arah</strong> vertex <strong>normal</strong> , seperti namanya, adalah vektor satuan panjang ( <em>arah</em> ) yang mengindikasikan tegak lurus terhadap permukaan.  <em>Normal</em> diperlukan karena mereka memainkan peran penting dalam menaungi model 3D.  Mereka digunakan oleh semua permukaan shader untuk menghitung bagaimana cahaya harus dipantulkan dari setiap segitiga model 3D.  Biasanya ini diperlukan untuk meningkatkan tiga dimensi dari model, misalnya, itu menyebabkan cahaya memantul dari permukaan datar sama seperti itu akan memantul dari permukaan melengkung.  Trik ini sering digunakan untuk membuat permukaan poli-rendah terlihat lebih halus daripada yang sebenarnya (lihat di bawah). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6b/d7c/443/f6bd7c443381c1f0e133ee7b7bce05e1.png"></div><br>  Namun, dalam kasus kami yang sebaliknya terjadi.  Geometri melengkung dan halus, tetapi karena semua normals diarahkan ke atas, cahaya dipantulkan dari model seolah-olah datar (lihat di bawah): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/241/cde/323241cdef1b3a41604c579f4fdb509b.png"></div><br>  Anda dapat membaca lebih lanjut tentang peran normals dalam bayangan objek dalam artikel tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Pemetaan Normal (Bump Mapping)</a> , di mana silinder identik terlihat sangat berbeda, meskipun model 3D yang sama, karena berbagai metode penghitungan normals vertex (lihat di bawah). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b7/4fc/15f/1b74fc15f90516cc80b283953ef12373.png" width="315" height="243"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f93/544/d9c/f93544d9c95a70da71848897f0913676.png" width="347" height="254"></div><br>  Sayangnya, baik Unity maupun bahasa untuk membuat shader tidak memiliki solusi bawaan untuk menghitung ulang normals secara otomatis.  Ini berarti Anda harus mengubahnya secara manual tergantung pada geometri lokal model 3D. <br><br><h2>  Perhitungan normal </h2><br>  Satu-satunya cara untuk memperbaiki masalah bayangan adalah dengan menghitung secara manual normals berdasarkan geometri permukaan.  Tugas serupa dibahas dalam sebuah posting oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Vertex Displacement - Melting Shader Bagian 1</a> , di mana ia digunakan untuk mensimulasikan peleburan model 3D dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Cone Wars</a> . <br><br>  Meskipun kode yang sudah selesai harus bekerja dalam koordinat 3D, mari kita batasi tugas hanya dua dimensi untuk saat ini.  Bayangkan Anda perlu menghitung <strong>arah normal yang</strong> sesuai dengan titik pada kurva 2D (panah biru besar pada diagram di bawah). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5a/405/6be/e5a4056be62b920d9721a84d7c050ee6.png" width="316" height="346"></div><br>  Dari sudut pandang geometris, <em>arah normal</em> (panah biru besar) adalah vektor tegak lurus terhadap <strong>garis singgung yang</strong> melewati titik yang menarik bagi kita (garis biru tipis).  <em>Garis singgung</em> dapat direpresentasikan sebagai garis yang terletak pada kelengkungan model.  <strong>Vektor singgung</strong> adalah <strong>vektor</strong> <em>satuan</em> yang terletak pada singgung. <br><br>  Ini berarti bahwa untuk menghitung normal, Anda perlu mengambil dua langkah: pertama, temukan garis <em>singgung garis</em> ke titik yang diinginkan;  kemudian hitung vektor tegak lurus terhadapnya (yang akan menjadi <em>arah yang</em> diperlukan <em>dari normal</em> ). <br><br><h3>  Perhitungan singgung </h3><br>  Untuk mendapatkan yang <em>normal,</em> pertama-tama kita harus menghitung <em>garis singgung</em> .  Ini dapat diperkirakan dengan mengambil sampel titik terdekat dan menggunakannya untuk membangun garis di dekat titik.  Semakin kecil garis, semakin akurat nilainya. <br><br>  Dibutuhkan tiga langkah: <br><br><ul><li>  Tahap 1. Pindahkan sedikit pada permukaan yang rata </li><li>  Langkah 2. Hitung ketinggian titik baru. </li><li>  Langkah 3. Gunakan ketinggian titik saat ini untuk menghitung garis singgung </li></ul><br>  Semua ini bisa dilihat pada gambar di bawah ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46f/bd3/7e8/46fbd37e868d16ff7ec6f1a164377018.png"></div><br>  Agar ini berfungsi, kita perlu menghitung ketinggian dua poin, bukan satu.  Untungnya, kita sudah tahu bagaimana melakukan ini.  Pada bagian sebelumnya dari tutorial, kami membuat fungsi yang mengambil sampel ketinggian lanskap berdasarkan titik jala.  Kami menyebutnya <code>getVertex</code> . <br><br>  Kita dapat mengambil nilai titik baru pada titik saat ini, dan kemudian pada dua titik lainnya.  Satu akan untuk garis singgung, yang lain untuk garis singgung di dua titik.  Dengan bantuan mereka, kita mendapatkan yang normal.  Jika mesh asli yang digunakan untuk membuat efeknya rata (dan dalam kasus kami adalah), maka kita tidak perlu akses ke <code>v.normal</code> dan kita bisa menggunakan <code>float3(0, 0, 1)</code> untuk tangen dan tangen ke dua titik, masing-masing <code>float3(0, 0, 1)</code> dan <code>float3(1, 0, 0)</code> .  Jika kita ingin melakukan hal yang sama, tetapi, misalnya, untuk bola, maka akan jauh lebih sulit untuk menemukan dua titik yang cocok untuk menghitung garis singgung dan garis singgung menjadi dua titik. <br><br><h3>  Karya seni vektor </h3><br>  Setelah memperoleh vektor garis singgung dan garis singgung yang cocok untuk dua titik, kita dapat menghitung normal menggunakan operasi yang disebut <strong>produk vektor</strong> .  Ada banyak definisi dan penjelasan tentang karya vektor dan apa fungsinya. <br><br>  Produk vektor menerima dua vektor dan mengembalikan satu vektor baru.  Jika dua vektor awal adalah satuan (panjangnya sama dengan satu), dan mereka berada pada sudut 90, maka vektor yang dihasilkan akan berada pada 90 derajat relatif terhadap keduanya. <br><br>  Pada awalnya, ini dapat membingungkan, tetapi secara grafis dapat direpresentasikan sebagai berikut: produk vektor dari dua sumbu menciptakan yang ketiga.  Yaitu <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi><mtext>&amp;#xA0;</mtext><mi>k</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>Y</mi><mo>=</mo><mi>Z</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.05ex" height="2.057ex" viewBox="0 -780.1 5618.6 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-58" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6B" x="1102" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-61" x="1624" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6C" x="2153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-69" x="2452" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-59" x="2797" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMAIN-3D" x="3838" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-5A" x="4895" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi><mtext>&nbsp;</mtext><mi>k</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>Y</mi><mo>=</mo><mi>Z</mi></math></span></span><script type="math/tex" id="MathJax-Element-27"> X \ kali Y = Z </script>  tapi juga <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi><mtext>&amp;#xA0;</mtext><mi>k</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>Z</mi><mo>=</mo><mi>Y</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.05ex" height="2.057ex" viewBox="0 -780.1 5618.6 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-58" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6B" x="1102" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-61" x="1624" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-6C" x="2153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-69" x="2452" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-5A" x="2797" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMAIN-3D" x="3798" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhiuOqb1chZtE_9g1uAOxkZROsq12A#MJMATHI-59" x="4855" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi><mtext>&nbsp;</mtext><mi>k</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>Z</mi><mo>=</mo><mi>Y</mi></math></span></span><script type="math/tex" id="MathJax-Element-28"> X \ kali Z = Y </script>  , dan seterusnya. <br><br>  Jika kita mengambil langkah yang cukup kecil (dalam kode, ini <code>offset</code> ), maka vektor garis singgung dan garis singgung ke dua titik akan berada pada sudut 90 derajat.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bersama-sama dengan vektor normal, mereka membentuk tiga sumbu tegak lurus yang berorientasi di sepanjang permukaan model. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengetahui hal ini, kita dapat menulis semua kode yang diperlukan untuk menghitung dan memperbarui vektor normal.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ float3 bitangent = float3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); float3 tangent = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> offset = <span class="hljs-number"><span class="hljs-number">0.01</span></span>; float4 vertexBitangent = getVertex(v.vertex + float4(bitangent * offset, <span class="hljs-number"><span class="hljs-number">0</span></span>) ); float4 vertex = getVertex(v.vertex); float4 vertexTangent = getVertex(v.vertex + float4(tangent * offset, <span class="hljs-number"><span class="hljs-number">0</span></span>) ); float3 newBitangent = (vertexBitangent - vertex).xyz; float3 newTangent = (vertexTangent - vertex).xyz; v.normal = cross(newTangent, newBitangent); v.vertex.y = vertex.y; }</code> </pre> <br><h3>  Menyatukan semuanya </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang semuanya berfungsi, kita dapat mengembalikan efek gulir. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// v.vertex.xz: [_VertexMin, _VertexMax] // cropped.xz : [croppedMin, croppedMax] float2 croppedMin = _CropOffset; float2 croppedMax = croppedMin + _CropSize; float4 cropped = v.vertex; cropped.xz = (v.vertex.xz - _VertexMin) / (_VertexMax - _VertexMin) * (croppedMax - croppedMin) + croppedMin; float3 bitangent = float3(1, 0, 0); float3 normal = float3(0, 1, 0); float3 tangent = float3(0, 0, 1); float offset = 0.01; float4 vertexBitangent = getVertex(cropped + float4(bitangent * offset, 0) ); float4 vertex = getVertex(cropped); float4 vertexTangent = getVertex(cropped + float4(tangent * offset, 0) ); float3 newBitangent = (vertexBitangent - vertex).xyz; float3 newTangent = (vertexTangent - vertex).xyz; v.normal = cross(newTangent, newBitangent); v.vertex.y = vertex.y; v.texcoord = float4(vertexToUV(cropped), 0,0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan tentang ini efek kita akhirnya selesai. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d9/b07/680/0d9b0768068b2329d53e22a71ff27dfb.gif" width="700" height="272"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ke mana harus pergi selanjutnya </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutorial ini dapat menjadi dasar dari efek yang lebih kompleks, misalnya, proyeksi holografik atau bahkan salinan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tabel pasir</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari film "Black Panther".</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ecS1_-Y_uP8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paket Persatuan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paket lengkap untuk tutorial ini dapat diunduh di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , berisi semua aset yang diperlukan untuk memainkan efek yang dijelaskan.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462153/">https://habr.com/ru/post/id462153/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462141/index.html">Troli untuk pusat data</a></li>
<li><a href="../id462145/index.html">Mengapa perlu beberapa hari untuk berhenti berlangganan?</a></li>
<li><a href="../id462147/index.html">Bekerja dengan navigasi saat refactoring warisan proyek di React Native</a></li>
<li><a href="../id462149/index.html">Mode pembatasan akses untuk aksesori di perangkat iOS dan cara memintasnya</a></li>
<li><a href="../id462151/index.html">5 distribusi Kubernet teratas</a></li>
<li><a href="../id462155/index.html">Bekerja dengan Pekerja â€œsesuka Anda,â€ bukan â€œsebanyak mungkinâ€</a></li>
<li><a href="../id462159/index.html">Membangun sistem pengenalan wajah berdasarkan Golang dan OpenCV</a></li>
<li><a href="../id462161/index.html">Pengalaman menginstal Apache Airflow di Windows 10</a></li>
<li><a href="../id462163/index.html">Teknologi itu akan populer pada 2020</a></li>
<li><a href="../id462165/index.html">Bagaimana 25 orang tertipu untuk bekerja di perusahaan game yang tidak ada</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>