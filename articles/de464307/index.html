<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí° üö¥üèΩ ‚öôÔ∏è Integrationstests von Microservices auf Scala ü§ë üå† üë∂üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unit-Tests sind gro√üartig, aber einer reicht nicht aus. Oft m√∂chten Sie zus√§tzlich sicherstellen, dass die laufende Anwendung funktioniert. Integratio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Integrationstests von Microservices auf Scala</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/464307/">  Unit-Tests sind gro√üartig, aber einer reicht nicht aus.  Oft m√∂chten Sie zus√§tzlich sicherstellen, dass die laufende Anwendung funktioniert.  Integrationstests helfen.  Es wird zunehmend zum Testen von Diensten verwendet, und mit Docker k√∂nnen Sie Ihre Testumgebung bequem verwalten.  Aber wie immer sind die Dinge nicht so einfach, wenn es viel mehr Microservices und Abh√§ngigkeiten gibt. <br><br>  Yuri Badalyants von RIT ++ erz√§hlte, wie sie in 2GIS eine Reihe von Diensten und einen ganzen Technologiezoo testen.  Im Rahmen der K√ºrzung wird eine Version dieses Berichts unter sorgf√§ltiger Aufsicht des Redners erg√§nzt und aktualisiert: Welche Optionen haben Sie ausprobiert, worauf sind Sie gekommen, welche Probleme m√ºssen Sie jetzt nicht l√∂sen.  Es geht um Docker, Testcontainer und auch um Scala. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zE2sLcIeoZk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>√úber den Sprecher:</strong> Yuri Badalyants (@ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LMnet</a> ) begann seine Karriere 2011 als Webentwickler und arbeitete mit PHP, JavaScript und Java.  Jetzt schreibt er in 2GIS √ºber Scala. <br><br><h2>  Casino </h2><br>  2GIS bietet seit 20 Jahren praktische Stadtpl√§ne und Firmenverzeichnisse an. Vor kurzem haben wir eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neue Version</a> mit einer unbegrenzten Karte von Russland.  Ich erz√§hle Ihnen von den Erfahrungen, die ich w√§hrend meiner Arbeit im Casino-Team gesammelt habe.  Dieses Team ist in drei Hauptbereiche involviert: <br><br><ul><li>  Werbung - Welche Werbetreibenden sollen angezeigt, welche ausgeblendet, welche angehoben und wie die Bewertung gesenkt werden? </li></ul><br><ul><li>  BigData bezieht sich auf Werbung und deren Personalisierung sowie auf die Erstellung von Analysen und Metriken. </li><li>  Crawler ist ein Programm, das im Internet nach Organisationen sucht, um diese automatisch zur Datenbank hinzuzuf√ºgen. </li></ul><br>  Diese drei Bereiche sind die Hauptaufgaben, die wiederum eine gro√üe Anzahl von Unteraufgaben haben.  Derzeit sind mehr als 25 Microservices in Scala geschrieben.  Dies ist ausschlie√ülich unser Code, wir verwenden jedoch auch Systeme von Drittanbietern, z. B. PostgreSQL, Cassandra und Kafka.  Wir speichern die Daten in Hadoop und verarbeiten sie in Spark.  Dar√ºber hinaus verwenden wir die vom Data Science-Team bereitgestellten Methoden des maschinellen Lernens. <br><br>  Infolgedessen haben wir eine gro√üe Anzahl von Diensten und Mikrodiensten, eine gro√üe Anzahl von Abh√§ngigkeiten, und nat√ºrlich muss all dies auf irgendeine Weise getestet werden. <br><br>  Nat√ºrlich schreiben wir Unit-Tests.  Selbst wenn alle Tests gr√ºn sind, bedeutet dies nicht, dass alles funktioniert.  W√§hrend der Integrationsphase von Komponenten oder Microservices kann ein Fehler auftreten.  Deshalb schreiben wir Integrationstests. <br><br><h2>  Integrationstests </h2><br>  Jeder vom Casino-Team entwickelte Microservice l√∂st sein Gesch√§ftsproblem und befindet sich in einem separaten Repository in GitLab.  Dieser Artikel konzentriert sich auf Integrationstests in einem solchen Repository (Microservice) mit gesperrten Abh√§ngigkeiten, f√ºr die die Entwickler selbst verantwortlich sind.  Das QA-Team testet die Interaktion von Microservices, und ich werde dieses Thema nicht ansprechen. <br><br>  Als ich Ende 2016 zum ersten Mal ins Team kam, gab es ungef√§hr das folgende Integrationstestschema: <br><img src="https://habrastorage.org/webt/ws/fx/0r/wsfx0rhcuvtffigxdhrpmmoizya.png"><br><br><ol><li>  Der Entwickler schiebt seinen Code in GIT, woraufhin der Microservice-Code in TeamCity eingeht.  TeamCity beginnt mit dem Erstellen von Code und dem Ausf√ºhren von Tests. </li><li>  TeamCity √ºbernimmt die Konfigurationsdatei (config) von Chef (ein Ansible-√§hnliches Konfigurationsverwaltungssystem, das nur in Ruby geschrieben wurde).  Chefkoch dient auch zur Automatisierung der Bereitstellung.  Wenn ich 100 Maschinen habe, m√∂chte ich nicht zu jeder Maschine gehen und das, was ich brauche, auf SSH installieren. Chef kann mir dies automatisieren. </li><li>  TeamCity sammelt die JAR-Datei (da wir in Scala schreiben, ist das von uns ver√∂ffentlichte Artefakt das JAR) und wird dann vom Programm in die CI-Umgebung geladen.  Unsere Anwendung wird dort bereitgestellt, es gibt auch einige Abh√§ngigkeiten.  Im Diagramm ist eine der Abh√§ngigkeiten als Datenbank dargestellt.  Es kann so viele solche Abh√§ngigkeiten wie m√∂glich geben, und dank Chef kennt unsere Anwendung sie und beginnt mit ihnen zu interagieren. </li><li>  Als n√§chstes startet TeamCity <strong>SBT</strong> (dies ist unser Build-System, in dem Kompilierung und Tests ausgef√ºhrt werden) und f√ºhrt die Tests selbst aus.  Sie sind Unit-Tests relativ √§hnlich, arbeiten jedoch haupts√§chlich nach diesem Prinzip: Gehen Sie √ºber http zu einer bestimmten Adresse, √ºberpr√ºfen Sie eine Methode und sehen Sie, was sie zur√ºckgibt.  oder bereiten Sie sich vor und pr√ºfen Sie, ob das, was ben√∂tigt wird, zur√ºckgekehrt ist. </li></ol><br>  <strong>Was kann √ºber ein solches Schema gesagt werden?</strong>  Am wichtigsten ist, dass es funktioniert.  Wenn alles eingerichtet ist, ist das Ausf√ºhren von Tests einfach, da sie wie Komponententests aussehen.  Aber die Pluspunkte enden dort. <br><br>  Und die Nachteile beginnen.  <strong>Die CI-Umgebung ist immer aktiv</strong> , und dies ist eine zus√§tzliche Verschwendung von Ressourcen.  Da Chef eine statische Konfiguration ist, sollten Sie immer eine Art Computer haben, auf dem alle Abh√§ngigkeiten konfiguriert werden und auf dem die Anwendungen unabh√§ngig voneinander bereitgestellt werden.  Eine solche Maschine verbraucht zus√§tzliche Ressourcen, da von Zeit zu Zeit Tests ausgef√ºhrt werden und die Maschine jederzeit bereit sein muss.  Dar√ºber hinaus ist die CI-Umgebung in allen Abh√§ngigkeiten enthalten. <br><br>  <strong>Es ist nicht m√∂glich, Tests f√ºr zwei Zweige gleichzeitig durchzuf√ºhren</strong> .  Dies folgt aus dem vorherigen Absatz: Da wir eine Umgebung haben, k√∂nnen wir sie einfach nicht parallel ausf√ºhren. <br><br>  <strong>Es ist nicht m√∂glich, Start, Stopp und Neustart zu testen</strong> .  Ich werde erkl√§ren, warum dies notwendig ist: Alle unsere Anwendungen folgen der Logik des sogenannten <strong>ordnungsgem√§√üen Herunterfahrens</strong> , dh wenn wir SIGTERM erhalten, stoppen wir den Prozess nicht in der Mitte, sondern fangen dieses Signal ab und verstehen, dass wir das Programm ausschalten m√ºssen.  Zu diesem Zeitpunkt ist eine bestimmte Logik aktiviert, z. B. werden die HTTP-Anforderungen verarbeitet, die sich "im Flug" befinden, oder wenn wir mit Kafka arbeiten, legen wir alle Offs fest. Mit anderen Worten, wir f√ºhren bestimmte Aktionen aus, damit wir die Arbeit sicher abschlie√üen k√∂nnen Wenn alles erledigt ist, schalten Sie es aus. <br><br>  Diese Logik ist nicht immer einfach, und Sie k√∂nnen sie mit einem solchen Schema nur manuell testen, da wir anhand der Tests den Anwendungslebenszyklus nicht steuern.  Es stellt sich heraus, dass TeamCity etwas √ºber Chef bereitgestellt hat, w√§hrend sich die Tests in einem anderen Stadium befinden und nicht wissen, wie die Anwendung bereitgestellt wird. <br><br>  Das n√§chste Minus ist, dass es sehr <strong>schwierig ist, all dies lokal zu konfigurieren</strong> .  Das hei√üt, es gibt viele Abh√§ngigkeiten, sie haben ihre eigenen Konfigurationen, sie m√ºssen auf dem lokalen Computer ausgel√∂st werden.  Die Anwendung selbst hat auch eine eigene Konfigurationsdatei, in der es viele Werte gibt.  Die Tests selbst haben eine Konfiguration, die mit der Anwendungskonfiguration abgeglichen werden muss, und es kann auch mehr als einen Konfigurationswert geben.  Es scheint, dass all dies nicht so be√§ngstigend klingt, wie "Gehen Sie und reparieren Sie die Konfigurationen an drei Orten", aber in Wirklichkeit kann es Stunden dauern, bis neue Mitarbeiter dies tun. <br><br><h3>  GitLab CI + Docker </h3><br>  Im Laufe der Zeit hat sich dieses Schema in ein anderes verwandelt: <strong>GitLab CI</strong> und <strong>Docker</strong> .  Dies geschah nicht, weil das vorherige Schema nicht ideal war, sondern weil das Unternehmen seinen Kurs in Bezug auf die Verwaltungsorganisation geringf√ºgig ge√§ndert hatte. <br><br>  Zuvor hatte jedes Team und wir viele von ihnen, wie wir wollten oder wie wir konnten, und setzte seine Arbeit ein.  Zum Beispiel hatten wir TeamCity, Chef und andere Teams konnten Jenkins oder Ansible verwenden. <br><br>  Jetzt bewegen wir uns in Richtung der lokalen Cloud und Kubernetes, und es gibt ein separates Team, das all dies verwaltet, sowohl GitLab CI als auch Kubernetes.  Andere Teams nutzen dies nur als Service.  Dies ist viel praktischer, da Sie dies alles nicht manuell verwalten m√ºssen. <br><br>  Mit Kubernetes haben wir das folgende Schema bereitgestellt: <br><img src="https://habrastorage.org/webt/lr/uc/gq/lrucgqg479qcboq4xxwpil0pohq.png"><br><br><ol><li>  Anstelle von TeamCity wird jetzt Gitlab CI verwendet. </li><li>  GitLab CI erstellt ein Docker-Image und stellt es in Kubernetes bereit.  Die Konfiguration wird jetzt direkt im Repository und nicht separat in Chef gespeichert, sodass Sie f√ºr die Bereitstellung nicht mit einem Konfigurationsdienst eines Drittanbieters arbeiten m√ºssen. </li><li>  Abh√§ngigkeiten werden im Voraus auch in Kubernetes angesprochen. </li><li>  Anschlie√üend startet GitLab CI SBT und testet in einem separaten Schritt. </li></ol><br>  Alles ist dem vorherigen Schema ziemlich √§hnlich und unterscheidet sich nicht grundlegend davon, das hei√üt, selbst die Vor- und Nachteile werden genau gleich sein, aber Docker erscheint. <br><br>  Mit Docker k√∂nnen Sie verschiedene lustige Dinge machen, und eine davon ist Docker-Compose. <br><br><h3>  Docker-Compose </h3><br>  Dies ist eine Art "Overlay" in Docker, mit dem Sie mehrere Docker-Images als eine Einheit ausf√ºhren k√∂nnen. <br><br>  Ein gutes Beispiel, wo Docker-Compose wirklich hilft, ist Kafka.  Sie braucht ZooKeeper, um zu rennen.  Wenn Sie Kafka und ZooKeeper ohne Docker-Compose anheben, m√ºssen Sie ZooKeeper separat im Docker anheben - Kafka - und diese beiden Docker-Container konsistent halten.  Dies ist nicht sehr praktisch, und mit Docker-Compose k√∂nnen Sie beide Container in einer Datei docker-compose.yml beschreiben und mit dem einfachen <code>docker-compose run Kafka</code> docker <code>docker-compose run Kafka</code> Kafka und ZooKeeper ausl√∂sen. <br><br>  Sie k√∂nnen Integrationstests auf Docker-Compose erstellen.  Mal sehen, wie es aussehen wird. <br><img src="https://habrastorage.org/webt/ae/a9/wn/aea9wn8lh9tdi8ezctgs1hfhkuw.png"><br><br><ol><li>  Schieben Sie erneut alles in GitLab. </li><li>  GitLab CI startet Docker-Compose. </li><li>  In Docker-Compose wird die Anwendung hochgefahren, alle Abh√§ngigkeiten und SBT werden hochgefahren, und der SBT steuert die Tests f√ºr diese Anwendung - alles geschieht in Docker-Compose. </li></ol><br>  Dank dieses Schemas m√ºssen keine separate Umgebung und Abh√§ngigkeiten beibehalten werden, da alles direkt an den GitLab CI-Runner geht, wo Docker und Docker-Compose nur sein m√ºssen.  W√§hrend des Starts pumpt er die erforderlichen Bilder auf und f√ºhrt sie aus. <br><br>  Au√üerdem k√∂nnen Sie verschiedene Zweige gleichzeitig testen, da alles auf dem L√§ufer passiert. <br><br>  Jetzt ist <strong>es einfacher, die</strong> Umgebung <strong>lokal zu konfigurieren</strong> , aber Sie m√ºssen immer noch mehrere Orte koordinieren.  Der Punkt ist, dass wir jetzt, wenn wir die lokale Konfiguration durchf√ºhren, nicht alles auf dem lokalen Computer ablegen m√ºssen, sondern alles in die Datei docker-compose.yml geschrieben ist.  Sie m√ºssen also an zwei verschiedenen Stellen konfigurieren - dies ist docker-compose.yml und die Konfiguration unserer Tests. <br><br>  Was die Minuspunkte betrifft, ist <strong>es immer noch unm√∂glich, Start, Stopp und Neustart zu testen</strong> , da wir von SBT aus Tests den Anwendungslebenszyklus nicht steuern.  Es wird von Docker-Compose ausgef√ºhrt, es wird SBT ausgef√ºhrt und Tests werden innerhalb von SBT ausgef√ºhrt.  Daher gibt es kein vollwertiges Lebenszyklusmanagement der Anwendung.  Es gibt auch Schwierigkeiten beim Start, √ºber die ich gerne mehr sprechen m√∂chte. <br><br><h4>  Docker-Compose 2 </h4><br>  In den Tagen von Docker-Compose 2, Docker-Compose.yml sah die Datei folgenderma√üen aus: <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'2.1'</span></span> services: web: build: . depends_on: db: condition: service_healthy redis: condition: service_started redis: image: redis db: image: db healthcheck: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>: <span class="hljs-string"><span class="hljs-string">"some test here"</span></span></code> </pre> <br>  Hier werden Dienste registriert, das hei√üt, was wir im Rahmen dieser Docker-Komposition erheben werden.  In diesem Fall habe ich nur ein Beispiel aus der Docker-Compose-Dokumentation genommen.  Es gibt drei Dienste: Web, Redis und DB (Datenbank). <br><br>  Web ist unsere Anwendung, und redis und db sind eine Art von Abh√§ngigkeiten. <br><br>  Es gibt ein Element im <code>depends_on</code> Namen <code>depends_on</code> .  Dies deutet darauf hin, dass die Webanwendung von einigen anderen Containern abh√§ngt und im Folgenden beschrieben wird: aus der Datenbank und Redis. <br><br>  Es gibt auch eine <code>condition</code> .  F√ºr redis ist dies <code>service_started</code> bedeutet, dass der Container bis zum Start von <code>service_started</code> nicht versucht, die Webanwendung zu starten. <br><br>  Der Zustand der Datenbank lautet <code>service_healthy</code> , und der Healthcheck wird unten beschrieben.  Das hei√üt, wir m√ºssen nicht nur den Docker-Container starten, sondern auch einen bestimmten Healthcheck ausf√ºhren.  Es kann eine beliebige benutzerdefinierte Logik sein. <br><br>  Zum Beispiel verwenden wir PostgreSQL, das die PostGIS-Erweiterung verwendet, und die Initialisierung ben√∂tigt einige Zeit.  Wenn wir den Docker-Container starten, k√∂nnen wir nicht sofort mit der Postgis-Erweiterung arbeiten. Wir m√ºssen warten, bis die Erweiterung initialisiert ist.  Daher <code>SELECT PostGIS_Version();</code> wir nur <code>SELECT PostGIS_Version();</code> Abfragen an <code>SELECT PostGIS_Version();</code>  .  Bis die Erweiterung initialisiert ist, gibt die Anforderung einen Fehler aus. Wenn die Erweiterung initialisiert wird, wird die Version zur√ºckgegeben.  Dies ist sehr praktisch und logisch - <strong>zuerst werden alle Abh√§ngigkeiten und dann die Anwendung erh√∂ht</strong> . <br><br><h4>  Docker-Compose 3 </h4><br>  Als Docker-Compose 3 herauskam, haben wir damit begonnen. <br><br>  In der Dokumentation dazu wurde jedoch ein Element zum √Ñndern der abh√§ngigen Logik angezeigt.  Die Docker-Entwickler entschieden, dass eine Beschreibung des Abh√§ngigkeitsgraphen ausreichend war.  Dies bedeutet, dass beim Starten des <code>docker-compose run web</code> sowohl die Anwendung selbst als auch die Datenbank, von der sie abh√§ngt, gleichzeitig gestartet werden. <br><br><img src="https://habrastorage.org/webt/yp/4_/vy/yp4_vyw7zxudu9naji96akfjeic.png"><br><br>  Der n√§chste Absatz in der Dokumentation besagt, dass abh√§ngige_on keine Bedingung mehr ist. <br><br>  Wenn Sie also immer noch die Funktionalit√§t erhalten m√∂chten, die in der zweiten Version verwendet wurde, m√ºssen Sie alles selbst in die Hand nehmen. <br><br>  Die Seite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Controlling Startup Order</a> bietet verschiedene L√∂sungen.  Die erste Option ist die Verwendung von <strong>wait-for-it.sh</strong> . <br><br>  Jetzt sieht docker-compose.yml etwas anders aus: <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: web: build: . depends_on: [ db, redis ] redis: image: redis <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: [ <span class="hljs-string"><span class="hljs-string">"./wait-for-it.sh"</span></span>, ... ] db: image: redis <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: [ <span class="hljs-string"><span class="hljs-string">"./wait-for-db.sh"</span></span>, ... ]</code> </pre> <br>  <code>depends_on</code> ist nur ein Array, es gibt keine Bedingungen. <br><br>  In unseren Abh√§ngigkeiten definieren wir den Befehl neu, dh in Docker-Compose k√∂nnen Sie einen Befehl anh√§ngen, mit dem der Docker-Container startet. <br><br>  Dort sollten wir wait-for-it.sh und etwas anderes schreiben.  Anstelle der drei Punkte im obigen Beispiel sollten wir schreiben, was wir warten m√ºssen, sowie den urspr√ºnglichen Befehl, der den Docker-Container startet. <br><br>  Dazu m√ºssen Sie die Docker-Datei suchen, den Befehl f√ºr redis von dort kopieren und einf√ºgen. Gleiches gilt f√ºr die Datenbank.  Ein gro√ües Minus ist, dass die <strong>Abstraktion zusammenbricht</strong> - ich m√∂chte nicht wissen, welcher Befehl den Docker-Container startet.  Diese Befehle k√∂nnen nicht trivial und recht komplex sein, aber ich m√∂chte mich nicht darum k√ºmmern, sondern nur den <code>docker run</code> eingeben und <code>docker run</code> . <br><br>  Ich pers√∂nlich mag diese L√∂sung nicht wirklich, aber wir hatten einige Dienste, die so funktionieren. <br><br><h4>  Skript √ºber Docker-Compose </h4><br>  Dann entschied ich, dass die Zeit f√ºr "Fahrradbau" gekommen war und ich hatte <strong>docker-compose-run.sh</strong> : <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: postgres: ... my_service: depends_on: [ postgres ] ... sbt: depends_on: [ my_service ] ...</code> </pre><br>  Lassen Sie mich ein semi-realistisches Beispiel geben: Es gibt postgres in docker-compose.yml, es gibt die Anwendung my_service, die von postgres abh√§ngt, und SBT, in der Tests ausgef√ºhrt werden und die von meinem Service abh√§ngt. <br><br>  Ich f√ºhre das Programm nicht √ºber <code>docker run</code> , sondern √ºber das Skript Docker-Compose-Run.sh. <br><br>  Erstens beginnt die tiefste Abh√§ngigkeit zuerst, in meinem Fall sind es Postgres.  Das Skript startet die Abh√§ngigkeit im "Daemon" -Modus, dh es blockiert das Terminal nicht: <br><br><pre> <code class="bash hljs">docker-compose up -d postgres</code> </pre> <br>  Dann warte ich, bis die Bedingung wait_until die Bedingung erf√ºllt.  Dies ist fast das Gleiche wie wait-for-it.sh, nur sozusagen in einem imperativen Stil.  W√§hrend der Initialisierung von PostGIS wird das Terminal blockiert, dh das Programm wartet ebenfalls. Wenn es nicht wartet, wird ein Fehler ausgegeben und die Tests funktionieren nicht mehr. <br><br><pre> <code class="bash hljs">wait_until 10 2 docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> -T postgres psql</code> </pre> <br>  Wenn PostGIS initialisiert ist, fahren Sie mit dem n√§chsten Schritt fort und machen Sie dasselbe mit dem Dienst.  F√ºr ihn ist der Test etwas einfacher: Port 80 sollte gebunden sein. <br><br><pre> <code class="bash hljs">docker-compose up -d my_service wait_until 10 2 docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> -T \ my_service sh -c <span class="hljs-string"><span class="hljs-string">"netstat -ntlp | grep 80 || exit 1"</span></span></code> </pre> <br>  Der letzte Schritt besteht darin, SBT √ºber den Befehl run auszuf√ºhren, in dem Tests ausgef√ºhrt werden. <br><br><pre> <code class="bash hljs">docker-compose run sbt down $?</code> </pre> <br>  Somit wird alles in der richtigen Reihenfolge ausgel√∂st, jedoch manuell. <br><br>  Am Ende wird die <code>down</code> Funktion aufgerufen, die das Ergebnis des vorherigen Befehls akzeptiert.  Wenn es "0" ist, sind die Tests bestanden und wir schalten Docker-Compose einfach aus.  Andernfalls ‚Äûspucken‚Äú wir zuerst die Protokolle aus, um herauszufinden, was schief gelaufen ist, und deaktivieren dann erst Docker-Compose. <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> down { <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Exiting with code </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$1</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$1</span></span> -eq 0 ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> docker-compose down <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> docker-compose logs -t postgres my_service docker-compose down <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> }</code> </pre> <br>  Ein solches Schema funktioniert, l√§sst sich aber nicht gut skalieren.  Jeder Dienst muss seine docker-compose-run.sh mit seiner eigenen Logik beschreiben.  Au√üerdem erstreckt sich die Startkonfiguration zwischen docker-compose-run.sh und docker-compose.yml.  Im Allgemeinen sieht es so aus, als w√ºrden wir Docker-Compose nicht verwenden, aber mit seinen M√§ngeln k√§mpfen. <br><br><h4>  Docker aus Code ausf√ºhren </h4><br>  Als das vorherige Schema erstellt wurde, dachte ich: Wenn ich bereits alles im Docker habe, warum nicht aus dem Code ausf√ºhren?  Ich suchte nach einer L√∂sung und fand mehrere M√∂glichkeiten. <br><br>  Die erste M√∂glichkeit besteht darin, einfach <strong>den Docker-Client zu verwenden</strong> .  In der JVM-Welt gibt es zwei Haupt-Docker-Clients: <strong>Docker-Java</strong> und <strong>Spotify-Docker-Client</strong> . <br><br>  Mit dem Docker-Client k√∂nnen Sie Docker-Befehle mithilfe der API direkt aus dem Code ausf√ºhren.  Das hei√üt, anstatt Zeichenfolgen zu verketten, um Befehle wie <code>`docker run ...`</code> zu erstellen, k√∂nnen Sie einfach einen solchen Befehl im Code bilden und ausf√ºhren.  Es ist viel bequemer. <br><br>  Diese Methode funktioniert gut und sie k√∂nnen mit Sicherheit alles, dies ist jedoch ein sehr niedriges Niveau.  Ich m√ºsste mein eigenes Docker-Compose-Analogon erstellen, was eine sehr gro√üe Aufgabe ist. <br><br>  Die n√§chste Option ist die <strong>Docker-it-Scala-Bibliothek</strong> , die beide Clients umschlie√üt und es Ihnen erm√∂glicht, das zu verwendende Backend auszuw√§hlen.  Sie kann die Container laufen lassen, die Sie brauchen. <br><br>  Das Minus dieser Bibliothek ist jedoch, dass sie keine sehr flexible API hat und keine Lebenszykluskontrolle gibt. <br><br>  Diese Option hat mir auch nicht gefallen, ich habe weiter gesucht und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testcontainer</a> gefunden.  Ich m√∂chte Ihnen mehr dar√ºber erz√§hlen. <br><br><h2>  Testcontainer </h2><br>  Dies ist eine Art Java-Bibliothek zum Starten und Testen von Docker-Containern.  Es gibt eine Scala-Fassade, Testcontainer-Scala.  Standardm√§√üig gibt es eine Reihe beliebter Dienste, z. B. PostgreSQL, MySQL, Nginx, Kafka, Selenium.  Sie k√∂nnen beliebige andere Container ausf√ºhren.  Die Bibliothek verf√ºgt √ºber eine recht einfache und flexible API, auf die ich noch n√§her eingehen werde. <br><br><h3>  Vordefinierte Container </h3><br>  So arbeiten Sie mit vordefinierten Containern, die sich in der Bibliothek befinden: Tats√§chlich ist alles recht einfach, da Container als Objekte dargestellt werden: <br><br><pre> <code class="bash hljs">val pgContainer: PostgreSQLContainer = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) pgContainer.start() val pgUrl: String = pgContainer.jdbcUrl val pgPort: Int = pgContainer.mappedPort(5432) pgContainer.stop()</code> </pre> <br>  In diesem Fall erstellen wir <code>PostgreSQLContainer</code> , wir k√∂nnen es starten und damit arbeiten.  Als n√§chstes erhalten wir <code>jbdcUrl</code> , mit dem Sie eine Verbindung zu PostgreSQL herstellen k√∂nnen.  Danach bekommen wir <code>mappedPort</code> . <br><br>  Dies bedeutet, dass PostgreSQL sich vom Docker-Port 5432 abhebt und Testcontainer diesen Port erkennt und automatisch einem zuf√§lligen Port zuweist.  Das hei√üt, aus den Tests sehen wir beispielsweise 32422. Die Zuweisung erfolgt automatisch. <br><br><h3>  Benutzerdefinierter Container </h3><br>  Die folgende Ansicht, der sogenannte benutzerdefinierte Container, ist ebenfalls recht einfach: <br><br><pre> <code class="bash hljs">class GenericContainer( imageName: String, exposedPorts: Seq[Int] = Seq(), env: Map[String, String] = Map(), <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: Seq[String] = Seq(), classpathResourceMapping: Seq[(String, String, BindMode)] = Seq(), waitStrategy: Option[WaitStrategy] = None ) ...</code> </pre> <br>  Es gibt einen <code>GenericContainer</code> von dem Sie eine Reihe von Feldern erben und √ºberschreiben m√ºssen.  <code>imageName</code> Sie sicher, dass Sie nur <code>imageName</code> Dies ist der Name des Containers, den Sie erstellen m√∂chten. <br><br>  Sie k√∂nnen <code>exposedPorts</code> Ports <code>exposedPorts</code> : die Ports, aus denen der Container herausragt.  In env k√∂nnen Sie Umgebungsvariablen festlegen und den <code>command</code> zum Ausf√ºhren festlegen. <br><br>  <code>classpathResourceMapping</code> k√∂nnen Sie Ressourcen aus dem Klassenpfad in den Docker-Container werfen.  Dies ist beispielsweise sehr praktisch, wenn sich die Anwendungskonfiguration direkt in den Testressourcen befindet.  Sie ordnen sie einfach zu, und die Anwendung im Docker erh√§lt Zugriff auf diese Konfiguration. <br><br>  <code>waitStrategy</code> ist eine sehr praktische Sache, die in Docker-Compose 3 fehlte, tats√§chlich ist es HealthCheck.  Es gibt mehrere vordefinierte <code>waitStrategy</code> . Sie k√∂nnen beispielsweise warten, bis eine <code>waitStrategy</code> auftritt, oder eine bestimmte http-Methode gibt 200 zur√ºck. Sie k√∂nnen jedoch einen beliebigen HealthCheck schreiben. <br><br>  Da Sie HealthCheck einfach in Ihren Code schreiben, k√∂nnen Sie zum einen eine normale Sprache verwenden, nicht Bash, und zum anderen alle Bibliotheken, die in Ihrem Code verf√ºgbar sind: Wenn Sie einen benutzerdefinierten HealthCheck in Cassandra erstellen m√∂chten, nehmen Sie den Treiber und schreiben Sie jeder HealthCheck. <br><br><h3>  Ausf√ºhren von Tests </h3><br>  Und jetzt ein wenig dar√ºber, wie man Tests durchf√ºhrt: <br><br><pre> <code class="bash hljs">class PostgresqlSpec extends FlatSpec with ForAllTestContainer { override val container = PostgreSQLContainer() <span class="hljs-string"><span class="hljs-string">"PostgreSQL container"</span></span> should <span class="hljs-string"><span class="hljs-string">"be started"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { Class.forName(container.driverClassName) val connection = DriverManager .getConnection(container.jdbcUrl, container.username, container.password) // <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> some stuff } }</code> </pre> <br>  Ich werde √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ScalaTest</a> sprechen, den De-facto-Standard f√ºr Tests in der Scala-Welt. <br><br>  Zum Beispiel m√∂chten wir Tests f√ºr Postgres schreiben.  Erstellen Sie einen <code>PostgresqlSpec</code> Test und erben Sie ihn von <code>ForAllTestContainer</code> .  Dies ist eine Eigenschaft, die von der Bibliothek bereitgestellt wird.  Die erforderlichen Container werden vor allen Tests gestartet und nach allen Tests gestoppt.  Oder Sie k√∂nnen <code>ForeachTestContainer</code> , dann beginnen die Container vor jedem Test und stoppen nach jedem von ihnen. <br><br>  Dann m√ºssen Sie den Container neu definieren.  Dies kann durch √úberschreiben der <code>container</code> .  In meinem Fall verwende ich <code>PostgreSQLContainer</code> . <br><br>  Dann schreiben wir Tests.  Im Beispiel erstelle ich eine Verbindung, nehme jdbcUrl, Benutzername, Passwort, schreibe bestimmte Tests, sende Anfragen. <br><br>  In der Regel erfordern Integrationstests mehrere Container.  Ich kann sie mit <code>MultipleContainers</code> erstellen: <br><br><pre> <code class="bash hljs">val pgContainer = PostgreSQLContainer() val myContainer = MyContainer() override val container = MultipleContainers(pgContainer, myContainer)</code> </pre> <br>  Das hei√üt, ich erstelle Container, f√ºge sie <code>MultipleContainers</code> und verwende sie als <code>container</code> . <br><br>  Das Schema zum Ausf√ºhren von Tests mit Testcontainern lautet wie folgt: <br><br><img src="https://habrastorage.org/webt/vp/0f/-e/vp0f-ehxlezqapcu3rfq3tqzmeu.jpeg"><br><br><ol><li>  Schieben Sie den Code in GitLa. </li><li>  GitLab CI Runner startet SBT. </li><li>  SBT f√ºhrt Tests durch.  Innerhalb der Tests werden unsere Anwendung und Abh√§ngigkeiten gestartet. </li></ol><br>  Die Vorteile dieses Schemas: <br><br><ul><li>  Sie m√ºssen keine separate Umgebung und Abh√§ngigkeiten beibehalten, alles geschieht auf dem L√§ufer. </li><li>  Sie k√∂nnen verschiedene Zweige gleichzeitig testen. </li><li>  Sie k√∂nnen Start, Stopp und Neustart testen, da wir den Lebenszyklus der Anwendung steuern k√∂nnen (alles beginnt direkt im Testcode). </li><li>  Es gibt flexible HealthChecks, die schmerzlich fehlten. </li><li>  Es befinden sich keine * .sh-Dateien im Repository. Sie k√∂nnen Tests in der Anwendung so flexibel konfigurieren, wie Sie m√∂chten. </li><li>  Dank der classpathResource-Zuordnung k√∂nnen Sie f√ºr beide Tests und die Anwendung dieselbe Konfiguration verwenden. </li><li>  Sie k√∂nnen Tests aus Code konfigurieren. </li><li>  All dies l√§uft sowohl auf CI als auch lokal gleich einfach, da es sich nur um Tests handelt, die als Komponententests aussehen und ausgef√ºhrt werden. Nur alles wird im Docker-Container angezeigt. </li></ul><br>  Es stellt sich heraus, dass alles verd√§chtig glatt und gut ist, aber dies ist nur auf den ersten Blick, tats√§chlich sind wir auf eine Reihe von Problemen gesto√üen. <br><br><h3>  Abh√§ngige Container </h3><br>  Das erste Problem, auf das wir gesto√üen sind, sind <strong>abh√§ngige Container</strong> .  Nehmen wir an, es gibt eine Art Test: <br><br><pre> <code class="bash hljs">class MySpec extends FlatSpec with ForAllTestContainer { val pgCont = PostgreSQLContainer() val appCont = AppContainer(pgCont.jdbcUrl, pgCont.username, pgCont.password) override val container = MultipleContainers(appCont, pgCont) // tests here }</code> </pre> <br>  Es werden Postgres und AppContainer ausgef√ºhrt.  Dem appContainer von postgres wird jdbcUrl √ºbergeben, der Benutzername und das Passwort f√ºr die Verbindung.  Als N√§chstes werden MultipleContainer erstellt und der Test selbst beschrieben. <br><br>  Ich starte das Programm und sehe einen Fehler: <br><br><pre> <code class="bash hljs">Exception encountered when invoking run on a nested suite - Mapped port can only be obtained after the container is started</code> </pre> <br>  Der Punkt ist, dass der zugewiesene Port nicht genommen werden kann, bis der Container gestartet wird.  Warum passiert das? <br><br>  Tatsache ist, dass <code>ForAllTestContainer</code> oder <code>ForEachTestContainer</code> Container direkt vor den Tests starten und nicht in dem Moment, in dem ich Containerinstanzen erstelle.  Es stellt sich heraus, dass zum Zeitpunkt des Erstellens des AppContainers <code>PostgreSQLContainer</code> noch nicht <code>jdbcUrl</code> . <code>jdbcUrl</code> bedeutet, dass ich den zugewiesenen Port nicht <code>jdbcUrl</code> kann und er zur Bildung von <code>jdbcUrl</code> ben√∂tigt <code>jdbcUrl</code> . <br><br>  Das Problem ist, dass das Wesen des Containers ver√§nderlich ist: Es hat mehrere Zust√§nde.  Zum Beispiel kann es ein- und ausgeschaltet werden. <br><br>  Wie kann man dieses Problem l√∂sen?  Die erste Methode w√ºrde ich "faul" nennen. <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with BeforeAndAfterAll { lazy val pgCont = PostgreSQLContainer() lazy val appCont = AppContainer(pgCont.jdbcUrl, pgCont.username, pgCont.password) override def beforeAll(): Unit = { super.beforeAll() pgCont.start() appCont.start() } override def afterAll(): Unit = { super.afterAll() appCont.stop() pgCont.stop() } // tests here }</code> </pre> <br>  Die Hauptidee besteht darin, Container mit <strong>Lazy Val</strong> zu erstellen.  Dann werden sie nicht sofort im Testkonstruktor initialisiert, sondern warten auf den ersten Aufruf.  Wir werden die <code>afterAll</code> <code>beforeAll</code> und <code>afterAll</code> initialisieren, die das <code>BeforeAndAfterAll</code> BeforeAndAfterAll von ScalaTest bereitstellt.  In <code>beforeAll</code> Container gestartet und in <code>afterAll</code> werden sie ausgeschaltet.  Da die Container als faul deklariert sind, werden sie zum Zeitpunkt des Aufrufs der Startmethode beforeAll erstellt, initialisiert und gestartet. <br><br>  Es tritt jedoch immer noch ein Fehler auf, dass ich localhost nicht beitreten kann: 32787: <br><br><pre> <code class="bash hljs">org.postgresql.util.PSQLException: Connection to localhost:32787 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.</code> </pre> <br>  Es scheint, dass wir jdbcUrl verwendet haben. Warum erscheint localhost?  Mal sehen, wie jdbcUrl funktioniert: <br><br><pre> <code class="bash hljs">@Override public String <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJdbcUrl</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://"</span></span> + getContainerIpAddress() + <span class="hljs-string"><span class="hljs-string">":"</span></span> + getMappedPort(POSTGRESQL_PORT) + <span class="hljs-string"><span class="hljs-string">"/"</span></span> + databaseName; }</code> </pre> <br>  Es ist nur eine Zeichenfolgenverkettung.  Mit Konstanten ist alles klar, sie k√∂nnen nicht brechen.  <code>getMappedPort</code> sollte auch funktionieren, da wir es bereits behoben haben.  <code>databaseName</code> ist eine fest codierte Konstante.  Aber mit <code>getContainerIpAddress</code> interessanter.  Beim Namen k√∂nnen wir davon ausgehen, dass die IP-Adresse des Containers zur√ºckgegeben werden soll.  Wenn Sie diesen Code jedoch ausf√ºhren, stellt sich heraus, dass immer localhost zur√ºckgegeben wird.  Wie sich herausstellte, ist diese Methode nicht f√ºr die Interaktion zwischen Containern vorgesehen: <code>getContainerIpAddress</code> <strong>bietet Interaktion aus Tests innerhalb des Containers</strong> . <br><br>  Empfehlung des Testcontainer-Entwicklers: <strong>Erstellen Sie ein benutzerdefiniertes Netzwerk f√ºr die Kommunikation zwischen Containern</strong> .  Docker-Compose funktioniert ungef√§hr so: Es erstellt ein Netzwerk und l√∂st alles selbst. <br><br>  Sie m√ºssen also ein Netzwerk erstellen. <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with BeforeAndAfterAll { val network: Network = Network.newNetwork() val dbName = <span class="hljs-string"><span class="hljs-string">"some_db"</span></span> val pgContainerAlias = <span class="hljs-string"><span class="hljs-string">"postgres"</span></span> val jdbcUrl = s<span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pgContainerAlias</span></span></span><span class="hljs-string">:5432/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dbName</span></span></span><span class="hljs-string">"</span></span> lazy val pgCont = { val c = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) c.container.withNetwork(network) c.container.withNetworkAliases(pgContainerAlias) c.container.withDatabaseName(dbName) c } lazy val appCont = { val c = AppContainer(jdbcUrl, pgCont.username, pgCont.password) c.container.withNetwork(network) c } override def beforeAll(): Unit = { super.beforeAll() pgCont.start() appCont.start() } override def afterAll(): Unit = { super.afterAll() appCont.stop() pgCont.stop() network.close() } // tests here }</code> </pre> <br>  Jetzt m√ºssen wir unsere jdbcUrl manuell konfigurieren.  Wir m√ºssen auch unsere Container im Netzwerk aktivieren und einen Alias ‚Äã‚Äãf√ºr den PostgreSQLContainer festlegen, damit er √ºber einen Dom√§nennamen im Netzwerk zug√§nglich ist.  Am Ende m√ºssen Sie daran denken, das Netzwerk zu "t√∂ten". <br><br>  Schlie√ülich wird ein solches Programm funktionieren. <br><br>  In neueren Versionen von testcontainers-scala wird die verz√∂gerte Containerinitialisierung sofort unterst√ºtzt: <br><br><pre> <code class="bash hljs">class MyTest extends FreeSpec with ForAllTestContainer with BeforeAndAfterAll { val network: Network = Network.newNetwork() val dbName = <span class="hljs-string"><span class="hljs-string">"some_db"</span></span> val pgContainerAlias = <span class="hljs-string"><span class="hljs-string">"postgres"</span></span> val jdbcUrl = s<span class="hljs-string"><span class="hljs-string">"jdbc:postgresql://</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pgContainerAlias</span></span></span><span class="hljs-string">:5432/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dbName</span></span></span><span class="hljs-string">"</span></span> lazy val pgCont = { val c = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>) c.container.withNetwork(network) c.container.withNetworkAliases(pgContainerAlias) c.container.withDatabaseName(dbName) c } lazy val appCont = { val c = AppContainer(jdbcUrl, pgCont.username, pgCont.password) c.container.withNetwork(network) c } override val container = MultipleContainers(pgCont, appCont) override def afterAll(): Unit = { super.afterAll() network.close() } // tests here }</code> </pre> <br>  Sie k√∂nnen <code>ForAllTestContainer</code> und <code>MultipleContainers</code> wieder verwenden.  In <code>beforeAll</code> Startreihenfolge nicht mehr manuell <code>beforeAll</code> .  Jetzt k√∂nnen <code>MultipleContainers</code> mit Lazy Val arbeiten und diese in der richtigen Reihenfolge ausf√ºhren und f√ºhren keine strikte Initialisierung unmittelbar nach der Erstellung durch.  Gleichzeitig m√ºssen Manipulationen mit dem benutzerdefinierten Netzwerk und jdbcUrl auch manuell durchgef√ºhrt werden. <br><br><h3>  Verspottet </h3><br>  Es gibt jedoch immer noch Probleme.  Zum Beispiel Moki.  Manchmal ist es nicht sehr praktisch, eine Abh√§ngigkeit in einem Docker-Container zu erstellen.  Wir verwenden den Spark JobServer, der Spark-Jobs erstellt und deren Lebenszyklus in Spark steuert.  Wir verwenden zwei seiner Methoden: "erstellen" und "Status geben". <br><br>  So f√ºhren Sie Spark JobServer im Docker aus  Es ist notwendig, Spark zu erh√∂hen, und bis vor kurzem hatte es √ºberhaupt keinen Docker-Container und es war notwendig, ihn selbst zusammenzubauen.  Dar√ºber hinaus verwendet Spark JobServer PostgreSQL zum Speichern von Status.  Infolgedessen m√ºssen Sie viel schwierige Arbeit leisten, wenn Sie wirklich nur zwei Methoden mit einer einfachen API ben√∂tigen. <br><br>  Sie k√∂nnen jedoch einen Blick in die Implementierung des Spark JobServers werfen und ein Modell erstellen, das sich genauso verh√§lt, jedoch nicht die Abh√§ngigkeiten des urspr√ºnglichen Spark JobServers erfordert. <br><br>  Es sieht so aus (im Beispiel ein vereinfachter Pseudocode): <br><br><pre> <code class="bash hljs">val hostIp = ??? AppContainer(sparkJobServerMockHost = hostIp) val sparkJobServerMock = new SparkJobServerMock() sparkJobServerMock.init(someData) val apiResult = appApi.callMethod() assert(apiResult == someData)</code> </pre> <br>       http-    API    Spark JobServer.    - ,          . ,   ,   ,     mock. <br><br>   -  ,      .       :    ¬´¬ª    config;   ,   host. <br><br>  <code>SparkJobServerMock</code>    ,     host-,     docker-, ,   ,       docker-. <br><br>      ?      docker-,   ,    gateway  ,   docker-. <br><br>   ,   Testcontainers   API. ,   Testcontainers    docker-java-,     .    ¬´¬ª docker-: <br><br><pre> <code class="bash hljs">val client: com.github.dockerjava.api.DockerClient = DockerClientFactory .instance .client val networkInfo: com.github.dockerjava.api.model.Network = client .inspectNetworkCmd() .withNetworkId(network.getId) .<span class="hljs-built_in"><span class="hljs-built_in">exec</span></span>() val hostIp: String = networkInfo .getIpam .getConfig .get(0) .getGateway</code> </pre> <br> -,   <code>DockerClient</code> .  Testcontainers  <code>DockerClientFactory</code>  .  c  <code>inspectNetworkCmd</code> .   ,  info,  gateway. <br><br>      ,      ,   . <br><br>       ‚Äî    . Docker    : Windows, Mac,   .        Linux.     ,  ,     Linux      . <br><br>  ,    Testcontainers    .         ,      docker-.    : <br><br><pre> <code class="bash hljs">Testcontainers.exposeHostPorts(sparkJobServerMockPort)</code> </pre> <br> ,      <strong>  </strong> .        docker-.        <code>`host.testcontainers.internal`</code> . <br><br>  ,    : <br><br><pre> <code class="bash hljs">val sparkJobServerMockHost = <span class="hljs-string"><span class="hljs-string">"host.testcontainers.internal"</span></span> val sparkJobServerMockPort = 33333 Testcontainers.exposeHostPorts(sparkJobServerPort) AppContainer(sparkJobServerMockHost, sparkJobServerMockPort)</code> </pre> <br><br><h3>  Testcontainers </h3><br>    ,  ,     Testcontainers   ,      .   Java-,   Scala-.       : <br><br><ul><li>          . , testcontainers-java    JUnit,  testcontainers-scala   ScalaTest,   testcontainers-java       .  Scala-    . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> Scala </a> .      .    ,    .  ,   predefined         Java-.        ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  API</a> .        API,          . ,      .    ,       ,   . </li></ul><br><h2>  Zusammenfassung </h2><br>     . Docker ,      ,      ,     ,   network gateway. <br><br> Testcontainers ‚Äî   ,    . API   ,      . <br><br>     Java-,        .      ‚Äî     .     . <br><br>        ,    docker-,         . <br><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"> <strong><em>‚Äî       ,       , ,     . .?</em></strong> <br><br> ,    . <br><br> <strong><em>‚Äî   -     ?</em></strong> <br><br>     Kubernetes,     .      end-to-end ,    ,    ,   ,   . <br><br>      ,   ,       unit-,            . <br><br> <strong><em>‚Äî         Kubernetes    ?</em></strong> <br><br> -,  ,  -,   ,     ,        ,    Spark  Kubernetes   ;       ,       . <br><br> ,       ,      unit-,   , ,  break point  ,       ,    . <br><br> ,   ,  ,   CI  ,      . <br><br>  ,       minicube ‚Äî     Mac, .       ,      ,   ,   ,  . <br><br> <strong><em>‚Äî     ?       :  master? ,    - ,  ,   2.1,    2.2,   ?</em></strong> <br><br>    ImageName,   Postgres 9.6. <br><br><pre> <code class="bash hljs">val pgContainer: PostgreSQLContainer = PostgreSQLContainer(<span class="hljs-string"><span class="hljs-string">"postgres:9.6"</span></span>)</code> </pre> <br>    9.6,     10.    [ ],     . <br><br>      Image tag ‚Äî   , ‚Äî       ,        .    ,    latest   . <br><br> <strong><em>‚Äî ,           ?</em></strong> <br><br> ,  CI    ,  GitLab CI , ,  Branch Name. <br><br> <strong><em>‚Äî  ,      ,    ,   ?     - ,      ?    20-   ,   ?</em></strong> <br><br> -,       ,        .      ,      ,  ,  ,     ,  . <br><br> -      ,    ,    full-time ,   ,      ,  . <br><br>      commit',       , ,      ,    Android, iOS  . .    ,       ,  ,   , ‚Äî   . <br><br>     ,  ,      -: -  , - . , -    . <br></div></div><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√∂chten Sie mehr √ºber die Microservices selbst und nicht nur √ºber Scala </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfahren?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unser </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">ScalaConf-</font></a><font style="vertical-align: inherit;"> Programm </font><font style="vertical-align: inherit;">bietet Antworten auf verschiedene Fragen. </font><font style="vertical-align: inherit;">Mehr Interesse an Architektur und den Verbindungen der verschiedenen Teile - kommen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vom 7. </font><font style="vertical-align: inherit;">bis </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">8.</font></a><font style="vertical-align: inherit;"> November </font><font style="vertical-align: inherit;">zu </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">HighLoad ++</font></a><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles ist so lecker und es ist nicht klar, was man w√§hlen soll. Abonnieren Sie dann den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Newsletter,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in dem wir √ºber Berichte sprechen und n√ºtzliche Materialien zu diesem Thema sammeln.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464307/">https://habr.com/ru/post/de464307/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464293/index.html">Ersetzen Haken in React Redux?</a></li>
<li><a href="../de464295/index.html">Beispiele f√ºr die Verwendung einiger neuer JavaScript-Funktionen</a></li>
<li><a href="../de464299/index.html">0, 0, 1, 0, 2, 0, 2, 2, 1, 6, 0, 5, 0, 2, 6, 5, 4, 0, 5, 3, 0, 3, 2, 9, 0, 4, 9, 3, 6, 14, 0, 6, 3, 5, 15, 0, 5, 3, 5 ...</a></li>
<li><a href="../de464303/index.html">Zeitreihendaten in einem relationalen DBMS. Erweiterungen TimescaleDB und PipelineDB f√ºr PostgreSQL</a></li>
<li><a href="../de464305/index.html">Klein, ja. Unboxing des Firecracker mikrovirtuell</a></li>
<li><a href="../de464309/index.html">DIY Ruftaste. Raspberry Pi, MajorDoMo, Freeswitch und Linphonec</a></li>
<li><a href="../de464315/index.html">Der Film, in dem es Erde gab. Yandex-Forschung und eine kurze Geschichte der Suche nach Bedeutung</a></li>
<li><a href="../de464317/index.html">Konbanwa-Projekt</a></li>
<li><a href="../de464325/index.html">Wie Scrumban das Beste aus Kanban- und Scrum-Methoden vereint</a></li>
<li><a href="../de464327/index.html">Vergleich der Speichernutzung verschiedener Toolkit-GUIs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>