<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â›±ï¸ ğŸ™‰ ğŸ‘¨ğŸ»â€ğŸ”§ Cepat di bawah tenda: Implementasi umum ğŸ”“ ğŸ§œğŸ¾ ğŸ‘¨ğŸ½â€âœˆï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kode generik memungkinkan Anda untuk menulis fungsi dan tipe yang fleksibel dan dapat digunakan kembali yang dapat bekerja dengan jenis apa pun, tundu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cepat di bawah tenda: Implementasi umum</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451704/"><blockquote>  Kode generik memungkinkan Anda untuk menulis fungsi dan tipe yang fleksibel dan dapat digunakan kembali yang dapat bekerja dengan jenis apa pun, tunduk pada persyaratan yang Anda tetapkan.  Anda dapat menulis kode yang menghindari duplikasi dan mengekspresikan maksudnya dengan cara yang jelas dan abstrak.  - <strong>Dokumen cepat</strong> </blockquote><p> Setiap orang yang menulis di Swift menggunakan obat generik.  <code>Array</code> , <code>Dictionary</code> , <code>Set</code> - opsi paling dasar untuk menggunakan obat generik dari perpustakaan standar.  Bagaimana mereka diwakili di dalam?  Mari kita lihat bagaimana fitur dasar bahasa ini diimplementasikan oleh para insinyur Apple. </p><a name="habracut"></a><br><p>  Parameter generik dapat dibatasi oleh protokol atau tidak terbatas, meskipun, pada dasarnya, generik digunakan bersama dengan protokol yang menggambarkan apa yang sebenarnya dapat dilakukan dengan parameter metode atau bidang tipe. </p><br><p>  Untuk mengimplementasikan obat generik, Swift menggunakan dua pendekatan: </p><br><ol><li>  Runtime-way - kode generik adalah pembungkus (Boxing). </li><li>  Cara kompiletime - kode generik dikonversi ke jenis kode khusus untuk pengoptimalan (Spesialisasi). </li></ol><br><h2 id="boxing">  Tinju </h2><br><p>  Pertimbangkan metode sederhana dengan parameter generik protokol tidak terbatas: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: T)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> copy = value <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(copy) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> copy }</code> </pre> <br><p>  Kompilator cepat membuat satu blok kode tunggal yang akan dipanggil untuk bekerja dengan <code>&lt;T&gt;</code> .  Yaitu, terlepas dari apakah kita menulis <code>test(value: 1)</code> atau <code>test(value: "Hello")</code> , kode yang sama akan dipanggil dan informasi tambahan tentang tipe <code>&lt;T&gt;</code> berisi semua informasi yang diperlukan akan ditransfer ke metode . </p><br><p>  Sedikit yang dapat dilakukan dengan parameter protokol tidak terbatas tersebut, tetapi sudah menerapkan metode ini, Anda perlu tahu cara menyalin parameter, Anda perlu tahu ukurannya untuk mengalokasikan memori untuk itu dalam runtime, Anda perlu tahu cara menghancurkannya ketika parameter meninggalkan lapangan visibilitas.  <code>Value Witness Table</code> ( <code>VWT</code> ) digunakan untuk menyimpan informasi ini.  <code>VWT</code> dibuat pada tahap kompilasi untuk semua jenis dan kompiler menjamin bahwa dalam runtime akan ada tata letak objek.  Biarkan saya mengingatkan Anda bahwa struktur dalam Swift diberikan oleh nilai, dan kelas dengan referensi, jadi hal-hal yang berbeda akan dilakukan untuk <code>let copy = value</code> dengan <code>T == MyClass</code> dan <code>T == MyStruct</code> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ac/l5/dh/acl5dhtdca3tl80zbott4turszy.gif" alt="Tabel nilai saksi"></div><br><p>  Artinya, memanggil metode <code>test</code> dengan melewati struktur yang dideklarasikan di sana pada akhirnya akan terlihat seperti ini: </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,  metadata   let myStruct = MyStruct() test(value: myStruct, metadata: MyStruct.metadata)</span></span></code> </pre> <br><p>  Segalanya menjadi sedikit lebih rumit ketika <code>MyStruct</code> sendiri merupakan struktur generik dan mengambil bentuk <code>MyStruct&lt;T&gt;</code> .  Bergantung pada <code>&lt;T&gt;</code> di dalam <code>MyStruct</code> , metadata dan <code>VWT</code> akan berbeda untuk tipe <code>MyStruct&lt;Int&gt;</code> dan <code>MyStruct&lt;Bool&gt;</code> .  Ini adalah dua jenis berbeda dalam runtime.  Tetapi menciptakan metadata untuk setiap kombinasi yang mungkin dari <code>MyStruct</code> dan <code>T</code> sangat tidak efisien, jadi Swift sebaliknya, dan untuk kasus seperti itu membangun metadata dalam runtime saat dalam perjalanan.  Kompiler membuat satu pola metadata untuk struktur generik, yang dapat dikombinasikan dengan tipe tertentu dan, sebagai hasilnya, menerima informasi tipe lengkap dalam runtime dengan <code>VWT</code> benar. </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,  metadata   func test&lt;T&gt;(value: MyStruct&lt;T&gt;, tMetadata: T.Type) { //       let myStructMetadata = get_generic_metadata(MyStruct.metadataPattern, tMetadata) ... } let myStruct = MyStruct&lt;Int&gt;() test(value: myStruct) //   test(value: myStruct, tMetadata: Int.metadata) //     </span></span></code> </pre> <br><p>  Ketika kami menggabungkan informasi, kami mendapatkan metadata yang dapat kami kerjakan (menyalin, memindahkan, menghancurkan). </p><br><p>  Ini masih sedikit lebih rumit ketika pembatasan protokol ditambahkan ke obat generik.  Misalnya, kami membatasi <code>&lt;T&gt;</code> protokol yang <code>Equatable</code> .  Biarkan itu menjadi metode yang sangat sederhana yang membandingkan dua argumen yang disampaikan.  Hasilnya hanyalah pembungkus metode perbandingan. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-function">&lt;T: Equatable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: T, second: T)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first == second }</code> </pre> <br><p>  Agar program dapat bekerja dengan benar, Anda harus memiliki penunjuk ke metode perbandingan, <code>static func ==(lhs:T, rhs:T)</code> .  Bagaimana cara mendapatkannya?  Jelas, transmisi <code>VWT</code> tidak cukup, tidak mengandung informasi ini.  Untuk mengatasi masalah ini, ada <code>Protocol Witness Table</code> atau <code>PWT</code> .  <code>VWT</code> ini mirip dengan <code>VWT</code> dan dibuat pada tahap kompilasi untuk protokol dan menjelaskan protokol ini. </p><br><pre> <code class="swift hljs">isEquals(first: <span class="hljs-number"><span class="hljs-number">1</span></span>, second: <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   //     isEquals(first: 1, // 1 second: 2, metadata: Int.metadata, // 2 intIsEquatable: Equatable.witnessTable) // 3</span></span></code> </pre> <br><ol><li>  Dua argumen berlalu </li><li>  Pass metadata untuk <code>Int</code> sehingga Anda dapat menyalin / memindahkan / menghancurkan objek </li><li>  Kami meneruskan informasi yang mengimplementasikan <code>Int</code> <code>Equatable</code> . </li></ol><br><p>  Jika pembatasan memerlukan implementasi protokol lain, misalnya, <code>T: Equatable &amp; MyProtocol</code> , maka informasi tentang <code>MyProtocol</code> akan ditambahkan dengan parameter berikut: </p><br><pre> <code class="swift hljs">isEquals(..., intIsEquatable: <span class="hljs-type"><span class="hljs-type">Equatable</span></span>.witnessTable, intIsMyProtocol: <span class="hljs-type"><span class="hljs-type">MyProtocol</span></span>.witnessTable)</code> </pre> <br><p>  Menggunakan pembungkus untuk mengimplementasikan obat generik memungkinkan Anda untuk secara fleksibel menerapkan semua fitur yang diperlukan, tetapi memiliki overhead yang dapat dioptimalkan. </p><br><h2 id="specializaciya-dzhenerikov">  Spesialisasi generik </h2><br><p>  Untuk menghilangkan kebutuhan yang tidak perlu untuk mendapatkan informasi selama pelaksanaan program, apa yang disebut pendekatan spesialisasi generik digunakan.  Ini memungkinkan Anda untuk mengganti pembungkus generik dengan tipe tertentu dengan implementasi spesifik.  Misalnya, untuk dua panggilan ke <code>isEquals(first: 1, second: 2)</code> dan <code>isEquals(first: "Hello", second: "world")</code> , di samping implementasi "wrapper" utama, dua versi metode yang sama sekali berbeda untuk <code>Int</code> dan untuk <code>String</code> . </p><br><h3 id="ishodnyy-kod">  Kode sumber </h3><br><p>  Pertama, buat file <em>generic.swift</em> dan tulis fungsi generik kecil yang akan kita pertimbangkan. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-function">&lt;T: Equatable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: T, second: T)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first == second } isEquals(first: <span class="hljs-number"><span class="hljs-number">10</span></span>, second: <span class="hljs-number"><span class="hljs-number">11</span></span>)</code> </pre> <br><p>  Sekarang Anda perlu memahami apa yang akhirnya berubah menjadi kompiler. <br>  Ini dapat dilihat dengan jelas dengan mengkompilasi file <em>.swift</em> kami dalam <em>Bahasa Swift Intermediate</em> atau <code>SIL</code> . </p><br><h4 id="nemnogo-o-sil-i-processe-kompilyacii">  Sedikit tentang SIL dan proses kompilasi </h4><br><p>  <code>SIL</code> adalah hasil dari salah satu dari beberapa tahap kompilasi cepat. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-a/lw/p-/-alwp-gdushiyhqxgfch2iyppj8.gif" alt="Pipa penyusun"></div><br><p>  Kode sumber <em>.swift diteruskan ke Lexer, yang membuat pohon sintaksis abstrak ( <code>AST</code> ) dari bahasa tersebut, berdasarkan jenis pemeriksaan dan analisis semantik dari kode yang dilakukan.</em>  <em>SilGen mengonversi <code>AST</code> ke <code>SIL</code> , yang disebut <code>raw SIL</code> , berdasarkan kode yang dioptimalkan dan <code>canonical SIL</code> dioptimalkan diperoleh, yang diteruskan ke <code>IRGen</code> untuk dikonversi ke <code>IR</code> - format khusus yang dimengerti <code>LLVM</code> , yang akan dikonversi ke</em> <code>,     .             </code> .o yang <code>,     .             </code>  <code>,     .             </code> SIL`. </p><br><h3 id="i-snova-k-dzhenerikam">  Dan lagi ke obat generik </h3><br><p>  Buat file <code>SIL</code> dari kode sumber kami. </p><br><pre> <code class="plaintext hljs">swiftc generic.swift -O -emit-sil -o generic-sil.s</code> </pre> <br><p>  Kami mendapatkan file baru dengan ekstensi <code>*.s</code> .  Melihat ke dalam, kita akan melihat kode yang jauh lebih mudah dibaca daripada yang asli, tetapi masih relatif jelas. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wt/4g/0y/wt4g0yxc0ang-ityxpwxr9wrelg.png" alt="Sil mentah"></div><br><p>  Temukan baris dengan komentar <code>// isEquals&lt;A&gt;(first:second:)</code> .  Ini adalah awal dari deskripsi metode kami.  Itu berakhir dengan komentar <code>// end sil function '$s4main8isEquals5first6secondSbx_xtSQRzlF'</code> .  Nama Anda mungkin sedikit berbeda.  Mari kita menganalisis deskripsi metode sedikit. </p><br><ul><li>  <code>%0</code> dan <code>%1</code> pada baris 21 masing-masing adalah parameter <code>first</code> dan <code>second</code> </li><li>  Pada baris 24 kita mendapatkan informasi jenis dan meneruskannya ke <code>%4</code> </li><li>  Pada baris 25 kita mendapatkan pointer ke metode perbandingan dari informasi jenis </li><li>  on line 26 Kami memanggil metode dengan pointer, meneruskannya baik parameter dan ketik informasi </li><li>  Pada baris 27 kami memberikan hasilnya. </li></ul><br><p>  Akibatnya, kita melihat: untuk melakukan tindakan yang diperlukan dalam implementasi metode generik, kita perlu memperoleh informasi dari deskripsi tipe <code>&lt;T&gt;</code> selama eksekusi program. </p><br><p>  Kami melanjutkan langsung ke spesialisasi. </p><br><p>  Dalam file <code>SIL</code> dikompilasi, segera setelah deklarasi metode <code>isEquals</code> umum, deklarasi khusus untuk tipe <code>Int</code> berikut. </p><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ay/ts/j1/aytsj1ykoyhd0o38wpi1owignwo.png" alt="SIL khusus"></div><br><p>  Pada baris 39, alih-alih mendapatkan metode dalam runtime dari informasi jenis, metode untuk membandingkan bilangan bulat <code>"cmp_eq_Int64"</code> segera dipanggil. </p><br><p>  Agar metode untuk "mengkhususkan", <a href="">optimasi</a> harus <a href="">diaktifkan</a> .  Anda juga perlu tahu itu </p><br><blockquote>  Pengoptimal hanya dapat melakukan spesialisasi jika definisi deklarasi generik terlihat di Modul saat ini ( <a href="">Sumber</a> ) </blockquote><p>  Artinya, metode ini tidak dapat dikhususkan di antara berbagai modul Swift (misalnya, metode generik dari pustaka Cocoapods).  Pengecualian adalah pustaka Swift standar, di mana tipe dasar seperti <code>Array</code> , <code>Set</code> and <code>Dictionary</code> .  Semua obat generik dari pangkalan perpustakaan berspesialisasi dalam tipe tertentu. </p><br><p>  <strong>Catatan:</strong> Atribut <code>@inlinable</code> dan <code>@usableFromInline</code> diimplementasikan di Swift 4.2, yang memungkinkan pengoptimal untuk melihat <code>@usableFromInline</code> metode dari modul lain dan sepertinya ada peluang untuk mengkhususkannya, tetapi perilaku ini tidak diuji oleh saya ( <a href="">Sumber</a> ) </p><br><h3 id="ssylki">  Referensi </h3><br><ol><li>  <a href="">Deskripsi obat generik</a> </li><li>  <a href="">Optimasi dalam Swift</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Presentasi yang lebih rinci dan mendalam tentang topik tersebut.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel bahasa inggris</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451704/">https://habr.com/ru/post/id451704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451682/index.html">"Awal" yang cukup fantastis dari Euclid di TeX</a></li>
<li><a href="../id451690/index.html">Membaca untuk burung hantu</a></li>
<li><a href="../id451694/index.html">Bayar Perhatian # 4: Intisari Artikel tentang Pemikiran Produk, Psikologi Perilaku dan Produktivitas</a></li>
<li><a href="../id451696/index.html">Kami mengambil bagian dalam Kontes Telegram baru-baru ini, menulis aplikasi OpenGL ES yang keren dan tidak memenangkan apa pun</a></li>
<li><a href="../id451702/index.html">Bagaimana saya dan Stas mengotomatisasi pabrik dalam 2 bulan</a></li>
<li><a href="../id451708/index.html">Cara mempersiapkan cek ILV pada data pribadi: panduan lengkap</a></li>
<li><a href="../id451710/index.html">Internet untuk penduduk musim panas. Kami mendapatkan kecepatan maksimum di jaringan 4G. Bagian 2. Memilih antena eksternal</a></li>
<li><a href="../id451716/index.html">Meningkatkan kinerja perangkat lunak dengan alat Intel untuk pengembang. Pemodelan numerik objek astrofisika</a></li>
<li><a href="../id451718/index.html">Buat Asisten Suara</a></li>
<li><a href="../id451720/index.html">FIAS memuat ke dalam database di MSSQLSERVER dengan cara improvisasi (SQLXMLBULKLOAD). Bagaimana itu (mungkin) tidak perlu dilakukan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>