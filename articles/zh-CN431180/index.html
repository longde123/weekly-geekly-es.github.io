<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏾 🍇 🛸 服务器上的Ext JS 🎠 🆒 🌿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="当涉及到Ext JS库时，专家们听到了很多消极的东西：笨重，昂贵，越野车。 通常，大多数问题与无法烹饪有关。 使用Sencha Cmd和所有css正确组装的项目，图像在1Mb区域中的生产权重，与同一个Angular相当。 是的，而且故障不多... 

 Sencha的想法很不同，但是即使是有原则的反...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>服务器上的Ext JS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431180/"><img src="https://habrastorage.org/webt/wl/0h/yu/wl0hyunbvr2q-wqwydwamsfk804.png" width="250" align="left" alt="照片从这里https://github.com/tj/palette"> 当涉及到Ext JS库时，专家们听到了很多消极的东西：笨重，昂贵，越野车。 通常，大多数问题与无法烹饪有关。 使用Sencha Cmd和所有css正确组装的项目，图像在1Mb区域中的生产权重，与同一个Angular相当。 是的，而且故障不多... <br><br>  Sencha的想法很不同，但是即使是有原则的反对者也承认，很难找到构建严肃的Intranet项目的最佳解决方案。 <br><br> 我认为，Ext JS中最有价值的东西不是UI组件的集合，而是一个好的OOP体系结构。 即使考虑到近年来JS的快速发展，本机类中仍缺少7年前在Ext JS中实现的许多必需的东西（命名空间，mixins，静态属性，方便的父方法调用）。 这就是几年前促使我尝试在后端启动Ext JS类的原因。 关于最初的类似实验，我已经在Habré上发表过文章。 本文介绍了旧思想的新实现和许多新思想。 <br><br> 在开始之前，请注意以下问题：您认为如何，它在哪里执行，下面的代码段是做什么的？ <br><br><pre><code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Module.message.model.Message'</span></span>, { .... <span class="hljs-comment"><span class="hljs-comment">/* scope:server */</span></span> ,<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> newMessage() { ......... this.fireEvent(<span class="hljs-string"><span class="hljs-string">'newmessage'</span></span>, data); ...... } ... })</code> </pre> <a name="habracut"></a><br> 此代码在服务器上执行，并在连接到服务器的所有客户端计算机上的“ Module.message.model.Message”类的所有实例中导致“ newmessage”事件。 <br><br> 为了说明使用服务器端Ext JS的可能性，我们将分析一个简单的聊天项目。 仅当您输入用户输入昵称时，我们才会进行任何登录。 您可以发布常规或私人消息。 聊天应该实时进行。 那些希望的人可以立即尝试所有这种经济活动。 <br><br><h2> 安装方式 </h2><br> 首先，我们需要nodejs 9+和redis-server（假定它们已经安装）。 <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/Kolbaskin/extjs-backend-example <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> extjs-backend-example npm i</code> </pre><br> 我们启动服务器： <br><br><pre> <code class="bash hljs">node server</code> </pre><br> 在浏览器中，打开<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">localhost</a>页面：3000 / www / auth / <br> 输入一些昵称，然后按Enter。 <br><br> 该项目是一个演示，因此不支持旧的浏览器（有ES8设计），请使用新的Chrome或FF。 <br><br><h2> 伺服器 </h2><br> 让我们去吧。 <br><br> 服务器代码（server.js） <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   http-  express //   Ext JS     express const express = require('express'); const staticSrv = require('extjs-express-static'); const app = express(); const bodyParser = require('body-parser'); //    global = { config: require('config') } //     Ext JS require('extjs-on-backend')({ //     express app, //         wsClient: 'Base.wsClient' }); //    Ext.Loader.setPath('Api', 'protected/rest'); Ext.Loader.setPath('Base', 'protected/base'); Ext.Loader.setPath('Www', 'protected/www'); //   http   app.use( bodyParser.json() ); app.use(bodyParser.urlencoded({ extended: true })); //     Ext JS  app.use('/api/auth', Ext.create('Api.auth.Main')); app.use('/www/auth', Ext.create('Www.login.controller.Login')); //    app.use(staticSrv(__dirname + '/static')); //   const server = app.listen(3000, () =&gt; { console.log('server is running at %s', server.address().port); });</span></span></code> </pre><br> 如您所见，这里的所有内容或多或少都是服务器上的标准。 有趣的是包含Ext JS类以服务相应的路由： <br><br><pre> <code class="javascript hljs">app.use(<span class="hljs-string"><span class="hljs-string">'/api/auth'</span></span>, Ext.create(<span class="hljs-string"><span class="hljs-string">'Api.auth.Main'</span></span>)); app.use(<span class="hljs-string"><span class="hljs-string">'/www/auth'</span></span>, Ext.create(<span class="hljs-string"><span class="hljs-string">'Www.login.controller.Login'</span></span>));</code> </pre><br><h3>  REST API实施 </h3><br>  Api.auth.Main类将请求提供给REST API（受保护的/ rest / auth / Main.js）。 <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Api.auth.Main'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Api.Base'</span></span>, <span class="hljs-comment"><span class="hljs-comment">//   //     routes: [ { path: '/', get: 'login'}, { path: '/restore', post: 'restoreLogin' }, { path: '/registration', post: 'newuser'}, { path: '/users', get: 'allUsers'} ] //     : // {query: &lt;...&gt;, params: &lt;...&gt;, body: &lt;...&gt;} ,async login(data) { return {data:[{ id:1, subject: 111, sender:222, }]} } ,async restoreLogin() { ... } ,async newuser() { ... } ,async allUsers() { .... } })</span></span></code> </pre><br><h3> 使用服务器上的XTemplate生成HTML页面 </h3><br> 第二类是Www.login.controller.Login，它使用登录表单（受保护的/www/login/controller/Login.js）构建一个常规的html页面。 <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Www.login.controller.Login'</span></span>, { <span class="hljs-comment"><span class="hljs-comment">//      "" : // ,    .. extend: 'Www.Base' //    //   ,   .. ,baseTpl: 'view/inner' //     // ,   ,loginFormTpl: 'login/view/login' //  ,routes: [ { path: '/', get: 'loginForm', post: 'doLogin'} ] //  html   //       ,async loginForm () { return await this.tpl(this.loginFormTpl, { pageTitle: 'Login page', date: new Date() }); } ,async doLogin (params, res) { if(params.body.name &amp;&amp; /^[a-z0-9]{2,10}$/i.test(params.body.name)) { this.redirect(`/index.html?name=${params.body.name}`, res); return; } return await this.tpl(this.loginFormTpl, { pageTitle: 'Login page', date: new Date() }); } })</span></span></code> </pre><br> 模板使用标准的XTemplate（受保护的/www/login/view/login.tpl） <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag">&gt;</span></span>{pageTitle} (date: {[Ext.Date.format(values.date,'dmY')]})<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">method</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"post"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">placeholder</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"submit"</span></span></span><span class="hljs-tag">&gt;</span></span>enter<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br> 一丝不苟的读者会说，上述所有内容都是一个完全标准的集合，因此，无需通过将Ext JS传输到服务器来围堵这个花园。 因此，我们继续进行本文的第二部分，它将显示其全部意图。 <br><br><h2> 顾客 </h2><br> 让我们在静态目录中创建普通的客户端Ext JS应用程序。 在此示例中，我故意不考虑使用cmd，而是采用了已经构建的ext-all和standard主题。 大会问题是一个单独的主题，也许会另辟一个职位。 <br><br> 一切都始于app.js <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   Ext.Loader.setConfig({ enabled: true, paths: { "Core": "app/core", "Admin": "app/admin", "Module": "app/admin/modules", "Ext.ux": "ext/ux" } }); //    this.token = Ext.data.identifier.Uuid.createRandom()(); //      //    () //    (   ) Ext.WS = Ext.create('Core.WSocket', { token: this.token, user: new URLSearchParams(document.location.search).get("name") }); //   Ext.application({ name: 'Example', extend: 'Ext.app.Application', requires: ['Admin.*'], autoCreateViewport: 'Admin.view.Viewport' })</span></span></code> </pre><br>  Web套接字的存在是至关重要的一点，正是它可以让您实现下面描述的所有魔术。 <br><br> 页面上元素的布局包含在Admin.view.Viewport类中（静态/app/view/Viewport.js）。 那里没什么有趣的。 <br><br> 主要功能元素（用户列表，消息栏和发送表单）被实现为单独的模块。 <br><br><h3> 用户清单 </h3><br> 该列表的简单算法如下：打开页面时，当前用户已从服务器加载。 当新用户连接时，服务器在“ Module.users.model.UserModel”类中生成一个“ add”事件，当断开连接时，在同一类中，将引发“ remove”事件。 事实是该事件是在服务器端触发的，您可以在客户端上对其进行跟踪。 <br><br> 现在，首先是第一件事。 在客户端，存储杂项数据（静态/应用程序/模块/用户/商店/UsersStore.js） <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Module.users.store.UsersStore'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.data.Store'</span></span> ,<span class="hljs-attr"><span class="hljs-attr">autoLoad</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> ,<span class="hljs-attr"><span class="hljs-attr">total</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> ,<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-comment"><span class="hljs-comment">//         this.dataModel = Ext.create('Module.users.model.UserModel'); //      this.dataModel.on({ add: (records) =&gt; { this.onDataAdd(records) }, remove: (records) =&gt; { this.onDataRemove(records) } }) this.callParent(arguments) } //   load ,async load() { //      const data = await this.dataModel.$read(); //   this.total = data.total; //    UI this.loadData(data.data); } ,getTotalCount() { return this.total; } //          ,onDataAdd(records) { this.add(records[0]); } //   --  ,onDataRemove(records) { this.remove(this.getById (records[0].id)) } });</span></span></code> </pre><br> 有两个有趣的观点。 首先，在“ const data = await this.dataModel。$ Read（）;”行中 该模型的服务器方法被调用。 现在，您无需使用Ajax，支持协议等，只需将服务器方法称为本地方法即可。 同时，安全性也没有牺牲（更多内容见下文）。 <br><br> 其次，this.dataModel.on（...）的标准构造使您可以跟踪服务器将生成的事件。 <br><br> 该模型是应用程序的客户端和服务器部分之间的桥梁。 就像光的二元论一样-它实现了前端和后端的属性。 让我们仔细看一下模型。 <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Module.users.model.UserModel'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Core.data.DataModel'</span></span> <span class="hljs-comment"><span class="hljs-comment">/* scope:client */</span></span> ,testClientMethod() { ... } ,testGlobalMethod() { ... } <span class="hljs-comment"><span class="hljs-comment">/* scope:server */</span></span> ,privateServerMethod() { .... } <span class="hljs-comment"><span class="hljs-comment">/* scope:server */</span></span> ,<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> $read(params) { <span class="hljs-comment"><span class="hljs-comment">//      redis const keys = await this.getMemKeys('client:*'); let data = [], name; for(let i = 0;i&lt;keys.length;i++) { //         name = await this.getMemKey(keys[i]); if(name) { data.push({ id: keys[i].substr(7), name }) } } //    return { total: data.length, data } } })</span></span></code> </pre><br> 请注意以下注释：/ *作用域：服务器* /和/ *作用域：客户端* /-这些构造是服务器的标签，通过它确定方法的类型。 <br><br>  testClientMethod-此方法专门在客户端上运行，并且仅在客户端可用。 <br>  testGlobalMethod-此方法在客户端和服务器上运行，并且可以在客户端和服务器端使用。 <br>  privateServerMethod-该方法在服务器上执行，仅可用于在服务器上调用。 <br>  $ read是仅在服务器端运行的最有趣的方法类型，但是您可以在客户端和服务器上调用它。  $前缀使客户端可以使用任何服务器端方法。 <br><br> 您可以使用Web套接字跟踪客户端连接和断开连接。 为每个用户连接创建一个Base.wsClient类的实例（protected / base / wsClient.js） <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Base.wsClient'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Core.WsClient'</span></span> <span class="hljs-comment"><span class="hljs-comment">//      ,usersModel: Ext.create('Module.users.model.UserModel') //       ,async onStart() { //   "add"    this.usersModel.fireEvent('add', 'all', [{id: this.token, name: this.req.query.user}]); //     redis await this.setMemKey(`client:${this.token}`, this.req.query.user || ''); //   ""      , //     await this.queueProcess(`client:${this.token}`, async (data, done) =&gt; { const res = await this.prepareClientEvents(data); done(res); }) } //      ,onClose() { //   "remove"    this.usersModel.fireEvent('remove', 'all', [{id: this.token, name: this.req.query.user}]) this.callParent(arguments); } })</span></span></code> </pre><br> 与标准方法不同，fireEvent方法具有一个附加参数，在该参数上传递事件应在哪个客户端上触发。 传递单个客户端标识符，标识符数组或字符串“ all”是可以接受的。 在后一种情况下，事件将在所有连接的客户端上触发。 否则，这是标准的fireEvent。 <br><br><h3> 发送和接收消息 </h3><br> 表单控制器（静态/app/admin/modules/messages/view/FormController.js）负责发送消息。 <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Module.messages.view.FormController'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.app.ViewController'</span></span> ,init(view) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.view = view; <span class="hljs-comment"><span class="hljs-comment">//     this.model = Ext.create('Module.messages.model.Model'); //      this.msgEl = this.view.down('[name=message]'); //     this.usersGrid = Ext.getCmp('users-grid') //    "" this.control({ '[action=submit]' : {click: () =&gt; {this.newMessage() }} }) } //     ,newMessage() { let users = []; //     const sel = this.usersGrid.getSelection(); if(sel &amp;&amp; sel.length) { sel.forEach((s) =&gt; { users.push(s.data.id) }) } //        if(users.length &amp;&amp; users.indexOf(Ext.WS.token) == -1) users.push(Ext.WS.token); //       this.model.$newmessage({ to: users, user: Ext.WS.user, message: this.msgEl.getValue() }) //    this.msgEl.setValue(''); } });</span></span></code> </pre><br> 该消息未保存在服务器上的任何位置，只需触发“ newmessage”事件。 有趣的是调用“ this.fireEvent（'newmessage'，data.to，msg）;”，其中客户端标识符作为消息接收者传递。 因此，实现了私人消息的分发（静态/ app / admin /模块/消息/模型/Model.js）。 <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Module.messages.model.Model'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Core.data.DataModel'</span></span> <span class="hljs-comment"><span class="hljs-comment">/* scope:server */</span></span> ,<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> $newmessage(data) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> msg = { <span class="hljs-attr"><span class="hljs-attr">user</span></span>: data.user, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: data.message } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(data.to &amp;&amp; Ext.isArray(data.to) &amp;&amp; data.to.length) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fireEvent(<span class="hljs-string"><span class="hljs-string">'newmessage'</span></span>, data.to, msg); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fireEvent(<span class="hljs-string"><span class="hljs-string">'newmessage'</span></span>, <span class="hljs-string"><span class="hljs-string">'all'</span></span>, msg); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } })</code> </pre><br> 与用户一样，消息列表的数据由商店驱动（静态/ app / admin /模块/消息/商店/MessagesStore.js） <br><br><pre> <code class="javascript hljs">Ext.define(<span class="hljs-string"><span class="hljs-string">'Module.messages.store.MessagesStore'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-string"><span class="hljs-string">'Ext.data.Store'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: [<span class="hljs-string"><span class="hljs-string">'user'</span></span>, <span class="hljs-string"><span class="hljs-string">'message'</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-comment"><span class="hljs-comment">//       Ext.create('Module.messages.model.Model', { listeners: { newmessage: (mess) =&gt; { this.add(mess) } } }) this.callParent(arguments); } });</span></span></code> </pre><br> 通常，在此示例中，这就是所有有趣的事情。 <br><br><h2> 可能的问题 </h2><br>  <b>客户端上服务器方法的可用性当然很好，但是安全性又如何呢？</b>  <b>事实证明，邪恶的黑客可以看到服务器代码并尝试破解后端？</b> <br><br> 不，他不会成功。 首先，所有服务器方法在发送到客户端浏览器时都将从类代码中删除。 为此，打算使用注释/指令/ *作用域：... * /。 其次，最公共的服务器端方法的代码被中间结构替代，该中间结构在客户端实现了远程调用机制。 <br><br>  <b>再次谈到安全性。</b>  <b>事实证明，如果可以在客户端上调用服务器方法，我可以调用任何此类方法吗？</b>  <b>如果这是数据库清理方法？</b> <br><br> 从客户端，您只能调用名称中带有$前缀的方法。 对于这种方法，您自己确定检查和访问的逻辑。 如果没有$，外部用户将无法访问服务器方法，他甚至都不会看到它们（请参阅前面的答案） <br><br>  <b>看起来您拥有一个完整的系统，其中客户端和服务器之间有着千丝万缕的联系。</b>  <b>水平缩放是否可能？</b> <br><br> 实际上，该系统看起来是整体的，但事实并非如此。 客户端和服务器可以“驻留”在不同的计算机上。 客户端可以在任何第三方Web服务器（Nginx，Apache等）上运行。 自动项目构建器很容易解决客户端与服务器分离的问题（我可以为此撰写单独的文章）。 为了实现内部服务消息传递机制，系统使用队列（即，为此需要Redis）。 因此，只需添加新机器即可轻松地水平扩展服务器部分。 <br><br>  <b>通常，使用通常的开发方法，后端提供了一组API，您可以将它们与各种客户端应用程序（网站，移动应用程序）连接。</b>  <b>在您的情况下，事实证明只有用Ext JS编写的客户端可以与后端一起使用吗？</b> <br><br> 在服务器上，尤其是在模块模型中，实现了某种业务逻辑。 为了通过REST API提供对它的访问，一个小的“包装器”就足够了。 本文的第一部分提供了一个相应的示例。 <br><br><h2> 结论 </h2><br> 如您所见，为了对相当复杂的应用程序进行舒适的编码，很可能在前端和后端使用一个库。 这具有明显的好处。 <br><br>  <b>加快开发过程。</b> 每个团队成员都可以在后端和前端工作。 由于“我正在等待此API出现在服务器上”原因而导致的停机时间不再相关。 <br><br>  <b>更少的代码。</b> 可以在客户端和服务器上使用相同的代码部分（检查，验证等）。 <br><br>  <b>维护这样的系统更加简单和便宜。</b> 该系统将能够支持一个（或两个相同但可互换），而不是两个不同的程序员。 出于同样的原因，与团队更替相关的风险也较低。 <br><br>  <b>从包装盒中创建实时系统的能力。</b> <br><br>  <b>对后端和前端使用单个测试系统。</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN431180/">https://habr.com/ru/post/zh-CN431180/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN431170/index.html">来自中国的科学家宣布了转基因儿童的出生</a></li>
<li><a href="../zh-CN431172/index.html">我们对暴雪有什么期望？ 《暗黑破坏神》系列的过去，现在和未来</a></li>
<li><a href="../zh-CN431174/index.html">模拟理论：量子化学计算与现实的关系</a></li>
<li><a href="../zh-CN431176/index.html">微服务，API和创新：API的力量</a></li>
<li><a href="../zh-CN431178/index.html">英文寄生虫词</a></li>
<li><a href="../zh-CN431184/index.html">使用Mesh Connex技术的WIFI多跳网状网络</a></li>
<li><a href="../zh-CN431186/index.html">按类型设计：如何使无效状态在C＃中无法表达</a></li>
<li><a href="../zh-CN431188/index.html">在俄罗斯阻止互联网的技术方面。 挑战与前景</a></li>
<li><a href="../zh-CN431190/index.html">如何在不与SEO达成协议的情况下评估SEO公司的水平</a></li>
<li><a href="../zh-CN431192/index.html">AWC推出Firecracker-Linux的微虚拟化</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>