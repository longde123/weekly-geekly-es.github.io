<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüéì ‚ôøÔ∏è üë©üèø‚Äçü§ù‚Äçüë©üèæ Elixir comme objectif de d√©veloppement pour Python async üî∑ üå¥ üéÖüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans le livre ¬´Python. Aux sommets de l'excellence ¬ªLuciano Ramallo d√©crit une histoire. En 2000, Luciano a suivi des cours, et une fois Guido van Ros...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elixir comme objectif de d√©veloppement pour Python async</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/476112/">  Dans le livre ¬´Python.  Aux sommets de l'excellence ¬ªLuciano Ramallo d√©crit une histoire.  En 2000, Luciano a suivi des cours, et une fois Guido van Rossum a regard√© le public.  Une fois qu'un tel √©v√©nement s'est produit, tout le monde a commenc√© √† lui poser des questions.  Lorsqu'on lui a demand√© quelles fonctions Python avait emprunt√©es √† d'autres langues, Guido a r√©pondu: "Tout ce qui est bon en Python est vol√© √† d'autres langues." <br><br>  √áa l'est vraiment.  Python a longtemps v√©cu dans le contexte d'autres langages de programmation et absorbe les concepts de son environnement: asyncio est emprunt√©, gr√¢ce √† l'apparition d'expressions lambda Lisp, et Tornado a √©t√© copi√© depuis libevent.  Mais si quelqu'un doit emprunter des id√©es, c'est celui d'Erlang.  Il a √©t√© cr√©√© il y a 30 ans, et tous les concepts en Python qui sont actuellement en cours d'impl√©mentation ou qui viennent d'√™tre d√©crits fonctionnent depuis longtemps √† Erlang: multic≈ìur, messages comme base de communication, appels de m√©thode et introspection √† l'int√©rieur d'un syst√®me de production en direct.  Ces id√©es, sous une forme ou une autre, trouvent leur expression dans des syst√®mes comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Seastar.io</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fb/0x/mf/fb0xmfg8afpsrhs7js423v4bvjy.jpeg" width="500"></div><br>  Si vous ne tenez pas compte de la Data Science, dans laquelle Python est d√©sormais hors comp√©tition, alors tout le reste est d√©j√† impl√©ment√© dans Erlang: travailler avec un r√©seau, g√©rer les sockets HTTP et Web, travailler avec les bases de donn√©es.  Par cons√©quent, il est important pour les d√©veloppeurs Python de comprendre o√π le langage se d√©placera: le long d'une route qui a d√©j√† pass√© il y a 30 ans. <br><br>  Pour comprendre l'histoire du d√©veloppement d'autres langues et comprendre o√π les progr√®s progressent, nous avons invit√© <strong>Maxim Lapshin</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">erlyvideo</a> ), l'auteur du projet Erlyvideo.ru, √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moscou Python Conf ++</a> . <br><br>  Sous la coupe se trouve la version texte de ce rapport, √† savoir: dans quelle direction le syst√®me est oblig√© de se d√©velopper, qui continue de migrer du simple code lin√©aire vers libevent et au-del√†, ce qui est courant et quelles sont les diff√©rences entre Elixir et Python.  Nous porterons une attention particuli√®re √† la fa√ßon de g√©rer les sockets, les threads et les donn√©es dans diff√©rents langages de programmation et plates-formes. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RAZ0sHpPrZE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Erlyvideo.ru dispose d'un syst√®me de vid√©osurveillance dans lequel le contr√¥le d'acc√®s pour les cam√©ras est √©crit en Python.  Il s'agit d'une t√¢che classique pour cette langue.  Il y a des utilisateurs et des cam√©ras, des vid√©os dont ils peuvent regarder: quelqu'un voit des cam√©ras, tandis que d'autres voient un site normal. <br><br>  Python a √©t√© choisi car il est pratique d'y √©crire un tel service: il y a des frameworks, des ORM, des programmeurs, apr√®s tout.  Le logiciel d√©velopp√© est emball√© et vendu aux utilisateurs.  Erlyvideo.ru est une entreprise qui vend des logiciels et non seulement fournit des services. <br><br>  Quels probl√®mes avec Python je veux r√©soudre. <br><br>  <strong>Pourquoi y a-t-il de tels probl√®mes avec le multic≈ìur?</strong>  Nous avons lanc√© Flussonic sur les ordinateurs des stades avant m√™me qu'Intel ne le fasse.  Mais Python a des difficult√©s avec cela: pourquoi n'utilise-t-il toujours pas les 80 c≈ìurs de nos serveurs pour fonctionner? <br><br>  <strong>Comment ne pas souffrir de prises ouvertes?</strong>  La surveillance du nombre de sockets ouvertes est un gros probl√®me.  Quand il atteint la limite, fermez et √©vitez √©galement les fuites. <br><br>  <strong>Les variables globales oubli√©es ont-elles une solution?</strong>  Les fuites de variables globales sont un enfer pour tout langage de r√©cup√©ration de place comme Java ou C #. <br><br>  <strong>Comment utiliser le fer sans gaspiller les ressources?</strong>  Comment s'en sortir sans ex√©cuter 40 employ√©s Jung et 64 Go de RAM si nous voulons utiliser les serveurs efficacement et ne pas jeter des centaines de milliers de dollars par mois sur du mat√©riel inutile? <br><br><h3>  Pourquoi le multic≈ìur est n√©cessaire </h3><br>  <strong>Pour que tous les c≈ìurs soient pleinement utilis√©s, il faut</strong> beaucoup plus de travailleurs que de c≈ìurs.  Par exemple, pour 40 c≈ìurs de processeur, 100 travailleurs sont n√©cessaires: un travailleur est all√© √† la base de donn√©es, l'autre est occup√© par autre chose. <br><br>  <strong>Un travailleur peut consommer de 300 √† 400 Mo.</strong>  Nous √©crivons toujours cela en Python, et non en Ruby on Rails, qui peut consommer plusieurs fois plus et 40 Go de RAM seront facilement et facilement gaspill√©s.  Ce n'est pas tr√®s cher, mais pourquoi acheter de la m√©moire l√† o√π on ne peut pas l'acheter. <br><br>  <strong>Le multic≈ìur aide √† fouiller les donn√©es partag√©es et √† r√©duire la consommation de m√©moire</strong> , et √† ex√©cuter de mani√®re pratique et s√ªre de nombreux processus ind√©pendants.  Il est beaucoup plus facile √† programmer, mais plus cher √† partir de la m√©moire. <br><br><h3>  Gestion des sockets </h3><br>  Sur le socket Web, nous interrogeons les donn√©es d'ex√©cution des cam√©ras depuis le backend.  Le logiciel Python se connecte √† Flussonic et interroge les donn√©es d'√©tat des cam√©ras: qu'elles fonctionnent ou non, y a-t-il de nouveaux √©v√©nements? <br><br>  D'un autre c√¥t√©, le client se connecte et, via le socket Web, nous envoyons ces donn√©es au navigateur.  Nous voulons transf√©rer les donn√©es des clients en temps r√©el: la cam√©ra s'allume et s'√©teint, le chat mange, dort, d√©chire un canap√©, appuie sur le bouton et √©loigne le chat. <br><br>  Mais, par exemple, une sorte de probl√®me s'est produit: la base de donn√©es n'a pas r√©pondu √† la demande, tout le code est tomb√©, il y avait deux sockets ouvertes.  Nous avons commenc√© √† recharger, fait quelque chose, encore une fois ce probl√®me - il y avait deux sockets.  L'erreur de base de donn√©es a √©t√© trait√©e de mani√®re incorrecte et deux connexions ouvertes ont √©t√© bloqu√©es.  Au fil du temps, cela conduit √† des fuites de socket. <br><br><h3>  Variables globales oubli√©es </h3><br>  Faire un dict global pour la liste des navigateurs connect√©s via la prise Web.  Une personne se connecte au site, nous lui ouvrons une prise web.  Ensuite, nous mettons le socket Web avec son identifiant dans une sorte de dict global, et il s'av√®re qu'une sorte d'erreur se produit. <br><br>  Par exemple, ils ont enregistr√© un lien de connexion dans dict pour envoyer des donn√©es.  <strong>Une exception a fonctionn√©, oubli√© de supprimer le lien et les donn√©es ont √©t√© bloqu√©es</strong> .  Donc apr√®s un certain temps, 64 Go commencent √† manquer et je veux doubler la m√©moire du serveur.  Ce n'est pas une solution, car les donn√©es fuiront de toute fa√ßon. <br><blockquote>  Nous faisons toujours des erreurs - nous sommes des personnes et nous ne pouvons pas tout suivre. </blockquote>  La question est que certaines erreurs se produisent, m√™me celles que nous ne nous attendions pas √† voir. <br><br><h2>  Excursion historique </h2><br>  Pour aborder le sujet principal, approfondissons l'histoire.  Tout ce dont nous parlons maintenant de Python, Go et Erlang, d'autres personnes ont fait tout ce chemin il y a environ 30 ans.  En Python, nous allons loin et comblons les bosses qui se sont d√©j√† produites il y a des d√©cennies.  Le chemin se r√©p√®te de mani√®re √©tonnante. <br><br><h3>  Dos </h3><br>  D'abord, passons au DOS, c'est le plus proche.  Avant lui, il y avait des choses compl√®tement diff√©rentes et tout le monde n'est pas vivant qui se souvient des ordinateurs avant DOS. <br><br>  <strong>Le programme DOS occupait l'ordinateur (presque) exclusivement</strong> .  Pendant qu'un jeu, par exemple, est en cours d'ex√©cution, rien d'autre n'est ex√©cut√©.  Vous n'allez pas sur Internet - il n'y est pas encore, et vous n'irez nulle part.  C'√©tait triste, mais les souvenirs en sont chaleureux, car il est associ√© √† la jeunesse. <br><br><h3>  Multit√¢che coop√©ratif </h3><br>  Comme c'√©tait vraiment douloureux avec DOS, de nouveaux d√©fis sont apparus, les ordinateurs sont devenus plus puissants.  <strong>Il y a des d√©cennies, ils ont d√©velopp√© le concept de multit√¢che coop√©ratif</strong> , m√™me avant Windows 3.11. <br><br>  <strong>Les donn√©es sont s√©par√©es par des processus, et chaque processus est effectu√© s√©par√©ment:</strong> ils sont en quelque sorte prot√©g√©s les uns des autres.  Un mauvais code dans un processus ne pourra pas g√¢cher le code dans le navigateur (alors les premiers navigateurs sont d√©j√† apparus). <br><br>  La question suivante est: comment le temps de calcul sera-t-il r√©parti entre les diff√©rents processus?  Ensuite, ce n'√©tait pas qu'il n'y avait pas plus d'un c≈ìur, un syst√®me √† double processeur √©tait une raret√©.  Le sch√©ma √©tait le suivant: alors qu'un processus est all√©, par exemple, sur un disque pour les donn√©es, le deuxi√®me processus re√ßoit le contr√¥le du syst√®me d'exploitation.  Le premier pourra prendre le contr√¥le lorsque le second lui-m√™me donnera volontairement.  Je simplifie grandement la situation, mais le <strong>processus a en quelque sorte volontairement permis de le retirer du processeur</strong> . <br><br><h3>  Multit√¢che pr√©emptif </h3><br>  Le multit√¢che coop√©ratif a conduit au probl√®me suivant: le processus pourrait simplement se bloquer car il est mal √©crit.  <strong>Si le processeur prend beaucoup de temps √† traiter, il bloque le reste</strong> .  Dans ce cas, l'ordinateur est tomb√© en panne et rien ne pouvait √™tre fait avec, par exemple, la commutation de la fen√™tre. <br><br>  En r√©ponse √† ce probl√®me, le multit√¢che pr√©emptif a √©t√© invent√©.  Le syst√®me d'exploitation lui-m√™me g√®re d√©sormais strictement: supprime les processus de l'ex√©cution, s√©pare compl√®tement leurs donn√©es, prot√®ge la m√©moire des processus les uns des autres et donne √† chacun un certain temps de calcul.  <strong>Le syst√®me d'exploitation alloue les m√™mes intervalles de temps √† chaque processus</strong> . <br><br>  La question du d√©calage horaire est toujours ouverte.  Aujourd'hui, les d√©veloppeurs de syst√®mes d'exploitation trouvent toujours ce qui est juste, dans quel ordre, √† qui et combien de temps √† consacrer √† la gestion.  Aujourd'hui, nous voyons le d√©veloppement de ces id√©es. <br><br><h3>  Streams </h3><br>  Mais cela ne suffisait pas.  Les processus doivent √©changer des donn√©es: via le r√©seau, cela co√ªte cher, mais reste en quelque sorte compliqu√©.  Par cons√©quent, le <strong>concept de flux a</strong> √©t√© invent√©. <br><blockquote>  Les threads sont des processus l√©gers qui partagent une m√©moire commune. <br></blockquote>  Les flux ont √©t√© cr√©√©s dans l'espoir que tout sera facile, simple et amusant.  D√©sormais, la <strong>programmation multi-thread est consid√©r√©e comme anti-mod√®le</strong> .  Si la logique m√©tier est √©crite dans des threads, ce code devrait tr√®s probablement √™tre jet√©, car il contient probablement des erreurs.  S'il vous semble qu'il n'y a pas d'erreurs, vous ne les avez tout simplement pas encore trouv√©es. <br><br>  La programmation multithread est une chose extr√™mement complexe.  Il y a peu de gens qui se sont vraiment consacr√©s √† la capacit√© d'√©crire sur les threads et ils obtiennent quelque chose de vraiment fonctionnel. <br><br>  Pendant ce temps, <strong>des ordinateurs multic≈ìurs</strong> sont apparus.  Ils ont apport√© des choses terribles avec eux.  Il a fallu une approche compl√®tement diff√©rente des donn√©es, des questions se sont pos√©es avec la localit√© des donn√©es, maintenant vous devez comprendre √† partir de quel noyau vous allez vers quelles donn√©es. <br><br>  Un noyau doit mettre les donn√©es ici, l'autre l√†, et en aucun cas confondre ces choses, car les clusters sont apparus √† l'int√©rieur de l'ordinateur.  √Ä l'int√©rieur d'un ordinateur moderne, il y a un cluster lorsqu'une partie de la m√©moire est soud√©e √† un c≈ìur et l'autre √† un autre.  Le temps de transit entre ces donn√©es peut varier selon des ordres de grandeur. <br><br><h2>  Exemples Python </h2><br>  Prenons un exemple simple de ¬´Service pour aider le client¬ª.  Il s√©lectionne le meilleur prix pour les marchandises sur plusieurs plateformes: nous conduisons au nom des marchandises et recherchons des parquets avec un prix minimum. <br><br>  C'est le code de l'ancien Django, Python 2. Aujourd'hui, il n'est pas tr√®s populaire, peu de gens d√©marrent des projets dessus. <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@api_view(['GET']) def best_price(request): name = request.GET['name'] price1 = http_fetch_price('market.yandex.ru', name) price2 = http_fetch_price('ebay.com', name) price3 = http_fetch_price('taobao.com', name) return Response(min([price1,price2,price3]))</span></span></code> </pre> <br>  Une demande arrive, nous allons dans un backend, puis dans un autre.  Aux endroits o√π <code>http_fetch_price</code> est <code>http_fetch_price</code> , les threads sont bloqu√©s.  En ce moment, l'ensemble du travailleur se lance dans un voyage √† Yandex.Market, puis √† eBay, puis jusqu'√† un timeout sur Taobao, et √† la fin donne une r√©ponse.  <strong>Pendant tout ce temps, tout le travailleur est debout</strong> . <br><br>  Il est tr√®s difficile d'interroger plusieurs backends en m√™me temps.  C'est une mauvaise situation: la m√©moire est consomm√©e, le lancement d'un grand nombre de travailleurs et la surveillance de l'ensemble du service sont n√©cessaires.  Il est n√©cessaire de v√©rifier la fr√©quence de ces demandes, avez-vous encore besoin d'ex√©cuter des travailleurs ou y en a-t-il encore d'autres.  Ce sont les probl√®mes m√™mes dont j'ai parl√©.  <strong>Il est n√©cessaire d'interroger successivement plusieurs backends</strong> . <br><br>  Que voit-on en Python?  <strong>Un processus par t√¢che,</strong> en Python il n'y a toujours pas de multic≈ìur.  La situation est claire: dans les langages de cette classe, il est difficile de cr√©er un multic≈ìur simple et s√ªr, car cela <strong>r√©duira les performances</strong> . <br><br>  Si vous acc√©dez √† la dict√©e √† partir de diff√©rents threads, l'acc√®s aux donn√©es peut √™tre √©crit comme ceci: collez deux instances Python en m√©moire afin qu'elles fouillent les donn√©es - elles les cassent simplement.  Par exemple, pour aller dicter et ne rien casser, vous devez mettre des mutex devant.  S'il y a un mutex avant chaque dict, le syst√®me ralentira environ 1000 fois - ce sera simplement g√™nant.  Il est difficile de le faire glisser dans un multic≈ìur. <br><br>  Nous n'avons <strong>qu'un seul thread d'ex√©cution</strong> et <strong>seuls les processus peuvent √©voluer</strong> .  En fait, nous avons r√©invent√© DOS √† l'int√©rieur du processus - le langage de script de 2010.  √Ä l'int√©rieur du processus, il y a une chose qui ressemble √† DOS: pendant que nous faisons quelque chose, tous les autres processus ne fonctionnent pas.  Personne n'a aim√© les √©normes d√©passements de co√ªts et la lenteur des r√©ponses. <br><br>  <b>Les r√©acteurs Socket sont</b> apparus en Python il y a quelque temps, bien que le concept lui-m√™me soit n√© il y a longtemps.  Vous pouvez d√©sormais vous attendre √† la disponibilit√© de plusieurs sockets √† la fois. <br><br>  Au d√©but, le r√©acteur est devenu en demande sur des serveurs comme nginx.  Y compris en raison de l'utilisation correcte de cette technologie, elle est devenue populaire.  Ensuite, le concept a ramp√© dans des langages de script comme Python et Ruby. <br><blockquote>  L'id√©e du r√©acteur est que nous sommes pass√©s √† une programmation orient√©e √©v√©nements. </blockquote><br><h2>  Programmation orient√©e √©v√©nement </h2><br>  Un contexte d'ex√©cution produit une demande.  En attendant une r√©ponse, un contexte diff√©rent est en cours d'ex√©cution.  Il est √† noter que nous avons presque travers√© le m√™me stade d'√©volution que la transition de DOS √† Windows 3.11.  Seuls les gens l'avaient fait 20 ans plus t√¥t, et en Python et Ruby, il est apparu il y a 10 ans. <br><br><h3>  Tordu </h3><br>  Il s'agit d'un cadre de r√©seau pilot√© par les √©v√©nements.  Il est apparu en 2002 et est √©crit en Python.  J'ai pris l'exemple ci-dessus et l'ai r√©√©crit sur Twisted. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render_GET</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> price1 = deferred_fetch_price(<span class="hljs-string"><span class="hljs-string">'market.yandex.ru'</span></span>, name) price2 = deferred_fetch_price(<span class="hljs-string"><span class="hljs-string">'ebay.com'</span></span>, name) price3 = deferred_fetch_price(<span class="hljs-string"><span class="hljs-string">'taobao.com'</span></span>, name) dl = defer.DeferredList([price1,price2,price3]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prices)</span></span></span><span class="hljs-function">:</span></span> request.write(<span class="hljs-string"><span class="hljs-string">'%d'</span></span>.format(min(prices))) request.finish() dl.addCallback(reply) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server.NOT_DONE_YET</code> </pre> <br>  Il peut y avoir des erreurs, des inexactitudes et la gestion des erreurs notoire n'est pas suffisante.  Mais le sch√©ma approximatif est le suivant: nous ne faisons pas de demande, mais demandons d'aller chercher cette demande un peu plus tard, quand il y aura du temps.  Dans la lign√©e de <code>defer.DeferredList</code> nous voulons rassembler les r√©ponses de plusieurs requ√™tes. <br><br>  En fait, le code se compose de deux parties.  Dans la premi√®re partie, ce qui s'est pass√© avant la demande, et dans la seconde, ce qui s'est pass√©. <br><blockquote>  Toute l'histoire de la programmation √©v√©nementielle est satur√©e de la douleur de casser le code lin√©aire sur ¬´avant la demande¬ª et ¬´apr√®s la demande¬ª. </blockquote>  Cela fait mal car les morceaux de code sont m√©lang√©s: les derni√®res lignes sont toujours ex√©cut√©es dans la requ√™te d'origine, et la fonction de <code>reply</code> sera appel√©e apr√®s. <br><br>  Il n'est pas facile de garder √† l'esprit pr√©cis√©ment parce que nous avons cass√© le code lin√©aire, mais il fallait le faire.  Sans entrer dans les d√©tails, le code r√©√©crit de Django √† Twisted <strong>produira une pseudo-acc√©l√©ration compl√®tement incroyable</strong> . <br><br><h3>  Id√©e tordue </h3><blockquote>  Un objet peut √™tre activ√© lorsque la prise est pr√™te. </blockquote>  Nous prenons des objets dans lesquels nous collectons les donn√©es n√©cessaires du contexte et lions leur activation au socket.  La disponibilit√© des sockets est d√©sormais l'un des contr√¥les les plus importants pour l'ensemble du syst√®me.  Les objets seront nos contextes. <br><br>  Mais en m√™me temps, le langage s√©pare toujours le concept m√™me du contexte d'ex√©cution dans lequel vivent les exceptions.  <strong>Le contexte d'ex√©cution vit s√©par√©ment des objets et est vaguement li√© √† eux</strong> .  Ici, le probl√®me se pose avec le fait que nous essayons de collecter des donn√©es √† l'int√©rieur des objets: il n'y a aucun moyen sans eux, mais le langage ne le prend pas en charge. <br><br>  Tout cela conduit √† un enfer de rappel classique.  Pour ce qu'ils aiment, par exemple, Node.js - jusqu'√† r√©cemment, il n'y avait aucune autre m√©thode, mais elle apparaissait toujours en Python.  Le probl√®me est qu'il y a des <strong>ruptures de code aux points de l'IO externe</strong> qui conduisent √† un rappel. <br><br>  Il y a beaucoup de questions.  Est-il possible de ¬´coller¬ª les bords de l'√©cart dans le code?  Est-il possible de revenir au code humain normal?  Que faire si un objet logique fonctionne avec deux sockets et que l'un d'eux est ferm√©?  Comment ne pas oublier de fermer la seconde?  Est-il possible d'utiliser en quelque sorte tous les c≈ìurs? <br><br><h3>  Async io </h3><br>  Une bonne r√©ponse √† ces questions est Async IO.  Il s'agit d'un pas en avant, mais pas facile.  Async IO est une chose compliqu√©e, sous le capot de laquelle il existe de nombreuses nuances douloureuses. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">best_price</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> name = request.GET[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] price1 = async_http_fetch_price(<span class="hljs-string"><span class="hljs-string">'market.yandex.ru'</span></span>, name) price2 = async_http_fetch_price(<span class="hljs-string"><span class="hljs-string">'ebay.com'</span></span>, name) price3 = async_http_fetch_price(<span class="hljs-string"><span class="hljs-string">'taobao.com'</span></span>, name) prices = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait([price1,price2,price3]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> min(prices)</code> </pre> <br>  L'√©cart de code est cach√© sous la syntaxe <code>async/await</code> .  Nous avons pris tout ce qui √©tait avant, mais ne sommes pas all√©s au r√©seau dans ce code.  Nous avons supprim√© <code>Callback(reply)</code> , qui √©tait dans l'exemple pr√©c√©dent, et l'avons cach√© derri√®re <code>await</code> - l'endroit o√π le code sera coup√© avec des ciseaux.  Il sera divis√© en deux parties: la partie appelante et la partie rappel, qui traite les r√©sultats. <br><br>  C'est un <strong>excellent sucre syntaxique</strong> .  Il existe des m√©thodes pour coller plusieurs attentes en une seule.  C'est cool, mais il y a une nuance: <strong>tout peut √™tre cass√© par une prise "classique"</strong> .  En Python, il existe encore un grand nombre de biblioth√®ques qui vont au socket de mani√®re synchrone, cr√©ent une <code>timer library</code> et tout g√¢chent pour vous.  Comment d√©boguer cela, je ne sais pas. <br><br>  Mais <strong>asyncio n'aide pas avec les fuites et le multic≈ìur</strong> .  Par cons√©quent, il n'y a pas de changements fondamentaux, bien qu'il soit devenu meilleur. <br><br>  Nous avons toujours tous les probl√®mes dont nous avons parl√© au d√©but: <br><br><ul><li>  facile √† fuir avec des prises; </li><li>  facile de laisser des liens dans des variables globales; </li><li>  gestion tr√®s minutieuse des erreurs; </li><li>  il est toujours difficile de faire du multic≈ìur. </li></ul><br><h3>  Que faire </h3><br>  Si tout cela va √©voluer, je ne sais pas, mais je vais montrer l'impl√©mentation dans d'autres langages et plateformes. <br><br>  <strong>Contextes d'ex√©cution isol√©s.</strong>  Dans les contextes d'ex√©cution, les r√©sultats sont accumul√©s, les sockets sont conserv√©s: des objets logiques dans lesquels nous stockons g√©n√©ralement toutes les donn√©es sur les rappels et les sockets.  Un concept: prendre des contextes d'ex√©cution, les coller sur des fils d'ex√©cution et les isoler compl√®tement les uns des autres. <br><br>  <strong>Changement de paradigme des objets.</strong>  Connectons le contexte au thread d'ex√©cution.  Il y a des analogues, ce n'est pas quelque chose de frais.  Si quelqu'un a essay√© de modifier le code source d'Apache et d'y √©crire des modules, il sait qu'il existe un pool Apache.  <strong>Aucun lien autoris√©</strong> entre le pool Apache.  Les donn√©es d'un pool Apache - le pool associ√© aux requ√™tes, se trouve √† l'int√©rieur, et vous ne pouvez rien en retirer. <br><br>  Th√©oriquement, c'est possible, mais si vous le faites, soit quelqu'un grondera, soit il n'acceptera pas le correctif, soit il aura un d√©bogage long et p√©nible sur la production.  Apr√®s cela, personne ne fera cela et permettra aux autres de faire de telles choses.  Il est tout simplement impossible de se r√©f√©rer aux donn√©es entre les contextes, une isolation compl√®te est n√©cessaire. <br><br>  Comment √©changer une activit√©?  Ce qu'il faut, ce ne sont pas de petites monades, qui sont ferm√©es en elles-m√™mes et ne communiquent pas entre elles.  Nous avons besoin d'eux pour communiquer.  Une approche est la messagerie.  Il s'agit en gros du chemin emprunt√© par Windows lors de l'√©change de messages entre processus.  Dans un syst√®me d'exploitation normal, vous ne pouvez pas donner de lien vers la m√©moire d'un autre processus, mais vous pouvez signaler via le r√©seau, comme sous UNIX, ou via des messages, comme sous Windows. <br><br>  <strong>Toutes les ressources du processus et du contexte deviennent un fil d'ex√©cution</strong> .  Nous avons coll√© ensemble: <br><br><ul><li>  donn√©es d'ex√©cution dans une machine virtuelle dans laquelle des exceptions se produisent; </li><li>  le fil d'ex√©cution, comme ce qui est ex√©cut√© sur le processeur; </li><li>  Un objet dans lequel toutes les donn√©es sont collect√©es logiquement. </li></ul><br>  F√©licitations - nous avons invent√© UNIX dans un langage de programmation!  Cette id√©e a √©t√© invent√©e vers 1969.  Jusqu'√† pr√©sent, il n'est pas encore en Python, mais Python est susceptible d'y arriver.  Et peut-√™tre qu'elle ne viendra pas - je ne sais pas. <br><br><h3>  Qu'est-ce que √ßa donne </h3><br>  Tout d'abord, <strong>le contr√¥le automatique des ressources</strong> .  √Ä Moscou Python Conf ++ 2019, ils ont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dit</a> que vous pouvez √©crire un programme sur Go et traiter toutes les erreurs.  Le programme restera comme un gant et fonctionnera pendant des mois.  C'est vrai, mais nous ne g√©rons pas toutes les erreurs. <br><br>  Nous sommes des gens vivants, nous avons toujours des d√©lais, le d√©sir de faire quelque chose d'utile, et de ne pas g√©rer la 535√®me erreur pour aujourd'hui.  Un code parsem√© de gestion des erreurs ne provoque jamais de sentiments chaleureux chez qui que ce soit. <br><br>  Par cons√©quent, nous √©crivons tous ¬´chemin heureux¬ª, puis nous le d√©couvrirons sur la production.  Soyons honn√™tes: seulement lorsque vous avez besoin de traiter quelque chose, nous commen√ßons alors le traitement.  La programmation d√©fensive est un peu diff√©rente, et ce n'est pas un d√©veloppement commercial. <br><br>  Par cons√©quent, <strong>lorsque nous avons un contr√¥le automatique des erreurs - c'est tr√®s bien</strong> .  Mais les syst√®mes d'exploitation l'ont cr√©√© il y a 50 ans: si un processus meurt, tout ce qu'il ouvre se ferme automatiquement.  Aujourd'hui, personne n'a besoin d'√©crire du code qui nettoiera les fichiers derri√®re le processus tu√©.  Cela n'a pas exist√© depuis 50 ans dans n'importe quel syst√®me d'exploitation, mais en Python, vous devez toujours le suivre attentivement et soigneusement avec vos mains.  C'est bizarre. <br><br>  <strong>Vous pouvez amener l'informatique lourde dans un contexte diff√©rent</strong> , mais elle peut d√©j√† aller dans un autre c≈ìur.  Nous avons partag√© les donn√©es, nous n'avons plus besoin de mutex.  Vous pouvez envoyer les donn√©es dans un contexte diff√©rent, par exemple: "Vous le ferez quelque part, puis dites-moi que vous avez termin√© et fait quelque chose." <br><br>  <strong>Une impl√©mentation asyncio sans les mots "async / wait"</strong> .  Un peu d'aide de la machine virtuelle, du runtime.  C'est ce dont nous avons parl√© avec <code>async/await</code> : vous pouvez √©galement convertir en messages, supprimer <code>async/await</code> et l'obtenir au niveau de la machine virtuelle. <br><br><h2>  Processus d'Erlang </h2><br>  Erlang a √©t√© invent√© il y a 30 ans.  Les gars barbus, qui n'√©taient pas tr√®s barbus √† l'√©poque, ont regard√© UNIX et ont transf√©r√© tous les concepts au langage de programmation.  Ils ont d√©cid√© qu'ils auraient maintenant leur propre truc pour dormir la nuit et aller tranquillement p√™cher sans ordinateur.  Il n'y avait pas encore d'ordinateurs portables, mais les barbus savaient d√©j√† que cela devait √™tre pens√© √† l'avance. <br><br>  <strong>Nous avons eu Erlang (Elixir) - des contextes actifs qui s'ex√©cutent d'eux-m√™mes</strong> .  Poursuivez mon exemple sur Erlang.  Sur Elixir, il ressemble √† peu pr√®s, avec quelques variations. <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">best_price</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Name)</span></span></span><span class="hljs-function"> -&gt;</span></span> Price1 = spawn_price_fetcher('market.yandex.ru', Name), Price2 = spawn_price_fetcher('ebay.com', Name), Price3 = spawn_price_fetcher('taobao.com', Name), lists:min(wait4([Price1,Price2,Price3])).</code> </pre> <br>  Nous lan√ßons plusieurs r√©cup√©rateurs - ce sont plusieurs nouveaux contextes distincts que nous attendons.  Ils ont attendu, collect√© les donn√©es et renvoy√© le r√©sultat comme prix minimum.  Tout cela est similaire √† <code>async/await</code> , mais sans les mots ¬´async / wait¬ª. <br><br><h3>  Caract√©ristiques d'Elixir </h3><br>  Elixir est situ√© √† la base d'Erlang, et tous les concepts de langage sont tranquillement port√©s sur Elixir.  Quelles sont ses fonctionnalit√©s? <br><br>  <strong>Interdiction des liaisons entre processeurs.</strong>  Par processus, j'entends un processus l√©ger √† l'int√©rieur d'une machine virtuelle - le contexte.  Simplifi√©, s'il est port√© sur Python, les liaisons de donn√©es √† l'int√©rieur d'un autre objet sont interdites dans Erlang.  Vous pouvez avoir un lien vers l'objet entier sous forme de bo√Æte ferm√©e, mais vous ne pouvez pas r√©f√©rencer les donn√©es qu'il contient.  Vous ne pouvez m√™me pas obtenir syntaxiquement un pointeur vers des donn√©es qui se trouvent dans un autre objet.  Vous ne pouvez conna√Ætre que l'objet lui-m√™me. <br><br>  <strong>Il n'y a pas de mutex √† l'int√©rieur des processus (objets).</strong>  C'est important - personnellement, je ne veux jamais jamais croiser dans ma vie l'histoire du d√©bogage des vols multi-threads en production.  Je ne souhaite cela √† personne. <br><br>  <strong>Les processus peuvent se d√©placer autour des noyaux, c'est s√ªr.</strong>  Nous n'avons plus besoin de contourner, comme en Java, un tas d'autres <code>pointer</code> et de les r√©√©crire lors du d√©placement de donn√©es d'un endroit √† un autre: nous n'avons pas de donn√©es communes et de liens internes.  Par exemple, d'o√π vient le probl√®me de raret√© de la hanche?  En raison du fait que quelqu'un se r√©f√®re √† ces donn√©es. <br><br>  Si nous transf√©rons des donn√©es √† l'int√©rieur du tas vers un autre emplacement pour le compactage, nous devons parcourir tout le syst√®me.  Il peut occuper des dizaines de gigaoctets et mettre √† jour tous les pointeurs - c'est fou. <br><br>  <strong>S√©curit√© compl√®te des threads</strong> , car toute communication passe par des messages.  √Ä la reddition de tout cela, nous avons <strong>perdu le processus d'√©viction</strong> .  Il l'a obtenu facile et bon march√©. <br><br>  <strong>Les messages comme base de communication.</strong>  √Ä l'int√©rieur des objets, des appels de fonction ordinaires et entre les objets de message.  L'arriv√©e des donn√©es du r√©seau est un message, la r√©ponse d'un autre objet est un message, quelque chose d'autre √† l'ext√©rieur est √©galement un message dans une file d'attente entrante.  Ce n'est pas sous UNIX car il n'a pas pris racine. <br><br>  <strong>Appels de m√©thode.</strong>  Nous avons des objets que nous appelons processus.  Les m√©thodes sur les processus sont appel√©es via des messages. <br><br>  <strong>Les m√©thodes d'appel envoient √©galement un message.</strong>  C'est formidable que maintenant cela puisse √™tre fait avec un timeout.  Si quelque chose nous r√©pond lentement, nous appelons la m√©thode sur un autre objet.  Mais en m√™me temps, nous disons que nous sommes pr√™ts √† attendre pas plus de 60 s, car j'ai un client avec un d√©lai d'attente de 70 s.  Je vais devoir aller lui dire "503" - viens demain, maintenant ils ne t'attendent pas. <br><br>  De plus, la <strong>r√©ponse √† l'appel peut √™tre diff√©r√©e</strong> .  √Ä l'int√©rieur de l'objet, vous pouvez accepter la demande d'appeler la m√©thode et dire: "Oui, oui, je vais vous poser maintenant, revenez dans une demi-heure, je vous r√©pondrai."  Vous ne pouvez pas parler, mais mettez-vous silencieusement de c√¥t√©.  Nous l'utilisons parfois. <br><br><h3>  Comment travailler avec un r√©seau? </h3><br>  Vous pouvez √©crire du code lin√©aire, des rappels ou dans le style <code>asyncio.gather</code> .  Un exemple de ce √† quoi cela ressemblera. <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([ ])</span></span></span><span class="hljs-function"> -&gt;</span></span> [ ]; wait4(List) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">receive</span></span> {reply, Pid, Price} -&gt; [Price] ++ wait4(List -- [Pid]) <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-number"><span class="hljs-number">60000</span></span> -&gt; [] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br>  Dans la fonction <code>wait4</code> de l'exemple pr√©c√©dent, nous <code>wait4</code> la liste de ceux dont nous attendons toujours les r√©ponses.  Si vous utilisez la m√©thode de <code>receive</code> , nous obtenons un message de ce processus, nous l'√©crivons dans la liste.  Si la liste est termin√©e, nous retournons tout ce qui √©tait et accumulons la liste.  Nous avons demand√© en m√™me temps trois objets pour nous conduire les donn√©es.  S'ils ne se sont pas d√©brouill√©s ensemble en 60 secondes et qu'au moins l'un d'eux n'a pas r√©pondu OK, nous aurons une liste vide.  Mais il est important que nous ayons fait un d√©lai g√©n√©ral pour une demande imm√©diatement √† tout un tas d'objets. <br><br>  Quelqu'un pourrait dire: ¬´Pensez, libcurl a la m√™me chose.¬ª  Mais ici, il est important que d'autre part, il puisse y avoir non seulement un voyage HTTP, mais aussi un voyage DB, ainsi que certains calculs, par exemple, le calcul d'un nombre optimal pour le client. <br><br><h3>  Gestion des erreurs </h3><br>  <strong>Des erreurs sont pass√©es du flux √† l'objet, qui sont d√©sormais identiques</strong> .  Maintenant, l'erreur elle-m√™me n'est pas attach√©e au thread, mais √† l'objet o√π elle a √©t√© ex√©cut√©e. <br><br>  C'est beaucoup plus logique.  Habituellement, lorsque nous dessinons toutes sortes de petits carr√©s et cercles sur le tableau dans l'espoir qu'ils prennent vie et commencent √† nous apporter des r√©sultats et de l'argent, nous dessinons g√©n√©ralement des objets, pas les flux dans lesquels ces objets seront ex√©cut√©s.  Par exemple, √† la livraison, nous pouvons recevoir un <strong>message</strong> automatique <strong>sur la mort d'un autre objet</strong> . <br><br><h3>  Introspection ou d√©bogage en production </h3><br>  Quoi de plus agr√©able que d'aller au prod et de d√©biter, surtout si l'erreur ne se produit que sous charge pendant les heures de pointe.  Aux heures de pointe, nous disons: <br><br>  <em>- Allez, je vais recommencer maintenant!</em> <br>  <em>- Sortez et il y a un red√©marrage chez quelqu'un d'autre!</em> <br><br>  Ici, nous pouvons entrer dans un syst√®me vivant qui fonctionne actuellement et n'est pas sp√©cialement pr√©par√© pour cela.  Pour ce faire, vous n'avez pas besoin de le red√©marrer avec le profileur, avec le d√©bogueur, reconstruire. <br><br>  <strong>Sans aucune perte de performances dans un syst√®me de production en direct,</strong> nous pouvons consulter une liste de processus: ce qui est √† l'int√©rieur d'eux, comment tout cela fonctionne, les jeter, v√©rifier ce qui leur arrive.  Tout cela est gratuit d√®s la sortie de la bo√Æte. <br><br><h3>  Bonus </h3><br>  <strong>Le code est super fiable.</strong>  Par exemple, Python a une fragilit√© avec l' <code>old vs async</code> , et il restera pendant cinq ans, rien de moins.  Compte tenu de la vitesse √† laquelle Python 3 a √©t√© impl√©ment√©, vous ne devriez pas esp√©rer qu'il sera rapide. <br><br>  <strong>La lecture et le suivi des messages sont plus faciles que le d√©bogage des rappels</strong> .  C'est important.  Il semblerait que si nous avons encore des rappels pour le traitement des messages que nous pouvons voir, alors quoi de mieux?  Par le fait que les messages sont une donn√©e en m√©moire.  Vous pouvez le regarder avec des yeux et comprendre ce qui est arriv√© ici.  Il peut √™tre ajout√© au traceur, obtenir une liste de messages dans un fichier texte.  C'est plus pratique que les rappels. <br><br>  <strong>Magnifique multic≈ìur</strong> , gestion de la m√©moire et <strong>introspection √† l'int√©rieur d'un syst√®me de</strong> production en <strong>direct</strong> . <br><br><h3>  Les probl√®mes </h3><br>  Naturellement, Erlang a √©galement des probl√®mes. <br><br>  <strong>Perte de performance maximale</strong> due au fait que nous ne pouvons plus faire r√©f√©rence aux donn√©es dans un autre processus ou objet.  Nous devons les d√©placer, mais ce n'est pas gratuit. <br><br>  <strong>La surcharge de la copie de donn√©es entre les processus.</strong>  Nous pouvons √©crire un programme en C qui s'ex√©cutera sur les 80 c≈ìurs et traitera un tableau de donn√©es, et nous supposerons qu'il le fait correctement et correctement.  Dans Erlang, vous ne pouvez pas faire cela: vous devez couper soigneusement les donn√©es, les distribuer sur un tas de processus, suivre tout.  Cette communication co√ªte des ressources - des cycles de processeur. <br><br>  <strong>Est-ce rapide ou lent?</strong>  Nous √©crivons du code Erlang depuis 10 ans.  Le seul concurrent qui a surv√©cu √† ces 10 ann√©es est √©crit en Java.  Avec lui, nous avons une parit√© de performance presque compl√®te: quelqu'un dit que nous sommes pires, quelqu'un qu'il est.  Mais ils ont Java avec tous ses probl√®mes, √† commencer par JIT. <br><br>  Nous √©crivons un programme qui dessert des dizaines de milliers de sockets et pompe des dizaines de Go de donn√©es √† travers lui-m√™me.  Soudain, il s'av√®re que dans ce cas, la <strong>justesse des algorithmes et la capacit√© de d√©boguer tout cela en production est plus importante que les chignons Java potentiels</strong> .  Des milliards de dollars y ont √©t√© investis, mais cela ne conf√®re au Java JIT aucun avantage magique. <br><br>  Mais si nous voulons mesurer des rep√®res stupides et d√©nu√©s de sens, tels que "calculer les nombres de Fibonacci", alors Erlang sera probablement encore pire que Python ou comparable. <br><br>  <strong>La surcharge de l'allocation des messages.</strong>  Parfois √ßa fait mal.  Par exemple, nous avons quelques morceaux en C dans le code, et √† ces endroits, cela ne fonctionnait pas du tout avec Erlang.     ,      ,   . <br><br>    Erlang <strong>     </strong> ,   ,     .  ,    ,   <code>receive</code>  <code>send receive</code> .     ‚Äî   ,   .   <strong> ,   ,    </strong> . <br><br><h2>      Python </h2><br> <strong>   </strong> .        .       ,       Python  -     . <br><br> ,  <strong>   </strong> .  -     Python,      ,    20 ,   40. <br><br> , <strong>   </strong>  . - , ,     Elixir,   ,      . <br><br><blockquote>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moscow Python Conf++</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>  ,         6      4   .  ,   ,  )     ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>  . Call for Papers   13 ,     27 . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr476112/">https://habr.com/ru/post/fr476112/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr476102/index.html">Tapez travailler en toute s√©curit√© avec les tableaux PHP</a></li>
<li><a href="../fr476104/index.html">N'utilisez pas MTProxy gratuit et d'autres types de proxy gratuits ...</a></li>
<li><a href="../fr476106/index.html">¬´Protocoles de cryptosyst√®mes¬ª: Diffie - Hellman, El-Gamal, MTI / A (0), STS</a></li>
<li><a href="../fr476108/index.html">Cerveau mutable</a></li>
<li><a href="../fr476110/index.html">Pourquoi l'informatique a-t-elle besoin d'une marque personnelle</a></li>
<li><a href="../fr476114/index.html">Et si sans Python? Julia pour l'apprentissage automatique et en g√©n√©ral</a></li>
<li><a href="../fr476118/index.html">Conception d'interface pour le jeu, dessinez une bague Havel de Dark Souls 3</a></li>
<li><a href="../fr476122/index.html">¬´√âcoutez¬ª le cosmos: de la mati√®re noire √† la com√®te Churyumov - Gerasimenko</a></li>
<li><a href="../fr476126/index.html">Comment tester les performances du serveur: une s√©lection de plusieurs benchmarks open source</a></li>
<li><a href="../fr476128/index.html">Ivan Osipov et Yuri Artamonov √† propos de Kotlin et des plugins pour IntelliJ IDEA lors de la r√©union jug.msk.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>