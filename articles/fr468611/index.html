<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äç‚úàÔ∏è üåê üòé Multithreading .NET: lorsque les performances font d√©faut üê† üë≠ üò≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La plate-forme .NET fournit de nombreuses primitives de synchronisation pr√©d√©finies et des collections thread-safe. Si vous devez impl√©menter, par exe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Multithreading .NET: lorsque les performances font d√©faut</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/468611/"><img src="https://habrastorage.org/webt/rn/su/tj/rnsutjjvg7sllluahknu8brlnbc.jpeg"><br><br>  La plate-forme .NET fournit de nombreuses primitives de synchronisation pr√©d√©finies et des collections thread-safe.  Si vous devez impl√©menter, par exemple, un cache thread-safe ou une file d'attente de requ√™tes lors du d√©veloppement d'une application, ces solutions pr√™tes √† l'emploi sont g√©n√©ralement utilis√©es, parfois plusieurs √† la fois.  Dans certains cas, cela entra√Æne des probl√®mes de performances: une longue attente sur les verrous, une consommation de m√©moire excessive et une longue r√©cup√©ration de place. <br><br>  Ces probl√®mes peuvent √™tre r√©solus si nous tenons compte du fait que les solutions standard sont rendues assez g√©n√©rales - elles peuvent avoir une surcharge dans nos sc√©narios qui est redondante.  Par cons√©quent, vous pouvez √©crire, par exemple, votre propre collection thread-safe efficace pour un cas sp√©cifique. <br><br>  Sous la cin√©matique se trouve une vid√©o et une transcription de mon rapport de la conf√©rence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DotNext</a> , o√π <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">j'analyse</a> plusieurs exemples o√π l'utilisation d'outils de la biblioth√®que standard .NET (Task.Delay, SemaphoreSlim, ConcurrentDictionary) a conduit √† des baisses de performances, et je propose des solutions adapt√©es √† des t√¢ches sp√©cifiques et d√©pourvues de ces lacunes. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-tNeYjRNJtY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Au moment du rapport, il travaillait √† Kontur.  Kontur d√©veloppe diverses applications pour les entreprises, et l'√©quipe dans laquelle j'ai travaill√© s'occupe des infrastructures et d√©veloppe divers services de support et biblioth√®ques qui aident les d√©veloppeurs d'autres √©quipes √† cr√©er des services de produits. <br><br>  L'√©quipe Infrastructure construit son entrep√¥t de donn√©es, un syst√®me d'h√©bergement d'applications pour Windows et diverses biblioth√®ques pour le d√©veloppement de microservices.  Nos applications sont bas√©es sur une architecture de microservice - tous les services interagissent les uns avec les autres sur le r√©seau, et, bien s√ªr, ils utilisent beaucoup de code asynchrone et multithread.  Certaines de ces applications sont tr√®s critiques en termes de performances; elles doivent √™tre capables de g√©rer un grand nombre de demandes. <br><br>  De quoi allons-nous parler aujourd'hui? <br><br><ul><li>  Multithreading et asynchronie dans .NET; </li><li>  Remplissage des primitives et des collections de synchronisation; </li><li>  Que faire si les approches standard ne peuvent pas supporter la charge? </li></ul><br>  Analysons quelques fonctionnalit√©s du travail avec du code multithread et asynchrone dans .NET.  Examinons quelques primitives de synchronisation et collections simultan√©es, voyons comment elles sont organis√©es √† l'int√©rieur.  Nous verrons ce qu'il faut faire s'il n'y a pas suffisamment de performances, si les classes standard ne peuvent pas faire face √† la charge, et si quelque chose peut √™tre fait dans cette situation. <br><br>  Je vais vous raconter quatre histoires qui se sont produites sur notre site de production. <br><br><h2>  Historique 1: Task.Delay &amp; TimerQueue </h2><br>  Cette histoire est d√©j√† assez bien connue, y compris √† ce sujet lors du pr√©c√©dent DotNext.  Cependant, il a eu une suite plut√¥t int√©ressante, alors je l'ai ajout√©.  Alors √† quoi √ßa sert? <br><br><h3>  1.1 Interrogation et interrogation longue </h3><br>  Le serveur effectue de longues op√©rations, le client les attend. <br>  <b>Interrogation: le</b> client interroge p√©riodiquement le serveur sur le r√©sultat. <br>  <b>Interrogation longue: le</b> client envoie une demande avec un long d√©lai d'expiration et le serveur r√©pond lorsque l'op√©ration est termin√©e. <br><br>  Avantages: <br><br><ul><li>  Moins de trafic </li><li>  Le client apprend le r√©sultat plus rapidement </li></ul><br>  Imaginez que nous ayons un serveur capable de g√©rer de longues demandes, par exemple une application qui convertit des fichiers XML en PDF, et qu'il existe des clients qui ex√©cutent ces t√¢ches pour le traitement et souhaitent attendre leur r√©sultat de mani√®re asynchrone.  Comment r√©aliser une telle attente? <br><br>  La premi√®re fa√ßon est le <b>sondage</b> .  Le client d√©marre la t√¢che sur le serveur, puis v√©rifie p√©riodiquement l'√©tat de cette t√¢che, tandis que le serveur renvoie l'√©tat de la t√¢che ("termin√©e" / "√©chou√©" / "termin√©e avec une erreur").  Le client envoie p√©riodiquement des demandes jusqu'√† ce que le r√©sultat apparaisse. <br><br>  La deuxi√®me fa√ßon est le <b>long scrutin</b> .  La diff√©rence ici est que le client envoie des demandes avec de longs d√©lais d'attente.  Le serveur, recevant une telle demande, ne signalera pas imm√©diatement que la t√¢che n'est pas termin√©e, mais essaiera d'attendre un certain temps pour que le r√©sultat apparaisse. <br>  Alors, quel est l'avantage d'un sondage long par rapport au vote r√©gulier?  Premi√®rement, moins de trafic est g√©n√©r√©.  Nous faisons moins de demandes sur le r√©seau - moins de trafic est poursuivi sur le r√©seau.  De plus, le client pourra conna√Ætre le r√©sultat plus rapidement qu'avec une interrogation r√©guli√®re, car il n'a pas besoin d'attendre l'intervalle entre plusieurs demandes d'interrogation.  Ce que nous voulons obtenir est compr√©hensible.  Comment allons-nous impl√©menter cela dans le code? <br><blockquote>  T√¢che: timeout <br>  Nous voulons attendre la t√¢che avec un d√©lai d'attente <br>  attendre SendAsync (); </blockquote>  Par exemple, nous avons une t√¢che qui envoie une demande au serveur, et nous voulons attendre son r√©sultat avec un d√©lai d'attente, c'est-√†-dire que nous retournerons le r√©sultat de cette t√¢che ou enverrons une sorte d'erreur.  Le code C # ressemblera √† ceci: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sendTask = SendAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delayTask = Task.Delay(timeout); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAny(sendTask, delayTask); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task == delayTask) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Timeout;</code> </pre> <br>  Ce code lance notre t√¢che, dont nous voulons attendre le r√©sultat, et Task.Delay.  Ensuite, en utilisant Task.WhenAny, nous attendons notre t√¢che ou Task.Delay.  S'il s'av√®re que Task.Delay est ex√©cut√© en premier, puis le temps est √©coul√© et nous avons un d√©lai d'attente, nous devons renvoyer une erreur. <br><br>  Ce code, bien s√ªr, n'est pas parfait et peut √™tre am√©lior√©.  Par exemple, l'annulation de Task.Delay ne ferait pas de mal si SendAsync revenait plus t√¥t, mais ce n'est pas tr√®s int√©ressant pour nous maintenant.  L'essentiel est que si nous √©crivons un tel code et l'appliquons pour une longue interrogation avec de longs d√©lais d'attente, nous aurons des probl√®mes de performances. <br><br><h3>  1.2 Probl√®mes li√©s √† l'interrogation longue </h3><br><ul><li>  Gros d√©lais d'attente </li><li>  De nombreuses requ√™tes simultan√©es </li><li>  =&gt; Utilisation √©lev√©e du CPU </li></ul><br>  Dans ce cas, le probl√®me est la consommation √©lev√©e de ressources processeur.  Il peut arriver que le processeur soit enti√®rement charg√© √† 100% et que l'application cesse g√©n√©ralement de fonctionner.  Il semblerait que nous ne consommions pas du tout les ressources du processeur: nous faisons des op√©rations asynchrones, attendons une r√©ponse du serveur et le processeur est toujours charg√© avec nous. <br><br>  Face √† cette situation, nous avons supprim√© un vidage de m√©moire de notre application: <br><br><pre> <code class="cs hljs"> ~*e!clrstack System.Threading.Monitor.Enter(System.Object) System.Threading.TimerQueueTimer.Change(‚Ä¶) System.Threading.Timer.TimerSetup(‚Ä¶) System.Threading.Timer..ctor(‚Ä¶) System.Threading.Tasks.Task.Delay(‚Ä¶)</code> </pre> <br>  Pour analyser le vidage, nous avons utilis√© l'outil WinDbg.  Nous avons entr√© une commande qui affiche les traces de pile de tous les threads g√©r√©s et avons vu un tel r√©sultat.  Nous avons beaucoup de threads en cours qui attendent un verrou.  La m√©thode Monitor.Enter est ce dans quoi la construction de verrouillage en C # se d√©veloppe.  Ce verrou est captur√© dans des classes appel√©es Timer et TimerQueueTimer.  Dans Timer, nous venions de Task.Delay lorsque nous avons essay√© de les cr√©er.  Qu'est ce que c'est?  Lorsque Task.Delay d√©marre, le verrou √† l'int√©rieur de TimerQueue est captur√©. <br><br><h3>  1.3 Verrouiller le convoi </h3><br><ul><li>  De nombreux threads essaient de verrouiller un verrou </li><li>  Sous le verrou, peu de code est ex√©cut√© </li><li>  Le temps est consacr√© √† la synchronisation des threads, pas √† l'ex√©cution de code. </li><li>  Les blocs de threads sont bloqu√©s - ils ne sont pas infinis </li></ul><br>  Nous avions un convoi d'√©cluses dans l'application.  De nombreux threads tentent de capturer le m√™me verrou.  Sous ce verrou, un peu de code est ex√©cut√©.  Les ressources du processeur ne sont pas d√©pens√©es ici sur le code d'application lui-m√™me, mais sur des op√©rations de synchronisation entre les threads sur ce verrou.  Il convient √©galement de noter une fonctionnalit√© li√©e √† .NET: les threads qui participent au convoi de verrous sont des threads du pool de threads. <br><br>  Par cons√©quent, si les threads du pool de threads sont bloqu√©s, ils peuvent se terminer - le nombre de threads dans le pool de threads est limit√©.  Il peut √™tre configur√©, mais il existe toujours une limite sup√©rieure.  Une fois qu'il est atteint, tous les threads de pool de threads participeront au verrouillage du convoi et tout code impliquant le pool de threads cessera d'√™tre ex√©cut√© dans l'application.  Cela aggrave consid√©rablement la situation. <br><br><h3>  1.4 TimerQueue </h3><br><ul><li>  G√®re les temporisateurs dans une application .NET. </li><li>  Les minuteries sont utilis√©es dans: <br>  - Task.Delay <br>  - CancellationTocken.CancelAfter <br>  - HttpClient </li></ul><br>  TimerQueue est une classe qui g√®re tous les temporisateurs dans une application .NET.  Si vous avez d√©j√† programm√© dans WinForms, vous avez peut-√™tre cr√©√© des minuteurs manuellement.  Pour ceux qui ne savent pas ce que sont les temporisateurs: ils sont utilis√©s dans Task.Delay (c'est juste notre cas), ils sont √©galement utilis√©s dans CancellationToken, dans la m√©thode CancelAfter.  En d'autres termes, le remplacement de Task.Delay par CancellationToken.CancelAfter ne nous aiderait en aucune fa√ßon.  De plus, les temporisateurs sont utilis√©s dans de nombreuses classes internes .NET, par exemple, dans HttpClient. <br><br>  Pour autant que je sache, certaines impl√©mentations des gestionnaires HttpClient ont des temporisateurs.  M√™me si vous ne les utilisez pas explicitement, ne d√©marrez pas Task.Delay, tr√®s probablement, vous les utilisez quand m√™me. <br><br>  Voyons maintenant comment TimerQueue est organis√© √† l'int√©rieur. <br><br><ul><li>  √âtat global (par domaine d'application): <br>  - Double liste cha√Æn√©e de TimerQueueTimer <br>  - Verrouiller l'objet </li><li>  Rappels de minuterie de routine </li><li>  Minuteurs non class√©s par temps de r√©ponse </li><li>  Ajout d'une minuterie: O (1) + verrouillage </li><li>  Retrait de la minuterie: O (1) + verrouillage </li><li>  Minuteurs de d√©marrage: O (N) + verrouillage </li></ul><br>  A l'int√©rieur de TimerQueue il y a un √©tat global, c'est une liste doublement li√©e d'objets de type TimerQueueTimer.  TimerQueueTimer contient un lien vers d'autres TimerQueueTimer, voisins dans une liste cha√Æn√©e, il contient √©galement l'heure de la minuterie et le rappel, qui sera appel√© lorsque la minuterie se d√©clenche.  Cette liste doublement li√©e est prot√©g√©e par un objet de verrouillage, juste celui sur lequel le convoi de verrouillage s'est produit dans notre application.  √âgalement √† l'int√©rieur de TimerQueue, il existe une routine qui lance des rappels li√©s √† nos temporisateurs. <br><br>  Les temporisateurs ne sont en aucun cas class√©s par temps de r√©ponse, toute la structure est optimis√©e pour ajouter / supprimer de nouveaux temporisateurs.  Lorsque Routine d√©marre, il parcourt toute la liste doublement li√©e, s√©lectionne les temporisateurs qui devraient fonctionner et les rappelle. <br><br>  La complexit√© de l'op√©ration ici est telle.  L'ajout et la suppression d'une minuterie se produisent O par unit√©, et le d√©marrage des temporisateurs se produit par ligne.  De plus, si tout est acceptable avec la complexit√© algorithmique, il y a un probl√®me: toutes ces op√©rations capturent le verrou, ce qui n'est pas tr√®s bon. <br><br>  Quelle situation peut arriver?  Nous avons trop de temporisations accumul√©es dans TimerQueue, donc lorsque Routine d√©marre, il verrouille son long fonctionnement lin√©aire, √† ce moment-l√†, ceux qui essaient de d√©marrer ou de supprimer des temporisations de TimerQueue ne peuvent rien y faire.  Pour cette raison, le convoi d'√©cluse se produit.  Ce probl√®me a √©t√© corrig√© dans .NET Core. <br><blockquote>  R√©duire les conflits de verrouillage du minuteur (coreclr # 14527) <br><ul><li>  Verrouillage du partitionnement <br>  - Environment.ProcessorCount TimerQueue's TimerQueueTimer </li><li>  Files d'attente s√©par√©es pour les temporisateurs √† dur√©e de vie courte / longue </li><li>  Minuterie courte: temps &lt;= 1/3 seconde </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/dotnet/coreclr/issues/14462</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/dotnet/coreclr/pull/14527</a> <br></blockquote>  Comment a-t-il √©t√© corrig√©?  Ils ont attaqu√© TimerQueue: au lieu d'un TimerQueue, qui √©tait statique pour l'ensemble du AppDomain, pour toute l'application, plusieurs TimerQueue ont √©t√© cr√©√©s.  Lorsque les threads y arrivent et essaient de d√©marrer leurs temporisateurs, ces temporisateurs tomberont dans une TimerQueue al√©atoire et les threads auront moins de chance d'entrer en collision sur un verrou. <br><br>  √âgalement dans .NET Core appliqu√© certaines optimisations.  Les minuteries ont √©t√© divis√©es en longue dur√©e et courte dur√©e, des TimerQueue s√©par√©s sont maintenant utilis√©s pour elles.  La minuterie de courte dur√©e est s√©lectionn√©e pour √™tre inf√©rieure √† 1/3 de seconde.  Je ne sais pas pourquoi une telle constante a √©t√© choisie.  Dans .NET Core, nous n'avons pas r√©ussi √† d√©tecter les probl√®mes de temporisation. <br><br><img src="https://habrastorage.org/webt/f_/am/cv/f_amcv6bohiq54ciyuunvtrr0ei.jpeg"><br><br>  <a href="">https://github.com/Microsoft/dotnet-framework-early-access/blob/master/release-notes/NET48/dotnet-48-changes.md</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/dotnet/coreclr/labels/netfx-port-consider</a> <br><br>  Ce correctif a √©t√© r√©troport√© vers le .NET Framework, version 4.8.  La balise netfx-port-consider est indiqu√©e dans le lien ci-dessus, si vous allez dans le r√©f√©rentiel .NET Core, CoreCLR, CoreFX, vous pouvez rechercher ce probl√®me qui sera r√©troport√© vers le .NET Framework, il y en a maintenant une cinquantaine.  Autrement dit, le .NET open source a beaucoup aid√©, quelques bugs ont √©t√© corrig√©s.  Vous pouvez lire le journal des modifications .NET Framework 4.8: de nombreux bugs ont √©t√© corrig√©s, bien plus que dans les autres versions de .NET.  Fait int√©ressant, ce correctif est d√©sactiv√© par d√©faut dans le .NET Framework 4.8.  Il est inclus dans le fichier entier que vous connaissez appel√© App.config <br><br>  Le param√®tre dans App.config qui active ce correctif est appel√© UseNetCoreTimer.  Avant la sortie du .NET Framework 4.8, pour que notre application fonctionne et n'entre pas dans le convoi de verrous, vous deviez utiliser votre impl√©mentation de Task.Delay.  Dans ce document, nous avons essay√© d'utiliser un tas binaire afin de comprendre plus efficacement quels temporisateurs devraient √™tre appel√©s maintenant. <br><br><h3>  1.5 Task.Delay: impl√©mentation native </h3><br><ul><li>  Binaryheap </li><li>  Partage </li><li>  Cela a aid√©, mais pas dans tous les cas </li></ul><br>  L'utilisation d'un segment binaire vous permet d'optimiser la routine, qui appelle des rappels, mais aggrave le temps n√©cessaire pour supprimer un temporisateur arbitraire de la file d'attente - pour cela, vous devez reconstruire le segment.  C'est probablement pourquoi .NET utilise une liste doublement li√©e.  Bien s√ªr, l'utilisation d'un tas binaire ne nous aiderait pas ici, nous avons √©galement d√ª travailler sur TimerQueue.  Cette solution a fonctionn√© pendant un certain temps, mais tout est encore tomb√© dans le convoi de verrous en raison du fait que les minuteries sont utilis√©es non seulement l√† o√π elles s'ex√©cutent explicitement dans le code, mais aussi dans les biblioth√®ques tierces et le code .NET.  Pour r√©soudre compl√®tement ce probl√®me, vous devez mettre √† niveau vers la version 4.8 de .NET Framework et activer le correctif aupr√®s des d√©veloppeurs .NET. <br><br><h3>  1.6 D√©lai de t√¢che: conclusions </h3><br><ul><li>  Les pi√®ges partout - m√™me dans les choses les plus utilis√©es </li><li>  Faites des tests de r√©sistance </li><li>  Passez √† Core, obtenez d'abord des corrections de bugs (et de nouveaux bugs) :) </li></ul><br>  Quelles sont les conclusions de toute cette histoire?  Premi√®rement, les pi√®ges peuvent √™tre localis√©s vraiment partout, m√™me dans les classes que vous utilisez tous les jours sans penser, par exemple, √† la m√™me t√¢che, Task.Delay. <br><br>  Je recommande d'effectuer des tests de r√©sistance de vos propositions.  Ce probl√®me que nous venons d'identifier au stade des tests de charge.  Nous l'avons ensuite tourn√© plusieurs fois en production dans d'autres applications, mais, n√©anmoins, les tests de r√©sistance nous ont aid√©s √† retarder le temps avant de rencontrer ce probl√®me dans la r√©alit√©. <br><br>  Passez √† .NET Core - vous serez le premier √† recevoir des corrections de bugs (et de nouveaux bugs).  O√π sans nouveaux bugs? <br><br>  L'histoire des minuteries est termin√©e et nous passons √† la suivante. <br><br><h2>  Histoire 2: SemaphoreSlim </h2><br>  L'histoire suivante concerne le c√©l√®bre SemaphoreSlim. <br><br><h3>  2.1 Limitation du serveur </h3><br><ul><li>  Il est n√©cessaire de limiter le nombre de demandes trait√©es simultan√©ment sur le serveur </li></ul><br>  Nous voulions impl√©menter la limitation sur le serveur.  Qu'est ce que c'est  Vous connaissez probablement tous l'√©tranglement du processeur: lorsque le processeur surchauffe, il diminue sa fr√©quence pour refroidir, ce qui limite ses performances.  C'est donc ici.  Nous savons que notre serveur peut traiter N requ√™tes en parall√®le et ne pas tomber.  Que voulons-nous faire?  Limitez le nombre de demandes trait√©es simultan√©ment √† cette constante et faites en sorte que si plus de demandes lui parviennent, elles se mettent en file d'attente et attendent que les demandes pr√©c√©dentes soient ex√©cut√©es.  Comment r√©soudre ce probl√®me?  Il est n√©cessaire d'utiliser une sorte de primitive de synchronisation. <br><br>  Semaphore est une primitive de synchronisation sur laquelle vous pouvez attendre N fois, apr√®s quoi celui qui arrive en premier N + et ainsi de suite l'attendra jusqu'√† ce que ceux qui l'ont entr√© plus t√¥t lib√®rent Semaphore.  Il s'av√®re quelque chose comme ceci: deux fils d'ex√©cution, deux ouvriers sont pass√©s sous Semaphore, les autres se sont align√©s. <br><br><img src="https://habrastorage.org/webt/6s/bu/h7/6sbuh77p4temzi5yiofjlh-rxoi.png"><br><br>  Bien s√ªr, c'est juste que Semaphore n'est pas tr√®s appropri√© pour nous, il est en synchronisme .NET, donc nous avons pris SemaphoreSlim et √©crit ce code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> semaphore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SemaphoreSlim(N); ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> semaphore.WaitAsync(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> HandleRequestAsync(request); semaphore.Release();</code> </pre> <br>  Nous cr√©ons SemaphoreSlim, attendez-le, sous Semaphore nous traitons votre demande, apr√®s cela nous lib√©rons Semaphore.  Il semblerait que ce soit une impl√©mentation id√©ale de la limitation du serveur, et elle ne peut plus √™tre meilleure.  Mais tout est beaucoup plus compliqu√©. <br><br><h3>  2.2 Limitation du serveur: complication </h3><br><ul><li>  Traitement des demandes dans l'ordre LIFO </li><li>  SemaphoreSlim </li><li>  Concurrentstack </li><li>  TaskCompletionSource </li></ul><br>  Nous avons un peu oubli√© la logique m√©tier.  Les requ√™tes qui aboutissent √† la limitation sont de v√©ritables requ√™tes http.  En r√®gle g√©n√©rale, ils ont un certain d√©lai, qui est d√©fini par ceux qui ont envoy√© cette demande automatiquement, ou un d√©lai de l'utilisateur qui appuie sur F5 apr√®s un certain temps.  Par cons√©quent, si vous traitez les demandes dans un ordre de file d'attente, comme un s√©maphore normal, tout d'abord les demandes de la file d'attente qui ont expir√© peuvent d√©j√† √™tre trait√©es.  Si vous travaillez dans l'ordre de la pile - traitez d'abord toutes les demandes qui sont arriv√©es en dernier, un tel probl√®me ne se posera pas. <br><br>  En plus de SemaphoreSlim, nous avons d√ª utiliser ConcurrentStack, TaskCompletionSource, pour envelopper beaucoup de code autour de tout cela, afin que tout fonctionne dans l'ordre dont nous avions besoin.  TaskCompletionSource est une telle chose, qui est similaire √† CancellationTokenSource, mais pas pour CancellationToken, mais pour Task.  Vous pouvez cr√©er une TaskCompletionSource, en extraire une t√¢che, la donner et ensuite dire √† TaskCompletionSource que vous devez d√©finir le r√©sultat de cette t√¢che, et ceux qui attendent cette t√¢che d√©couvriront ce r√©sultat. <br><br>  Nous l'avons tous mis en ≈ìuvre.  Le code est horrible.  et, pire que tout, il s'est av√©r√© inop√©rant. <br><br>  Quelques mois apr√®s le d√©but de son utilisation dans une application assez charg√©e, nous avons rencontr√© un probl√®me.  De la m√™me mani√®re que dans le cas pr√©c√©dent, la consommation du processeur est pass√©e √† 100%.  Nous avons fait de m√™me, enlev√© le d√©potoir, regard√© dans WinDbg, et retrouv√© le convoi d'√©cluse. <br><br><img src="https://habrastorage.org/webt/h_/ef/as/h_efasuul34r0fm7vwopo2hm1bc.jpeg"><br><br>  Cette fois, le convoi Lock s'est produit √† l'int√©rieur de SemaphoreSlim.WaitAsync et SemaphoreSlim.Release.  Il s'est av√©r√© qu'il y a un verrou √† l'int√©rieur de SemaphoreSlim, il n'est pas sans verrou.  Cela s'est av√©r√© √™tre un inconv√©nient assez s√©rieux pour nous. <br><br><img src="https://habrastorage.org/webt/0h/-k/qq/0h-kqqxojlujm3dglokmacabvwq.jpeg"><br><br>  √Ä l'int√©rieur de SemaphoreSlim, il y a un √©tat interne (un compteur du nombre de travailleurs qui peuvent encore y passer), et une liste doublement li√©e de ceux qui attendent sur ce s√©maphore.  Les id√©es ici sont √† peu pr√®s les m√™mes: vous pouvez attendre dans ce S√©maphore, vous pouvez annuler votre attente - quitter cette file d'attente.  Il y a une serrure qui vient de ruiner nos vies. <br><br>  Nous avons d√©cid√©: bas avec tout le terrible code que nous devions √©crire. <br><br><img src="https://habrastorage.org/webt/ax/ls/3i/axls3iseuxmgjt-vqkeiqs7hvtq.jpeg"><br><br>  √âcrivons notre S√©maphore, qui sera imm√©diatement sans verrou et qui fonctionnera imm√©diatement dans l'ordre de la pile.  L'annulation de l'attente n'est pas importante pour nous. <br><br><img src="https://habrastorage.org/webt/rv/rg/wv/rvrgwv8apebibtiymhxpvm5giti.jpeg"><br><br>  D√©finissez cette condition.  Voici le nombre de currentCount - c'est combien plus d'espace est laiss√© dans le s√©maphore.  S'il n'y a plus de si√®ge dans Semaphore, ce nombre sera n√©gatif et montrera combien de travailleurs sont dans la file d'attente.  Il y aura √©galement un ConcurrentStack, compos√© de TaskCompletionSource'ov - c'est juste une pile de waiter'ov d'o√π ils seront extraits si n√©cessaire.  √âcrivons la m√©thode WaitAsync. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> decrementedCount = Interlocked.Decrement(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (decrementedCount &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.CompletedTask; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> waiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(); waiters.Push(waiter); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waiter.Task;</code> </pre> <br>  D'abord, nous diminuons le compteur, prenons une place dans le S√©maphore pour nous-m√™mes, si nous avions des places libres, et ensuite nous disons: ¬´√áa y est, vous √™tes pass√© sous le S√©maphore¬ª. <br><br>  S'il n'y avait aucun endroit dans Semaphore, nous cr√©ons un TaskCompletionSource, le jetons sur la pile de waiter'ov et renvoyons Task au monde ext√©rieur.  Le moment venu, cette t√¢che fonctionnera et l'ouvrier pourra continuer son travail et passera sous S√©maphore. <br><br>  √âcrivons maintenant la m√©thode Release. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> countBefore = Interlocked.Increment(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (countBefore &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waiters.TryPop(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> waiter)) waiter.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  La m√©thode Release est la suivante: <br><br><ul><li>  Un si√®ge gratuit dans le s√©maphore </li><li>  Increment currentCount </li></ul><br>  Si nous pouvons dire par currentCount s'il y a un serveur dans la pile sur lequel nous devons signaler, nous retirons ce serveur de la pile et signalons.  Ici, le serveur est un TaskCompletionSource.  Question √† ce code: il semble logique, mais √ßa marche m√™me?  Quels sont les probl√®mes?  Il existe une nuance li√©e au lieu de lancement de continuation'y et TaskCompletionSource'y. <br><br><img src="https://habrastorage.org/webt/_1/zo/hu/_1zohu07rqeiemrkwrcubv7gwhe.png"><br><br>  Consid√©rez ce code.  Nous avons cr√©√© un TaskCompletionSource et lanc√© deux t√¢ches.  La premi√®re t√¢che affiche une unit√©, d√©finit le r√©sultat sur un TaskCompletionSource, puis affiche un diable sur la console.  La deuxi√®me t√¢che attend ce TaskCompletionSource, sa t√¢che, puis bloque d√©finitivement son thread du pool de threads. <br><br>  Que va-t-il se passer ici?  La t√¢che 2 lors de la compilation sera divis√©e en deux m√©thodes, la seconde √©tant une continuation contenant Thread.Sleep.  Apr√®s avoir d√©fini le r√©sultat de TaskCompletionSource, cette continuation sera ex√©cut√©e dans le m√™me thread dans lequel la premi√®re t√¢che a √©t√© ex√©cut√©e.  Par cons√©quent, le flux de la premi√®re t√¢che sera bloqu√© pour toujours et le deuce vers la console ne sera plus imprim√©. <br><br>  Fait int√©ressant, j'ai essay√© de modifier ce code, et si je supprimais la sortie de l'unit√© de console, la poursuite √©tait lanc√©e sur un autre thread du pool de threads et le diable √©tait imprim√©.  Dans quels cas la suite sera ex√©cut√©e dans le m√™me thread, et dans laquelle - arrivera au pool de threads - une question pour les lecteurs. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tcs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;( TaskCreationOptions.RunContinuationsAsynchronously); <span class="hljs-comment"><span class="hljs-comment">/* OR */</span></span> Task.Run(() =&gt; tcs.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>));</code> </pre> <br>  Pour r√©soudre ce probl√®me, nous pouvons soit cr√©er un TaskCompletionSource avec l'indicateur RunContinuationsAsynchronously correspondant, soit appeler la m√©thode TrySetResult dans Task.Run/ThreadPool.QueueUserWorkItem afin qu'il ne s'ex√©cute pas sur notre thread.  S'il est ex√©cut√© sur notre fil, nous pouvons avoir des effets secondaires ind√©sirables.  De plus, il y a un deuxi√®me probl√®me, nous allons nous y attarder plus en d√©tail. <br><br><img src="https://habrastorage.org/webt/m9/x8/gx/m9x8gxz7x5tw3mjcps7nygdmkjs.jpeg"><br><br>  Regardez les m√©thodes WaitAsync et Release et essayez de trouver un autre probl√®me dans la m√©thode Release. <br><br>  Tr√®s probablement, de la trouver si simplement impossible.  Il y a une course ici. <br><br><img src="https://habrastorage.org/webt/cs/1e/4q/cs1e4q3yaz4d3084_24z2ucsd6y.jpeg"><br><br>  Cela est d√ª au fait que dans la m√©thode WaitAsync, le changement d'√©tat n'est pas atomique.  D'abord, nous d√©cr√©mentons le compteur et ensuite nous poussons le serveur sur la pile.  S'il arrive que Release soit ex√©cut√© entre d√©cr√©mentation et push, il peut se fermer pour ne rien extraire de la pile.  Cela doit √™tre pris en compte et dans la m√©thode Release, attendez que le serveur apparaisse sur la pile. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> countBefore = Interlocked.Increment(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> currentCount) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (countBefore &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Waiter waiter; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spinner = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpinWait(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!waiter.TryPop(<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> waiter)) spinner.SpinOnce(); waiter.TrySetResult(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  Ici, nous le faisons en boucle jusqu'√† ce que nous parvenions √† le retirer.  Afin de ne pas g√¢cher √† nouveau les cycles du processeur, nous utilisons SpinWait. <br><br>  Dans les premi√®res it√©rations, il tournera en boucle.  S'il y a beaucoup d'it√©rations, le serveur n'appara√Ætra pas longtemps, alors notre thread ira √† Thread.Sleep, afin de ne pas gaspiller √† nouveau les ressources CPU. <br><br>  En fait, le S√©maphore d'ordre LIFO n'est pas seulement notre id√©e. <br><blockquote>  <b>LowLevelLifoSemaphore</b> <br><ul><li>  Synchrone </li><li>  Sous Windows utilise le port d'ach√®vement IO comme une pile Windows </li></ul><br>  <a href="">https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/src/System/Threading/LowLevelLifoSemaphore.cs</a> </blockquote>  Il existe un tel s√©maphore dans .NET lui-m√™me, mais pas dans CoreCLR, pas dans CoreFX, mais dans CoreRT.  Il est parfois tr√®s utile de jeter un ≈ìil au r√©f√©rentiel .NET.  Il existe un s√©maphore appel√© LowLevelLifoSemaphore.  Ce s√©maphore ne nous conviendrait pas de toute fa√ßon: il est synchrone. <br><br>  Remarquablement, sur Windows, il fonctionne via les ports d'ach√®vement IO.  Ils ont la propri√©t√© que les threads peuvent les attendre, et ces threads seront lib√©r√©s uniquement dans l'ordre LIFO.  Cette fonctionnalit√© y est utilis√©e, c'est vraiment LowLevel. <br><br><h3>  2.3 Conclusions: </h3><br><ul><li>  N'esp√©rez pas que le remplissage du cadre survivra sous votre charge </li><li>  Il est plus facile de r√©soudre un probl√®me sp√©cifique que le cas g√©n√©ral. </li><li>  Les tests de r√©sistance n'aident pas toujours </li><li>  Attention au blocage </li></ul><br>  Quelles sont les conclusions de toute cette histoire?  Tout d'abord, n'esp√©rez pas que certaines classes du framework que vous utilisez de la biblioth√®que standard supporteront votre charge.  Je ne veux pas dire que SemaphoreSlim est mauvais, il s'est av√©r√© √™tre inadapt√© sp√©cifiquement dans ce sc√©nario. <br><br>  Il s'est av√©r√© beaucoup plus facile pour nous d'√©crire notre s√©maphore pour une t√¢che sp√©cifique.  Par exemple, il ne prend pas en charge l'annulation de l'attente.  Cette fonctionnalit√© est disponible dans le SemaphoreSlim habituel, nous ne l'avons pas, mais cela nous a permis de simplifier le code. <br><br>  Le test de charge, bien qu'il aide, peut ne pas toujours aider. <br><br> .NET  ,           ‚Äî   .        lock,  : ¬´    ?¬ª     CPU 100%,     lock', , ,   -  .NET.      . <br><br>    . <br><br><h2>  3: (A)sync IO </h2><br>    /,      . <br><br><img src="https://habrastorage.org/webt/84/qh/sz/84qhsz9je7twmgbswt5so0dfx2q.jpeg"><br><br>    lock convoy,    stack trace     Overlapped  PinnableBufferCache.   lock.     : Overlapped  PinnableBufferCache? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OVERLAPPED</a> ‚Äî    Windows,      /.      ,        .        ,  .       ,     lock convoy.   ,      lock convoy,    ,   . <br><br><img src="https://habrastorage.org/webt/if/j_/fc/ifj_fclqmvkfgfff7zedxpj63mo.jpeg"><br><br>  ,       ,   .NET 4.5.1  4.5.2.     .NET 4.5.2,     ,    .NET 4.5.2.  .NET 4.5.1     OverlappedDataCache,      Overlapped ‚Äî ,       ,   .    ,  lock-free,   ConcurrentStack,       .  .NET 4.5.2     :  OverlappedDataCache   PinnableBufferCache. <br><br>   ? PinnableBufferCache     ,   Overlapped     ,    ,       ‚Äî      . ,     ,      . PinnableBufferCache     .   , lock-free,   ConcurrentStack.     ,      .        ,        ,  -    lock-free    list  lock'. <br><br><h3> 3.1 PinnableBufferCache </h3><br> LockConvoy: <br><br><ul><li>    </li><li>      </li></ul><br>  lock convoy  ,   -     .        list      ,     lock   ,  ,                . <br><br>     PinnableBufferCache  ,         .    : <br><br><pre> <code class="plaintext hljs">PinnableBufferCache_System.ThreadingOverlappedData_MinCount</code> </pre> <br>      ,      .  : ¬´ !         -  ¬ª.         -: <br><br><pre> <code class="cs hljs">Environment.SetEnvironmentVariable( <span class="hljs-string"><span class="hljs-string">"PinnableBufferCache_System.Threading.OverlappedData_MinCount"</span></span>, <span class="hljs-string"><span class="hljs-string">"10000"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Overlapped().GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced);</code> </pre> <br>    ?     ,    Overlapped  ,   ,        .     ,   ,     ,     ,  PinnableBufferCache      lock convoy'.    ,           . <br><br>  .NET Core  PinnableBufferCache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,   OverlappedData   . ,        , Garbage collector     ,      .     .NET Core  .  .NET Framework,   ,     . <br><br><h3> 3.2 : </h3><br><ul><li>      </li><li>      </li><li>   .NET Core </li></ul><br>      ,     .   ,   .NET            ,       . ,  ,  .NET Core. ,     ,         -. <br><br>    key-value . <br><br><h2>  4: Concurrent key-value collections </h2><br>  .NET   concurrent-.  lock-free  ConcurrentStack  ConcurrentQueu,       .   ConcurrentDictionary,    .   lock-free  ,   ,      .    ConcurrentDictionary? <br><br><h3> 4.1 ConcurrentDictionary </h3><br> : <br><br><ul><li>  </li><li>  </li></ul><br>  Avantages: <br><br><ul><li>     </li><li>   (TryAdd/TryUpdate/AddOrUpdate) </li><li> Lock-free  </li><li> Lock-free enumeration </li></ul><br>      , memory-,  ,        .    ,    ,    .NET Framework.            . ,  ,      (enumeration) lock-free. ,   . <br><br>  ,   ,   -  .NET.  key-value    -    : <br><br><img src="https://habrastorage.org/webt/ff/9f/g_/ff9fg_qzzuzvafep8c-p3seyigm.jpeg"><br><br>  -,     bucket'.      bucket',    .   ,    bucket   ,       . <br><br>    ‚Äî   ,  ConcurrentDictionary.  ConcurrentDictionary    ¬´-¬ª   .    ,      ,   ,       memory traffic.     ConcurrentDictionary,   lock'.   ‚Äî   . <br><br>    ,    Dictionary. <br><br><img src="https://habrastorage.org/webt/-_/dw/jo/-_dwjoxswmd1kecoi3aln8m7bow.jpeg"><br><br>  Dictionary  ,  Concurrent,      .     :  buckets,  entries.   buckets       bucket'   entries.   ¬´-¬ª    entries.          .      ¬´-¬ª   int,     bucket'. <br><br>   memory overhead,     ConcurrentDictionary   Dictionary. <br><br><img src="https://habrastorage.org/webt/em/aa/ch/emaachor-z_xxt7m_1wc7ntqupm.jpeg"><br><br>    Dictionary. Memory overhea'    ,       .    Dictionary  overhead  -    ,  int'.  8 . <br><br>    ConcurrentDictionary.  ConcurrentDictionary     ConcurrentDictionary.Node.   , .     int hashCode        .       ,    table (  16 ),  int hashCode     .      ,   64-    28  overhead'.       Dictionary. <br><br>  memory overhead', ConcurrentDictionary     GC   ,       .     Benchmark.   ConcurrentDictionary  ,       GC.Collect.    ? <br><br><img src="https://habrastorage.org/webt/on/yj/uq/onyjuq1rqgfkv8iav5x4z8nrnq8.jpeg"><br><br>     .       ConcurrentDictionary  10  ,        ,             ,      .   Dictionary   .      ,   ,  ,    .       . <br><br>     ,     ConcurrentDictionary? <br><br><h3> 4.2   </h3><br><ul><li>    </li><li> TTL </li><li> Dictionary+lock </li><li> Sharding </li></ul><br>     .      ConcurrentDictionary.        10  .   ,     .   TTL  ,    .        Dictionary  lock'. ,  ,  lock    .       Dictionary  lock'      ,   -     ,           lock.      ,     . <br><br><h3> 4.3  </h3><br><ul><li>   in-memory  &lt;Guid,Guid&gt; </li><li>   &gt;10 <sup>6</sup>  </li><li>       </li><li>   </li><li>        </li></ul><br>     .      ‚Äî      ,       in-memory   Guid'  Guid,     .       .     - - ,     .  ,            15    .   .     Semaphore     ConcurrentDictionary. <br><br><img src="https://habrastorage.org/webt/u4/kw/kt/u4kwkttmxwpyelqlqoqp9zxahaa.jpeg"><br><br> ,    lock-free    ,    overhead      GC.   ,          .      ,    ,       ,   .   ,     -  ,       ,    .  ,  ,      Large Object Heap.    ? <br><br>       ,     ,     Dictionary   . <br><br><img src="https://habrastorage.org/webt/kx/yn/oi/kxynoiatsy8zcyrc5dei-xohlk4.jpeg"><br><br>   Dictionary   bucket',  Entry.  Entry  , ,   ,   . <br><br><img src="https://habrastorage.org/webt/n8/7a/5r/n87a5rlkgdk62nw82qysi3fmi18.png"><br><br>  Dictionary   ,   ,      . ,     - . <br><br>      ,  -     ? -,  ,       ,     ,      .     .    Dictionary,     , buckets, entries,              Interlocked. ,         . <br><blockquote> <b>Dictionary</b> <br><ul><li>   ,    </li><li>     ,   ? <br> ‚Äî  Resize  buckets  entries   <br> ‚Äî      - <br> ‚Äî    Dictionary.Entry <br> ‚Äî   -   </li></ul><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://blogs.msdn.microsoft.com/tess/2009/12/21/high-cpu-in-net-app-using-a-static-generic-dictionary/</a> </blockquote>     ,       Dictionary       -  bucket'.       ,      .    ,     ,        .       ,       ,    . <br><br>      Entry  Dictionary.     - -    .  ,     . <br><br><img src="https://habrastorage.org/webt/4p/xb/aq/4pxbaqil2cd4jaxnayxjqz-5yae.jpeg"><br><br>    .NET Framework  1.1.     Hashtable,   Dictionary,    object'.     MSDN ,      .  ,             -.   .  ,  Hashtable  .  ,      . <br><br><h3> 4.4    Dictionary.Entry </h3><br><img src="https://habrastorage.org/webt/y2/ww/rs/y2wwrslyuqpioqcalmpnt8dh6cw.jpeg"><br>    ? Dictionary.Entry ,  ,  8 , ,  ,   ,     .  Comment faire <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> writing; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; buckets[index] = ‚Ä¶; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version++; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>   :  (    ,    )  int-.   ,  .   ,     , ,  ,  . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> writing; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version; bucket = bickets[index]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.writing || version != <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.version) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>    ,     ,         .       ,   .       ,  8 . <br><br><h3> 4.5   -   </h3><br>  ,   . <br><br><img src="https://habrastorage.org/webt/hh/bp/0l/hhbp0leb95qndz4bmg-2gtvmeue.jpeg"><br><br>  Dictionary     bucket    ,     . <br><br>  Dictionary,    .      : 0  2.   bucket, 1       2.   ?     0.   ,       ,    2.     .   ,  2,       , , 1. 1       2 ‚Äî     bucket.   ,      ,   .    1 ‚Äî ,     bucket.  Hashtable     ,     bucket'  -.        ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">double hashing</a> . <br><br><h3> 4.6   </h3><br><ul><li>     </li><li>      </li></ul><br>  <b>Record</b> <br><br><ul><li>        </li><li>    ,  resize </li></ul><br>  <b>La lecture</b> <br><br><ul><li>     ,      </li></ul><br>        .         ,       Buckets,     Entries (   Buckets,     Entries).   -  ,       ,   ,          ,    . <br><br>             .    ,    . <br><br>  :     ,      ,    ,     ,     . ,       ,   . <br><br><img src="https://habrastorage.org/webt/pm/lo/ah/pmloah0wlfbq7ilvlnrvbh3pyuu.png"><br><br>     ,   , ‚Äî  . <br><br>   ?   ,  -    2.   -   Capacity  ,            .    ‚Äî 2.       ,   .      2.    ?  ,  ,     ,   .    -  ,        ,       3. ,    ,  ,    ,  ,  . <br><br>  ,    Hashtable,  .   ,     double hashing.     ,       ,   ,     . <br><br>   ,      ,     ‚Äî   ,            .     Hashtable.   ,    ‚Äî     ‚Äî       .                 .  ,     bucket',       -  ,       .  . <br><br>     ,  ,   lock-free      LOH. <br><br><img src="https://habrastorage.org/webt/pg/2b/6b/pg2b6bbfkm_3nnkds27g2krziz8.jpeg"><br><br>   lock-free ?  MSDN    Hashtable ,      .    ,            ,            . <br><br><img src="https://habrastorage.org/webt/yu/sg/he/yusghe0crfu9ywaic0aozpr7wri.jpeg"><br><br>      ,     ,        ,   bucket'.         Dictionary  bucket',  -,   bucket'      .    -    bucket,  bucket  .      ,     . <br><br>  ,       Large Object Heap. <br><br><img src="https://habrastorage.org/webt/wf/po/8o/wfpo8ou1_fpzhdkgcdbjzw-7u9q.jpeg"><br><br>      .  CustomDictionary  CustomDictionarySegment    .   Dictionary,    ,      .   ‚Äî   Dictionary,      .       ,      Large Object Heap.        ,   bucket'   . ,      ,    ,   bucket,     - - . <br><br>           .       ConcurrentDictionary,     .NET,        ,      . <br><br><h3> 4.7  </h3><br><ul><li> .NET   </li><li>    </li><li>   </li><li> ,     </li><li>   </li><li>   </li></ul><br>     ? .NET  .   .   ,     ,       .    -   ‚Äî   - .   ,  , ,     . <br><br>  -   , ,   ,     ,   .   ,   ,   ,        , ,          .   ‚Äî   , ,   . <br><br><h3>  Liens utiles </h3><br><ul><li>   ConcurrentDictionary: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://habr.com/ru/company/skbkontur/blog/348508/</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/vostok/commons.threading</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/epeshk/dotnext-2019-threading</a> </li></ul><br>   ‚Äî          ConcurrentDictionary. ,      ,   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Diafilm</a> ),       . <br><br>      GitHub.   ‚Äî     ,    ,    LIFO-Semaphore,    .       ,    . <br><blockquote> 6-7     <b>DotNext 2019 Moscow</b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´.NET:  ¬ª</a>    ,        .NET Framework  .NET Core,  ,        . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468611/">https://habr.com/ru/post/fr468611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468601/index.html">Estimation de la dur√©e du projet. Pourquoi est-il presque toujours tr√®s discret et que faire?</a></li>
<li><a href="../fr468603/index.html">Rutracker a inclus eSNI. Fin de l'√®re DPI et fin des verrous</a></li>
<li><a href="../fr468605/index.html">Pointeurs constants √† pointeurs √† pointeurs ...</a></li>
<li><a href="../fr468607/index.html">Android pour l'ing√©nieur radio (deuxi√®me partie)</a></li>
<li><a href="../fr468609/index.html">Inconcevable efficacit√© d'envoi multiple</a></li>
<li><a href="../fr468615/index.html">Les 10 meilleures langues pour la localisation d'applications</a></li>
<li><a href="../fr468621/index.html">Nous traduisons le r√©seau domestique en DoH, ou un autre clic sur le nez de filtrage</a></li>
<li><a href="../fr468623/index.html">Je veux des avis sur Habr</a></li>
<li><a href="../fr468625/index.html">Sans serveur: 15% plus lent et huit fois plus cher</a></li>
<li><a href="../fr468627/index.html">Modules d'E / S ADAM-6200</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>