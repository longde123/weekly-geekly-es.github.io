<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📂 👞 🐗 Dart 2. Pemrograman asinkron: masa depan 🐪 🌦️ 🙅🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pemrograman Asinkron: masa depan 


 Isi 


- Pendahuluan 
- Apa masa depan 
- Async - tunggu Menangani kesalahan Eksekusi berurutan 
- Menangani kesa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dart 2. Pemrograman asinkron: masa depan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442282/"><h1 id="asinhronnoe-programmirovanie-futures">  Pemrograman Asinkron: masa depan </h1><br><p>  <strong>Isi</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa masa depan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Async - tunggu</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menangani kesalahan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Eksekusi berurutan</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API masa depan</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menangani kesalahan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memanggil beberapa fungsi untuk mengembalikan masa depan</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa lagi yang harus dibaca?</a> </li></ul><br><p>  <strong>Yang penting:</strong> </p><br><ul><li>  Kode di Dart berjalan dalam satu utas ( <em>catatan utas - utas</em> ) eksekusi. </li><li>  Karena kode yang memakan waktu (blok) utas untuk waktu yang lama, program mungkin membeku. </li><li> Objek <code>Future</code> ( <code>futures</code> ) mewakili hasil operasi asinkron - pemrosesan atau I / O, yang akan diselesaikan kemudian. </li><li>  Untuk menunda eksekusi hingga selesai di masa mendatang, gunakan <code>await</code> di fungsi asinkron (atau <code>then()</code> saat menggunakan API <code>Future</code> ). </li><li>  Untuk menangkap kesalahan, gunakan konstruksi <code>try-catch</code> (atau <code>catchError()</code> saat menggunakan API <code>Future</code> ) dalam fungsi asinkron. </li><li>  Untuk pemrosesan simultan, buat isolat (atau pekerja untuk aplikasi web). <a name="habracut"></a></li></ul><br><p>  Kode di Dart berjalan dalam utas eksekusi tunggal.  Jika kode sibuk dengan perhitungan panjang atau sedang menunggu operasi I / O, maka seluruh program dijeda. </p><br><p>  Operasi asinkron memungkinkan program Anda untuk menyelesaikan tugas-tugas lain sambil menunggu operasi selesai.  Dart menggunakan <code>futures</code> untuk menyajikan hasil operasi asinkron.  Anda juga dapat menggunakan async dan menunggu atau Future API untuk bekerja dengan <code>futures</code> . </p><br><p>  <em>Sebuah catatan</em> </p><br><blockquote>  Semua kode dieksekusi dalam konteks isolat, yang memiliki semua memori yang digunakan oleh kode.  Lebih dari satu eksekusi kode tidak dapat dimulai pada isolat yang sama. <br><br>  Untuk eksekusi paralel blok kode, Anda dapat memisahkannya menjadi isolat terpisah.  (Aplikasi Web menggunakan pekerja alih-alih isolat.) Biasanya, masing-masing isolat berjalan pada inti prosesornya sendiri.  Isolat tidak berbagi memori, dan satu-satunya cara mereka berinteraksi adalah saling mengirim pesan.  Untuk menyelami topik ini, lihat dokumentasi untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">isolat</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pekerja</a> . </blockquote><br><h2 id="vvedenie">  Pendahuluan </h2><br><p>  Mari kita lihat contoh kode yang dapat "membekukan" eksekusi program: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Synchronous code void printDailyNewsDigest() { var newsDigest = gatherNewsReports(); // Can take a while. print(newsDigest); } main() { printDailyNewsDigest(); printWinningLotteryNumbers(); printWeatherForecast(); printBaseballScore(); }</span></span></code> </pre> <br><p>  Program kami membaca berita dari file untuk hari itu, menampilkannya, lalu menampilkan informasi yang masih menarik bagi pengguna: </p><br><pre> <code class="plaintext hljs">&lt;gathered news goes here&gt; Winning lotto numbers: [23, 63, 87, 26, 2] Tomorrow's forecast: 70F, sunny. Baseball score: Red Sox 10, Yankees 0</code> </pre> <br><p>  Dalam contoh ini, masalahnya adalah bahwa semua operasi setelah memanggil <code>gatherNewsReports()</code> akan menunggu sampai <code>gatherNewsReports()</code> akan mengembalikan konten file, tidak peduli berapa lama.  Jika membaca file membutuhkan waktu lama, pengguna akan dipaksa untuk menunggu hasil undian, ramalan cuaca dan pemenang dari permainan baru-baru ini. </p><br><p>  Untuk mempertahankan respons aplikasi, penulis Dart menggunakan model asinkron untuk mengidentifikasi fungsi yang berpotensi melakukan pekerjaan mahal.  Fungsi tersebut mengembalikan nilainya menggunakan <code>futures</code> . </p><br><h2 id="chto-takoe-future">  Apa masa depan </h2><br><p>  <code>future</code> - turunan dari kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Future &lt;T&gt;</a> , yang merupakan operasi asinkron yang mengembalikan hasil tipe T. Jika hasil operasi tidak digunakan, maka tipe <code>future</code> ditunjukkan oleh <code>Future&lt;void&gt;</code> .  Saat memanggil fungsi yang mengembalikan <code>future</code> , dua hal terjadi: </p><br><ol><li>  Fungsi antrian untuk eksekusi dan mengembalikan objek <code>Future</code> tidak lengkap. </li><li>  Kemudian, ketika operasi selesai, <code>future</code> berakhir dengan nilai atau kesalahan. </li></ol><br><p>  Untuk menulis kode yang tergantung di masa <code>future</code> , Anda memiliki dua opsi: </p><br><ul><li>  Gunakan <code>async</code> - <code>await</code> </li><li>  Gunakan <code>Future</code> API </li></ul><br><h2 id="async---await">  Async - tunggu </h2><br><p>  <code>async</code> dan <code>await</code> kata kunci adalah bagian dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dukungan</a> <code>async</code> Dart.  Mereka memungkinkan Anda untuk menulis kode asinkron yang terlihat seperti kode sinkron dan tidak menggunakan API <code>Future</code> .  <em>Fungsi asinkron</em> adalah fungsi dengan kata kunci <code>async</code> di depan tubuhnya.  Kata kunci yang <code>await</code> hanya berfungsi dalam fungsi asinkron. </p><br><blockquote>  Catatan: di Dart 1.x, fungsi asinkron segera menunda eksekusi.  Di Dart 2, alih-alih segera berhenti, fungsi asinkron menjalankan secara sinkron sampai yang pertama <code>await</code> atau <code>return</code> . </blockquote><p>  Kode berikut mensimulasikan membaca berita dari file menggunakan <code>async</code> - <code>await</code> .  Buka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DartPad dengan aplikasi</a> , luncurkan dan klik CONSOLE untuk melihat hasilnya. </p><br><div class="spoiler">  <b class="spoiler_title">Kode contoh</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Copyright (c) 2013, the Dart project authors. Please see the AUTHORS file // for details. All rights reserved. Use of this source code is governed by a // BSD-style license that can be found in the LICENSE file. import 'dart:async'; Future&lt;void&gt; printDailyNewsDigest() async { var newsDigest = await gatherNewsReports(); print(newsDigest); } main() { printDailyNewsDigest(); printWinningLotteryNumbers(); printWeatherForecast(); printBaseballScore(); } printWinningLotteryNumbers() { print('Winning lotto numbers: [23, 63, 87, 26, 2]'); } printWeatherForecast() { print("Tomorrow's forecast: 70F, sunny."); } printBaseballScore() { print('Baseball score: Red Sox 10, Yankees 0'); } const news = '&lt;gathered news goes here&gt;'; const oneSecond = Duration(seconds: 1); // Imagine that this function is more complex and slow. :) Future&lt;String&gt; gatherNewsReports() =&gt; Future.delayed(oneSecond, () =&gt; news); // Alternatively, you can get news from a server using features // from either dart:io or dart:html. For example: // // import 'dart:html'; // // Future&lt;String&gt; gatherNewsReportsFromServer() =&gt; HttpRequest.getString( // 'https://www.dartlang.org/f/dailyNewsDigest.txt', // );</span></span></code> </pre> </div></div><br><p>  Perhatikan bahwa kita pertama-tama memanggil <code>printDailyNewsDigest()</code> , tetapi berita dicetak terakhir, bahkan jika file tersebut hanya berisi satu baris.  Ini karena kode yang membaca dan mencetak file berjalan secara tidak sinkron. </p><br><p>  Dalam contoh ini, <code>printDailyNewsDigest()</code> melakukan panggilan ke <code>gatherNewsReports()</code> , yang non-pemblokiran.  Memanggil metode <code>gatherNewsReports()</code> pekerjaan, tetapi tidak menghentikan sisa kode dari mengeksekusi.  Program ini menampilkan angka lotre, perkiraan dan skor pertandingan bisbol;  Program ini mencetak berita setelah pengumpulan <code>gatherNewsReports()</code> .  Jika <code>gatherNewsReports()</code> membutuhkan waktu untuk menyelesaikan pekerjaannya, tidak ada hal buruk terjadi: pengguna dapat membaca hal-hal lain sebelum ringkasan berita harian dicetak. </p><br><p>  Perhatikan jenis yang dikembalikan.  Tipe <code>gatherNewsReports()</code> fungsi <code>gatherNewsReports()</code> adalah <code>Future&lt;String&gt;</code> , yang berarti bahwa ia mengembalikan <code>future</code> yang berakhir dengan nilai string.  Fungsi <code>printDailyNewsDigest()</code> , yang tidak mengembalikan nilai, memiliki tipe pengembalian <code>Future&lt;void&gt;</code> . </p><br><p>  Diagram berikut menunjukkan langkah-langkah pelaksanaan kode. </p><br><p><img src="https://habrastorage.org/webt/cs/ez/9h/csez9hgmhhk6r1fyu8c4jryuydi.png"></p><br><ol><li>  Aplikasi mulai berjalan. </li><li>  Fungsi <code>main()</code> <code>printDailyNewsDigest()</code> fungsi asinkron <code>printDailyNewsDigest()</code> , yang mulai berjalan secara sinkron. </li><li>  <code>printDailyNewsDigest()</code> menggunakan <code>await</code> untuk memanggil fungsi <code>gatherNewsReports()</code> , yang mulai berjalan. </li><li>  <code>gatherNewsReports()</code> mengembalikan <code>future</code> belum selesai (turunan <code>Future&lt;String&gt;</code> ). </li><li>  Karena <code>printDailyNewsDigest()</code> adalah fungsi asinkron dan mengharapkan suatu nilai, itu menjeda eksekusi dan mengembalikan <code>future</code> tidak lengkap (dalam hal ini, <code>Future&lt;void&gt;</code> ) ke fungsi <code>main ()</code> . </li><li>  Fungsi output lainnya dijalankan.  Karena mereka sinkron, setiap fungsi dilakukan sepenuhnya sebelum pindah ke yang berikutnya.  Misalnya, semua nomor lotere yang menang akan ditampilkan sebelum ramalan cuaca. </li><li>  Setelah menyelesaikan <code>main()</code> fungsi asinkron dapat melanjutkan eksekusi.  Pertama, kita mendapatkan <code>future</code> dengan berita tentang selesainya <code>gatherNewsReports()</code> .  Kemudian <code>printDailyNewsDigest()</code> melanjutkan eksekusi, menampilkan berita. </li><li>  Pada akhir eksekusi <code>printDailyNewsDigest()</code> , <code>future</code> diterima awalnya <code>future</code> dan aplikasi keluar. </li></ol><br><p>  Perhatikan bahwa fungsi asinkron dimulai segera (secara sinkron).  Fungsi ini menjeda eksekusi dan mengembalikan <code>future</code> belum selesai saat kemunculan pertama dari salah satu dari berikut ini terjadi: </p><br><ul><li>  Ekspresi <code>await</code> pertama (setelah fungsi mendapatkan <code>future</code> tidak lengkap dari ekspresi ini). </li><li>  <code>return</code> dalam suatu fungsi. </li><li>  Akhir dari fungsi tubuh. </li></ul><br><h3 id="obrabotka-oshibok">  Menangani kesalahan </h3><br><p>  Kemungkinan besar Anda ingin "menangkap" kesalahan dalam pelaksanaan fungsi yang mengembalikan <code>future</code> .  Dalam fungsi asinkron, Anda dapat menangani kesalahan menggunakan <code>try-catch</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDailyNewsDigest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> async </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newsDigest = <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gatherNewsReports</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; print(newsDigest); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-comment"><span class="hljs-comment">// Handle error... } }</span></span></code> </pre> <br><p>  <code>try-catch</code> dengan kode asynchronous berperilaku sama dengan kode sinkron: jika kode di blok <code>try</code> pengecualian, kode di dalam <code>catch</code> dijalankan. </p><br><h3 id="posledovatelnoe-vypolnenie">  Eksekusi berurutan </h3><br><p>  Anda dapat menggunakan beberapa ekspresi <code>await</code> untuk memastikan bahwa setiap pernyataan selesai sebelum menjalankan yang berikut: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Sequential processing using async and await. main() async { await expensiveA(); await expensiveB(); doSomethingWith(await expensiveC()); }</span></span></code> </pre> <br><p>  Fungsi <code>expensiveB()</code> tidak dieksekusi sampai <code>expensiveA()</code> selesai, dan seterusnya. </p><br><h2 id="future-api">  API masa depan </h2><br><p>  Sebelum <code>async</code> dan <code>await</code> ditambahkan di Dart 1.9, Anda harus menggunakan API <code>Future</code> .  Anda masih dapat melihat penggunaan <code>Future</code> API dalam kode lama dan dalam kode yang membutuhkan lebih banyak fungsi daripada yang ditawarkan <code>async–await</code> . </p><br><p>  Untuk menulis kode asinkron menggunakan API <code>Future</code> , gunakan metode <code>then()</code> untuk mendaftarkan panggilan balik.  Panggilan balik ini akan berfungsi saat <code>future</code> selesai. </p><br><p>  Kode berikut mensimulasikan pembacaan berita dari file menggunakan <code>Future</code> API.  Buka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DartPad dengan aplikasi</a> , luncurkan dan klik CONSOLE untuk melihat hasilnya. </p><br><div class="spoiler">  <b class="spoiler_title">Kode contoh</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Copyright (c) 2013, the Dart project authors. Please see the AUTHORS file // for details. All rights reserved. Use of this source code is governed by a // BSD-style license that can be found in the LICENSE file. import 'dart:async'; Future&lt;void&gt; printDailyNewsDigest() { final future = gatherNewsReports(); return future.then(print); // You don't *have* to return the future here. // But if you don't, callers can't await it. } main() { printDailyNewsDigest(); printWinningLotteryNumbers(); printWeatherForecast(); printBaseballScore(); } printWinningLotteryNumbers() { print('Winning lotto numbers: [23, 63, 87, 26, 2]'); } printWeatherForecast() { print("Tomorrow's forecast: 70F, sunny."); } printBaseballScore() { print('Baseball score: Red Sox 10, Yankees 0'); } const news = '&lt;gathered news goes here&gt;'; const oneSecond = Duration(seconds: 1); // Imagine that this function is more complex and slow. :) Future&lt;String&gt; gatherNewsReports() =&gt; Future.delayed(oneSecond, () =&gt; news); // Alternatively, you can get news from a server using features // from either dart:io or dart:html. For example: // // import 'dart:html'; // // Future&lt;String&gt; gatherNewsReportsFromServer() =&gt; HttpRequest.getString( // 'https://www.dartlang.org/f/dailyNewsDigest.txt', // );</span></span></code> </pre> </div></div><br><p>  Perhatikan bahwa kita pertama-tama memanggil <code>printDailyNewsDigest()</code> , tetapi berita dicetak terakhir, bahkan jika file tersebut hanya berisi satu baris.  Ini karena kode yang membaca dan mencetak file berjalan secara tidak sinkron. </p><br><p>  Aplikasi ini berjalan sebagai berikut: </p><br><ol><li>  Aplikasi mulai berjalan. </li><li>  Fungsi utama memanggil <code>printDailyNewsDigest()</code> , yang tidak langsung mengembalikan hasilnya, tetapi panggilan pertama <code>gatherNewsReports()</code> . </li><li>  <code>gatherNewsReports()</code> mulai membaca berita dan kembali di <code>future</code> . </li><li>  <code>printDailyNewsDigest()</code> menggunakan <code>then()</code> untuk mendaftarkan panggilan balik yang akan mengambil sebagai parameter nilai yang diperoleh pada akhir <code>future</code> .  Panggilan <code>then()</code> mengembalikan <code>future</code> baru, yang berakhir dengan nilai yang dikembalikan oleh callback dari <code>then()</code> . </li><li>  Sisa dari fungsi output dieksekusi.  Karena mereka sinkron, setiap fungsi dilakukan sepenuhnya sebelum pindah ke yang berikutnya.  Misalnya, semua nomor lotere yang menang akan ditampilkan sebelum ramalan cuaca. </li><li>  Ketika semua berita telah diterima, <code>future</code> dikembalikan oleh fungsi <code>gatherNewsReports()</code> berakhir dengan string yang berisi berita yang dikumpulkan. </li><li>  Kode yang ditentukan <code>then()</code> di <code>printDailyNewsDigest()</code> dijalankan untuk <code>printDailyNewsDigest()</code> berita. </li><li>  Aplikasi dimatikan. </li></ol><br><blockquote>  Catatan: dalam fungsi <code>printDailyNewsDigest()</code> , kode <code>future.then(print)</code> setara dengan yang berikut: <code>future.then((newsDigest) =&gt; print(newsDigest))</code> . </blockquote><p>  Selain itu, kode di dalamnya <code>then()</code> dapat menggunakan kurung kurawal: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDailyNewsDigest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> future = gatherNewsReports(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> future.then((newsDigest) { print(newsDigest); <span class="hljs-comment"><span class="hljs-comment">// Do something else... }); }</span></span></code> </pre> <br><p>  Anda harus menentukan argumen panggilan balik di <code>then()</code> , bahkan jika <code>future</code> adalah tipe <code>Future&lt;void&gt;</code> .  Dengan konvensi, argumen yang tidak digunakan didefinisikan melalui <code>_</code> (garis bawah). </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> future = printDailyNewsDigest(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> future.then((_) { <span class="hljs-comment"><span class="hljs-comment">// Code that doesn't use the `_` parameter... print('All reports printed.'); });</span></span></code> </pre> <br><h3 id="obrabotka-oshibok-1">  Menangani kesalahan </h3><br><p>  Menggunakan <code>Future</code> API, Anda dapat menangkap kesalahan menggunakan <code>catchError()</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Future&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printDailyNewsDigest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; gatherNewsReports().then(print).catchError(handleError);</code> </pre> <br><p>  Jika berita tidak dapat dibaca, maka kode di atas dijalankan sebagai berikut: </p><br><ol><li>  <code>future</code> dikembalikan oleh <code>gatherNewsReports()</code> gagal. </li><li>  <code>future</code> dikembalikan <code>then()</code> gagal, <code>print()</code> tidak dipanggil. </li><li>  <code>catchError()</code> di <code>catchError()</code> ( <code>handleError()</code> ) menangkap kesalahan, <code>future</code> dikembalikan oleh <code>catchError()</code> selesai secara normal, dan kesalahan tidak menyebar lebih lanjut. </li></ol><br><blockquote>  Rantai <code>catchError()</code> - <code>catchError()</code> adalah pola umum saat menggunakan API <code>Future</code> .  Pertimbangkan pasangan ini sebagai setara dengan <code>try-catch</code> di <code>Future</code> API. </blockquote><p>  Seperti then (), catchError () mengembalikan <code>future</code> baru yang berakhir dengan nilai balik dari callback.  Untuk menyelami topik, baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Futures and Error Handling</a> . </p><br><h3 id="vyzov-neskolkih-funkciy-vozvraschayuschih-future">  Memanggil beberapa fungsi untuk mengembalikan <code>future</code> </h3><br><p>  Mari kita perhatikan tiga fungsi: <code>expensiveA()</code> , <code>expensiveB()</code> , <code>expensiveC()</code> , yang mengembalikan <code>future</code> .  Anda dapat memanggil mereka secara berurutan (satu fungsi dimulai setelah yang sebelumnya selesai), atau Anda dapat menjalankan semuanya sekaligus dan melakukan sesuatu segera setelah semua nilai kembali.  Antarmuka Future cukup fleksibel untuk mengimplementasikan kedua use case. </p><br><p>  <strong>Rantai panggilan fungsi menggunakan <code>then()</code></strong> <br>  Ketika fungsi mengembalikan <code>future</code> harus dijalankan secara berurutan, gunakan rantai sejak <code>then()</code> : </p><br><pre> <code class="java hljs">expensiveA() .then((aValue) =&gt; expensiveB()) .then((bValue) =&gt; expensiveC()) .then((cValue) =&gt; doSomethingWith(cValue));</code> </pre> <br><p>  Melampirkan panggilan balik juga berfungsi, tetapi lebih sulit untuk dibaca.  ( <em>perhatikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://callbackhell.com/</a></em> ) </p><br><p>  <strong>Menunggu beberapa <code>futures</code> selesai menggunakan <code>Future.wait()</code></strong> <br>  Jika urutan eksekusi fungsi tidak penting, Anda dapat menggunakan <code>Future.wait()</code> .  Ketika Anda menentukan daftar <code>futures</code> untuk parameter untuk fungsi Future.wait (), itu segera mengembalikan <code>future</code> .  <code>future</code> ini tidak akan berakhir sampai semua <code>futures</code> ditentukan <code>futures</code> .  <code>future</code> ini akan berakhir dengan daftar hasil dari semua masa <code>futures</code> ditunjukkan. </p><br><pre> <code class="java hljs">Future.wait([expensiveA(), expensiveB(), expensiveC()]) .then((List responses) =&gt; chooseBestResponse(responses, moreInfo)) .catchError(handleError);</code> </pre> <br><p>  Jika panggilan ke salah satu fungsi gagal, maka <code>future</code> dikembalikan oleh <code>Future.wait()</code> juga gagal.  Gunakan <code>catchError()</code> untuk menangkap kesalahan ini. </p><br><hr><br><h2 id="chto-esche-pochitat">  Apa lagi yang harus dibaca? </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dart 2. Pemrograman Asinkron: Aliran Data</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442282/">https://habr.com/ru/post/id442282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442270/index.html">5 Kesalahan yang Harus Dihindari Saat Membuat Model 3D untuk Pencetakan 3D</a></li>
<li><a href="../id442272/index.html">Go + = versi paket</a></li>
<li><a href="../id442274/index.html">Dart 2. Pemrograman Asinkron: Aliran Data</a></li>
<li><a href="../id442278/index.html">Panduan Pengguna Kibana. Visualisasi. Bagian 6</a></li>
<li><a href="../id442280/index.html">Pembelajaran Mesin di Dodo. Cara meluncurkan arah baru jika Anda seorang pengembang</a></li>
<li><a href="../id442284/index.html">NoVerify: linter untuk PHP dari Tim VKontakte sekarang berada di domain publik</a></li>
<li><a href="../id442286/index.html">Dokter mata Rusia berbicara tentang visi bionik. Aplikasi mobile baru menunjukkan karya siber</a></li>
<li><a href="../id442288/index.html">Radiasi: sumber</a></li>
<li><a href="../id442290/index.html">Membuat ST-Link V2.1 dari Bahasa Cina ST-Link V2</a></li>
<li><a href="../id442292/index.html">Magang Sberseason: Python, UX / UI, Data dan banyak lagi untuk siswa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>