<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺🏻 🎅🏿 👴🏾 O que você precisa saber sobre matrizes JavaScript 🌼 🤸🏼 👨‍👨‍👧‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apresentamos a você a tradução de um artigo de Thomas Lombart, publicado em medium.freecodecamp.org. A tradução é publicada com permissão do autor. 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O que você precisa saber sobre matrizes JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/446902/">  Apresentamos a você a tradução de um artigo de Thomas Lombart, publicado em medium.freecodecamp.org.  A tradução é publicada com permissão do autor. <br><br><img src="https://habrastorage.org/webt/sm/gs/6k/smgs6kbtqkaxsoz79qtt2on6m5c.png"><br>  <i>Um exemplo de uso do método de redução para reduzir uma matriz</i> <br><br>  Deixe-me fazer uma declaração ousada: os loops geralmente são inúteis e dificultam a leitura do código.  Para iterações em matrizes, pesquisa, classificação de elementos e outras ações semelhantes, você pode usar um dos métodos abaixo. <br><br>  Apesar da eficácia, a maioria desses métodos ainda é pouco conhecida e pouco popular.  Farei o trabalho duro por você e falarei sobre os mais úteis.  Leia este artigo como seu guia para métodos de matriz JavaScript. <a name="habracut"></a><br><br>  <b>Nota</b> : Antes de começarmos, você precisa saber uma coisa: sou inclinado para a programação funcional.  Para evitar efeitos colaterais, eu me esforço para aplicar métodos que não modificam diretamente a matriz original.  Não estou dizendo para você se recusar a alterar a matriz, mas vale a pena considerar que alguns métodos levam a isso.  Como resultado, efeitos colaterais, alterações indesejadas e, como resultado, erros aparecem. <br><br>  Este artigo foi publicado originalmente em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">thomlom.dev</a> , onde você pode encontrar mais material de desenvolvimento da Web. <br><br><h3>  O básico </h3><br>  Existem quatro métodos que vale a pena saber se você estiver trabalhando com matrizes.  Estes são <code>map</code> , <code>filter</code> , <code>reduce</code> e o operador de <code>spread</code> .  Eles são eficazes e úteis. <br><br>  <b>mapa</b> <br>  Você costuma usar o método de <code>map</code> .  Em geral, sempre que precisar alterar os elementos de uma matriz, considere esta opção. <br><br>  É necessário um parâmetro - uma função que é chamada em cada elemento da matriz e, em seguida, retorna uma <b>nova matriz</b> para que não haja efeitos colaterais. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbersPlusOne = numbers.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(numbersPlusOne) <span class="hljs-comment"><span class="hljs-comment">// [2, 3, 4, 5]</span></span></code> </pre> <br>  Você também pode criar uma nova matriz que armazena apenas uma propriedade específica do objeto. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allActivities = [ { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'My activity'</span></span>, <span class="hljs-attr"><span class="hljs-attr">coordinates</span></span>: [<span class="hljs-number"><span class="hljs-number">50.123</span></span>, <span class="hljs-number"><span class="hljs-number">3.291</span></span>] }, { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Another activity'</span></span>, <span class="hljs-attr"><span class="hljs-attr">coordinates</span></span>: [<span class="hljs-number"><span class="hljs-number">1.238</span></span>, <span class="hljs-number"><span class="hljs-number">4.292</span></span>] } ] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allCoordinates = allActivities.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">activity</span></span></span><span class="hljs-function"> =&gt;</span></span> activity.coordinates) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(allCoordinates) <span class="hljs-comment"><span class="hljs-comment">// [[50.123, 3.291], [1.238, 4.292]]</span></span></code> </pre> <br>  Portanto, lembre-se: quando precisar <b>alterar uma</b> matriz, pense em usar o <b>mapa</b> . <br><br>  <b>filtrar</b> <br>  O nome desse método fala por si: use-o quando desejar filtrar uma matriz. <br><br>  Como o <code>map</code> , o <code>filter</code> usa como único parâmetro uma função que é chamada em cada elemento da matriz.  Esta função deve retornar um valor booleano: <br><br><ul><li>  <code>true</code> - se você deseja <b>salvar o</b> elemento em uma matriz; </li><li>  <code>false</code> - se você não quiser salvá-lo. </li></ul><br>  Como resultado, você terá a nova matriz correta com os elementos que deseja deixar. <br><br>  Por exemplo, apenas números ímpares podem ser armazenados em uma matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oddNumbers = numbers.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function"> =&gt;</span></span> n % <span class="hljs-number"><span class="hljs-number">2</span></span> !== <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(oddNumbers) <span class="hljs-comment"><span class="hljs-comment">// [1, 3, 5]</span></span></code> </pre><br>  Você também pode usar o filtro para remover um elemento específico da matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> participants = [ { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'a3f47'</span></span>, <span class="hljs-attr"><span class="hljs-attr">username</span></span>: <span class="hljs-string"><span class="hljs-string">'john'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'fek28'</span></span>, <span class="hljs-attr"><span class="hljs-attr">username</span></span>: <span class="hljs-string"><span class="hljs-string">'mary'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'n3j44'</span></span>, <span class="hljs-attr"><span class="hljs-attr">username</span></span>: <span class="hljs-string"><span class="hljs-string">'sam'</span></span> }, ] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeParticipant</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">participants, id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> participants.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">participant</span></span></span><span class="hljs-function"> =&gt;</span></span> participant.id !== id) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(removeParticipant(participants, <span class="hljs-string"><span class="hljs-string">'a3f47'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// [{ id: 'fek28', username: 'mary' }, { id: 'n3j44', username: 'sam' }];</span></span></code> </pre> <br>  <b>reduzir</b> <br>  Na minha opinião, esse método é o mais difícil de entender.  Mas assim que dominá-lo, você terá várias oportunidades. <br><br>  Normalmente, o método de <code>reduce</code> pega uma matriz de valores e concatena-os em um único valor.  São necessários dois parâmetros, uma função de retorno de chamada (que é o <b>redutor</b> ) e um valor inicial opcional (que é o primeiro elemento da matriz por padrão).  A caixa de engrenagens possui quatro parâmetros: <br><br><ul><li>  uma bateria que coleta os valores retornados na <b>caixa de velocidades</b> ; </li><li>  valor atual da matriz; </li><li>  índice atual; </li><li>  a matriz para a qual o método de <code>reduce</code> foi chamado. </li></ul><br>  Basicamente, você usará apenas os dois primeiros parâmetros - a bateria e o valor atual. <br><br>  Mas não vamos aprofundar a teoria e considerar o exemplo mais comum de aplicação de <code>reduce</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">37</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> total = numbers.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">total, n</span></span></span><span class="hljs-function">) =&gt;</span></span> total + n) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(total) <span class="hljs-comment"><span class="hljs-comment">// 90</span></span></code> </pre> <br>  Na primeira iteração, o acumulador, que é a soma, assume o valor inicial 37. O valor retornado é 37 + n, onde n = 12. Obtemos 49. <br><br>  Durante a segunda iteração, o acumulador é 49, o valor retornado é 49 + 28 = 77. E assim por diante. <br><br>  O método de <code>reduce</code> é tão funcional que você pode usá-lo para criar muitos métodos de matriz, como <code>map</code> ou <code>filter</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> map = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr, fn</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">mappedArr, element</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [...mappedArr, fn(element)] }, []) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(map([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>], n =&gt; n + <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// [2, 3, 4, 5] const filter = (arr, fn) =&gt; { return arr.reduce((filteredArr, element) =&gt; { return fn(element) ? [...filteredArr] : [...filteredArr, element] }, []) } console.log(filter([1, 2, 3, 4, 5, 6], n =&gt; n % 2 === 0)) // [1, 3, 5]</span></span></code> </pre> <br>  Como regra, atribuímos o valor inicial <code>[]</code> ao método de <code>reduce</code> - o acumulador.  Para o <code>map</code> executamos uma função cujo resultado é adicionado ao final da bateria usando <b>o operador spread</b> (falaremos sobre isso abaixo, não se preocupe).  Para o <code>filter</code> fazendo quase a mesma coisa, apenas executamos a função de filtro no elemento.  Se for verdade, retornamos a matriz <b>anterior</b> .  Caso contrário, adicione o elemento ao final da matriz. <br><br>  Vejamos um exemplo mais complexo: reduza muito o array <code>[1, 2, 3, [4, [[[5, [6, 7]]]], 8]]</code> para <code>[1, 2, 3, 4, 5, 6, 7, 8]</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flatDeep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arr</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">flattenArray, element</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(element) ? [...flattenArray, ...flatDeep(element)] : [...flattenArray, element] }, []) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(flatDeep([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, [<span class="hljs-number"><span class="hljs-number">4</span></span>, [[[<span class="hljs-number"><span class="hljs-number">5</span></span>, [<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>]]]], <span class="hljs-number"><span class="hljs-number">8</span></span>]])) <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span></code> </pre> <br>  Este exemplo é muito semelhante ao <code>map</code> , exceto pelo fato de usarmos recursão aqui.  Não vou me deter na recursão em detalhes, porque isso está além do escopo de nosso tópico, mas se você quiser saber mais, acesse este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">excelente recurso</a> . <br><br>  <b>Declaração de spread (ES2015)</b> <br>  Eu concordo, este não é um método.  No entanto, o operador de spread ajuda a atingir objetivos diferentes ao trabalhar com matrizes.  Você pode aplicá-lo para expandir os valores de uma matriz em outra e, em seguida, fazer uma cópia ou vincular várias matrizes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbersCopy = [...numbers] <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(numbersCopy) <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3] const otherNumbers = [4, 5, 6] const numbersConcatenated = [...numbers, ...otherNumbers] console.log(numbersConcatenated) // [1, 2, 3, 4, 5, 6]</span></span></code> </pre> <br>  <b>Nota</b> : a declaração de spread faz uma <b>cópia superficial da</b> matriz original.  Mas o que significa "superficial"? <br><br>  Essa cópia duplicará os elementos originais o mínimo possível.  Se você tiver uma matriz com números, seqüências de caracteres ou valores booleanos ( <b>tipos primitivos</b> ), não haverá problemas e os valores serão realmente duplicados.  No entanto, as coisas são diferentes com <b>objetos</b> e <b>matrizes</b> : apenas uma <b>referência</b> ao valor original é copiada.  Portanto, se você fizer uma cópia superficial da matriz, incluindo o objeto e alterar o objeto na matriz copiada, ela também será alterada no original, porque eles têm a <b>mesma referência</b> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Thomas'</span></span> }] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> copy = [...arr] copy[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">'bar'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr) <span class="hljs-comment"><span class="hljs-comment">// No mutations: ["foo", 42, { name: "Thomas" }] console.log(copy) // ["bar", 42, { name: "Thomas" }] copy[2].name = 'Hello' console.log(arr) // /!\ MUTATION ["foo", 42, { name: "Hello" }] console.log(copy) // ["bar", 42, { name: "Hello" }]</span></span></code> </pre> <br>  Portanto, se você quiser criar uma cópia real de uma matriz que contenha um objeto ou matrizes, poderá usar uma função <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lodash</a> como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cloneDeep</a> .  Mas não se considere obrigado a fazer isso.  Seu objetivo é <b>descobrir como tudo funciona sob o capô</b> . <br><br><h3>  Métodos úteis </h3><br>  Abaixo, você encontrará outros métodos que também são úteis e que podem ser úteis para solucionar problemas, como encontrar um elemento em uma matriz, remover parte de uma matriz e muito mais. <br><br>  <b>inclui (ES2015)</b> <br>  Você já usou o <code>indexOf</code> para descobrir se há um elemento em uma matriz ou não?  Uma maneira terrível de verificar, certo? <br><br>  Felizmente, o método <code>includes</code> faz a validação para nós.  Defina o parâmetro para includes e ele procurará o elemento na matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sports = [<span class="hljs-string"><span class="hljs-string">'football'</span></span>, <span class="hljs-string"><span class="hljs-string">'archery'</span></span>, <span class="hljs-string"><span class="hljs-string">'judo'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hasFootball = sports.includes(<span class="hljs-string"><span class="hljs-string">'football'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(hasFootball) <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  <b>concat</b> <br>  O método concat pode ser usado para mesclar duas ou mais matrizes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> otherNumbers = [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbersConcatenated = numbers.concat(otherNumbers) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(numbersConcatenated) <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4, 5, 6] // You can merge as many arrays as you want function concatAll(arr, ...arrays) { return arr.concat(...arrays) } console.log(concatAll([1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12])) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span></span></code> </pre> <br>  <b>forEach</b> <br>  Se você deseja executar uma ação para cada elemento da matriz, pode usar o método <code>forEach</code> .  Ele assume uma função como parâmetro, que por sua vez também aceita três parâmetros: valor atual, índice e matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] numbers.forEach(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-comment"><span class="hljs-comment">// 1 0 [ 1, 2, 3 ] // 2 1 [ 1, 2, 3 ] // 3 2 [ 1, 2, 3 ]</span></span></code> </pre><br>  <b>indexOf</b> <br>  Este método é usado para retornar o primeiro índice no qual o elemento pode ser encontrado na matriz.  Além disso, o <code>indexOf</code> frequentemente verifica a presença de um elemento em uma matriz.  Honestamente, agora eu o uso com pouca frequência. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sports = [<span class="hljs-string"><span class="hljs-string">'football'</span></span>, <span class="hljs-string"><span class="hljs-string">'archery'</span></span>, <span class="hljs-string"><span class="hljs-string">'judo'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> judoIndex = sports.indexOf(<span class="hljs-string"><span class="hljs-string">'judo'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(judoIndex) <span class="hljs-comment"><span class="hljs-comment">// 2</span></span></code> </pre> <br>  <b>encontrar</b> <br>  O método <code>find</code> é semelhante ao <code>filter</code> .  Você precisa fornecê-lo com uma função que testa cada elemento da matriz.  No entanto, o <code>find</code> para de testar os itens assim que encontrar um que passou no teste.  Este <b>não</b> é <b>um</b> <code>filter</code> que itera por toda a matriz, independentemente das circunstâncias. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = [ { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'af35'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'john'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'6gbe'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'mary'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'932j'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gary'</span></span> }, ] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = users.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.id === <span class="hljs-string"><span class="hljs-string">'6gbe'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user) <span class="hljs-comment"><span class="hljs-comment">// { id: '6gbe', name: 'mary' }</span></span></code> </pre> <br>  Portanto, use o método <code>filter</code> quando desejar filtrar <b>toda a</b> matriz e o método <code>find</code> quando tiver certeza de que está procurando um elemento <b>exclusivo</b> na matriz. <br>  <b>findIndex</b> <br>  Este método é quase o mesmo que <code>find</code> , mas retorna o índice do primeiro elemento encontrado em vez do próprio elemento. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = [ { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'af35'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'john'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'6gbe'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'mary'</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'932j'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gary'</span></span> }, ] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = users.findIndex(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.id === <span class="hljs-string"><span class="hljs-string">'6gbe'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user) <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre> <br>  Você pode pensar que <code>findIndex</code> e <code>indexOf</code> são a mesma coisa.  Na verdade não.  O primeiro parâmetro de <code>indexOf</code> é um valor primitivo (um valor booleano, número, sequência, valor indefinido ou caractere), enquanto o primeiro parâmetro, <code>findIndex</code> é uma função de retorno de chamada. <br><br>  Portanto, quando você precisar encontrar o índice de um elemento em uma matriz de valores primitivos, poderá trabalhar com <code>indexOf</code> .  Se você tiver elementos mais complexos, como objetos, use <code>findIndex</code> . <br><br>  <b>fatia</b> <br>  Quando você precisar participar de uma matriz ou copiar uma matriz, pode consultar o método de <code>slice</code> .  Mas tenha cuidado: como o operador de propagação, a <code>slice</code> retorna uma <b>cópia superficial</b> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> copy = numbers.slice()</code> </pre> <br>  No começo do artigo, mencionei que os loops geralmente são inúteis.  Deixe-me mostrar como se livrar deles. <br><br>  Suponha que você deseje retornar um certo número de mensagens de bate-papo da API e você só precisará ver cinco delas.  Abaixo estão duas abordagens: uma com loops e outra com o método de <code>slice</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// The "traditional way" to do it: // Determine the number of messages to take and use a for loop const nbMessages = messages.length &lt; 5 ? messages.length : 5 let messagesToShow = [] for (let i = 0; i &lt; nbMessages; i++) { messagesToShow.push(posts[i]) } // Even if "arr" has less than 5 elements, // slice will return an entire shallow copy of the original array const messagesToShow = messages.slice(0, 5)</span></span></code> </pre> <br>  <b>alguns</b> <br>  Se você deseja verificar se <b>pelo menos um elemento da</b> matriz passa no teste, você pode usar <code>some</code> .  Como <code>map</code> , <code>filter</code> ou <code>find</code> , o método <code>some</code> recebe uma função de retorno de chamada como o único parâmetro e retorna <code>true</code> se pelo menos um elemento passa na verificação e <code>false</code> se não. <br><br>  <code>some</code> também são adequados para trabalhar com permissões. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = [ { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'fe34'</span></span>, <span class="hljs-attr"><span class="hljs-attr">permissions</span></span>: [<span class="hljs-string"><span class="hljs-string">'read'</span></span>, <span class="hljs-string"><span class="hljs-string">'write'</span></span>], }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'a198'</span></span>, <span class="hljs-attr"><span class="hljs-attr">permissions</span></span>: [], }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'18aa'</span></span>, <span class="hljs-attr"><span class="hljs-attr">permissions</span></span>: [<span class="hljs-string"><span class="hljs-string">'delete'</span></span>, <span class="hljs-string"><span class="hljs-string">'read'</span></span>, <span class="hljs-string"><span class="hljs-string">'write'</span></span>], } ] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hasDeletePermission = users.some(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.permissions.includes(<span class="hljs-string"><span class="hljs-string">'delete'</span></span>) ) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(hasDeletePermission) <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  <b>todo</b> <br>  Este método é semelhante a <code>some</code> , exceto pelo fato de verificar se <b>cada</b> elemento (e <b>não um</b> ) corresponde à condição. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = [ { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'fe34'</span></span>, <span class="hljs-attr"><span class="hljs-attr">permissions</span></span>: [<span class="hljs-string"><span class="hljs-string">'read'</span></span>, <span class="hljs-string"><span class="hljs-string">'write'</span></span>], }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'a198'</span></span>, <span class="hljs-attr"><span class="hljs-attr">permissions</span></span>: [], }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'18aa'</span></span>, <span class="hljs-attr"><span class="hljs-attr">permissions</span></span>: [<span class="hljs-string"><span class="hljs-string">'delete'</span></span>, <span class="hljs-string"><span class="hljs-string">'read'</span></span>, <span class="hljs-string"><span class="hljs-string">'write'</span></span>], } ] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hasAllReadPermission = users.every(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.permissions.includes(<span class="hljs-string"><span class="hljs-string">'read'</span></span>) ) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(hasAllReadPermission) <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  <b>plano (ES2019)</b> <br>  Estes são métodos completamente novos no mundo do JavaScript.  Normalmente, <code>flat</code> cria uma nova matriz, conectando todos os elementos de uma matriz aninhada.  É preciso um parâmetro - um número que indica quanto você deseja reduzir a dimensão da matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, [<span class="hljs-number"><span class="hljs-number">5</span></span>, [<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>]], [[[[<span class="hljs-number"><span class="hljs-number">8</span></span>]]]]]] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbersflattenOnce = numbers.flat() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(numbersflattenOnce) <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4, Array[2], Array[1]] const numbersflattenTwice = numbers.flat(2) console.log(numbersflattenTwice) // [1, 2, 3, 4, 5, Array[2], Array[1]] const numbersFlattenInfinity = numbers.flat(Infinity) console.log(numbersFlattenInfinity) // [1, 2, 3, 4, 5, 6, 7, 8]</span></span></code> </pre> <br>  <b>flatMap (ES2019)</b> <br>  Adivinha o que esse método faz?  Aposto que você entenderá um nome. <br><br>  Primeiro, ele executa a função de mapeamento para cada elemento e reduz a matriz de cada vez.  Simples assim! <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sentences = [ <span class="hljs-string"><span class="hljs-string">'This is a sentence'</span></span>, <span class="hljs-string"><span class="hljs-string">'This is another sentence'</span></span>, <span class="hljs-string"><span class="hljs-string">"I can't find any original phrases"</span></span>, ] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allWords = sentences.flatMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sentence</span></span></span><span class="hljs-function"> =&gt;</span></span> sentence.split(<span class="hljs-string"><span class="hljs-string">' '</span></span>)) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(allWords) <span class="hljs-comment"><span class="hljs-comment">// ["This", "is", "a", "sentence", "This", "is", "another", "sentence", "I", "can't", "find", "any", "original", "phrases"]</span></span></code> </pre> <br>  Neste exemplo, você tem muitas frases na matriz e deseja obter todas as palavras.  Em vez de usar o método de <code>map</code> e dividir todas as frases em palavras e encurtar a matriz, você pode usar o <code>flatMap</code> . <br><br>  Depois, você pode contar o número de palavras com a função <code>reduce</code> (isso não se aplica ao <code>flatMap</code> , só quero lhe mostrar outro exemplo usando o método <code>reduce</code> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wordsCount = allWords.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">count, word</span></span></span><span class="hljs-function">) =&gt;</span></span> { count[word] = count[word] ? count[word] + <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count }, {}) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(wordsCount) <span class="hljs-comment"><span class="hljs-comment">// { This: 2, is: 2, a: 1, sentence: 2, another: 1, I: 1, "can't": 1, find: 1, any: 1, original: 1, phrases: 1, }</span></span></code> </pre><br>  O método <code>flatMap</code> também <code>flatMap</code> frequentemente usado em programação reativa.  Você pode ver um exemplo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  <b>juntar</b> <br>  Se você precisar criar uma string com base nos elementos da matriz, o método <code>join</code> será o que você precisa.  Permite criar uma nova linha conectando todos os elementos da matriz, separados pelo separador fornecido. <br><br>  Por exemplo, usando a <code>join</code> você pode exibir visualmente todos os participantes de uma atividade. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> participants = [<span class="hljs-string"><span class="hljs-string">'john'</span></span>, <span class="hljs-string"><span class="hljs-string">'mary'</span></span>, <span class="hljs-string"><span class="hljs-string">'gary'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> participantsFormatted = participants.join(<span class="hljs-string"><span class="hljs-string">', '</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(participantsFormatted) <span class="hljs-comment"><span class="hljs-comment">// john, mary, gary</span></span></code> </pre> <br>  E este é um exemplo mais realista, onde você pode primeiro filtrar os participantes e obter seus nomes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> potentialParticipants = [ { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'k38i'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'john'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">17</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'baf3'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'mary'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">13</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'a111'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'gary'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">24</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'fx34'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'emma'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">34</span></span> }, ] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> participantsFormatted = potentialParticipants .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.age &gt; <span class="hljs-number"><span class="hljs-number">18</span></span>) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.name) .join(<span class="hljs-string"><span class="hljs-string">', '</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(participantsFormatted) <span class="hljs-comment"><span class="hljs-comment">// gary, emma</span></span></code> </pre> <br>  <b>de</b> <br>  Este é um método <b>estático</b> que cria uma nova matriz a partir de um objeto iterável ou semelhante a uma matriz, como uma string.  Pode ser útil quando você trabalha com o modelo de objeto do documento. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nodes = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'.todo-item'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// this is an instance of NodeList const todoItems = Array.from(nodes) // now, you can use map, filter, etc. as you're workin with an array!</span></span></code> </pre> <br>  Você viu que usamos um tipo de matriz em vez de uma instância de matriz?  É por isso que esse método é chamado estático. <br><br>  Então você pode se divertir com os nós, por exemplo, registrando ouvintes de eventos para cada um deles usando o método <code>forEach</code> . <br><br><pre> <code class="javascript hljs">todoItems.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function"> =&gt;</span></span> { item.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">`You clicked on </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${item.innerHTML}</span></span></span><span class="hljs-string">`</span></span>) }) })</code> </pre><br><h3>  Modificação de matriz que vale a pena conhecer </h3><br>  A seguir estão outros métodos padrão.  A diferença deles é que eles modificam a matriz original.  Não há nada errado com a alteração, mas você deve considerar isso ao trabalhar. <br><br>  Se você não deseja modificar a matriz original enquanto trabalha com esses métodos, faça uma cópia de superfície ou completa com antecedência. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> copy = [...arr] <span class="hljs-comment"><span class="hljs-comment">// or arr.slice()</span></span></code> </pre><br>  <b>ordenar</b> <br>  Sim, a <code>sort</code> modifica a matriz original.  De fato, ele classifica os elementos da matriz no lugar.  O método de classificação padrão transforma todos os elementos em seqüências de caracteres e os classifica em ordem alfabética. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> names = [<span class="hljs-string"><span class="hljs-string">'john'</span></span>, <span class="hljs-string"><span class="hljs-string">'mary'</span></span>, <span class="hljs-string"><span class="hljs-string">'gary'</span></span>, <span class="hljs-string"><span class="hljs-string">'anna'</span></span>] names.sort() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(names) <span class="hljs-comment"><span class="hljs-comment">// ['anna', 'gary', 'john', 'mary']</span></span></code> </pre> <br>  Cuidado: se você, por exemplo, mudou da linguagem Python, o método de <code>sort</code> ao trabalhar com uma matriz de números não fornecerá o resultado desejado. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-number"><span class="hljs-number">187</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>] numbers.sort() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(numbers) <span class="hljs-comment"><span class="hljs-comment">// [12, 17, 187, 23, 3, 90]</span></span></code> </pre> <br>  Como então classificar uma matriz?  O método de <code>sort</code> assume uma função - <b>uma função de comparação</b> .  São necessários dois parâmetros: o primeiro elemento ( <code></code> ) e o segundo elemento para comparação ( <code>b</code> ).  Uma comparação entre esses dois elementos requer que um dígito seja retornado: <br><br><ul><li>  se o valor for negativo - <code>a</code> classificado antes de <code>b</code> ; </li><li>  se o valor for positivo, <code>b</code> classificado antes de <code>a</code> ; </li><li>  se o valor for 0, nenhuma alteração. </li></ul><br>  Então você pode classificar os números. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-number"><span class="hljs-number">187</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>] numbers.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a - b) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(numbers) <span class="hljs-comment"><span class="hljs-comment">// [3, 12, 17, 23, 90, 187]</span></span></code> </pre> <br>  Ou você pode classificar as datas das mais recentes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> posts = [ { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Create a Discord bot under 15 minutes'</span></span>, <span class="hljs-attr"><span class="hljs-attr">date</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(<span class="hljs-number"><span class="hljs-number">2018</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">26</span></span>), }, { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'How to get better at writing CSS'</span></span>, <span class="hljs-attr"><span class="hljs-attr">date</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(<span class="hljs-number"><span class="hljs-number">2018</span></span>, <span class="hljs-number"><span class="hljs-number">06</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>) }, { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'JavaScript arrays'</span></span>, <span class="hljs-attr"><span class="hljs-attr">date</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() }, ] posts.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a.date - b.date) <span class="hljs-comment"><span class="hljs-comment">// Substracting two dates returns the difference in millisecond between them console.log(posts) // [ { title: 'How to get better at writing CSS', // date: 2018-07-17T00:00:00.000Z }, // { title: 'Create a Discord bot under 15 minutes', // date: 2018-12-26T00:00:00.000Z }, // { title: 'Learn Javascript arrays the functional way', // date: 2019-03-16T10:31:00.208Z } ]</span></span></code> </pre><br>  <b>preencher</b> <br>  O método de <code>fill</code> modifica ou preenche todos os elementos da matriz do índice inicial até o final com o valor especificado.  Um exemplo do excelente uso do <code>fill</code> é preencher uma nova matriz com dados iniciais. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Normally I would have called a function that generates ids and random names but let's not bother with that here. function fakeUser() { return { id: 'fe38', name: 'thomas', } } const posts = Array(3).fill(fakeUser()) console.log(posts) // [{ id: "fe38", name: "thomas" }, { id: "fe38", name: "thomas" }, { id: "fe38", name: "thomas" }]</span></span></code> </pre> <br>  <b>inverter</b> <br>  Parece-me que o nome do método explica completamente sua essência. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] numbers.reverse() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(numbers) <span class="hljs-comment"><span class="hljs-comment">// [5, 4, 3, 2, 1]</span></span></code> </pre> <br>  <b>pop</b> <br>  Este método remove o último elemento da matriz e o retorna. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> messages = [<span class="hljs-string"><span class="hljs-string">'Hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'Hey'</span></span>, <span class="hljs-string"><span class="hljs-string">'How are you?'</span></span>, <span class="hljs-string"><span class="hljs-string">"I'm fine"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lastMessage = messages.pop() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(messages) <span class="hljs-comment"><span class="hljs-comment">// ['Hello', 'Hey', 'How are you?'] console.log(lastMessage) // I'm fine</span></span></code> </pre> <br><h3>  Métodos que podem ser substituídos </h3><br>  Na última seção, você encontrará métodos que modificam a matriz original e são fáceis de encontrar uma alternativa.  Não estou dizendo que eles precisam ser descontados, apenas quero transmitir a você que alguns métodos têm efeitos colaterais e podem ser substituídos. <br><br>  <b>empurrar</b> <br>  Este método é usado com freqüência.  Ele permite adicionar um ou mais elementos à matriz e criar uma nova matriz com base na matriz anterior. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> todoItems = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itemsIncremented = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; items.length; i++) { itemsIncremented.push(items[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(itemsIncremented) <span class="hljs-comment"><span class="hljs-comment">// [2, 3, 4, 5, 6] const todos = ['Write an article', 'Proofreading'] todos.push('Publish the article') console.log(todos) // ['Write an article', 'Proofreading', 'Publish the article']</span></span></code> </pre> <br>  Se você precisar criar uma matriz com base em outra, como no método <code>itemsIncremented</code> , existem <code>map</code> , <code>filter</code> ou <code>itemsIncremented</code> adequados que já nos são familiares.  Por exemplo, podemos pegar um <code>map</code> para fazer isso. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itemsIncremented = todoItems.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x + <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  E se você deseja usar <code>push</code> quando precisar adicionar um novo elemento, o operador de propagação é útil. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> todos = [<span class="hljs-string"><span class="hljs-string">'Write an article'</span></span>, <span class="hljs-string"><span class="hljs-string">'Proofreading'</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([...todos, <span class="hljs-string"><span class="hljs-string">'Publish the article'</span></span>])</code> </pre> <br>  <b>emenda</b> <br>  <code>splice</code> frequentemente acessada para limpar um elemento em um índice específico.  Você pode fazer o mesmo com o método de <code>filter</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> months = [<span class="hljs-string"><span class="hljs-string">'January'</span></span>, <span class="hljs-string"><span class="hljs-string">'February'</span></span>, <span class="hljs-string"><span class="hljs-string">'March'</span></span>, <span class="hljs-string"><span class="hljs-string">'April'</span></span>, <span class="hljs-string"><span class="hljs-string">' May'</span></span>] <span class="hljs-comment"><span class="hljs-comment">// With splice months.splice(2, 1) // remove one element at index 2 console.log(months) // ['January', 'February', 'April', 'May'] // Without splice const monthsFiltered = months.filter((month, i) =&gt; i !== 3) console.log(monthsFiltered) // ['January', 'February', 'April', 'May']</span></span></code> </pre> <br>  Você pode perguntar: e se eu precisar remover muitos elementos?  Então use <code>slice</code> . <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> months = [<span class="hljs-string"><span class="hljs-string">'January'</span></span>, <span class="hljs-string"><span class="hljs-string">'February'</span></span>, <span class="hljs-string"><span class="hljs-string">'March'</span></span>, <span class="hljs-string"><span class="hljs-string">'April'</span></span>, <span class="hljs-string"><span class="hljs-string">' May'</span></span>] <span class="hljs-comment"><span class="hljs-comment">// With splice months.splice(1, 3) // remove thirds element starting at index 1 console.log(months) // ['January', 'February', 'April', 'May'] // Without splice const monthsFiltered = [...months.slice(0, 1), ...months.slice(4)] console.log(monthsFiltered) // ['January', 'February', 'April', 'May']</span></span></code> </pre><br>  <b>mudança</b> <br>  O método <code>shift</code> remove o primeiro elemento da matriz e o retorna.  Para fazer isso no estilo de programação funcional, você pode usar a instrução spread ou rest. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-comment"><span class="hljs-comment">// With shift const firstNumber = numbers.shift() console.log(firstNumber) // 1 console.log(numbers) // [2, 3, 4, 5] // Without shift const [firstNumber, ...numbersWithoutOne] = numbers console.log(firstNumber) // 1 console.log(numbersWithoutOne) // [2, 3, 4, 5]</span></span></code> </pre> <br>  <b>deslocar</b> <br>  O método unshift permite adicionar um ou mais elementos ao início de uma matriz.  Como no <code>shift</code> , você pode fazer isso com o operador de spread. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-comment"><span class="hljs-comment">// With unshift numbers.unshift(1, 2) console.log(numbers) // [1, 2, 3, 4, 5] // Without unshift const newNumbers = [1, 2, ...numbers] console.log(newNumbers) // [1, 2, 3, 4, 5]</span></span></code> </pre><br><h3>  TL; DR </h3><br><ul><li>  Quando você deseja executar algumas operações com uma matriz, não use <b>o loop for</b> e não reinvente a roda, porque provavelmente existe um método acima que pode fazer o que você precisa. </li><li>  Na maioria das vezes, você usará o <code>map</code> , <code>filter</code> , <code>reduce</code> métodos e o operador de propagação - essas são ferramentas importantes para qualquer desenvolvedor. </li><li>  Também existem muitos métodos de matriz que seria bom saber: <code>slice</code> , <code>some</code> , <code>flatMap</code> , etc. Conheça-os e aplique-os, se necessário. </li><li>  Os efeitos colaterais podem levar a alterações indesejadas.  Lembre-se de que alguns métodos modificam sua matriz original. </li><li>  O método de <code>slice</code> e o operador de propagação fazem cópias rasas.  Como resultado, objetos e sub-matrizes terão os mesmos links - isso também vale a pena ter em mente. </li><li>  Métodos antigos que modificam a matriz podem ser substituídos por novos.  Você decide o que fazer. </li></ul><br>  Agora você sabe tudo o que deve saber sobre matrizes JavaScript.  Se você gostou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deste artigo</a> , clique no botão "Pat" (até 50 vezes, se quiser :-)) e compartilhe-o.  E fique à vontade para compartilhar suas impressões nos comentários! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt446902/">https://habr.com/ru/post/pt446902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt446882/index.html">O MIPT recebeu o direito de sediar a Copa do Mundo de Programação do ICPC em 2020 em Moscou</a></li>
<li><a href="../pt446884/index.html">O que ler e assistir em novas ficção científica: Marte, cyborgs e IA rebelde</a></li>
<li><a href="../pt446886/index.html">Os principais especialistas da Expo 3D: Sunny Wong. Mais de 25 milhões de entorses podem ser evitadas</a></li>
<li><a href="../pt446888/index.html">Criptografia em Java. Classe de certificado</a></li>
<li><a href="../pt446896/index.html">Os gerentes de projeto não são necessários</a></li>
<li><a href="../pt446904/index.html">Ações da Tesla caem em meio ao maior declínio de vendas na história da empresa</a></li>
<li><a href="../pt446906/index.html">Música ambiente e seus efeitos na escrita de código</a></li>
<li><a href="../pt446908/index.html">Recomendações de segurança da informação DLP e FSTEC: interseção de paralelos</a></li>
<li><a href="../pt446912/index.html">Quanto custa a segurança de aplicativos da Web (usando o Barracuda WAF como serviço como exemplo)</a></li>
<li><a href="../pt446914/index.html">Por que você ensina ir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>