<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéà ü•™ ü•Ö Tres trucos simples para reducir las im√°genes acoplables üö£üèª üë©‚Äçüåæ üë©üèª‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cuando se trata de crear contenedores Docker, es mejor siempre esforzarse por minimizar el tama√±o de las im√°genes. Im√°genes que usan las mismas capas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tres trucos simples para reducir las im√°genes acoplables</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nixys/blog/437372/"><img src="https://habrastorage.org/getpro/habr/post_images/339/ed2/afb/339ed2afb54b94a155f95e6a279ede9d.png" alt="imagen"><br><p>  Cuando se trata de crear contenedores Docker, es mejor siempre esforzarse por minimizar el tama√±o de las im√°genes.  Im√°genes que usan las mismas capas y pesan menos: se transfieren y despliegan m√°s r√°pidamente. </p><br><p> Pero, ¬øc√≥mo controlar el tama√±o cuando cada ejecuci√≥n de la instrucci√≥n <code>RUN</code> crea una nueva capa?  Adem√°s, a√∫n necesita artefactos intermedios antes de crear la imagen en s√≠ ... </p><a name="habracut"></a><br><p>  Probablemente sepa que la mayor√≠a de los archivos Docker tienen sus propias caracter√≠sticas bastante extra√±as, por ejemplo: </p><br><pre> <code class="plaintext hljs">FROM ubuntu RUN apt-get update &amp;&amp; apt-get install vim</code> </pre> <br><p>  Bueno, ¬øpor qu√© est√° <code>&amp;&amp;</code> aqu√≠?  ¬øNo es m√°s f√°cil ejecutar dos sentencias <code>RUN</code> , como aqu√≠? </p><br><pre> <code class="plaintext hljs">FROM ubuntu RUN apt-get update RUN apt-get install vim</code> </pre> <br><p>  A partir de Docker versi√≥n 1.10, los operadores <code>COPY</code> , <code>ADD</code> y <code>RUN</code> agregan una nueva capa a la imagen.  En el ejemplo anterior, se crearon dos capas en lugar de una. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/cfb/fd8/e34/cfbfd8e34d1dd89685121383128c05aa.gif" alt="imagen"></p><br><h3 id="sloi-kak-git-kommity">  Capas como git commits. </h3><br><p>  Las capas Docker conservan las diferencias entre la versi√≥n anterior y actual de la imagen.  Y como git commits, son √∫tiles si los comparte con otros repositorios o im√°genes.  De hecho, al solicitar una imagen del registro, solo se cargan las capas que faltan, lo que simplifica la separaci√≥n de im√°genes entre contenedores. </p><br><p>  Pero al mismo tiempo, cada capa tiene lugar, y cuanto m√°s, m√°s pesada es la imagen final.  Los repositorios de Git son similares a este respecto: el tama√±o del repositorio crece con el n√∫mero de capas, porque debe almacenar todos los cambios entre confirmaciones.  Sol√≠a ‚Äã‚Äãser una buena pr√°ctica combinar varias declaraciones <code>RUN</code> en la misma l√≠nea, como en el primer ejemplo.  Pero ahora, por desgracia, no. </p><br><h2 id="1-obedinyaem-neskolkih-sloev-v-odin-s-pomoschyu-poetapnoy-sborki-docker-obrazov">  1. Combine varias capas en una usando el ensamblaje por fases de im√°genes Docker </h2><br><p>  Cuando crezca el repositorio de Git, simplemente puede resumir todo el historial de cambios en una confirmaci√≥n y olvidarse de √©l.  Result√≥ que algo similar se puede implementar en Docker a trav√©s del ensamblaje por fases. </p><br><p>  Creemos un contenedor Node.js. </p><br><p>  Comencemos con <code>index.js</code> : </p><br><pre> <code class="plaintext hljs">const express = require('express') const app = express() app.get('/', (req, res) =&gt; res.send('Hello World!')) app.listen(3000, () =&gt; { console.log(`Example app listening on port 3000!`) })</code> </pre> <br><p>  y <code>package.json</code> : </p><br><pre> <code class="plaintext hljs">{ "name": "hello-world", "version": "1.0.0", "main": "index.js", "dependencies": { "express": "^4.16.2" }, "scripts": { "start": "node index.js" } }</code> </pre> <br><p>  Empaquete la aplicaci√≥n con el siguiente <code>Dockerfile</code> : </p><br><pre> <code class="plaintext hljs">FROM node:8 EXPOSE 3000 WORKDIR /app COPY package.json index.js ./ RUN npm install CMD ["npm", "start"]</code> </pre> <br><p>  Crea una imagen: </p><br><pre> <code class="plaintext hljs">$ docker build -t node-vanilla .</code> </pre> <br><p>  Comprueba que todo funciona: </p><br><pre> <code class="plaintext hljs">$ docker run -p 3000:3000 -ti --rm --init node-vanilla</code> </pre> <br><p>  <em>Ahora puede seguir el enlace: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http: // localhost: 3000</a> y ver "¬°Hola, mundo!".</em> </p><br><p>  En el <code>Dockerfile</code> ahora tenemos los operadores <code>COPY</code> y <code>RUN</code> , por lo que corregimos el aumento en al menos dos capas, en comparaci√≥n con la imagen original: </p><br><pre> <code class="plaintext hljs">$ docker history node-vanilla IMAGE CREATED BY SIZE 075d229d3f48 /bin/sh -c #(nop) CMD ["npm" "start"] 0B bc8c3cc813ae /bin/sh -c npm install 2.91MB bac31afb6f42 /bin/sh -c #(nop) COPY multi:3071ddd474429e1‚Ä¶ 364B 500a9fbef90e /bin/sh -c #(nop) WORKDIR /app 0B 78b28027dfbf /bin/sh -c #(nop) EXPOSE 3000 0B b87c2ad8344d /bin/sh -c #(nop) CMD ["node"] 0B &lt;missing&gt; /bin/sh -c set -ex &amp;&amp; for key in 6A010‚Ä¶ 4.17MB &lt;missing&gt; /bin/sh -c #(nop) ENV YARN_VERSION=1.3.2 0B &lt;missing&gt; /bin/sh -c ARCH= &amp;&amp; dpkgArch="$(dpkg --print‚Ä¶ 56.9MB &lt;missing&gt; /bin/sh -c #(nop) ENV NODE_VERSION=8.9.4 0B &lt;missing&gt; /bin/sh -c set -ex &amp;&amp; for key in 94AE3‚Ä¶ 129kB &lt;missing&gt; /bin/sh -c groupadd --gid 1000 node &amp;&amp; use‚Ä¶ 335kB &lt;missing&gt; /bin/sh -c set -ex; apt-get update; apt-ge‚Ä¶ 324MB &lt;missing&gt; /bin/sh -c apt-get update &amp;&amp; apt-get install‚Ä¶ 123MB &lt;missing&gt; /bin/sh -c set -ex; if ! command -v gpg &gt; /‚Ä¶ 0B &lt;missing&gt; /bin/sh -c apt-get update &amp;&amp; apt-get install‚Ä¶ 44.6MB &lt;missing&gt; /bin/sh -c #(nop) CMD ["bash"] 0B &lt;missing&gt; /bin/sh -c #(nop) ADD file:1dd78a123212328bd‚Ä¶ 123MB</code> </pre> <br><p>  Como puede ver, la imagen final ha aumentado en cinco nuevas capas: una para cada operador en nuestro <code>Dockerfile</code> .  Probemos ahora la compilaci√≥n gradual de Docker.  Usamos el mismo <code>Dockerfile</code> , que consta de dos partes: </p><br><pre> <code class="plaintext hljs">FROM node:8 as build WORKDIR /app COPY package.json index.js ./ RUN npm install FROM node:8 COPY --from=build /app / EXPOSE 3000 CMD ["index.js"]</code> </pre> <br><p>  La primera parte del <code>Dockerfile</code> crea tres capas.  Luego, las capas se combinan y copian en la segunda y √∫ltima etapa.  Se agregan dos capas m√°s a la imagen de arriba.  Como resultado, tenemos tres capas. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/72c/6a6/61e/72c6a661ef969eabd58a91b4b71b0329.gif" alt="imagen"></p><br><p>  Prob√©moslo.  Primero, cree un contenedor: </p><br><pre> <code class="plaintext hljs">$ docker build -t node-multi-stage .</code> </pre> <br><p>  Comprobando el historial: </p><br><pre> <code class="plaintext hljs">$ docker history node-multi-stage IMAGE CREATED BY SIZE 331b81a245b1 /bin/sh -c #(nop) CMD ["index.js"] 0B bdfc932314af /bin/sh -c #(nop) EXPOSE 3000 0B f8992f6c62a6 /bin/sh -c #(nop) COPY dir:e2b57dff89be62f77‚Ä¶ 1.62MB b87c2ad8344d /bin/sh -c #(nop) CMD ["node"] 0B &lt;missing&gt; /bin/sh -c set -ex &amp;&amp; for key in 6A010‚Ä¶ 4.17MB &lt;missing&gt; /bin/sh -c #(nop) ENV YARN_VERSION=1.3.2 0B &lt;missing&gt; /bin/sh -c ARCH= &amp;&amp; dpkgArch="$(dpkg --print‚Ä¶ 56.9MB &lt;missing&gt; /bin/sh -c #(nop) ENV NODE_VERSION=8.9.4 0B &lt;missing&gt; /bin/sh -c set -ex &amp;&amp; for key in 94AE3‚Ä¶ 129kB &lt;missing&gt; /bin/sh -c groupadd --gid 1000 node &amp;&amp; use‚Ä¶ 335kB &lt;missing&gt; /bin/sh -c set -ex; apt-get update; apt-ge‚Ä¶ 324MB &lt;missing&gt; /bin/sh -c apt-get update &amp;&amp; apt-get install‚Ä¶ 123MB &lt;missing&gt; /bin/sh -c set -ex; if ! command -v gpg &gt; /‚Ä¶ 0B &lt;missing&gt; /bin/sh -c apt-get update &amp;&amp; apt-get install‚Ä¶ 44.6MB &lt;missing&gt; /bin/sh -c #(nop) CMD ["bash"] 0B &lt;missing&gt; /bin/sh -c #(nop) ADD file:1dd78a123212328bd‚Ä¶ 123MB</code> </pre> <br><p>  Vea si el tama√±o del archivo ha cambiado: </p><br><pre> <code class="plaintext hljs">$ docker images | grep node- node-multi-stage 331b81a245b1 678MB node-vanilla 075d229d3f48 679MB</code> </pre> <br><p>  S√≠, se ha vuelto m√°s peque√±o, pero a√∫n no significativamente. </p><br><h2 id="2-snosim-vse-lishnee-iz-konteynera-s-pomoschyu-distroless">  2. Eliminamos todo lo innecesario del contenedor usando distroless </h2><br><p>  La imagen actual nos proporciona Node.js, <code>yarn</code> , <code>npm</code> , <code>bash</code> y muchos otros binarios √∫tiles.  Adem√°s, est√° basado en Ubuntu.  Por lo tanto, al implementarlo, obtenemos un sistema operativo completo con muchos binarios y utilidades √∫tiles. </p><br><p>  Sin embargo, no los necesitamos para ejecutar el contenedor.  La √∫nica dependencia necesaria es Node.js. </p><br><p>  Los contenedores Docker deben admitir la operaci√≥n de un proceso y contener el conjunto m√≠nimo de herramientas necesarias para ejecutarlo.  No se requiere un sistema operativo completo para esto. </p><br><p>  Entonces podemos sacar todo de √©l excepto Node.js. </p><br><p>  <strong>Pero como?</strong> </p><br><p>  Google ya ha presentado una soluci√≥n similar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GoogleCloudPlatform / distroless</a> . </p><br><p>  La descripci√≥n del repositorio dice: </p><br><p>  <em>Las im√°genes sin distribuci√≥n contienen solo la aplicaci√≥n y sus dependencias.</em>  <em>No hay administradores de paquetes, shells u otros programas que generalmente se encuentran en la distribuci√≥n est√°ndar de Linux.</em> </p><br><p>  <strong>¬°Esto es lo que necesitas!</strong> </p><br><p>  Ejecute <code>Dockerfile</code> para obtener una nueva imagen: </p><br><pre> <code class="plaintext hljs">FROM node:8 as build WORKDIR /app COPY package.json index.js ./ RUN npm install FROM gcr.io/distroless/nodejs COPY --from=build /app / EXPOSE 3000 CMD ["index.js"]</code> </pre> <br><p>  Recopilamos la imagen como de costumbre: </p><br><pre> <code class="plaintext hljs">$ docker build -t node-distroless .</code> </pre> <br><p>  La aplicaci√≥n deber√≠a funcionar bien.  Para verificar, ejecute el contenedor: </p><br><pre> <code class="plaintext hljs">$ docker run -p 3000:3000 -ti --rm --init node-distroless</code> </pre> <br><p>  Y vaya a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http: // localhost: 3000</a> .  ¬øLa imagen se ha vuelto m√°s f√°cil sin binarios adicionales? </p><br><pre> <code class="plaintext hljs">$ docker images | grep node-distroless node-distroless 7b4db3b7f1e5 76.7MB</code> </pre> <br><p>  <strong>Solo asi!</strong>  <strong>Ahora pesa solo 76.7 MB, ¬°hasta 600 MB menos!</strong> </p><br><p>  Todo es genial, pero hay un punto importante.  Cuando el contenedor se est√° ejecutando y necesita verificarlo, puede conectarse usando: </p><br><pre> <code class="plaintext hljs">$ docker exec -ti &lt;insert_docker_id&gt; bash</code> </pre> <br><p>  Conectarse a un contenedor en ejecuci√≥n e iniciar <code>bash</code> muy similar a crear una sesi√≥n SSH. </p><br><p>  Pero dado que distroless es una versi√≥n simplificada del sistema operativo original, ¬°no hay binarios adicionales, ni, en realidad, un shell! </p><br><p>  ¬øC√≥mo conectarse a un contenedor en ejecuci√≥n si no hay shell? </p><br><p>  Lo m√°s interesante es que nada. </p><br><p>  Esto no es muy bueno, ya que solo se pueden ejecutar binarios en un contenedor.  Y el √∫nico que se puede iniciar es Node.js: </p><br><pre> <code class="plaintext hljs">$ docker exec -ti &lt;insert_docker_id&gt; node</code> </pre> <br><p>  De hecho, hay una ventaja en esto, porque si alg√∫n atacante puede obtener acceso al contenedor, har√° mucho menos da√±o que si tuviera acceso al shell.  En otras palabras, menos binarios: menos peso y mayor seguridad.  Pero, a costa de una depuraci√≥n m√°s compleja. </p><br><p>  Aqu√≠ debe tenerse en cuenta que no vale la pena conectar y depurar contenedores en el entorno de producci√≥n.  Es mejor confiar en sistemas de registro y monitoreo configurados adecuadamente. </p><br><p>  Pero, ¬øqu√© sucede si todav√≠a necesitamos depurar y, sin embargo, queremos que la imagen del acoplador sea la m√°s peque√±a? </p><br><h2 id="3-umenshaem-bazovye-obrazy-s-pomoschyu-alpine">  3. Reduce las im√°genes base con Alpine </h2><br><p>  Puede reemplazar distroless con una imagen alpina. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alpine Linux</a> es una distribuci√≥n liviana orientada a la seguridad basada en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">musl libc</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">busybox</a> .  Pero no tomaremos una palabra, sino que la revisaremos. </p><br><p>  Ejecute <code>Dockerfile</code> usando el <code>node:8-alpine</code> : </p><br><pre> <code class="plaintext hljs">FROM node:8 as build WORKDIR /app COPY package.json index.js ./ RUN npm install FROM node:8-alpine COPY --from=build /app / EXPOSE 3000 CMD ["npm", "start"]</code> </pre> <br><p>  Crea una imagen: </p><br><pre> <code class="plaintext hljs">$ docker build -t node-alpine .</code> </pre> <br><p>  Comprobar tama√±o: </p><br><pre> <code class="plaintext hljs">$ docker images | grep node-alpine node-alpine aa1f85f8e724 69.7MB</code> </pre> <br><p>  <strong>En la salida, tenemos 69.7MB, esto es incluso menos que una imagen sin distro.</strong> </p><br><p>  Verifiquemos si es posible conectarse a un contenedor que funcione (en el caso de la imagen de distribuci√≥n, no podr√≠amos hacer esto). </p><br><p>  Lanzar el contenedor: </p><br><pre> <code class="plaintext hljs">$ docker run -p 3000:3000 -ti --rm --init node-alpine Example app listening on port 3000!</code> </pre> <br><p>  Y conecta: </p><br><pre> <code class="plaintext hljs">$ docker exec -ti 9d8e97e307d7 bash OCI runtime exec failed: exec failed: container_linux.go:296: starting container process caused "exec: \"bash\": executable file not found in $PATH": unknown</code> </pre> <br><p>  Sin √©xito  Pero tal vez el contenedor tiene <code>sh</code> 'ell ...: </p><br><pre> <code class="plaintext hljs">$ docker exec -ti 9d8e97e307d7 sh / #</code> </pre> <br><p>  Genial  Logramos conectarnos al contenedor y, al mismo tiempo, su imagen tambi√©n es m√°s peque√±a.  Pero aqu√≠ hab√≠a algunos matices. </p><br><p>  Las im√°genes alpinas se basan en muslc, una biblioteca est√°ndar alternativa para C. Mientras que la mayor√≠a de las distribuciones de Linux, como Ubuntu, Debian y CentOS, se basan en glibc.  Se cree que ambas bibliotecas proporcionan la misma interfaz para trabajar con el n√∫cleo. </p><br><p>  Sin embargo, tienen objetivos diferentes: glibc es el m√°s com√∫n y r√°pido, mientras que muslc ocupa menos espacio y est√° escrito con un sesgo de seguridad.  Cuando una aplicaci√≥n compila, por regla general, se compila en una biblioteca espec√≠fica de C. Si necesita usarla con otra biblioteca, tendr√° que volver a compilar. </p><br><p>  En otras palabras, la construcci√≥n de contenedores en im√°genes Alpine puede conducir a eventos inesperados, ya que la biblioteca C est√°ndar utilizada en ella es diferente.  La diferencia se notar√° cuando trabaje con archivos binarios precompilados, como las extensiones Node.js para C ++. </p><br><p>  Por ejemplo, el paquete PhantomJS terminado no funciona en Alpine. </p><br><h2 id="tak-kakoy-zhe-bazovyy-obraz-vybrat">  Entonces, ¬øcu√°l es la imagen b√°sica para elegir? </h2><br><p>  Aspecto alpino, distroless o vainilla: por supuesto, es mejor decidir seg√∫n la situaci√≥n. </p><br><p>  <strong>Si se trata de productos y la seguridad es importante, quiz√°s la distribuci√≥n sin distorsiones ser√≠a lo m√°s apropiado.</strong> </p><br><p>  Cada binario agregado a la imagen de Docker agrega un cierto riesgo a la estabilidad de toda la aplicaci√≥n.  Este riesgo puede reducirse si solo se instala un binario en el contenedor. </p><br><p>  Por ejemplo, si un atacante podr√≠a encontrar una vulnerabilidad en una aplicaci√≥n que se ejecuta sobre la base de una imagen ininterrumpida, ¬°no podr√≠a ejecutar el shell en el contenedor porque no estaba all√≠! </p><br><p>  <strong>Si por alguna raz√≥n el tama√±o de la imagen acoplable es extremadamente importante para usted, definitivamente vale la pena echar un vistazo m√°s de cerca a las im√°genes basadas en Alpine.</strong> </p><br><p>  Son realmente peque√±os, pero a costa de la compatibilidad.  Alpine utiliza una biblioteca C est√°ndar ligeramente diferente, muslc, por lo que a veces surgen problemas.  Los ejemplos est√°n disponibles en los siguientes enlaces: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/grpc/grpc/issues/8528</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/grpc/grpc/issues/6126</a> . </p><br><p>  <strong>Las im√°genes de vainilla son ideales para pruebas y desarrollo.</strong> </p><br><p>  S√≠, son grandes, pero se ven lo m√°s posible en una m√°quina completa con Ubuntu instalado.  Adem√°s, todos los binarios en el sistema operativo est√°n disponibles. </p><br><p>  <strong>Resuma el tama√±o de las im√°genes Docker recibidas:</strong> </p><br><p>  <code>node:8</code> 681 MB <br>  <code>node:8</code> con 678MB de compilaci√≥n incremental <br>  <code>gcr.io/distroless/nodejs</code> 76.7MB <br>  <code>node:8-alpine</code> 69.7MB </p><br><h3 id="naputstvie-ot-perevodchika">  Palabras de despedida del traductor </h3><br><p>  Lea otros art√≠culos en nuestro blog: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Copias de seguridad con estado en Kubernetes</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Copia de seguridad de una gran cantidad de proyectos web heterog√©neos</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Telegram bot para Redmine.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo simplificar la vida para ti y para las personas</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437372/">https://habr.com/ru/post/437372/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437358/index.html">Gesti√≥n de compatibilidad de productos</a></li>
<li><a href="../437360/index.html">Descargar controladores sin usar una consola Arduino IDE</a></li>
<li><a href="../437364/index.html">El control sobre Tele2 le costar√° a Rostelecom 240 mil millones de rublos</a></li>
<li><a href="../437366/index.html">C√≥mo hackear una f√°brica: los sistemas de radio control como un eslab√≥n d√©bil en la producci√≥n moderna</a></li>
<li><a href="../437368/index.html">MOSDROID # 15 F√≥sforo</a></li>
<li><a href="../437374/index.html">Los usuarios de Facebook alquilan sus cuentas con dinero y computadoras port√°tiles gratuitas</a></li>
<li><a href="../437376/index.html">Perversiones curiosas del mundo de TI - 2</a></li>
<li><a href="../437378/index.html">¬øQu√© es ARCore? Todo lo que necesitas saber</a></li>
<li><a href="../437380/index.html">Todos rega√±an los marcos de prueba auto-escritos. Y estamos contentos con nuestro</a></li>
<li><a href="../437382/index.html">Teor√≠a de los fuegos artificiales. Fantas√≠a cosmol√≥gica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>