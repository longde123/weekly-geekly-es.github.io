<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåå ‚úãüèº ü§ö Suchen nach Fehlern im Amazon Web Services SDK-Quellcode f√ºr .NET ‚ù£Ô∏è üåù üèÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Willkommen bei allen Fans, die den Code eines anderen wegwerfen. :) Heute haben wir in unserem Labor ein neues Material f√ºr eine Forschung - den Quell...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Suchen nach Fehlern im Amazon Web Services SDK-Quellcode f√ºr .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/437514/"><p><img src="https://habrastorage.org/getpro/habr/post_images/188/292/f27/188292f271dd0648b09f848dbe66efa6.png" alt="Bild 1"></p><br>  Willkommen bei allen Fans, die den Code eines anderen wegwerfen.  :) Heute haben wir in unserem Labor ein neues Material f√ºr eine Forschung - den Quellcode des AWS SDK for .NET-Projekts.  Zu dieser Zeit haben wir einen Artikel √ºber das √úberpr√ºfen des AWS SDK auf C ++ geschrieben.  Dann gab es nichts besonders Interessantes.  Mal sehen, was .NET der AWS SDK-Version wert ist.  Es ist wieder einmal eine gro√üartige Gelegenheit, die F√§higkeiten des PVS-Studio-Analysators zu demonstrieren und die Welt ein bisschen besser zu machen. <br><a name="habracut"></a><br>  Das Amazon Web Services (AWS) SDK f√ºr .NET ist eine Reihe von Entwicklertools, mit denen Anwendungen basierend auf .NET in der AWS-Infrastruktur erstellt werden k√∂nnen.  Dieser Satz erm√∂glicht es, den Prozess des Code-Schreibens erheblich zu vereinfachen.  Das SDK enth√§lt Sets API .NET f√ºr verschiedene AWS-Dienste wie Amazon S3, Amazon EC2, DynamoDB und andere.  SDK-Quellcode ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> verf√ºgbar. <br><br>  Wie bereits erw√§hnt, haben wir zu diesem Zeitpunkt bereits den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> √ºber das √úberpr√ºfen des AWS SDK auf C ++ geschrieben.  Der Artikel erwies sich als klein - nur ein paar Fehler pro 512 Tausend Codezeilen.  Dieses Mal haben wir es mit einer viel gr√∂√üeren Gr√∂√üe des Codes zu tun, die ungef√§hr 34.000 cs-Dateien enth√§lt, und die Gesamtzahl der Codezeilen (ohne leere) betr√§gt beeindruckende 5 Millionen.  Ein kleiner Teil des Codes (200.000 Zeilen in 664-cs-Dateien) f√§llt f√ºr Tests an, ich habe sie nicht ber√ºcksichtigt. <br><br>  Wenn die Qualit√§t des .NET-Codes der SDK-Version ungef√§hr der von C ++ entspricht (zwei Fehler pro 512 KLOC), sollten wir ungef√§hr zehnmal mehr Fehler erhalten.  Nat√ºrlich ist dies eine sehr ungenaue Berechnungsmethode, die die sprachlichen Besonderheiten und viele andere Faktoren nicht ber√ºcksichtigt, aber ich denke nicht, dass der Leser jetzt auf langweilige √úberlegungen eingehen m√∂chte.  Stattdessen schlage ich vor, mit den Ergebnissen fortzufahren. <br><br>  Die Pr√ºfung wurde mit PVS-Studio 6.27 durchgef√ºhrt.  Es ist einfach unglaublich, aber dennoch ist es dem AWS SDK f√ºr .NET gelungen, 40 Fehler zu erkennen, √ºber die es sich zu sprechen lohnt.  Es zeigt nicht nur eine hohe Qualit√§t des SDK-Codes (ca. 4 Fehler pro 512 KLOC), sondern auch eine vergleichbare Qualit√§t des C # PVS-Studio-Analysators im Vergleich zu C ++.  Ein tolles Ergebnis! <br><br>  Autoren des AWS SDK f√ºr .NET, Sie sind echte Champions!  Mit jedem Projekt demonstrieren Sie eine enorme Qualit√§t des Codes.  Es kann ein gutes Beispiel f√ºr andere Teams sein.  Nat√ºrlich w√§re ich kein Entwickler eines statischen Analysators, wenn ich nicht meine 2 Cent geben w√ºrde.  :) Wir arbeiten bereits mit einem Lumberyard-Team von Amazon an der Verwendung von PVS-Studio.  Da es sich um ein sehr gro√ües Unternehmen mit einer Reihe von Einheiten auf der ganzen Welt handelt, ist es sehr wahrscheinlich, dass das AWS SDK-Team f√ºr .NET noch nie von PVS-Studio geh√∂rt hat.  Wie auch immer, ich habe keine Anzeichen f√ºr die Verwendung unseres Analysators im SDK-Code gefunden, obwohl er nichts aussagt.  Zumindest verwendet das Team <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jedoch</a> den in Visual Studio integrierten Analysator.  Es ist gro√üartig, aber Code-Reviews k√∂nnen immer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verbessert werden</a> :). <br><br>  Infolgedessen habe ich es geschafft, einige Fehler im SDK-Code zu finden, und schlie√ülich ist es Zeit, sie zu teilen. <br><br>  <b>Fehler in der Logik</b> <br><br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3008</a> [CWE-563] Der Variablen 'this.linker.s3.region' werden zweimal nacheinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 116, 114. AWSSDK.DynamoDBv2.Net45 S3Link.cs 116 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Region { get { .... } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String.IsNullOrEmpty(value)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = <span class="hljs-string"><span class="hljs-string">"us-east-1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = value; } }</code> </pre> <br>  Der Analysator warnt vor einer wiederholten Wertzuweisung an dieselbe Variable.  Aus dem Code wird deutlich, dass dies auf den Fehler zur√ºckzuf√ºhren ist, der die Logik der Programmarbeit verletzt: Der Wert der Variablen <i>this.linker.s3.region</i> ist unabh√§ngig von der Bedingung immer gleich dem Wert des Variablenwerts <i>if (String.IsNullOrEmpty (Wert))</i> .  <i>Die return-</i> Anweisung wurde im Hauptteil des <i>if-</i> Blocks √ºbersehen.  Der Code muss wie folgt korrigiert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Region { get { .... } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String.IsNullOrEmpty(value)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = <span class="hljs-string"><span class="hljs-string">"us-east-1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = value; } }</code> </pre> <br>  <b>Unendliche Rekursion</b> <br><br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3110</a> [CWE-674] M√∂gliche unendliche Rekursion innerhalb der Eigenschaft 'OnFailure'.  AWSSDK.ElasticMapReduce.Net45 ResizeJobFlowStep.cs 171 <br><br><pre> <code class="cpp hljs">OnFailure? onFailure = null; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OnFailure? OnFailure { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.OnFailure; } <span class="hljs-comment"><span class="hljs-comment">// &lt;= set { this.onFailure = value; } }</span></span></code> </pre> <br>  Ein klassisches Beispiel f√ºr einen Tippfehler, der zu einer unendlichen Rekursion im <i>get-</i> Accessor der <i>OnFailure-</i> Eigenschaft f√ºhrt.  Anstatt den Wert eines privaten Felds <i>onFailure zur√ºckzugeben, erfolgt</i> der Zugriff auf die Eigenschaft <i>OnFailure</i> .  Richtige Variante: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OnFailure? OnFailure { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onFailure; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onFailure = value; } }</code> </pre> <br>  Sie fragen sich vielleicht: "Wie hat es funktioniert?"  Bisher - nein wie.  Die Eigenschaft wird nirgendwo anders verwendet, dies ist jedoch nur vor√ºbergehend.  Irgendwann wird jemand damit anfangen und sicherlich ein unerwartetes Ergebnis erhalten.  Um solche Tippfehler zu vermeiden, wird empfohlen, keine Bezeichner zu verwenden, die sich nur im Fall des ersten Buchstabens unterscheiden. <br><br>  Ein weiterer Kommentar zu dieser Konstruktion ist die Verwendung des Bezeichners, der vollst√§ndig mit dem Namen des <i>OnFailure-</i> Typs <i>√ºbereinstimmt</i> .  Aus Sicht des Compilers ist dies durchaus akzeptabel, dies erschwert jedoch die Wahrnehmung von Code f√ºr eine Person. <br><br>  Ein weiterer √§hnlicher Fehler: <br><br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3110</a> [CWE-674] M√∂gliche unendliche Rekursion innerhalb der Eigenschaft 'SSES3'.  AWSSDK.S3.Net45 InventoryEncryption.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SSES3 sSES3; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SSES3 SSES3 { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SSES3; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SSES3 = value; } }</code> </pre> <br>  Die Situation ist identisch mit der oben beschriebenen.  Hier tritt jedoch eine unendliche Rekursion auf, wenn auf die Eigenschaft <i>SSES3</i> sowohl zum Lesen als auch zum Zuweisen <i>zugegriffen wird</i> .  Richtige Variante: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SSES3 SSES3 { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sSES3; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sSES3 = value; } }</code> </pre> <br>  <b>Test unter Ber√ºcksichtigung</b> <br><br>  Jetzt m√∂chte ich eine Aufgabe eines Entwicklers zitieren, die mit der Copy-Paste-Methode erstellt wurde.  Sehen Sie sich an, wie Code im Visual Studio-Editor aussieht, und versuchen Sie, einen Fehler zu finden. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bfa/71b/1ab/bfa71b1ab4af941c43e5349df51b1614.png" alt="Bild 3"></p><br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3029</a> Die bedingten Ausdr√ºcke der nebeneinander angeordneten if-Anweisungen sind identisch.  √úberpr√ºfen Sie die Zeilen: 91, 95. AWSSDK.AppSync.Net45 CreateApiKeyResponseUnmarshaller.cs 91 <br><br>  Ich habe den Hauptteil der Methode <i>UnmarshallException reduziert</i> , nachdem ich alles entfernt habe, was nicht ben√∂tigt wird.  Jetzt k√∂nnen Sie sehen, dass identische Pr√ºfungen aufeinander folgen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override AmazonServiceException </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnmarshallException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errorResponse.Code != null &amp;&amp; errorResponse.Code.Equals(<span class="hljs-string"><span class="hljs-string">"LimitExceededException"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LimitExceededException(errorResponse.Message, innerException, errorResponse.Type, errorResponse.Code, errorResponse.RequestId, statusCode); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errorResponse.Code != null &amp;&amp; errorResponse.Code.Equals(<span class="hljs-string"><span class="hljs-string">"LimitExceededException"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LimitExceededException(errorResponse.Message, innerException, errorResponse.Type, errorResponse.Code, errorResponse.RequestId, statusCode); } .... }</code> </pre> <br>  Es scheint, dass der Fehler nicht grob ist - nur eine zus√§tzliche √úberpr√ºfung.  Trotzdem kann ein solches Muster h√§ufig auf schwerwiegendere Probleme im Code hinweisen, wenn eine erforderliche √úberpr√ºfung nicht durchgef√ºhrt wird. <br><br>  Im Code gibt es mehrere √§hnliche Fehler. <br><br>  <b>PVS-Studio-Warnungen:</b> <br><br><ul><li>  V3029 Die bedingten Ausdr√ºcke der nebeneinander angeordneten if-Anweisungen sind identisch.  √úberpr√ºfen Sie die Zeilen: 75, 79. AWSSDK.CloudDirectory.Net45 CreateSchemaResponseUnmarshaller.cs 75 </li><li>  V3029 Die bedingten Ausdr√ºcke der nebeneinander angeordneten if-Anweisungen sind identisch.  √úberpr√ºfen Sie die Zeilen: 105, 109. AWSSDK.CloudDirectory.Net45 GetSchemaAsJsonResponseUnmarshaller.cs 105 </li><li>  V3029 Die bedingten Ausdr√ºcke der nebeneinander angeordneten if-Anweisungen sind identisch.  √úberpr√ºfen Sie die Zeilen: 201, 205. AWSSDK.CodeCommit.Net45 PostCommentForPullRequestResponseUnmarshaller.cs 201 </li><li>  V3029 Die bedingten Ausdr√ºcke der nebeneinander angeordneten if-Anweisungen sind identisch.  √úberpr√ºfen Sie die Zeilen: 101, 105. AWSSDK.CognitoIdentityProvider.Net45 VerifySoftwareTokenResponseUnmarshaller.cs 101 </li><li>  V3029 Die bedingten Ausdr√ºcke der nebeneinander angeordneten if-Anweisungen sind identisch.  √úberpr√ºfen Sie die Zeilen: 72, 76. AWSSDK.Glue.Net45 UpdateConnectionResponseUnmarshaller.cs 72 </li><li>  V3029 Die bedingten Ausdr√ºcke der nebeneinander angeordneten if-Anweisungen sind identisch.  √úberpr√ºfen Sie die Zeilen: 123, 127. AWSSDK.Neptune.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 123 </li><li>  V3029 Die bedingten Ausdr√ºcke der nebeneinander angeordneten if-Anweisungen sind identisch.  √úberpr√ºfen Sie die Zeilen: 167, 171. AWSSDK.Neptune.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 167 </li><li>  V3029 Die bedingten Ausdr√ºcke der nebeneinander angeordneten if-Anweisungen sind identisch.  √úberpr√ºfen Sie die Zeilen: 127, 131. AWSSDK.RDS.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 127 </li><li>  V3029 Die bedingten Ausdr√ºcke der nebeneinander angeordneten if-Anweisungen sind identisch.  √úberpr√ºfen Sie die Zeilen: 171, 175. AWSSDK.RDS.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 171 </li><li>  V3029 Die bedingten Ausdr√ºcke der nebeneinander angeordneten if-Anweisungen sind identisch.  √úberpr√ºfen Sie die Zeilen: 99, 103. AWSSDK.Rekognition.Net45 RecognizeCelebritiesResponseUnmarshaller.cs 99 </li></ul><br>  <b>Was ist das</b> <br><br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3062</a> Ein Objekt 'attributeName' wird als Argument f√ºr seine eigene Methode verwendet.  √úberpr√ºfen Sie das erste tats√§chliche Argument der Methode 'Enth√§lt'.  AWSSDK.MobileAnalytics.Net45 CustomEvent.cs 261 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; /// Dictionary that stores attribute for this event only. /// &lt;/summary&gt; private Dictionary&lt;string,string&gt; _attributes = new Dictionary&lt;string,string&gt;(); /// &lt;summary&gt; /// Gets the attribute. /// &lt;/summary&gt; /// &lt;param name="attributeName"&gt;Attribute name.&lt;/param&gt; /// &lt;returns&gt;The attribute. Return null of attribute doesn't /// exist.&lt;/returns&gt; public string GetAttribute(string attributeName) { if(string.IsNullOrEmpty(attributeName)) { throw new ArgumentNullException("attributeName"); } string ret = null; lock(_lock) { if(attributeName.Contains(attributeName)) // &lt;= ret = _attributes[attributeName]; } return ret; }</span></span></code> </pre> <br>  Der Analysator hat einen Fehler in der <i>GetAttribute-</i> Methode <i>festgestellt</i> : Eine Zeichenfolge wird √ºberpr√ºft, ob sie sich selbst enth√§lt.  Aus der Beschreibung der Methode folgt, dass, wenn der Attributname ( <i>Attributname-</i> Schl√ºssel) gefunden wird (im W√∂rterbuch <i>_attributes</i> ), der Attributwert zur√ºckgegeben werden sollte, andernfalls - <i>null</i> .  Da die Bedingung <i>attributeName.Contains (attributeName)</i> immer wahr ist, wird versucht, den Wert durch einen Schl√ºssel zur√ºckzugeben, der m√∂glicherweise nicht in einem W√∂rterbuch gefunden wird.  Anstatt <i>null zur√ºckzugeben, wird dann</i> eine Ausnahme <i>KeyNotFoundException</i> ausgel√∂st. <br><br>  Versuchen wir, diesen Code zu beheben.  Um besser zu verstehen, wie das geht, sollten Sie sich eine andere Methode ansehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; /// Determines whether this instance has attribute the specified /// attributeName. /// &lt;/summary&gt; /// &lt;param name="attributeName"&gt;Attribute name.&lt;/param&gt; /// &lt;returns&gt;Return true if the event has the attribute, else /// false.&lt;/returns&gt; public bool HasAttribute(string attributeName) { if(string.IsNullOrEmpty(attributeName)) { throw new ArgumentNullException("attributeName"); } bool ret = false; lock(_lock) { ret = _attributes.ContainsKey(attributeName); } return ret; }</span></span></code> </pre> <br>  Diese Methode pr√ºft, ob der Attributname ( <i>Attributname-</i> Schl√ºssel) im W√∂rterbuch <i>_attributes vorhanden ist</i> .  <i>Kehren</i> wir noch einmal zur <i>GetAttribute-</i> Methode zur√ºck und beheben Sie den Fehler: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> attributeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(attributeName)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"attributeName"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret = null; lock(_lock) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_attributes.ContainsKey(attributeName)) ret = _attributes[attributeName]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br>  Jetzt macht die Methode genau das, was in der Beschreibung angegeben ist. <br><br>  Noch ein kleiner Kommentar zu diesem Codefragment.  Mir ist aufgefallen, dass die Autoren bei der Arbeit mit dem <i>_attributes-</i> W√∂rterbuch die <i>Sperre verwenden</i> .  Es ist klar, dass dies bei einem Multithread-Zugriff erforderlich ist, aber die <i>Schlosskonstruktion</i> ist ziemlich langsam und umst√§ndlich.  Anstelle eines <i>W√∂rterbuchs w√§re es</i> in diesem Fall m√∂glicherweise bequemer, eine thread-sichere Version des W√∂rterbuchs - <i>ConcurrentDictionary</i> - zu verwenden.  Auf diese Weise ist keine <i>Sperre</i> erforderlich <i>.</i>  Obwohl ich vielleicht nicht √ºber die Besonderheiten des Projekts Bescheid wei√ü. <br><br>  <b>Verd√§chtiges Verhalten</b> <br><br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3063</a> [CWE-571] Ein Teil des bedingten Ausdrucks ist immer wahr, wenn er ausgewertet wird: string.IsNullOrEmpty (inferredIndexName).  AWSSDK.DynamoDBv2.PCL ContextInternal.cs 802 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetQueryIndexName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> inferredIndexName = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(specifiedIndexName) &amp;&amp; indexNames.Count == <span class="hljs-number"><span class="hljs-number">1</span></span>) { inferredIndexName = indexNames[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (indexNames.Contains(specifiedIndexName, StringComparer.Ordinal)) { inferredIndexName = specifiedIndexName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(inferredIndexName) &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// &lt;= indexNames.Count &gt; 0) throw new InvalidOperationException("Local Secondary Index range key conditions are used but no index could be inferred from model. Specified index name = " + specifiedIndexName); .... }</span></span></code> </pre> <br>  Der Analysator war besorgt √ºber die <i>Pr√ºfzeichenfolge.IsNullOrEmpty (inferredIndexName)</i> .  In der Tat wird der Zeichenfolge <i>inferredIndexName</i> <i>null</i> zugewiesen, dann wird der Wert dieser Variablen nirgendwo ge√§ndert und aus irgendeinem Grund auf <i>null</i> oder eine leere Zeichenfolge √ºberpr√ºft.  Sieht verd√§chtig aus.  Schauen wir uns das obige Codefragment genauer an.  Ich habe es bewusst nicht reduziert, um die Situation besser zu verstehen.  In der ersten <i>if-</i> Anweisung (und auch in der n√§chsten) wird die Variable <i>specIndexName</i> irgendwie √ºberpr√ºft.  Abh√§ngig von den Ergebnissen der √úberpr√ºfungen erh√§lt die Variable <i>inferredIndexName</i> einen neuen Wert.  Schauen wir uns nun die dritte <i>if-</i> Anweisung an.  Der Hauptteil dieser Anweisung ( <i>Ausl√∂sen</i> der Ausnahme) wird ausgef√ºhrt, wenn <i>indexNames.Count&gt; 0</i> als erster Teil der gesamten Bedingung, n√§mlich <i>string.IsNullOrEmpty (inferredIndexName),</i> immer wahr ist.  M√∂glicherweise sind die <i>angegebenen</i> VariablenIndexName und <i>inferredIndexName</i> verwechselt, oder die dritte Pr√ºfung muss ohne <i>andere erfolgen</i> , was eine eigenst√§ndige <i>if-</i> Anweisung darstellt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(specifiedIndexName) &amp;&amp; indexNames.Count == <span class="hljs-number"><span class="hljs-number">1</span></span>) { inferredIndexName = indexNames[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (indexNames.Contains(specifiedIndexName, StringComparer.Ordinal)) { inferredIndexName = specifiedIndexName; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(inferredIndexName) &amp;&amp; indexNames.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(....);</code> </pre> <br>  In diesem Fall ist es schwierig, eine eindeutige Antwort auf Optionen zur Behebung dieses Codes zu geben.  Auf jeden Fall muss der Autor es √ºberpr√ºfen. <br><br>  <b>NullReferenceException</b> <br><br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3095</a> [CWE-476] Das Objekt 'conditionValues' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 228, 238. AWSSDK.Core.Net45 JsonPolicyWriter.cs 228 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeConditions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { IList&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; conditionValues = keyEntry.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; .... if (conditionValues != null &amp;&amp; conditionValues.Count != 0) { .... } .... } }</span></span></code> </pre> <br>  Es ist ein Klassiker.  Die Variable <i>conditionValues</i> wird ohne vorl√§ufige Pr√ºfung auf <i>null verwendet</i> .  W√§hrend sp√§ter im Code diese √úberpr√ºfung durchgef√ºhrt wird.  Der Code muss wie folgt korrigiert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeConditions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { IList&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; conditionValues = keyEntry.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues != null &amp;&amp; conditionValues.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues != null &amp;&amp; conditionValues.Count != <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } .... } }</code> </pre> <br>  Ich habe mehrere √§hnliche Fehler im Code gefunden. <br><br>  <b>PVS-Studio-Warnungen:</b> <br><br><ul><li>  V3095 [CWE-476] Das Objekt 'ts.Listeners' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 140, 143. AWSSDK.Core.Net45 Logger.Diagnostic.cs 140 </li><li>  V3095 [CWE-476] Das Objekt 'obj' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 743, 745. AWSSDK.Core.Net45 JsonMapper.cs 743 </li><li>  V3095 [CWE-476] Das Objekt 'multipartUploadMultipartUploadpartsList' wurde verwendet, bevor es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 65, 67. AWSSDK.S3.Net45 CompleteMultipartUploadRequestMarshaller.cs 65 </li></ul><br>  Die folgende Warnung ist in ihrer Bedeutung sehr √§hnlich, aber der Fall ist dem oben diskutierten entgegengesetzt. <br><br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3125</a> [CWE-476] Das ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">state'</a> -Objekt wurde verwendet, nachdem es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 139, 127. AWSSDK.Core.Net45 RefreshingAWSCredentials.cs 139 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateToGeneratedCredentials</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( CredentialsRefreshState state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> errorMessage; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ShouldUpdate) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == null) errorMessage = <span class="hljs-string"><span class="hljs-string">"Unable to generate temporary credentials"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AmazonClientException(errorMessage); } state.Expiration -= PreemptExpiryTime; <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Eines der Codefragmente umfasst das √úberpr√ºfen des Werts der Statusvariablen auf <i>Null</i> .  Im folgenden Code wird die Variable zum Abbestellen des <i>PreemptExpiryTime-</i> Ereignisses verwendet. Es wird jedoch keine √úberpr√ºfung auf <i>Null</i> mehr durchgef√ºhrt und das <i>Ausl√∂sen</i> der Ausnahme <i>NullReferenceException</i> wird m√∂glich.  Eine sicherere Version des Codes: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateToGeneratedCredentials</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( CredentialsRefreshState state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> errorMessage; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ShouldUpdate) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == null) errorMessage = <span class="hljs-string"><span class="hljs-string">"Unable to generate temporary credentials"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AmazonClientException(errorMessage); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state != null) state.Expiration -= PreemptExpiryTime; .... }</code> </pre> <br>  Im Code gibt es andere √§hnliche Fehler: <br><br>  <b>PVS-Studio-Warnungen:</b> <br><br><ul><li>  V3125 [CWE-476] Das Objekt 'wrapRequest.Content' wurde verwendet, nachdem es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 395, 383. AWSSDK.Core.Net45 HttpHandler.cs 395 </li><li>  V3125 [CWE-476] Das Objekt 'datasetUpdates' wurde verwendet, nachdem es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 477, 437. AWSSDK.CognitoSync.Net45 Dataset.cs 477 </li><li>  V3125 [CWE-476] Das Objekt 'cORSConfigurationCORSConfigurationcORSRulesListValue' wurde verwendet, nachdem es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 125, 111. AWSSDK.S3.Net45 PutCORSConfigurationRequestMarshaller.cs 125 </li><li>  V3125 [CWE-476] Das Objekt 'lifecycleConfigurationLifecycleConfigurationrulesListValue' wurde verwendet, nachdem es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 157, 68. AWSSDK.S3.Net45 PutLifecycleConfigurationRequestMarshaller.cs 157 </li><li>  V3125 [CWE-476] Das Objekt 'this.Key' wurde verwendet, nachdem es gegen null verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 199, 183. AWSSDK.S3.Net45 S3PostUploadRequest.cs 199 </li></ul><br>  <b>Nicht alternative Realit√§t</b> <br><br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3009</a> [CWE-393] Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  AWSSDK.Core.Net45 Lexer.cs 651 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State19</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'"'</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'\\'</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Die Methode gibt immer <i>true zur√ºck</i> .  Mal sehen, wie wichtig es f√ºr den aufrufenden Code ist.  Ich habe die F√§lle der Verwendung der <i>State19-</i> Methode √ºberpr√ºft.  Es ist daran beteiligt, das Array der Handler <i>fsm_handler_table</i> gleicherma√üen mit anderen √§hnlichen Methoden zu <i>f√ºllen</i> (es gibt 28 davon mit den Namen, beginnend von <i>State1</i> bis <i>State28</i> ).  Hierbei ist zu beachten, dass neben <i>State19</i> f√ºr einige andere Handler auch die Warnungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3009</a> [CWE-393] ausgegeben wurden.  Dies sind Handler: <i>State23, State26, State27, State28</i> .  Die vom Analysator f√ºr sie ausgegebenen Warnungen: <br><br><ul><li>  V3009 [CWE-393] Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  AWSSDK.Core.Net45 Lexer.cs 752 </li><li>  V3009 [CWE-393] Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  AWSSDK.Core.Net45 Lexer.cs 810 </li><li>  V3009 [CWE-393] Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  AWSSDK.Core.Net45 Lexer.cs 822 </li><li>  V3009 [CWE-393] Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  AWSSDK.Core.Net45 Lexer.cs 834 </li></ul><br>  So sehen die Deklaration und die Array-Initialisierung von Handlern aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StateHandler[] fsm_handler_table; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PopulateFsmTables</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fsm_handler_table = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StateHandler[<span class="hljs-number"><span class="hljs-number">28</span></span>] { State1, State2, .... State19, .... State23, .... State26, State27, State28 };</code> </pre> <br>  Um das Bild zu vervollst√§ndigen, sehen wir uns den Code eines der Handler an, f√ºr die der Analysator keine Anspr√ºche hatte, z. B. <i>State2</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State2</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  So erfolgt der Aufruf von Handlern: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextToken</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { handler = fsm_handler_table[state - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! handler (fsm_context)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= throw new JsonException (input_char); .... } .... }</span></span></code> </pre> <br>  Wie wir sehen k√∂nnen, wird eine Ausnahme ausgel√∂st, wenn <i>false zur√ºckgegeben wird</i> .  In unserem Fall wird dies f√ºr die Handler <i>State19, State23, State26 State27</i> und <i>State28</i> niemals passieren.  Sieht verd√§chtig aus.  Auf der anderen Seite haben f√ºnf Handler ein √§hnliches Verhalten (geben immer <i>true zur√ºck</i> ). Vielleicht wurde es so erfunden und ist nicht das Ergebnis eines Tippfehlers. <br><br>  Warum gehe ich so tief in all das?  Diese Situation ist insofern von gro√üer Bedeutung, als der statische Analysator h√§ufig nur eine verd√§chtige Konstruktion anzeigen kann.  Und selbst eine Person (keine Maschine), die nicht √ºber ausreichende Kenntnisse √ºber das Projekt verf√ºgt, kann immer noch keine vollst√§ndige Antwort auf das Vorhandensein des Fehlers geben, selbst wenn sie Zeit damit verbracht hat, Code zu lernen.  Ein Entwickler sollte diesen Code √ºberpr√ºfen. <br><br>  <b>Sinnlose Schecks</b> <br><br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022</a> [CWE-571] Der Ausdruck 'doLog' ist immer wahr.  AWSSDK.Core.Net45 StoredProfileAWSCredentials.cs 235 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidCredentialsExistInSharedFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var doLog = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { doLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InvalidDataException) { doLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doLog) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... } .... }</span></span></code> </pre> <br>  <i>Achten Sie auf die</i> Variable <i>doLog</i> .  Nach der Initialisierung mit dem <i>falschen</i> Wert erh√§lt diese Variable in allen F√§llen den <i>wahren</i> Wert weiter entlang des Codes.  Daher ist die √úberpr√ºfung, <i>ob (doLog)</i> immer wahr ist.  M√∂glicherweise gab es fr√ºher in der Methode einen Zweig, in dem der Variablen <i>doLog</i> kein Wert zugewiesen wurde.  Zum Zeitpunkt der √úberpr√ºfung kann es den <i>falschen</i> Wert enthalten, der beim Initialisieren empfangen wurde.  Aber jetzt gibt es keinen solchen Zweig. <br><br>  Ein weiterer √§hnlicher Fehler: <br><br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022</a> Ausdruck '! Ergebnis' ist immer falsch.  AWSSDK.CognitoSync.PCL SQLiteLocalStorage.cs 353 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PutValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = PutValueHelper(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!result) &lt;= { _logger.DebugFormat(<span class="hljs-string"><span class="hljs-string">"{0}"</span></span>, @<span class="hljs-string"><span class="hljs-string">"Cognito Sync - SQLiteStorage - Put Value Failed"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { UpdateLastModifiedTimestamp(....); } .... }</code> </pre> <br>  Der Analysator behauptet, dass der Wert der <i>Ergebnisvariablen</i> immer wahr ist.  <i>Dies</i> ist nur m√∂glich, wenn die Methode <i>PutValueHelper</i> immer <i>true</i> <i>zur√ºckgibt</i> .  Schauen Sie sich diese Methode an: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PutValueHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record == null) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br>  In der Tat wird die Methode unter allen Bedingungen <i>true zur√ºckgeben</i> .  Dar√ºber hinaus hat der Analysator eine Warnung f√ºr diese Methode ausgegeben.  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3009</a> [CWE-393] Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zur√ºckgibt.  SQLiteLocalStorage.cs 1016 <br><br>  Ich habe diese Warnung absichtlich nicht fr√ºher zitiert, als ich nach anderen Fehlern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3009 gefragt</a> und sie f√ºr diesen Fall gespeichert habe.  Daher hat das Tool zu Recht auf den Fehler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022</a> im aufrufenden Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hingewiesen</a> . <br><br>  <b>Kopieren-Einf√ºgen.</b>  <b>Wieder</b> <br><br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3001</a> Links und rechts vom '||' befinden sich identische Unterausdr√ºcke 'this.token == JsonToken.String'.  Betreiber.  AWSSDK.Core.Net45 JsonReader.cs 343 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.ObjectEnd || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.ArrayEnd || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.String || <span class="hljs-comment"><span class="hljs-comment">// &lt;= this.token == JsonToken.Boolean || this.token == JsonToken.Double || this.token == JsonToken.Int || this.token == JsonToken.UInt || this.token == JsonToken.Long || this.token == JsonToken.ULong || this.token == JsonToken.Null || this.token == JsonToken.String // &lt;= )) { .... } .... }</span></span></code> </pre> <br>  Das Feld <i>this.token</i> wird zweimal mit dem Wert <i>JsonToken.String</i> der Aufz√§hlung <i>JsonToken verglichen</i> .  Wahrscheinlich sollte einer der Vergleiche einen anderen Aufz√§hlungswert enthalten.  Wenn ja, wurde hier ein schwerwiegender Fehler gemacht. <br><br>  <b>Refactoring + Unaufmerksamkeit?</b> <br><br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3025</a> [CWE-685] Falsches Format.  Beim Aufrufen der Funktion 'Format' wird eine andere Anzahl von Formatelementen erwartet.  Nicht verwendete Argumente: AWSConfigs.AWSRegionKey.  AWSSDK.Core.Net45 AWSRegion.cs 116 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InstanceProfileAWSRegion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Format(CultureInfo.InvariantCulture, <span class="hljs-string"><span class="hljs-string">"EC2 instance metadata was not available or did not contain region information."</span></span>, AWSConfigs.AWSRegionKey)); } .... }</code> </pre> <br>  M√∂glicherweise enthielt die <i>Formatzeichenfolge</i> f√ºr die Methode <i>string.Format</i> zuvor das <i>Formatelement</i> <i>{0},</i> f√ºr das das Argument <i>AWSConfigs.AWSRegionKey</i> festgelegt wurde.  Dann wurde die Zeichenfolge ge√§ndert, das Formatelement wurde entfernt, aber ein Entwickler hat vergessen, das Argument zu entfernen.  Das angegebene Codebeispiel funktioniert fehlerfrei (die Ausnahme wurde im umgekehrten Fall ausgel√∂st - das Formatelement ohne Argument), sieht aber nicht gut aus.  Der Code sollte wie folgt korrigiert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( <span class="hljs-string"><span class="hljs-string">"EC2 instance metadata was not available or did not contain region information."</span></span>); }</code> </pre> <br>  <b>Unsicher</b> <br><br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3083</a> [CWE-367] Unsicherer Aufruf des Ereignisses 'mOnSyncSuccess', NullReferenceException ist m√∂glich.  √úberlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen m√∂chten, bevor Sie sie aufrufen.  AWSSDK.CognitoSync.PCL Dataset.cs 827 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FireSyncSuccessEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Record&gt; records)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mOnSyncSuccess != null) { mOnSyncSuccess(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SyncSuccessEventArgs(records)); } }</code> </pre> <br>  Eine h√§ufige Situation eines unsicheren Aufrufs des Ereignishandlers.  Ein Benutzer kann sich zwischen der √úberpr√ºfung der Variablen <i>mOnSyncSuccess</i> auf <i>null</i> und dem Aufruf eines <i>Handlers</i> abmelden, sodass sein Wert <i>null wird</i> .  Die Wahrscheinlichkeit eines solchen Szenarios ist gering, aber es ist immer noch besser, Code sicherer zu machen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FireSyncSuccessEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Record&gt; records)</span></span></span><span class="hljs-function"> </span></span>{ mOnSyncSuccess?.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SyncSuccessEventArgs(records)); }</code> </pre> <br>  Im Code gibt es andere √§hnliche Fehler: <br><br>  <b>PVS-Studio-Warnungen:</b> <br><br><ul><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses 'mOnSyncFailure', NullReferenceException ist m√∂glich.  √úberlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen m√∂chten, bevor Sie sie aufrufen.  AWSSDK.CognitoSync.PCL Dataset.cs 839 </li><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses, NullReferenceException ist m√∂glich.  √úberlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen m√∂chten, bevor Sie sie aufrufen.  AWSSDK.Core.PCL AmazonServiceClient.cs 332 </li><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses, NullReferenceException ist m√∂glich.  √úberlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen m√∂chten, bevor Sie sie aufrufen.  AWSSDK.Core.PCL AmazonServiceClient.cs 344 </li><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses, NullReferenceException ist m√∂glich.  √úberlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen m√∂chten, bevor Sie sie aufrufen.  AWSSDK.Core.PCL AmazonServiceClient.cs 357 </li><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses 'mExceptionEvent', NullReferenceException ist m√∂glich.  √úberlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen m√∂chten, bevor Sie sie aufrufen.  AWSSDK.Core.PCL AmazonServiceClient.cs 366 </li><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses, NullReferenceException ist m√∂glich.  √úberlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen m√∂chten, bevor Sie sie aufrufen.  AWSSDK.Core.PCL AmazonWebServiceRequest.cs 78 </li><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses 'OnRead', NullReferenceException ist m√∂glich.  √úberlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen m√∂chten, bevor Sie sie aufrufen.  AWSSDK.Core.PCL EventStream.cs 97 </li><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses, NullReferenceException ist m√∂glich.  √úberlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen m√∂chten, bevor Sie sie aufrufen.  AWSSDK.Core.Android NetworkReachability.cs 57 </li><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses, NullReferenceException ist m√∂glich.  √úberlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen m√∂chten, bevor Sie sie aufrufen.  AWSSDK.Core.Android NetworkReachability.cs 94 </li><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses, NullReferenceException ist m√∂glich.  √úberlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen m√∂chten, bevor Sie sie aufrufen.  AWSSDK.Core.iOS NetworkReachability.cs 54 </li></ul><br>  <b>Rohklasse</b> <br><br>  <b>PVS-Studio-Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3126 Der</a> Typ 'JsonData', der die IEquatable &lt;T&gt; -Schnittstelle implementiert, √ºberschreibt die 'GetHashCode'-Methode nicht.  AWSSDK.Core.Net45 JsonData.cs 26 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonData</span></span></span><span class="hljs-class"> :</span></span> IJsonWrapper, IEquatable&lt;JsonData&gt; { .... }</code> </pre> <br>  Die <i>JsonData-</i> Klasse enth√§lt ziemlich viel Code, daher habe ich sie nicht vollst√§ndig angegeben und nur ihre Deklaration zitiert.  Diese Klasse enth√§lt wirklich nicht die √ºberschriebene Methode <i>GetHashCode,</i> die unsicher ist, da sie zu fehlerhaftem Verhalten f√ºhren kann, wenn der Typ <i>JsonData beispielsweise</i> f√ºr die Arbeit mit Sammlungen verwendet wird.  Wahrscheinlich gibt es im Moment kein Problem, aber in Zukunft k√∂nnte sich diese Art von Strategie √§ndern.  Dieser Fehler wird in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> ausf√ºhrlicher beschrieben. <br><br>  <b>Fazit</b> <br><br>  Dies sind alles interessante Fehler, die ich im Code des AWS SDK f√ºr .NET mithilfe des statischen Analysators PVS-Studio feststellen konnte.  Ich m√∂chte noch einmal die Qualit√§t des Projekts hervorheben.  Ich habe eine sehr kleine Anzahl von Fehlern f√ºr 5 Millionen Codezeilen gefunden.  Obwohl eine wahrscheinlich gr√ºndlichere Analyse der ausgegebenen Warnungen es mir erm√∂glichen w√ºrde, dieser Liste einige weitere Fehler hinzuzuf√ºgen.  Trotzdem ist es auch sehr wahrscheinlich, dass ich einige der Warnungen umsonst zu Fehlern hinzugef√ºgt habe.  Eindeutige Schlussfolgerungen werden in diesem Fall immer nur von einem Entwickler gezogen, der sich im Kontext des gepr√ºften Codes befindet. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437514/">https://habr.com/ru/post/de437514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437502/index.html">Ich werde aufh√∂ren, das Gute in den M√ºll zu werfen</a></li>
<li><a href="../de437504/index.html">Winzige Komponenten: Was k√∂nnte schief gehen? Wir verwenden das Prinzip der alleinigen Verantwortung</a></li>
<li><a href="../de437508/index.html">CVE-2019-6111 und andere SCP-Schwachstellen</a></li>
<li><a href="../de437510/index.html">Was passiert, wenn Sie SMS senden?</a></li>
<li><a href="../de437512/index.html">Was sind reine Funktionen in JavaScript?</a></li>
<li><a href="../de437516/index.html">Suchen nach Fehlern im Amazon Web Services SDK f√ºr .NET-Quellcode</a></li>
<li><a href="../de437518/index.html">K√§fer greifen an</a></li>
<li><a href="../de437520/index.html">‚ÄûMein Licht ist ein Spiegel! - Sagen Sie, zeigen Sie mir mein Dual ... ": Entwerfen Sie einen guten Rahmen und erhalten Sie den zweiten als Geschenk</a></li>
<li><a href="../de437522/index.html">Kolonie. Kapitel 22: Endg√ºltige Entscheidung</a></li>
<li><a href="../de437524/index.html">Erstellen Sie eine einfache Schach-KI: 5 einfache Schritte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>