<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏽 🤱🏽 😩 PostgreSQL Antipatterns: mise à jour d'une grande table en charge 💟 ⬜️ 👨🏼‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Que dois-je faire (et certainement pas) si vous avez besoin de mettre à jour un grand nombre d'enregistrements dans la table PostgreSQL activement uti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL Antipatterns: mise à jour d'une grande table en charge</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/481610/">  Que dois-je faire (et certainement pas) si vous avez besoin de <b>mettre</b> à <b>jour un grand nombre d'enregistrements</b> dans la table PostgreSQL activement utilisée "plusieurs millions" - initialiser la valeur du nouveau champ ou corriger les erreurs dans les enregistrements existants?  Et en même temps, économisez votre temps et ne perdez pas d'argent en raison des temps d'arrêt. <br><br><img src="https://habrastorage.org/webt/vw/8_/jj/vw8_jjubp0owqcielxtg6gjufng.png"><br><a name="habracut"></a><br>  Préparez les données de test: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl(k <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, v <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">chr</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ascii</span></span>(<span class="hljs-string"><span class="hljs-string">'a'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) + (random() * <span class="hljs-number"><span class="hljs-number">26</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) k , (random() * <span class="hljs-number"><span class="hljs-number">100</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000000</span></span>) i; <span class="hljs-comment"><span class="hljs-comment">--  ,   ! CREATE INDEX ON tbl(k, v);</span></span></code> </pre> <br>  Supposons que nous voulions simplement augmenter la valeur de v de 1 pour tous les enregistrements avec k dans la plage «q» .. «z». <br><br>  Mais, avant de commencer les expériences, nous allons enregistrer le jeu de données d'origine afin d'avoir des résultats «propres» à chaque fois: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> _tbl <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl;</code> </pre> <br><h2>  MISE À JOUR: un pour tous et tous pour un </h2><br>  L'option la plus simple qui vient immédiatement à l'esprit est de tout faire «en une seule MISE À JOUR»: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> v = v + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-string"><span class="hljs-string">'q'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-string"><span class="hljs-string">'z'</span></span>;</code> </pre> <br><img src="https://habrastorage.org/webt/zs/0h/nb/zs0hnbsdmvjrctxn_wkia0wr6oy.png"><br>  <a href="https://explain.tensor.ru/archive/explain/197f26d0cedf3abba51a15d4650c897e:0:2019-12-23">[regardez expliquez.tensor.ru]</a> <br><br>  Une opération assez simple, semble-t-il, sur des lignes complètement «courtes» a pris plus de 2,5 secondes.  Et si votre expression est plus compliquée, la ligne est plus authentique, il y a plus d'enregistrements et même certains déclencheurs interviennent - le temps peut même augmenter jusqu'à quelques minutes, mais jusqu'à plusieurs heures.  Supposons que vous soyez prêt à attendre, et le reste de votre système, lié à cette base, s'il a une charge OLTP active? <br><br>  Le problème est que dès que UPDATE atteint un enregistrement particulier, il le <b>bloque jusqu'à la fin de l'exécution</b> .  Si simultanément avec le même enregistrement, il veut travailler sur une MISE À JOUR «spot» lancée parallèlement, il <b>«accrochera» toujours à attendre un blocage</b> pour la demande de mise à jour, et s'affaissera jusqu'à la fin de son travail. <br><br><img src="https://habrastorage.org/webt/p7/gx/qu/p7gxqutnt9o8zuwiwjlbmrf4fk8.png"><br>  © <a href="http://wumo.com/wumo">wumo.com/wumo</a> <br><br>  Le pire des cas est celui des systèmes Web, où les connexions à la base de données sont créées selon les besoins - après tout, ces connexions "pendantes" s'accumulent et consommeront les ressources de la base de données et du client, si vous ne créez pas un mécanisme de défense distinct à partir de cela. <br><br><h2>  Transactions fractionnées </h2><br>  En général, tout n'est pas très bon si tout se fait en une seule demande.  Oui, et même si nous divisons une grande MISE À JOUR en plusieurs petites, mais laissons tout cela fonctionner <b>dans une seule transaction</b> , le problème de verrouillage restera le même, car les enregistrements mutables sont verrouillés jusqu'à la fin de la transaction entière. <br><br>  Nous devons donc diviser une grande transaction en plusieurs.  Pour ce faire, nous pouvons soit utiliser des moyens externes, et écrire une sorte de script qui génère des transactions distinctes, soit utiliser les opportunités que la base de données elle-même peut nous fournir. <br><br><h4>  APPEL et gestion des transactions </h4><br>  À partir de PostgreSQL 11, il est <a href="https://postgrespro.ru/docs/postgresql/11/plpgsql-transactions">possible de gérer les transactions</a> directement dans le code de procédure: <br><blockquote>  Dans les procédures appelées par la commande CALL, ainsi que dans les blocs de code anonymes (dans la commande DO), vous pouvez effectuer des transactions en exécutant COMMIT et ROLLBACK.  Une fois la transaction terminée par ces commandes, une nouvelle sera automatiquement lancée. </blockquote>  Mais cette version est loin de tout le monde, et travailler avec CALL a ses limites.  Par conséquent, nous essaierons de résoudre notre problème sans moyens externes, et pour qu'il fonctionne sur toutes les versions actuelles, et même avec des changements minimes sur le serveur lui-même - afin qu'il ne soit pas nécessaire de compiler et de redémarrer quoi que ce soit. <br><br>  Pour la même raison, nous ne considérerons pas l'option d'organiser <a href="https://blog.dalibo.com/2016/08/19/Autonoumous_transactions_support_in_PostgreSQL.html">des transactions autonomes via pg_background</a> . <br><br><h4>  Gérer les connexions «à l'intérieur» de la base </h4><br>  PostgreSQL a toujours utilisé différentes méthodes pour <a href="https://www.cybertec-postgresql.com/en/implementing-autonomous-transactions-in-postgres/">émuler des transactions autonomes</a> , générant des connexions supplémentaires distinctes - via des langages procéduraux supplémentaires ou le <a href="https://postgrespro.ru/docs/postgresql/12/dblink">module dblink</a> standard.  L'avantage de ce dernier est qu'il est inclus par défaut dans la plupart des distributions, et qu'une seule commande est requise pour l'activer dans la base de données: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> EXTENSION dblink;</code> </pre> <br><h2>  "... et beaucoup, beaucoup d'enfants dégoûtants amenés" </h2><br>  Mais avant de créer une liaison dblink, voyons d'abord comment un «développeur ordinaire» décompose un grand ensemble de données, qu'il doit mettre à jour, en petits. <br><br><h3>  Naive LIMIT ... OFFSET </h3><br>  La première idée est de faire une recherche de «pagination»: <i>«Sélectionnons les <b>mille enregistrements suivants à</b> chaque fois»</i> en augmentant OFFSET à chaque nouvelle demande: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl T <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> v = Tv + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> k , v <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-string"><span class="hljs-string">'q'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-string"><span class="hljs-string">'z'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-comment"><span class="hljs-comment">--       k, v --     ! LIMIT $1 OFFSET $2 * $1 ) S WHERE (Tk, Tv) = (Sk, Sv);</span></span></code> </pre> <br>  Avant de tester les performances de cette solution, nous allons restaurer l'ensemble de données: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> _tbl;</code> </pre> <br>  Comme nous l'avons vu dans le plan ci-dessus, nous devrons mettre à jour environ 384 000 enregistrements.  Par conséquent, voyons immédiatement comment les mises à jour seront effectuées plus près de la fin - <b>dans la région de la 300e itération de 1000 entrées</b> : <br><br><img src="https://habrastorage.org/webt/j8/h3/ju/j8h3juddfyiwgyg6nxe4yjmp5w4.png"><br>  <a href="https://explain.tensor.ru/archive/explain/922c49ce866d7c879d15c7d144efff86:0:2019-12-23">[regardez expliquez.tensor.ru]</a> <br><br>  Oh ... La mise à jour de l'échantillon à la fin de tous les <b>enregistrements 1K</b> nous coûtera presque autant de temps que la <b>version originale entière</b> ! <br><br>  Ce n'est pas notre choix.  Il peut toujours être utilisé d'une manière ou d'une autre si vous obtenez peu d'itérations et de petites valeurs OFFSET.  Parce que le <b>LIMIT X OFFSET Y</b> pour la base de données équivaut à " <i>soustraire / sélectionner / former les premiers enregistrements X + Y, puis jeter le premier Y dans la corbeille</i> ", ce qui pour les grandes valeurs de Y semble tragique. <br><br>  En fait, cette méthode <b>ne peut pas être appliquée du tout</b> !  Non seulement nous nous appuyons sur des valeurs mises à jour pour la sélection, mais nous risquons également de sauter une partie des enregistrements et de mettre à jour l'autre partie deux fois si des blocs avec les mêmes clés atteignent la bordure de la page: <br><br><img src="https://habrastorage.org/webt/v0/kh/mn/v0khmnh_afkafan4fvvf4sfgq34.png"><br>  Dans cet exemple, nous avons mis à jour l'enregistrement vert deux fois et l'enregistrement rouge jamais.  Tout simplement parce qu'avec les mêmes valeurs des clés de tri, l'ordre des enregistrements eux-mêmes à l'intérieur d'un tel bloc n'est pas fixe. <br><br><h3>  TRÈS ORDRE PAR ... LIMITE </h3><br>  Modifions un peu la tâche - ajoutons un nouveau champ dans lequel nous écrirons notre valeur v + 1: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> x <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>;</code> </pre> <br>  Veuillez noter que cette conception fonctionne presque instantanément, sans réécrire la table entière.  Mais si vous ajoutez une valeur DEFAULT, alors - seulement à <a href="https://www.depesz.com/2018/04/04/waiting-for-postgresql-11-fast-alter-table-add-column-with-a-non-null-default/">partir de la 11ème version</a> . <br><br>  Déjà enseigné par une expérience amère, créons immédiatement un index dans lequel seules les entrées non initialisées resteront: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> CONCURRENTLY <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl(k, v) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>;</code> </pre> <br>  L'index CONCURRENTLY ne bloque pas le travail de lecture-écriture avec la table, alors qu'il roule lentement même sur un énorme ensemble de données. <br><br>  Maintenant, l'idée est <i>"Sélectionnons à partir de cet index à chaque fois <b>seulement les mille premiers enregistrements</b> "</i> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl T <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> x = Tv + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-string"><span class="hljs-string">'q'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-string"><span class="hljs-string">'z'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-comment"><span class="hljs-comment">--   OFFSET! ) S WHERE (Tk, Tv) = (Sk, Sv) AND Tx IS NULL;</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ne/dp/ck/nedpck-lvoeexx1ffpb63v8nd1w.png"><br>  <a href="https://explain.tensor.ru/archive/explain/9a152e5f94595f995599c9c558fc6f37:0:2019-12-23">[regardez expliquez.tensor.ru]</a> <br><br>  Déjà beaucoup mieux - la durée de chaque transaction individuelle est désormais plus courte d'environ 6 fois. <br><br>  Mais voyons à nouveau en quoi le plan de la 200e itération va se transformer: <br><br><pre> <code class="plaintext hljs">Update on tbl t (actual time=530.591..530.591 rows=0 loops=1) Buffers: shared hit=789337 read=1 dirtied=1</code> </pre> <br>  Le temps a encore empiré (seulement 25%, cependant) et les tampons ont augmenté - mais pourquoi? <br>  Le fait est que <a href="https://habr.com/ru/company/postgrespro/blog/445820/">MVCC dans PostgreSQL</a> laisse des «âmes mortes» dans l'index - des versions d'enregistrements déjà mis à jour, qui ne conviennent plus à l'index.  Autrement dit, en ne prenant que les 1000 premiers enregistrements à la 200e itération, nous analysons <b>toujours</b> , bien que plus tard, nous supprimions, les versions 199K précédentes des tuples ont déjà changé. <br><br>  Si des itérations chez nous sont nécessaires non pas plusieurs centaines, mais plusieurs centaines de milliers, la dégradation sera plus visible à chaque exécution de requête suivante. <br><br><h2>  MISE À JOUR par segment </h2><br>  En fait, pourquoi sommes-nous si attachés à cette valeur de «1000 enregistrements»?  Après tout, nous <b>n'avons aucune raison de choisir exactement 1000</b> ou un autre numéro spécifique.  Nous voulions simplement «couper» l'ensemble complet de données en certains <b>segments disjoints</b> , pas nécessairement égaux - utilisons donc notre index existant pour l'usage auquel il est destiné. <br><br>  Une <b>paire indexée (k, v) est</b> excellente pour notre tâche.  Construisons une requête afin qu'elle puisse s'appuyer sur la dernière paire traitée: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> kv <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (k, v) &gt; ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-string"><span class="hljs-string">'q'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-string"><span class="hljs-string">'z'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ) , upd <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl T <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> x = Tv + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (Tk, Tv) = (<span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> kv) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> Tx <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> k, v ) <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> upd <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  À la première itération, il nous suffit de définir les paramètres de la requête à la <b>valeur «zéro» ('', 0)</b> , et pour chaque itération suivante, nous prenons le <b>résultat de la requête précédente</b> . <br><br><img src="https://habrastorage.org/webt/ok/ea/fg/okeafgsqia7iejthcmz2wuvsnm0.png"><br>  <a href="https://explain.tensor.ru/archive/explain/2e6ac5867caa6be474c3845dcb7eebcb:0:2019-12-23">[regardez expliquez.tensor.ru]</a> <br><br>  Le temps de transaction / verrouillage est inférieur à une milliseconde, il n'y a pas de dégradation par le nombre d'itérations, une analyse préliminaire complète de toutes les données du tableau n'est pas requise.  Super! <br><br><div class="spoiler">  <b class="spoiler_title">Mettre la version finale avec dblink</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> k <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; v integer = 0; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> PERFORM dblink_connect(<span class="hljs-string"><span class="hljs-string">'dbname='</span></span> || current_database() || <span class="hljs-string"><span class="hljs-string">' port='</span></span> || current_setting(<span class="hljs-string"><span class="hljs-string">'port'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">--  PREPARED STATEMENT,      PERFORM dblink($q$ PREPARE _q(text, integer) AS WITH kv AS ( SELECT k, v FROM tbl WHERE (k, v) &gt; ($1, $2) AND k BETWEEN 'q' AND 'z' AND x IS NULL ORDER BY k, v LIMIT 1 ) , upd AS ( UPDATE tbl T SET x = Tv + 1 WHERE (Tk, Tv) = (TABLE kv) AND Tx IS NULL RETURNING k, v ) TABLE upd LIMIT 1; $q$); -- ,    LOOP SELECT * INTO k, v FROM dblink($p$EXECUTE _q('$p$ || k || $p$',$p$ || v || $p$)$p$) T(k text, v integer); RAISE NOTICE '(k,v) = (''%'',%)', k, v; --   ,     EXIT WHEN (k, v) IS NULL; END LOOP; PERFORM dblink_disconnect(); END; $$ LANGUAGE plpgsql;</span></span></code> </pre> <br></div></div><br>  Un avantage supplémentaire de cette méthode est la possibilité d'interrompre l'exécution de ce script à tout moment, puis de reprendre à partir du point souhaité. <br><br><h2>  Calculs complexes dans UPDATE </h2><br>  Je mentionnerai séparément la situation avec le calcul difficile de la valeur affectée - lorsque vous devez calculer quelque chose à partir des tables liées. <br><br>  Le temps consacré à l'informatique augmente également la durée de la transaction.  Par conséquent, la meilleure option serait <b>de prendre le processus de calcul de ces valeurs</b> au-delà de UPDATE. <br><br>  Par exemple, nous voulons remplir notre nouveau champ x avec le nombre d'enregistrements qui ont la même valeur (k, v).  Créons une table «temporaire», dont la génération n'impose pas de verrous supplémentaires: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tmp <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> k, v, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) x <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tmp(k, v);</code> </pre> <br>  Maintenant, nous pouvons itérer selon le modèle décrit ci-dessus selon ce tableau, en mettant à jour la cible: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl T <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> x = Sx <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tmp S <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (Tk, Tv) = (Sk, Sv) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (Sk, Sv) = ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Comme vous pouvez le voir, aucun calcul compliqué n'est requis. <br><br>  N'oubliez pas de supprimer la table auxiliaire plus tard. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481610/">https://habr.com/ru/post/fr481610/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481596/index.html">Analyse des paramètres ELK 7.5 pour l'analyse des journaux Mikrotik</a></li>
<li><a href="../fr481598/index.html">Une petite contribution à la lutte contre les plateformes de zoo Avalonia UI</a></li>
<li><a href="../fr481600/index.html">Moteur Wiki Bonsai Family: Résultats 2019</a></li>
<li><a href="../fr481604/index.html">Comment les développeurs de Chelyabinsk durs créent des jeux pour Google Play et les réseaux sociaux</a></li>
<li><a href="../fr481606/index.html">Abonnement statique à l'aide du modèle Observer à l'aide de C ++ et du microcontrôleur Cortex M4</a></li>
<li><a href="../fr481612/index.html">Notre petite contribution à la lutte d'Avalonia UI pour moins de plateformes</a></li>
<li><a href="../fr481616/index.html">Dôme géodésique. À propos de l'appareil et mon expérience des calculs</a></li>
<li><a href="../fr481618/index.html">MVP dans Unity ou comment simplifier la vie</a></li>
<li><a href="../fr481620/index.html">Juniper SRX et Cisco ASA: nouvelle série</a></li>
<li><a href="../fr481624/index.html">Écrire une application sur Flutter en collaboration avec Redux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>