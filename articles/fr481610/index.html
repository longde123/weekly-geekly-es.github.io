<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘µğŸ½ ğŸ¤±ğŸ½ ğŸ˜© PostgreSQL Antipatterns: mise Ã  jour d'une grande table en charge ğŸ’Ÿ â¬œï¸ ğŸ‘¨ğŸ¼â€ğŸ’¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Que dois-je faire (et certainement pas) si vous avez besoin de mettre Ã  jour un grand nombre d'enregistrements dans la table PostgreSQL activement uti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL Antipatterns: mise Ã  jour d'une grande table en charge</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/481610/">  Que dois-je faire (et certainement pas) si vous avez besoin de <b>mettre</b> Ã  <b>jour un grand nombre d'enregistrements</b> dans la table PostgreSQL activement utilisÃ©e "plusieurs millions" - initialiser la valeur du nouveau champ ou corriger les erreurs dans les enregistrements existants?  Et en mÃªme temps, Ã©conomisez votre temps et ne perdez pas d'argent en raison des temps d'arrÃªt. <br><br><img src="https://habrastorage.org/webt/vw/8_/jj/vw8_jjubp0owqcielxtg6gjufng.png"><br><a name="habracut"></a><br>  PrÃ©parez les donnÃ©es de test: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl(k <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, v <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">chr</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ascii</span></span>(<span class="hljs-string"><span class="hljs-string">'a'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) + (random() * <span class="hljs-number"><span class="hljs-number">26</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) k , (random() * <span class="hljs-number"><span class="hljs-number">100</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000000</span></span>) i; <span class="hljs-comment"><span class="hljs-comment">--  ,   ! CREATE INDEX ON tbl(k, v);</span></span></code> </pre> <br>  Supposons que nous voulions simplement augmenter la valeur de v de 1 pour tous les enregistrements avec k dans la plage Â«qÂ» .. Â«zÂ». <br><br>  Mais, avant de commencer les expÃ©riences, nous allons enregistrer le jeu de donnÃ©es d'origine afin d'avoir des rÃ©sultats Â«propresÂ» Ã  chaque fois: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> _tbl <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl;</code> </pre> <br><h2>  MISE Ã€ JOUR: un pour tous et tous pour un </h2><br>  L'option la plus simple qui vient immÃ©diatement Ã  l'esprit est de tout faire Â«en une seule MISE Ã€ JOURÂ»: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> v = v + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-string"><span class="hljs-string">'q'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-string"><span class="hljs-string">'z'</span></span>;</code> </pre> <br><img src="https://habrastorage.org/webt/zs/0h/nb/zs0hnbsdmvjrctxn_wkia0wr6oy.png"><br>  <a href="https://explain.tensor.ru/archive/explain/197f26d0cedf3abba51a15d4650c897e:0:2019-12-23">[regardez expliquez.tensor.ru]</a> <br><br>  Une opÃ©ration assez simple, semble-t-il, sur des lignes complÃ¨tement Â«courtesÂ» a pris plus de 2,5 secondes.  Et si votre expression est plus compliquÃ©e, la ligne est plus authentique, il y a plus d'enregistrements et mÃªme certains dÃ©clencheurs interviennent - le temps peut mÃªme augmenter jusqu'Ã  quelques minutes, mais jusqu'Ã  plusieurs heures.  Supposons que vous soyez prÃªt Ã  attendre, et le reste de votre systÃ¨me, liÃ© Ã  cette base, s'il a une charge OLTP active? <br><br>  Le problÃ¨me est que dÃ¨s que UPDATE atteint un enregistrement particulier, il le <b>bloque jusqu'Ã  la fin de l'exÃ©cution</b> .  Si simultanÃ©ment avec le mÃªme enregistrement, il veut travailler sur une MISE Ã€ JOUR Â«spotÂ» lancÃ©e parallÃ¨lement, il <b>Â«accrocheraÂ» toujours Ã  attendre un blocage</b> pour la demande de mise Ã  jour, et s'affaissera jusqu'Ã  la fin de son travail. <br><br><img src="https://habrastorage.org/webt/p7/gx/qu/p7gxqutnt9o8zuwiwjlbmrf4fk8.png"><br>  Â© <a href="http://wumo.com/wumo">wumo.com/wumo</a> <br><br>  Le pire des cas est celui des systÃ¨mes Web, oÃ¹ les connexions Ã  la base de donnÃ©es sont crÃ©Ã©es selon les besoins - aprÃ¨s tout, ces connexions "pendantes" s'accumulent et consommeront les ressources de la base de donnÃ©es et du client, si vous ne crÃ©ez pas un mÃ©canisme de dÃ©fense distinct Ã  partir de cela. <br><br><h2>  Transactions fractionnÃ©es </h2><br>  En gÃ©nÃ©ral, tout n'est pas trÃ¨s bon si tout se fait en une seule demande.  Oui, et mÃªme si nous divisons une grande MISE Ã€ JOUR en plusieurs petites, mais laissons tout cela fonctionner <b>dans une seule transaction</b> , le problÃ¨me de verrouillage restera le mÃªme, car les enregistrements mutables sont verrouillÃ©s jusqu'Ã  la fin de la transaction entiÃ¨re. <br><br>  Nous devons donc diviser une grande transaction en plusieurs.  Pour ce faire, nous pouvons soit utiliser des moyens externes, et Ã©crire une sorte de script qui gÃ©nÃ¨re des transactions distinctes, soit utiliser les opportunitÃ©s que la base de donnÃ©es elle-mÃªme peut nous fournir. <br><br><h4>  APPEL et gestion des transactions </h4><br>  Ã€ partir de PostgreSQL 11, il est <a href="https://postgrespro.ru/docs/postgresql/11/plpgsql-transactions">possible de gÃ©rer les transactions</a> directement dans le code de procÃ©dure: <br><blockquote>  Dans les procÃ©dures appelÃ©es par la commande CALL, ainsi que dans les blocs de code anonymes (dans la commande DO), vous pouvez effectuer des transactions en exÃ©cutant COMMIT et ROLLBACK.  Une fois la transaction terminÃ©e par ces commandes, une nouvelle sera automatiquement lancÃ©e. </blockquote>  Mais cette version est loin de tout le monde, et travailler avec CALL a ses limites.  Par consÃ©quent, nous essaierons de rÃ©soudre notre problÃ¨me sans moyens externes, et pour qu'il fonctionne sur toutes les versions actuelles, et mÃªme avec des changements minimes sur le serveur lui-mÃªme - afin qu'il ne soit pas nÃ©cessaire de compiler et de redÃ©marrer quoi que ce soit. <br><br>  Pour la mÃªme raison, nous ne considÃ©rerons pas l'option d'organiser <a href="https://blog.dalibo.com/2016/08/19/Autonoumous_transactions_support_in_PostgreSQL.html">des transactions autonomes via pg_background</a> . <br><br><h4>  GÃ©rer les connexions Â«Ã  l'intÃ©rieurÂ» de la base </h4><br>  PostgreSQL a toujours utilisÃ© diffÃ©rentes mÃ©thodes pour <a href="https://www.cybertec-postgresql.com/en/implementing-autonomous-transactions-in-postgres/">Ã©muler des transactions autonomes</a> , gÃ©nÃ©rant des connexions supplÃ©mentaires distinctes - via des langages procÃ©duraux supplÃ©mentaires ou le <a href="https://postgrespro.ru/docs/postgresql/12/dblink">module dblink</a> standard.  L'avantage de ce dernier est qu'il est inclus par dÃ©faut dans la plupart des distributions, et qu'une seule commande est requise pour l'activer dans la base de donnÃ©es: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> EXTENSION dblink;</code> </pre> <br><h2>  "... et beaucoup, beaucoup d'enfants dÃ©goÃ»tants amenÃ©s" </h2><br>  Mais avant de crÃ©er une liaison dblink, voyons d'abord comment un Â«dÃ©veloppeur ordinaireÂ» dÃ©compose un grand ensemble de donnÃ©es, qu'il doit mettre Ã  jour, en petits. <br><br><h3>  Naive LIMIT ... OFFSET </h3><br>  La premiÃ¨re idÃ©e est de faire une recherche de Â«paginationÂ»: <i>Â«SÃ©lectionnons les <b>mille enregistrements suivants Ã </b> chaque foisÂ»</i> en augmentant OFFSET Ã  chaque nouvelle demande: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl T <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> v = Tv + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> k , v <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-string"><span class="hljs-string">'q'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-string"><span class="hljs-string">'z'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-comment"><span class="hljs-comment">--       k, v --     ! LIMIT $1 OFFSET $2 * $1 ) S WHERE (Tk, Tv) = (Sk, Sv);</span></span></code> </pre> <br>  Avant de tester les performances de cette solution, nous allons restaurer l'ensemble de donnÃ©es: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> _tbl;</code> </pre> <br>  Comme nous l'avons vu dans le plan ci-dessus, nous devrons mettre Ã  jour environ 384 000 enregistrements.  Par consÃ©quent, voyons immÃ©diatement comment les mises Ã  jour seront effectuÃ©es plus prÃ¨s de la fin - <b>dans la rÃ©gion de la 300e itÃ©ration de 1000 entrÃ©es</b> : <br><br><img src="https://habrastorage.org/webt/j8/h3/ju/j8h3juddfyiwgyg6nxe4yjmp5w4.png"><br>  <a href="https://explain.tensor.ru/archive/explain/922c49ce866d7c879d15c7d144efff86:0:2019-12-23">[regardez expliquez.tensor.ru]</a> <br><br>  Oh ... La mise Ã  jour de l'Ã©chantillon Ã  la fin de tous les <b>enregistrements 1K</b> nous coÃ»tera presque autant de temps que la <b>version originale entiÃ¨re</b> ! <br><br>  Ce n'est pas notre choix.  Il peut toujours Ãªtre utilisÃ© d'une maniÃ¨re ou d'une autre si vous obtenez peu d'itÃ©rations et de petites valeurs OFFSET.  Parce que le <b>LIMIT X OFFSET Y</b> pour la base de donnÃ©es Ã©quivaut Ã  " <i>soustraire / sÃ©lectionner / former les premiers enregistrements X + Y, puis jeter le premier Y dans la corbeille</i> ", ce qui pour les grandes valeurs de Y semble tragique. <br><br>  En fait, cette mÃ©thode <b>ne peut pas Ãªtre appliquÃ©e du tout</b> !  Non seulement nous nous appuyons sur des valeurs mises Ã  jour pour la sÃ©lection, mais nous risquons Ã©galement de sauter une partie des enregistrements et de mettre Ã  jour l'autre partie deux fois si des blocs avec les mÃªmes clÃ©s atteignent la bordure de la page: <br><br><img src="https://habrastorage.org/webt/v0/kh/mn/v0khmnh_afkafan4fvvf4sfgq34.png"><br>  Dans cet exemple, nous avons mis Ã  jour l'enregistrement vert deux fois et l'enregistrement rouge jamais.  Tout simplement parce qu'avec les mÃªmes valeurs des clÃ©s de tri, l'ordre des enregistrements eux-mÃªmes Ã  l'intÃ©rieur d'un tel bloc n'est pas fixe. <br><br><h3>  TRÃˆS ORDRE PAR ... LIMITE </h3><br>  Modifions un peu la tÃ¢che - ajoutons un nouveau champ dans lequel nous Ã©crirons notre valeur v + 1: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> x <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>;</code> </pre> <br>  Veuillez noter que cette conception fonctionne presque instantanÃ©ment, sans rÃ©Ã©crire la table entiÃ¨re.  Mais si vous ajoutez une valeur DEFAULT, alors - seulement Ã  <a href="https://www.depesz.com/2018/04/04/waiting-for-postgresql-11-fast-alter-table-add-column-with-a-non-null-default/">partir de la 11Ã¨me version</a> . <br><br>  DÃ©jÃ  enseignÃ© par une expÃ©rience amÃ¨re, crÃ©ons immÃ©diatement un index dans lequel seules les entrÃ©es non initialisÃ©es resteront: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> CONCURRENTLY <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl(k, v) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>;</code> </pre> <br>  L'index CONCURRENTLY ne bloque pas le travail de lecture-Ã©criture avec la table, alors qu'il roule lentement mÃªme sur un Ã©norme ensemble de donnÃ©es. <br><br>  Maintenant, l'idÃ©e est <i>"SÃ©lectionnons Ã  partir de cet index Ã  chaque fois <b>seulement les mille premiers enregistrements</b> "</i> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl T <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> x = Tv + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-string"><span class="hljs-string">'q'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-string"><span class="hljs-string">'z'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-comment"><span class="hljs-comment">--   OFFSET! ) S WHERE (Tk, Tv) = (Sk, Sv) AND Tx IS NULL;</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ne/dp/ck/nedpck-lvoeexx1ffpb63v8nd1w.png"><br>  <a href="https://explain.tensor.ru/archive/explain/9a152e5f94595f995599c9c558fc6f37:0:2019-12-23">[regardez expliquez.tensor.ru]</a> <br><br>  DÃ©jÃ  beaucoup mieux - la durÃ©e de chaque transaction individuelle est dÃ©sormais plus courte d'environ 6 fois. <br><br>  Mais voyons Ã  nouveau en quoi le plan de la 200e itÃ©ration va se transformer: <br><br><pre> <code class="plaintext hljs">Update on tbl t (actual time=530.591..530.591 rows=0 loops=1) Buffers: shared hit=789337 read=1 dirtied=1</code> </pre> <br>  Le temps a encore empirÃ© (seulement 25%, cependant) et les tampons ont augmentÃ© - mais pourquoi? <br>  Le fait est que <a href="https://habr.com/ru/company/postgrespro/blog/445820/">MVCC dans PostgreSQL</a> laisse des Â«Ã¢mes mortesÂ» dans l'index - des versions d'enregistrements dÃ©jÃ  mis Ã  jour, qui ne conviennent plus Ã  l'index.  Autrement dit, en ne prenant que les 1000 premiers enregistrements Ã  la 200e itÃ©ration, nous analysons <b>toujours</b> , bien que plus tard, nous supprimions, les versions 199K prÃ©cÃ©dentes des tuples ont dÃ©jÃ  changÃ©. <br><br>  Si des itÃ©rations chez nous sont nÃ©cessaires non pas plusieurs centaines, mais plusieurs centaines de milliers, la dÃ©gradation sera plus visible Ã  chaque exÃ©cution de requÃªte suivante. <br><br><h2>  MISE Ã€ JOUR par segment </h2><br>  En fait, pourquoi sommes-nous si attachÃ©s Ã  cette valeur de Â«1000 enregistrementsÂ»?  AprÃ¨s tout, nous <b>n'avons aucune raison de choisir exactement 1000</b> ou un autre numÃ©ro spÃ©cifique.  Nous voulions simplement Â«couperÂ» l'ensemble complet de donnÃ©es en certains <b>segments disjoints</b> , pas nÃ©cessairement Ã©gaux - utilisons donc notre index existant pour l'usage auquel il est destinÃ©. <br><br>  Une <b>paire indexÃ©e (k, v) est</b> excellente pour notre tÃ¢che.  Construisons une requÃªte afin qu'elle puisse s'appuyer sur la derniÃ¨re paire traitÃ©e: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> kv <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (k, v) &gt; ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-string"><span class="hljs-string">'q'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-string"><span class="hljs-string">'z'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ) , upd <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl T <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> x = Tv + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (Tk, Tv) = (<span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> kv) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> Tx <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> k, v ) <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> upd <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Ã€ la premiÃ¨re itÃ©ration, il nous suffit de dÃ©finir les paramÃ¨tres de la requÃªte Ã  la <b>valeur Â«zÃ©roÂ» ('', 0)</b> , et pour chaque itÃ©ration suivante, nous prenons le <b>rÃ©sultat de la requÃªte prÃ©cÃ©dente</b> . <br><br><img src="https://habrastorage.org/webt/ok/ea/fg/okeafgsqia7iejthcmz2wuvsnm0.png"><br>  <a href="https://explain.tensor.ru/archive/explain/2e6ac5867caa6be474c3845dcb7eebcb:0:2019-12-23">[regardez expliquez.tensor.ru]</a> <br><br>  Le temps de transaction / verrouillage est infÃ©rieur Ã  une milliseconde, il n'y a pas de dÃ©gradation par le nombre d'itÃ©rations, une analyse prÃ©liminaire complÃ¨te de toutes les donnÃ©es du tableau n'est pas requise.  Super! <br><br><div class="spoiler">  <b class="spoiler_title">Mettre la version finale avec dblink</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> k <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; v integer = 0; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> PERFORM dblink_connect(<span class="hljs-string"><span class="hljs-string">'dbname='</span></span> || current_database() || <span class="hljs-string"><span class="hljs-string">' port='</span></span> || current_setting(<span class="hljs-string"><span class="hljs-string">'port'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">--  PREPARED STATEMENT,      PERFORM dblink($q$ PREPARE _q(text, integer) AS WITH kv AS ( SELECT k, v FROM tbl WHERE (k, v) &gt; ($1, $2) AND k BETWEEN 'q' AND 'z' AND x IS NULL ORDER BY k, v LIMIT 1 ) , upd AS ( UPDATE tbl T SET x = Tv + 1 WHERE (Tk, Tv) = (TABLE kv) AND Tx IS NULL RETURNING k, v ) TABLE upd LIMIT 1; $q$); -- ,    LOOP SELECT * INTO k, v FROM dblink($p$EXECUTE _q('$p$ || k || $p$',$p$ || v || $p$)$p$) T(k text, v integer); RAISE NOTICE '(k,v) = (''%'',%)', k, v; --   ,     EXIT WHEN (k, v) IS NULL; END LOOP; PERFORM dblink_disconnect(); END; $$ LANGUAGE plpgsql;</span></span></code> </pre> <br></div></div><br>  Un avantage supplÃ©mentaire de cette mÃ©thode est la possibilitÃ© d'interrompre l'exÃ©cution de ce script Ã  tout moment, puis de reprendre Ã  partir du point souhaitÃ©. <br><br><h2>  Calculs complexes dans UPDATE </h2><br>  Je mentionnerai sÃ©parÃ©ment la situation avec le calcul difficile de la valeur affectÃ©e - lorsque vous devez calculer quelque chose Ã  partir des tables liÃ©es. <br><br>  Le temps consacrÃ© Ã  l'informatique augmente Ã©galement la durÃ©e de la transaction.  Par consÃ©quent, la meilleure option serait <b>de prendre le processus de calcul de ces valeurs</b> au-delÃ  de UPDATE. <br><br>  Par exemple, nous voulons remplir notre nouveau champ x avec le nombre d'enregistrements qui ont la mÃªme valeur (k, v).  CrÃ©ons une table Â«temporaireÂ», dont la gÃ©nÃ©ration n'impose pas de verrous supplÃ©mentaires: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tmp <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> k, v, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) x <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tbl <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tmp(k, v);</code> </pre> <br>  Maintenant, nous pouvons itÃ©rer selon le modÃ¨le dÃ©crit ci-dessus selon ce tableau, en mettant Ã  jour la cible: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tbl T <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> x = Sx <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tmp S <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (Tk, Tv) = (Sk, Sv) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (Sk, Sv) = ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Comme vous pouvez le voir, aucun calcul compliquÃ© n'est requis. <br><br>  N'oubliez pas de supprimer la table auxiliaire plus tard. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481610/">https://habr.com/ru/post/fr481610/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481596/index.html">Analyse des paramÃ¨tres ELK 7.5 pour l'analyse des journaux Mikrotik</a></li>
<li><a href="../fr481598/index.html">Une petite contribution Ã  la lutte contre les plateformes de zoo Avalonia UI</a></li>
<li><a href="../fr481600/index.html">Moteur Wiki Bonsai Family: RÃ©sultats 2019</a></li>
<li><a href="../fr481604/index.html">Comment les dÃ©veloppeurs de Chelyabinsk durs crÃ©ent des jeux pour Google Play et les rÃ©seaux sociaux</a></li>
<li><a href="../fr481606/index.html">Abonnement statique Ã  l'aide du modÃ¨le Observer Ã  l'aide de C ++ et du microcontrÃ´leur Cortex M4</a></li>
<li><a href="../fr481612/index.html">Notre petite contribution Ã  la lutte d'Avalonia UI pour moins de plateformes</a></li>
<li><a href="../fr481616/index.html">DÃ´me gÃ©odÃ©sique. Ã€ propos de l'appareil et mon expÃ©rience des calculs</a></li>
<li><a href="../fr481618/index.html">MVP dans Unity ou comment simplifier la vie</a></li>
<li><a href="../fr481620/index.html">Juniper SRX et Cisco ASA: nouvelle sÃ©rie</a></li>
<li><a href="../fr481624/index.html">Ã‰crire une application sur Flutter en collaboration avec Redux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>