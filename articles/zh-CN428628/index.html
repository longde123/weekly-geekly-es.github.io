<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🎨 💪🏾 ❣️ 使用抽象的JavaScript语法树 👩🏿‍💻 💱 👩🏿‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="为什么要解析您的代码？ 例如，为了在提交之前找到被遗忘的console.log。 但是，如果您需要在代码的数百个条目中更改函数的签名，该怎么办？ 正则表达式在这里可以应付吗？ 本文将向您展示抽象语法树为开发人员提供的可能性。 



 在剪辑下-来自HolyJS 2018 Piter会议的Kiril...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用抽象的JavaScript语法树</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/428628/"> 为什么要解析您的代码？ 例如，为了在提交之前找到被遗忘的console.log。 但是，如果您需要在代码的数百个条目中更改函数的签名，该怎么办？ 正则表达式在这里可以应付吗？ 本文将向您展示抽象语法树为开发人员提供的可能性。 <br><br><img src="https://habrastorage.org/webt/l6/7k/fh/l67kfhnakjfo3vquzkyvklpwrns.png"><br><br> 在剪辑下-来自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HolyJS 2018 Piter</a>会议的Kirill Cherkashin（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">z6Dabrata</a> ）报告的视频和文字记录。 <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ILSpvViUlPU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i><b>关于作者</b></i> <i><br></i>  <i>西里尔（Cyril）出生在莫斯科，现在住在纽约，在Firebase工作。</i>  <i>不仅在Google，而且在全球范围内教授Angular。</i>  <i>世界上最大的Angular mitap的组织者是AngularNYC（以及VueNYC和ReactNYC）。</i>  <i>在编程的业余时间里，他喜欢探戈，书籍和愉快的对话。</i> <br><br><h2> 钢锯或木头？ </h2><br> 让我们从一个例子开始：假设您调试了一个程序并将对git所做的更改发送给git，然后您就安静地上床了。 早晨，事实证明您的同事已下载您的更改，并且由于您忘记了前一天将调试信息的输出删除到控制台，因此它将显示并阻塞输出。 许多人面临这个问题。 <br><br> 有一些工具（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EsLint</a> ）可以解决这种情况，但是出于教育目的，让我们尝试自己寻找解决方案。 <br> 我应该使用哪个工具从代码中删除所有<code>console.log()</code> ？ <br> 我们在正则表达式和使用Abstract Sitax树（ASD）之间进行选择。 让我们尝试通过编写一些<code>findConsoleLog</code>函数来使用正则表达式解决此问题。 在输入处，如果在程序文本中的某个位置找到console.log（），它将接收程序代码作为参数，并显示true。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findConsoleLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!code.match(<span class="hljs-regexp"><span class="hljs-regexp">/console.log/</span></span>); }</code> </pre><br> 我编写了17个测试，试图提出各种破坏功能的方法。 此列表远非完整。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c28/d83/9c4/c28d839c4c1450db0e7d752667ffd4c8.png"><br><br> 最简单的测试通过了。 <br> 如果函数名称中包含字符串“ console.log”怎么办？ <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findConsoleLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!code.match(<span class="hljs-regexp"><span class="hljs-regexp">/\bconsole.log/</span></span>); }</code> </pre><br> 添加了一个字符，指示<code>console.log</code>应该出现在单词的开头。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3cf/d71/598/3cfd715980aec5c9ead2421d87679fe8.jpg"><br><br> 仅通过了两个测试，但是如果<code>console.log</code>在注释中并且不需要删除，该怎么办？ <br><br> 我们重写它，以使解析器不会触及注释。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findConsoleLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!code   .replace(<span class="hljs-regexp"><span class="hljs-regexp">/\/\/.*/</span></span>)   .match(<span class="hljs-regexp"><span class="hljs-regexp">/\bconsole.log/</span></span>); }</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/a24/518/df4/a24518df4bd82e31257e50f4723083da.jpg"><br><br> 从以下各行中排除“ console.log”的删除： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findConsoleLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!code   .replace(<span class="hljs-regexp"><span class="hljs-regexp">/\/\/.*|'.*'/</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>)   .match(<span class="hljs-regexp"><span class="hljs-regexp">/\bconsole.log/</span></span>); }</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/832/c81/94b/832c8194b5e62d995d939e798fc9f2af.jpg"><br><br> 不要忘记，我们还有空格和其他字符，可能会阻止某些测试通过： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/077/793/86c/07779386cbd54babe9f0aff7db1c35f3.jpg"><br><br> 尽管想法不是很简单，但是可以通过使用正则表达式的所有17个测试。 因此，在这种情况下，解决方案代码将如下所示： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findConsoleLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> code   .replace(<span class="hljs-regexp"><span class="hljs-regexp">/\/\/.*|'.*?[^\\]'|".*?"|`[\s\S]*`|\/\*[\s\S]*\*\//</span></span>)   .match(<span class="hljs-regexp"><span class="hljs-regexp">/\bconsole\s*.log\(/</span></span>); }</code> </pre><br><br> 问题在于该代码无法涵盖所有​​可能的情况，因此很难对其进行维护。 <br><br> 考虑如何使用ASD解决此问题。 <br><br><h2> 树木如何生长？ </h2><br> 作为解析器使用您的应用程序代码的结果，获得了抽象语法树。 解析器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@ babel /解析器</a>用于演示<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> <br> 例如，使用字符串<code>console.log('holy')</code> ，将其通过解析器。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { parse } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'babylon'</span></span>; parse(<span class="hljs-string"><span class="hljs-string">"console.log('holy')"</span></span>);</code> </pre><br> 作为他的工作的结果，获得了大约300行的JSON文件。 我们从电话号码中排除服务信息。 我们对正文部分感兴趣。 元信息也不会让我们感兴趣。 结果大约是100行。 与浏览器为一个主体变量（大约300行）生成的结构相比，这并不多。 <br><br> 让我们看一些示例，说明语法树中的代码如何表示各种文字： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d1/ca2/867/0d1ca286756a8f61b77edcff73ed95c1.jpg"><br><br> 这是一个包含数字文字（数字文字）的表达式。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4bd/c34/419/4bdc34419216b4a39c3636cee741cbab.png"><br><br> 已经熟悉的console.log表达式。 它具有一个具有属性的对象。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11e/860/609/11e8606097dc09b48bf993c0be5dbdff.jpg"><br><br> 如果log是函数调用，则描述如下：有一个调用表达式，它具有参数-数字文字。 同时，调用表达式具有一个名称-log。 <br><br> 文字可以不同：数字，字符串，正则表达式，布尔值，空值。 <br> 返回console.log调用 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e1/4cb/2f2/9e14cb2f2efccc2fb7a43c4fa1945fd9.jpg"><br><br> 这是一个内部有“成员表达式”的调用表达式。 从中可以明显看出，控制台对象内部具有一个名为log的属性。 <br><br><h2>  ASD旁路 </h2><br> 现在，让我们尝试在代码中使用此结构。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">babel遍历</a>库将用于遍历树<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> <br><br> 给出了相同的17个测试。 通过分析程序的语法树并搜索“ console.log”的条目来获得这样的代码： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverseConsoleLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code, {babylon, babelTraverse, types, log}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ast = babylon.parse(code); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hasConsoleLog = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; babelTraverse(ast, {   MemberExpression(path){     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (       path.node.property.type === <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span> &amp;&amp;       path.node.property.name === <span class="hljs-string"><span class="hljs-string">'log'</span></span> &amp;&amp;       path.node.object.type === <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span> &amp;&amp;       path.node.object.name === <span class="hljs-string"><span class="hljs-string">'console'</span></span> &amp;&amp;       path.parent.type === <span class="hljs-string"><span class="hljs-string">'CallExpression'</span></span> &amp;&amp;       path.Parentkey === <span class="hljs-string"><span class="hljs-string">'callee'</span></span>     ) {       hasConsoleLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;     }   } }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasConsoleLog; }</code> </pre><br> 让我们分析一下这里写的内容。 <code>const ast = babylon.parse(code);</code> 进入ast变量，我们从代码中解析语法树。 接下来，我们将这棵树提供给babel-parse库进行处理。 我们正在寻找调用表达式中具有匹配名称的节点和属性。 如果找到了所需的节点及其名称的组合，请将hasConsoleLog变量设置为true。 <br><br> 我们可以在树上四处走动，获取节点，后代的父代，查找它们具有的参数和属性，查看这些属性，类型的名称-这非常方便。 <br><br> 有一个令人不愉快的细微差别，可以使用babel-types库轻松修复。 为了避免在树中搜索时由于名称错误而产生错误，例如，您意外地用<code>path.parent.type === 'callExpression'</code> -types代替<code>path.parent.type === 'CallExpression'</code>编写了<code>path.parent.type === 'callExpression'</code> ，您可以这样编写： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Before path.node.property.type === 'Identifier' path.node.property.name === 'log' // with babel types import {isIdentifier} from 'babel-types'; isIdentifier(path.node.property, {name: log}) //         ,  ,    isIdentifier,     </span></span></code> </pre><br> 我们使用babel-types重写前面的代码： <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverseConsoleLogSolved2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code, {babylon, babelTraverse, types}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ast = babylon.parse(code); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hasConsoleLog = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; babelTraverse(ast, {   MemberExpression(path) {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (       types.isIdentifier(path.node.object, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'console'</span></span>}) &amp;&amp;       types.isIdentifier(path.node.property, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'log'</span></span>}) &amp;&amp;       types.isCallExpression(path.parent) &amp;&amp;       path.parentKey === <span class="hljs-string"><span class="hljs-string">'callee'</span></span>     ) {       hasConsoleLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;     }   } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasConsoleLog; }</code> </pre><br><h2> 使用babel-traverse转换ASD </h2><br> 为了减少人工成本，我们需要立即从代码中删除<code>console.log</code>而不是发出代码已包含在代码中的信号。 <br><br> 因为我们不需要删除MemberExpression本身，而是它的父项， <code>hasConsoleLog = true;</code> 我们写<code>path.parentPath.remove();</code>  。 <br><br> 从<code>removeConsoleLog</code>函数，我们仍然返回一个布尔值。 我们将其输出替换为将生成babel-generator的代码，如下所示： <br>  <code>hasConsoleLog</code> =&gt; <code>babelGenerator(ast).code</code> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Babel-generator</a>接收修改后的抽象语法树作为参数，返回一个具有code属性的对象，该对象内部是没有<code>console.log</code>再生代码。 顺便说一句，如果要获取代码映射，可以调用此对象的sourceMaps属性。 <br><br><h2> 如果您需要找到调试器？ </h2><br> 这次，我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ASTexplorer</a>完成任务。 调试器是调试器语句节点的一种。 我们不需要看整个结构，因为这是一种特殊的节点，只需找到调试器语句即可。 我们将为ESLint（在ASTexplorer上）编写一个插件。 <br><br>  ASTexplorer的设计方式是，您在左侧编写代码，在右侧编写完成的ASD。 您可以选择要接收的格式：JSON或树格式。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e91/ee0/ecc/e91ee0ecc1d31ec006dcb4e99fa04d49.jpg"><br><br> 由于我们使用ESLint，它将为我们完成所有搜索文件的工作，并提供必要的文件，以便我们可以在其中找到调试器行。 该工具使用其他ASD解析器。 但是，JavaScript中有几种类型的ASD。 当不同的浏览器以不同的方式实现该规范时，让人想起过去。 因此，我们实现了调试器搜索： <br><br><pre> <code class="hljs lua">export default <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   DebuggerStatement(node) { // ,     console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>    <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>,    -  ,     <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>         context.report(node, <span class="hljs-string"><span class="hljs-string">'LOL Debugger!!!'</span></span>); //   ESLint ,   debugger, node     ,    ,    debugger   } } }</code> </pre><br> 检查书面插件的工作： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/90e/334/3fe/90e3343fe59bb834c9725beeb925598b.jpg"><br><br> 同样，您可以从代码中删除调试器。 <br><br><h2> 还有什么有用的ASD </h2><br> 我个人使用ASD来简化Angular和其他前端框架的工作。 您可以通过单击按钮来导入，扩展，添加接口，方法，装饰器和其他任何东西。 尽管我们在这种情况下讨论的是Javascript，但是TypeScript也有自己的ASD，唯一的区别是节点类型的名称和结构之间的区别。 在同一ASTExplorer中，可以选择语言TypeScript。 <br><br> 因此： <br><br><ul><li> 我们对代码有更多的控制权，更易于重构和codemods。 例如，在提交之前，您可以按一个键以按照准则格式化整个代码。  Codemods意味着根据所需的框架版本自动进行代码匹配。 <br></li><li> 减少关于代码设计的争议。 <br></li><li> 您可以创建游戏项目。 例如，自动向程序员提供有关他编写的代码的反馈。 <br></li><li> 更好地了解JavaScript。 <br></li></ul><br><h2> 一些有关Babel的有用链接 </h2><br><ol><li> 所有Babel转换都使用以下API： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">插件和预设</a> 。 <br></li><li> 向ECMAScript添加新功能的过程的一部分是为Babel创建一个插件。 这是必需的，以便人们可以测试新功能。 如果单击该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接</a> ，则可以看到在其内部使用了ASD的功能。 例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">逻辑分配运算符</a> 。 <br></li><li>  Babel Generator在生成代码时会丢失格式。 这在某种程度上是好的，因为如果开发团队使用了此工具，则在从ASD生成代码后，每个人的外观都一样。 但是，如果要保留格式，可以使用以下工具之一： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Recast</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Babel CodeMod</a> 。 <br></li><li> 从此链接，您可以找到有关Babel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Awesome Babel</a>的大量信息。 <br></li><li>  Babel是一个开源项目，一个志愿者团队正在研究该项目。 你可以帮忙 执行此操作的方法有以下三种：财务支持，可以支持patreon网站，babel的主要贡献者之一亨利·朱（Henry Zhu）可以与patreon网站一起使用，以获取<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">opencollective.com/babel</a>上的代码帮助。 <br></li></ol><br><h2> 红利 </h2><br> 我们还能如何找到我们的<code>console.log</code>代码？ 使用您的IDE！ 在选择要查找代码的位置之后，使用查找和替换工具。 <br>  Intellij IDEA还具有“结构搜索”工具，可以使用ASD帮助您在代码中找到正确的位置。 <br><br><blockquote>  <b>11月24日至25日，</b> Kirill将在<b>Moscow HolyJS</b>上发表有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JavaScript * LOVES *二进制数据</a>的演示文稿：我们将深入到二进制数据级别，以* .gif文件为例深入研究二进制文件，并处理诸如Protobuf或Thrift之类的序列化框架。 报告完成后，将有可能与Cyril进行对话并讨论讨论区域中所有感兴趣的问题。 </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN428628/">https://habr.com/ru/post/zh-CN428628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN428614/index.html">星期五 程序员的狂欢4.2</a></li>
<li><a href="../zh-CN428616/index.html">使用Google Apps脚本将XLS文件转换为Google Spreadsheet</a></li>
<li><a href="../zh-CN428620/index.html">如何创建Roguelike</a></li>
<li><a href="../zh-CN428624/index.html">Jeffrey Richter，Pavel Yosifovich，Greg Young和所有人。 DotNext 2018莫斯科的硬核和建筑</a></li>
<li><a href="../zh-CN428626/index.html">如何使PHP7中的扩展比“ hello，world”更困难，并且不致于眼花red乱。 第一部分</a></li>
<li><a href="../zh-CN428630/index.html">不，到2033年，比特币不会破坏我们的气候。</a></li>
<li><a href="../zh-CN428632/index.html">在React中处理拦截器</a></li>
<li><a href="../zh-CN428634/index.html">移植Quake3</a></li>
<li><a href="../zh-CN428636/index.html">Roskomnadzor将向Google处以罚款</a></li>
<li><a href="../zh-CN428638/index.html">Hearts Flame Motor：QardioCore心脏监护仪评论</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>