<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßìüèº üê¶ ü§ûüèª Quand le courrier est livr√©: lutter contre la perte de notifications push dans iOS üöô üî≠ üèîÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De la part de l'utilisateur, le client de messagerie est une application simple. Les d√©veloppeurs de Yandex.Mail plaisantent m√™me qu'il n'y a que troi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quand le courrier est livr√©: lutter contre la perte de notifications push dans iOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/462507/">  De la part de l'utilisateur, le client de messagerie est une application simple.  Les d√©veloppeurs de Yandex.Mail plaisantent m√™me qu'il n'y a que trois √©crans dans l'application: une liste de lettres;  envoyer une lettre;  sur l'√©cran. <br><br>  Mais beaucoup de choses int√©ressantes se passent sous le capot.  Comme de nombreuses applications mobiles, Mail utilise des notifications push pour interagir avec les utilisateurs.  Comme de nombreuses applications iOS, Mail perd certaines notifications en raison de la nature du service de notification push d'Apple. <br><br>  <strong>Asya Sviridenko</strong> , chef du groupe Yandex.Mail iOS, prouvera que m√™me avec les limites du syst√®me, il est possible et n√©cessaire de faire face √† la perte de notifications push si elles sont critiques pour votre application.  Cela est vrai pour Mail, car les notifications push de nouvelles lettres sont celles pour lesquelles l'utilisateur installe l'application.  Si, pour votre application, la livraison de notifications push n'est pas si critique, il est toujours int√©ressant de savoir quels v√©los le mobile Yandex.Mail a empil√©s. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SVCMbPIuy8w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Il s'agit de notifications √† distance, c'est-√†-dire de notifications provenant du serveur via des APN (Apple Push Notification Service).  Nous n'allons pas toucher aux notifications locales et parler de: <br><br><ul><li>  √Ä quoi ressemble l'API pour travailler avec les notifications push.  Envisagez un sch√©ma de remise des notifications push et o√π les pertes peuvent survenir dans ce sch√©ma. </li><li>  Comment avez-vous d√©cid√© de g√©rer les pertes dans Yandex.Mail - √† propos de la file d'attente de notifications push. </li><li>  Comment se connecter et quelles autres difficult√©s peuvent rencontrer. </li></ul><a name="habracut"></a><br><h2>  Ce que nous avons et o√π nous perdons </h2><br>  Maintenant, l'API pour travailler avec les notifications push est une chose assez puissante qui vous permet de faire beaucoup de choses int√©ressantes.  Mais cela n'a pas toujours √©t√© le cas. <br><br><img src="https://habrastorage.org/webt/p6/ln/n1/p6lnn1nbbopnz4xr9k2xiuf1dre.jpeg"><br><br>  Auparavant, les notifications push ressemblaient exactement √† ceci - c'√©tait un tableau de bord bleu malheureux qui apparaissait √† l'√©cran, bloquait le travail avec l'application actuelle, ne permettait rien de faire, puis disparaissait pour toujours, et il n'y avait plus de rappels √† ce sujet. <br><br>  Depuis, assez de temps s'est √©coul√©. <br><br><img src="https://habrastorage.org/webt/nq/kr/9j/nqkr9jbh2v4nwacrbhksoa1tpy0.jpeg"><br><br>  Pour nous, en tant que d√©veloppeurs, <strong>tout a commenc√© dans iOS 3</strong> lorsque les notifications push sont devenues disponibles pour les biblioth√®ques tierces. <br><br>  <strong>Le centre de notifications est apparu dans iOS 5</strong> , et les notifications push ont cess√© d'aller nulle part, maintenant elles restent dans le centre de notifications, o√π elles peuvent √™tre visualis√©es √† nouveau. <br><br>  <strong>IOS 6 a introduit Ne pas d√©ranger</strong> .  L'utilisateur a la possibilit√© de d√©finir la p√©riode pendant laquelle il ne souhaite pas recevoir de notifications. <br><br>  Ces changements concernaient principalement la fa√ßon dont l'utilisateur peut travailler avec les notifications push, comment elles peuvent rendre sa vie plus confortable et non comment les d√©veloppeurs peuvent influencer les notifications. <br><br>  Pour les d√©veloppeurs, une √©tape importante a √©t√© <strong>iOS 8 et l'√©mergence de Notification Action</strong> , qui a permis d'effectuer des actions sp√©cifiques √† une application sp√©cifique par des notifications push. <br><br>  <strong>IOS 10 introduit l'extension de service de notification et l'extension de contenu de notification</strong> .  Le premier vous permet de modifier la notification push avant qu'elle ne soit affich√©e √† l'utilisateur.  La seconde consiste √† afficher une interface utilisateur par notification push sur la notification push, dans laquelle, par exemple, vous pouvez afficher des informations plus d√©taill√©es.  Dans iOS 10, cette interface utilisateur n'√©tait pas cliquable - vous pouvez regarder, vous ne pouvez pas la toucher. <br><br>  <strong>IOS 11 a introduit les param√®tres de confidentialit√© des notifications</strong> .  L'utilisateur peut maintenant acc√©der aux param√®tres et indiquer s'il souhaite afficher le contenu des notifications entrantes.  C'est un grand pas vers la s√©curit√©.  Il n'a fallu que 8 versions d'iOS pour comprendre que tous les utilisateurs ne veulent pas que les informations personnelles apparaissent soudainement sur l'iPhone pos√© sur la table. <br><br>  <strong>Dans iOS 12, il est devenu possible de regrouper les notifications push</strong> par thread-id, et l'interface utilisateur que nous avons re√ßue dans iOS 10 avec l'extension de contenu de notification est devenue cliquable.  Vous pouvez maintenant y ajouter des boutons et des commandes gestuelles - tout ce qui aide l'utilisateur √† interagir avec l'interface utilisateur. <br><br><h2>  Notifications push aujourd'hui </h2><br>  Comme vous pouvez le voir, les notifications push ont parcouru un long chemin, et aujourd'hui avec leur aide, vous pouvez vraiment faire beaucoup de choses. <br><br><h3>  Messagerie texte et localisation </h3><br>  Comme pr√©c√©demment, nous pouvons envoyer des messages texte dans une notification push, mais vous pouvez d√©sormais sp√©cifier des cl√©s de localisation. <br><br><pre><code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"alert"</span></span> : { <span class="hljs-string"><span class="hljs-string">"title"</span></span> : <span class="hljs-string"><span class="hljs-string">"New Mail"</span></span>, <span class="hljs-string"><span class="hljs-string">"subtitle-loc-key"</span></span> : <span class="hljs-string"><span class="hljs-string">"alert_subtitle_localization_key"</span></span>, <span class="hljs-string"><span class="hljs-string">"loc-key"</span></span> : <span class="hljs-string"><span class="hljs-string">"alert_body_localization_key"</span></span>, } }</code> </pre> <br>  Si vous sp√©cifiez <code>subtitle-loc-key</code> et <code>loc-key</code> dans la notification de charge utile, lorsque la notification push arrive sur le p√©riph√©rique, les valeurs n√©cessaires seront trouv√©es dans le fichier Localizable.string de l'application et l'utilisateur verra un message localis√©. <br><br><h3>  Alerte sonore et critique </h3><br>  Comme pr√©c√©demment, vous pouvez ajouter des sons aux notifications de charge utile. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"sound"</span></span> : { <span class="hljs-string"><span class="hljs-string">"critical"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">"bingbong.aiff"</span></span>, <span class="hljs-string"><span class="hljs-string">"volume"</span></span> : <span class="hljs-number"><span class="hljs-number">1.0</span></span>, } }</code> </pre> <br>  IOS 12 a une alerte critique.  Ce sont des sons qui seront jou√©s m√™me si l'utilisateur est en mode Ne pas d√©ranger. <br><br>  En r√®gle g√©n√©rale, l'utilisateur n'a pas besoin, par exemple, d'une application avec un abonnement √† un magazine la nuit pour signaler qu'un nouveau num√©ro a √©t√© publi√©.  Par cons√©quent, Apple restreint les applications pouvant utiliser une alerte critique.  Si votre application fonctionne avec la sant√©, la s√©curit√© ou si vous pensez que l'alerte critique peut vraiment aider les utilisateurs √† interagir avec votre application, √©crivez √† Apple.  Ils vous permettront peut-√™tre d'utiliser cette fonctionnalit√©. <br><br><h3>  Notifications silencieuses </h3><br>  L'utilisateur ne voit pas les notifications silencieuses.  Ils viennent directement √† l'application, la r√©veillent et vous permettent d'effectuer certaines actions pour mettre √† jour l'application: envoyer une demande au serveur, demander des donn√©es en arri√®re-plan, mettre √† jour les donn√©es de la base de donn√©es, mettre √† jour l'interface utilisateur de sorte que lorsque l'utilisateur entre dans l'application, il voit donn√©es mises √† jour. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"content-available"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">//   alert, sound  badge   payload }</span></span></code> </pre> <br>  Pour que la notification push devienne silencieuse, vous devez sp√©cifier dans la charge utile: <code>"content-available" : 1</code> .  Et ne sp√©cifiez pas les cl√©s d'alerte, de son et de badge dans la charge utile - elles sont compl√®tement inutiles pour les notifications push qui ne seront pas affich√©es √† l'utilisateur. <br><br><h3>  Regroupement de notifications </h3><br>  Pour regrouper les messages, vous devez sp√©cifier ¬´thread-id¬ª dans la charge utile.  Il peut avoir plusieurs valeurs dans la m√™me application, si vous souhaitez regrouper de diff√©rentes mani√®res: par comptes, par destinataires, par th√®me. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"thread-id"</span></span> : <span class="hljs-string"><span class="hljs-string">"any_thread_identifier"</span></span> }</code> </pre> <br>  C'est tr√®s pratique, car les notifications push ne prennent plus tout l'espace sur l'√©cran verrouill√©, mais sont regroup√©es.  Si vous n'utilisez pas d√©j√† cette fonctionnalit√©, il est temps de commencer. <br><br><h3>  Modifier la notification avant de l'afficher </h3><br>  Les notifications push peuvent √™tre modifi√©es avant d'√™tre affich√©es.  Pour ce faire, vous devez ajouter l'extension de contenu de notification √† l'application et remplacer la m√©thode <code>didReceive</code> .  Dans cette m√©thode, vous pouvez obtenir le contenu de la notification et le modifier. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"mutable-content"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: UNNotificationRequest, withContentHandler contentHandler: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(UNNotificationContent)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mutableContent = request.content.mutableCopy() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">UNMutableNotificationContent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { contentHandler(request.content); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } mutableContent.subtitle = <span class="hljs-string"><span class="hljs-string">"Got it!"</span></span> contentHandler(mutableContent) }</code> </pre> <br>  Par exemple, vous pouvez envoyer un lien vers le contenu multim√©dia dans la notification, t√©l√©charger le contenu dans Extension et joindre le fichier t√©l√©charg√© √† la notification.  Apr√®s cela, appelez la fin avec un nouveau contexte et montrez √† l'utilisateur une notification push √©tendue.  Vous pouvez changer le titre, le sous-titre, etc. <br><br>  Un autre cas int√©ressant est que vous pouvez envoyer une notification push avec un contexte crypt√©, si vous souhaitez que les donn√©es soient prot√©g√©es en plus, et Apple ne l'a pas vu.  Dans l'extension de contenu de notification, vous pouvez les d√©chiffrer et montrer √† l'utilisateur les donn√©es d√©j√† d√©chiffr√©es. <br><br><h3>  Contenu de notification masqu√© </h3><br>  Dans iOS 11, il est devenu possible de masquer le contenu des notifications push, et nous, en tant que d√©veloppeurs, ne pouvons en aucun cas influencer cela.  Si l'utilisateur a coch√© le "Masquer le contenu de la notification", d'une mani√®re ou d'une autre, il sera masqu√©.  Tout ce que nous pouvons faire, c'est via l'UNNotificationCategory pour sp√©cifier un espace r√©serv√© qui sera affich√© √† la place du contenu (par d√©faut, il s'agit de la notification) et pour d√©finir s'il faut afficher le titre ou le sous-titre. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commentCategory = <span class="hljs-type"><span class="hljs-type">UNNotificationCategory</span></span>(identifier: <span class="hljs-string"><span class="hljs-string">"comment-category"</span></span>, actions: [], intentIdentifiers: [], hiddenPreviewsBodyPlaceholder: <span class="hljs-type"><span class="hljs-type">NSString</span></span>.localizedUserNotificationString(forKey:<span class="hljs-string"><span class="hljs-string">"COMMENT_KEY"</span></span>,arguments: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>), options: [.hiddenPreviewsShowTitle])</code> </pre> <br><h3>  √âtapes de notification sans lancer l'application </h3><br>  Pour effectuer des actions de notification push sans lancer l'application elle-m√™me, vous devez cr√©er une cat√©gorie et y ajouter une action.  L'identifiant de cat√©gorie est transmis au champ de cat√©gorie de la notification de charge utile.  Vous pouvez connecter diff√©rentes actions √† diff√©rents types de notifications. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"category"</span></span> : <span class="hljs-string"><span class="hljs-string">"message"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> action = <span class="hljs-type"><span class="hljs-type">UNNotificationAction</span></span>(identifier:<span class="hljs-string"><span class="hljs-string">"reply"</span></span>, title:<span class="hljs-string"><span class="hljs-string">"Reply"</span></span>, options:[]) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> category = <span class="hljs-type"><span class="hljs-type">UNNotificationCategory</span></span>(identifier: <span class="hljs-string"><span class="hljs-string">"message"</span></span>, actions: [action], minimalActions: [action], intentIdentifiers: [], options: []) <span class="hljs-type"><span class="hljs-type">UNUserNotificationCenter</span></span>.current().setNotificationCategories([category])</code> </pre> <br><h3>  Notifications riches </h3><br>  Dans cette extension, vous pouvez traiter des actions suppl√©mentaires que vous avez ajout√©es √† la notification push et afficher l'interface utilisateur personnalis√©e. <br><br>  Pour ce faire, vous devez ajouter l'extension de contenu de notification √† l'application, y d√©finir une classe qui h√©rite de UNNotificationContentExtension, puis travailler avec comme avec un UIViewController normal. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NotificationViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UNNotificationContentExtension</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> userLabel: <span class="hljs-type"><span class="hljs-type">UILabel?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> notification: UNNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> content = notification.request.content <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.title = content.title <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userInfo = content.userInfo <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.userLabel?.text = userInfo[<span class="hljs-string"><span class="hljs-string">"video-user"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">String</span></span> } }</code> </pre> <br>  Si vous traitez des actions personnalis√©es, il est important de se rappeler que ces actions valent la peine de mettre √† jour l'interface utilisateur que vous montrez √† l'utilisateur.  Pas besoin d'essayer d'impl√©menter la logique m√©tier dans cette extension.  Envoyez une demande au serveur par action avec une notification push dans l'application principale, et pas ici.  Cet endroit est pour l'interface utilisateur uniquement. <br><br><h2>  Syst√®me de remise des notifications push </h2><br>  D√©couvrez tout ce que vous pouvez faire avec les notifications push dans iOS.  De version en version, nous avons de plus en plus de nouvelles fonctionnalit√©s, mais le sch√©ma de livraison des notifications push est maintenant exactement le m√™me que dans iOS 3. <br><br><img src="https://habrastorage.org/webt/gt/pb/dd/gtpbdd_4eu403euuueyxscvk8bw.jpeg"><br><br>  On pourrait penser que le sch√©ma de livraison des notifications push √©tait bien au d√©part, mais ce n'est pas le cas. <br><br>  Il existe trois n≈ìuds principaux dans le sch√©ma de remise des notifications push: <br><br><ul><li>  fournisseur qui g√©n√®re des notifications push de charge utile; </li><li>  APN - Apple Push Notification Service, qui d√©livre une notification; </li><li>  Appareil iOS et votre application. </li></ul><br>  Je vais sauter la partie sur la fa√ßon de m'inscrire, recevoir un jeton, o√π l'envoyer.  Supposons que nous ayons tout cela.  Que se passe-t-il ensuite? <br><br><ul><li>  Le fournisseur g√©n√®re une charge utile et l'envoie aux APN. </li><li>  APNs l'envoie √† l'appareil. </li><li>  L'utilisateur voit un message push sur son appareil. </li></ul><br>  Mail et de nombreuses autres applications utilisent un sch√©ma avanc√© de remise des notifications push.  L'extension du service de notification est ajout√©e, qui re√ßoit des notifications push avec un <code>"mutable-content" : 1</code> .  Le fournisseur est divis√© en un serveur qui g√®re la logique de backend de l'application et le fournisseur lui-m√™me, qui g√©n√®re la charge utile et g√®re les abonnements. <br><br>  Dans Yandex, le fournisseur qui forme la charge utile est appel√© XIVA.  XIVA est une base de donn√©es d'abonnement.  Mail utilise XIVA pour travailler avec les notifications push en tant que biblioth√®que tierce. <br><br>  Dans Mail, le travail avec les abonnements est organis√© de mani√®re assez non triviale.  Nous ne signons pas seulement l'application pour les notifications, nous avons plusieurs comptes.  Nous pouvons signer diff√©rents comptes ou, au sein d'un m√™me compte, choisir les dossiers pour lesquels l'utilisateur souhaite recevoir des notifications et ceux pour lesquels il ne souhaite pas.  XIVA s'occupe de tout cela.  Certains autres services Yandex fonctionnent √©galement via XIVA: toutes les informations sur les applications, les notifications, les abonnements, les jetons sont stock√©es dans XIVA. <br><br><h3>  O√π sont les pertes? </h3><br>  Le sch√©ma de remise des notifications push comporte quatre fl√®ches; des pertes peuvent survenir √† trois de ces transitions. <br><br>  <strong>Entre le serveur et XIVA, des</strong> pertes peuvent survenir dans le cas suivant.  L'utilisateur a re√ßu une lettre, le serveur en a connaissance, g√©n√®re une notification et l'envoie √† XIVA.  Mais XIVA peut perdre ces informations, par exemple, si un utilisateur de l'application a choisi "S'abonner" √† un dossier sp√©cifique alors qu'il √©tait hors ligne.  Ensuite, XIVA ne recevra pas d'informations sur l'abonnement au dossier, et lorsque la charge utile arrivera, elle la supprimera simplement et l'utilisateur ne verra pas la notification. <br><br>  <strong>Entre XIVA et APN</strong> , une perte de r√©seau peut se produire.  Nous pouvons difficilement affecter le r√©seau, nous ne nous attarderons donc pas sur ce point. <br><br>  <strong>Entre APN et Extension, ou APNS et iOS</strong> si vous n'utilisez pas Extension.  Il s'agit du type de perte le plus courant.  De telles pertes se produisent car les APN ne stockent pas plus d'un push par application sur l'appareil.  Si, alors que l'utilisateur est hors ligne, il re√ßoit plusieurs notifications, lorsqu'il se connecte, il ne verra que le dernier message. <br><br>  Ce sont les m√™mes pertes qui ne nous permettent pas de garantir la livraison et de compter sur les notifications push.  Apple √©crit clairement que la livraison n'est pas garantie. <br><br>  <strong>Entre l'application Extension et iOS,</strong> <strong><em>aucune</em></strong> <strong>perte</strong> <strong><em>ne</em></strong> <strong>peut</strong> <strong><em>se produire</em></strong> <strong>, et Apple le garantit.</strong>  Si vous utilisez Extension et remplacez la m√©thode didReceiveContent avec compl√©tion, m√™me si vous n'appelez pas cette compl√©tion, la notification sera quand m√™me affich√©e.  C'est important √† retenir.  Vous ne pouvez pas l'appeler ou n'avez pas le temps de l'appeler, mais la notification sera affich√©e sans aucune modification, sous la forme dans laquelle elle provient des APN. <br><br>  Nous verrons comment nous g√©rons les pertes entre les APN et l'extension.  Mais si vous avez besoin d'augmenter la d√©livrabilit√© des notifications push, jetez un ≈ìil √† l'ensemble du sch√©ma.  V√©rifiez s'il y a des pertes du c√¥t√© service, si votre fournisseur interagit normalement avec les APN et ainsi de suite.  V√©rifiez et mesurez toute la cha√Æne, puis tirez des conclusions l√† o√π les pertes se produisent le plus et quelle partie de ce circuit doit √™tre modifi√©e. <br><br><h2>  File d'attente de notification push </h2><br>  Notre fa√ßon de g√©rer les pertes dans l'ensemble d'APN et d'extension, nous avons appel√© la file d'attente de notifications push. <br><br>  Si vous compressez toute l'histoire en une seule phrase, ce sera: <br><blockquote>  Si vous avez manqu√© la notification push, vous pouvez la demander √† nouveau. </blockquote><br><img src="https://habrastorage.org/webt/mi/dl/c8/midlc81bedgy18xv4gzgmkyb7zo.jpeg"><br><br>  Dans notre sch√©ma de livraison de notification, tous les m√™mes participants sont: XIVA, APN, Extension.  Le sch√©ma simplifi√© fonctionne comme ceci: <br><br><ul><li>  XIVA num√©rote les notifications push qu'il a l'intention d'envoyer aux APN, puis envoie uniquement des informations. </li><li>  L'extension re√ßoit une notification push num√©ro 1 et, apr√®s un certain temps, num√©ro 3. Elle comprend que certaines donn√©es sont manquantes. </li><li>  Envoie √† XIVA une demande avec la derni√®re position re√ßue, diff et demande de renvoyer les donn√©es manquantes. </li><li>  XIVA renvoie la notification push car elle stocke la base de donn√©es de charges utiles et la base de donn√©es d'abonnement.  Tous les abonnements sont stock√©s pendant un certain temps et peuvent √™tre demand√©s √† nouveau. </li><li>  Nous demandons √† nouveau, nous recevons une notification push, et nous avons sur le client tous les messages que le client aurait d√ª recevoir. </li></ul><br>  Le premier probl√®me attendu est les notifications en double.  Lorsque nous demandons √† nouveau un message √† XIVA, nous ne savons pas ce qui est dans la file d'attente pour l'envoi, car nous communiquons avec lui non pas directement, mais via des APN.  Supposons que nous ayons vu que certaines notifications manquaient et avons envoy√© une demande √† XIVA.  XIVA envoy√© via des APN de charge utile avec une notification manqu√©e.  Mais avant de le recevoir, nous avons re√ßu une autre charge utile et √©galement avec un laissez-passer.  Ils ont demand√© √† nouveau - XIVA a envoy√© √† nouveau. <br><br>  Pour que les notifications ne soient pas dupliqu√©es, nous utilisons <strong>apns-collapse-id</strong> .  Ce param√®tre permet au c√¥t√© iOS de r√©duire les notifications push avec le m√™me ID.  Si plusieurs notifications push avec le m√™me id-collapse-id sont arriv√©es sur l'appareil, iOS les r√©duira et l'utilisateur ne verra qu'une seule notification. <br><br><h3>  XIVA </h3><br>  Je vais vous expliquer comment tout cela fonctionne sur XIVA, car c'est toujours curieux de savoir ce qui se passe sur le backend. <br><br>  XIVA existait avant la file d'attente de notifications push et √©tait une base de donn√©es d'abonnement.  Il est important que dans la base de donn√©es tout soit stock√© par les utilisateurs: <br><br><ul><li>  La cl√© √©tait <code>&lt;service, user&gt;</code> . </li><li>  La charge utile a √©t√© stock√©e en tant que valeur (donn√©es sur les lettres dans le cas de Mail). </li></ul><br>  XIVA a pris des donn√©es de la base de donn√©es et envoy√©es aux APN ou √† un autre service, car cela ne fonctionne pas uniquement avec iOS.  Nous avons d√©cid√© de le r√©utiliser. <br><br>  Nous sommes venus √† l'√©quipe de d√©veloppement XIVA et avons vraiment demand√© une file d'attente de notifications push.  En principe, XIVA avait d√©j√† tout pour cela: la base de donn√©es, TTL pour les charges utiles, c'est-√†-dire qu'elles ne sont pas supprim√©es imm√©diatement, elles peuvent √™tre transmises.  La seule chose qui manquait √©tait qu'il √©tait possible de configurer la file d'attente de notifications push dans le cadre de l'impl√©mentation XIVA actuelle - c'est par le biais de la num√©rotation. <br><br>  Pour la num√©rotation directe, les notifications push doivent √™tre num√©rot√©es par appareil et nom_app.  C'est-√†-dire que la num√©rotation de bout en bout est n√©cessaire pour un appareil sp√©cifique et pour une application sp√©cifique afin de pouvoir compter sur elle c√¥t√© client.  Nous avons fait cela comme suit: r√©utilis√© la base de donn√©es XIVA, mais commenc√© √† y √©crire des charges utiles √† l'aide d'une cl√© diff√©rente.  Maintenant, apns_queue agit comme un service, <code>device_id + app_name</code> tant qu'utilisateur - les donn√©es m√™mes qui doivent √™tre num√©rot√©es sur le client, c'est-√†-dire la <code>key: &lt;apns_queue, device_id + app_name&gt;</code> . <br><br>  D√©sormais, XIVA prend les donn√©es de la base de donn√©es principale et les place dans la file d'attente lorsqu'elles doivent √™tre envoy√©es.  √Ä ce stade, les charges utiles re√ßoivent une nouvelle num√©rotation, car elles se trouvent maintenant dans la m√™me base de donn√©es, mais avec une cl√© diff√©rente.  D√©j√† √† partir de l√†, XIVA les sort et les envoie via des APN.  Au total, le client re√ßoit la num√©rotation de charge utile n√©cessaire. <br><br>  Le client utilise l'extension du service de notification. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: UNNotificationRequest, withContentHandler contentHandler: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(UNNotificationContent)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// . . . }</span></span></code> </pre> <br>  Nous y red√©finissons la m√©thode <code>didReceive</code> et voyons ce qui provient du serveur.  Nous ajoutons <code>"mutable-content" : 1</code> √† toutes les notifications push afin qu'elles tombent dans Extension, car sinon nous ne pourrons pas les prendre en compte dans les calculs. <br><br>  Plus loin dans le code √† l'int√©rieur de la m√©thode, il y a des contr√¥les continus: si la charge utile n√©cessaire est venue, si elle peut l'analyser.  S'il n'est pas analys√©, ce message ne provient pas de XIVA.  Si le message ne provient pas de XIVA, nous ne pouvons pas continuer √† travailler avec lui et simplement appeler la compl√©tion avec la notification provenant d'APN, nous n'effectuons aucun calcul. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> payload = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.payloadParser.parsePayload(from: request.content.userInfo) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,     xiva contentHandler(request.content); return }</span></span></code> </pre> <br>  Nous nous connectons, v√©rifions si le deviceId a chang√©, car nous savons que dans iOS, c'est possible.  Honn√™tement, nous n'avons pas rencontr√© de changement dans deviceId, mais juste au cas o√π nous le traiterions, car s'il change, nous ne pourrons pas faire confiance aux num√©ros de XIVA. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.logger.logNotificationReceived(with: payload) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastPositionDeviceId != deviceId { <span class="hljs-comment"><span class="hljs-comment">// deviceId ,    lastNotificationPosition = nil lastPositionDeviceId = deviceId }</span></span></code> </pre> <br>  En outre, nous examinons si nous pouvons recevoir les donn√©es XIVA dans cette charge utile, qu'elles le soient ou non.  Sinon, appelez √† nouveau contentHandler. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xivaInfo = payload.xivaInfo <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { contentHandler(request.content); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br>  S'il y a des donn√©es, v√©rifiez si deviceId a re√ßu des donn√©es.  XIVA envoie un hachage de l'appareil √† la charge utile, s'il est v√©rifi√© et correspond, nous continuons, non, nous appelons contentHandler. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> isHashCompatible(deviceId: deviceId, deviceIdHash: xivaInfo.deviceIdHash) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// payload device_id   device_id  contentHandler(request.content); return }</span></span></code> </pre> <br>  Le bloc suivant consiste √† voir s'il y a une position enregistr√©e: <br><br><ul><li>  Si nous n'avons pas la derni√®re position enregistr√©e, alors nous n'avons pas encore re√ßu de notifications et ne sommes pas entr√©s dans Extension, ou pour une raison quelconque, nous avons abandonn√©.  Ensuite, il n'y a rien √† pousser pour trouver le diff manqu√©, et nous appelons √† nouveau l'ach√®vement. </li><li>  S'il y en a, continuez. </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastPos = lastNotificationPosition <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      lastNotificationPosition = xivaInfo.notificationPosition contentHandler(request.content); return }</span></span></code> </pre> <br>  Nous comptons le nombre de notifications manqu√©es.  Si le z√©ro est parfait, nous n'avons rien manqu√©. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> missedMessages = xivaInfo.notificationPosition - lastPos - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> missedMessages &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   push‚Äì     contentHandler(request.content); return }</span></span></code> </pre> <br>  Sinon, nous prenons de XIVA les donn√©es de position - de cette m√™me num√©rotation continue.  En outre, nous examinons si la quantit√© de manqu√©s ne d√©passe pas une certaine valeur d√©finie. <br><br><pre> <code class="swift hljs">lastNotificationPosition = xivaInfo.notificationPosition <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> missedMessages &lt;= repeatMaxCount <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,   contentHandler(buildNewNotification()); return }</span></span></code> </pre> <br>  Pourquoi est-ce n√©cessaire?  Supposons que l'utilisateur soit hors ligne depuis longtemps, et pendant ce temps, une centaine de messages ont √©t√© accumul√©s.  Nous demanderons la centaine enti√®re (c'est facile pour nous), XIVA enverra la centaine enti√®re et l'utilisateur recevra toutes les notifications.  M√™me si nous les groupons par thread-id (et nous les groupons), tout de m√™me, pour chaque notification, cette extension sera appel√©e, toutes les v√©rifications passeront.  Il semble peu probable que l'utilisateur ait besoin des cent notifications.  Par cons√©quent, nous g√©n√©rons une notification dans laquelle nous √©crivons que vous avez 100 messages manqu√©s, allez dans l'application et regardez.  Et nous montrons exactement ce message √† l'utilisateur, car nous pouvons remplacer les notifications push. <br><br>  Une fois tous les contr√¥les effectu√©s, nous envoyons une demande √† XIVA: la derni√®re position qui nous est parvenue et le nombre de messages manqu√©s.  Et regardez: <br><br><ul><li>  Si le XIVA r√©pond avec succ√®s: "Tout va bien, j'enverrai les donn√©es", nous montrons √† l'utilisateur la notification actuelle et attendons que le XIVA envoie tout le reste et que l'utilisateur voit tous les messages manquants. </li><li>  Si XIVA r√©pond avec une erreur, nous montrons √† l'utilisateur une notification personnalis√©e qu'il a manqu√© des messages qui peuvent √™tre consult√©s dans l'application. </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.requestMissedNotifications(lastPosition: xivaInfo.notificationPosition, gap: missedMessages) { result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> result.onValue { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.logger.logNotificationProcessed(with: .success) contentHandler(request.content) }.onError { error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.logger.logNotificationProcessed(with: .failure(error)) contentHandler(buildNewNotification()) } }</code> </pre> <br>  Ainsi, l'impl√©mentation sur le client se r√©sume √† un grand nombre de contr√¥les dans lesquels nous d√©couvrons si nous pouvons travailler avec les donn√©es re√ßues. <br><br><h2>  Exploitation foresti√®re et autres difficult√©s </h2><br>  Comme vous le savez, pour vous assurer que l'approche fonctionne bien, vous devez vous connecter.  Nous avons commenc√© √† collecter des statistiques sur une nouvelle m√©thode de livraison des notifications et √† comparer l'√©volution de la d√©livrabilit√©. <br><br><h3>  Limitations de l'extension push </h3><br>  La premi√®re chose que nous avons rencontr√©e est les restrictions de push-extension. <br><br>  <strong>Pas toujours appel√©</strong> .  Si vous d√©sactivez le dessin de notification dans les param√®tres de l'application (la possibilit√© de recevoir une notification reste activ√©e, mais tout le rendu possible est d√©sactiv√©), l'extension ne sera pas appel√©e - toute la logique avec les recomptes et, surtout, la journalisation ne sera pas appel√©e.  Nous ne pourrons pas savoir ce qui est le plus important pour nous - si l'utilisateur a re√ßu une notification. <br><br>  <strong>L'extension push a une limite de temps</strong> .  La documentation Apple indique que dans environ 30 secondes, vous devez appeler la fin avec une notification modifi√©e, sinon la notification initiale sera affich√©e. <br><br>  Je me demande comment nous l'avons compris.  Nous avons impl√©ment√© une fonctionnalit√© que nous avons appel√©e ¬´belles¬ª notifications push, attach√© des √©l√©ments multim√©dias aux notifications, chang√© le titre, le sous-titre.  Au cours des tests, il s'est av√©r√© que certaines notifications push sont devenues belles, tandis que le reste est demeur√© de vilains canetons. <br><br>  Nous avons commenc√© √† examiner la diff√©rence entre ces notifications push et nous avons d√©couvert qu'il n'y avait pas de diff√©rence, pour certains, nous avons r√©ussi √† appeler l'ach√®vement, mais pour d'autres non. ,   , push-     ,     APNs. <br><br> <strong>  ‚Äî  </strong> . Apple ,  ,   push-extension, ,        ,     .   ,    12 . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apple Developer Forum</a>   ,   ,        .     ,     ‚Äî 10 . <br><br>     ,   .      AppMetrica.   , AppMetrica     ,   Extension   .      ,  -   . <br><br>     :    Extension   . <br><br><h3>   </h3><br>    push-extension    UserDefaults. ,    ,     AppMetrica. <br><br>     .      .   ,          ,      .          ,          .         ,   XIVA (  ),  ,   . <br><br>  ,  Notification Extension   iOS 10  ,       Extension,       ,     . <br><br> <strong> </strong> <strong>AppMetrica</strong> :      , push-extension      .  AppMetrica   push-,   ,             .   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppMetrica Push SDK</a> . <br><br> ,   .    ‚Äî   ,   .   ,   . <br><br><img src="https://habrastorage.org/webt/tg/k_/nk/tgk_nkvmus8kud-brgg6v9jvmhm.jpeg"><br><br>   ‚Äî   ,      ,     . <br><br>  ,     push-,   ,        ‚Äî   . <br><br>  ,  ,     .      , ‚Ä¶ <br><br><h2>  </h2><br>   :  , ,  .   ,  ?   -  ,     push-?  ,        ?    user experience   ? <br><br><blockquote>       ,       2‚Äì3‚Äì20  ? <br></blockquote><br> , ,  ,  ,  ,   ,  ,  .           ,      push-. ,     . <br><br><h2>  R√©sum√© </h2><br> <strong>Push-  iOS   .</strong>             ,    .. ,    . <br><br> <strong> push-  ( ) .</strong>       .  XIVA. ,     ,     . ,  ,      . ! <br><br> <strong>   push-extension.</strong>     ,    . ,   . <br><br> <strong>,     .</strong> ,     , ,    ,    -  . ,   push-           . , ,      ,      App Store,     ,   ! <br><br><blockquote>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppsConf</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,     21  22      ,        ..        50 ,     .  1   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   </a>      ,       ‚Äî . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462507/">https://habr.com/ru/post/fr462507/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462493/index.html">SGBD multimod√®le - la base des syst√®mes d'information modernes?</a></li>
<li><a href="../fr462495/index.html">Ev√©nements num√©riques √† Moscou du 05 au 11 ao√ªt</a></li>
<li><a href="../fr462501/index.html">Pourquoi ai-je besoin de ma propre autorit√© de certification</a></li>
<li><a href="../fr462503/index.html">√Ä quoi servent les ¬´signaux d'or¬ª de la surveillance et du SRE?</a></li>
<li><a href="../fr462505/index.html">Ne me trompez pas avec votre programmation fonctionnelle</a></li>
<li><a href="../fr462509/index.html">Product Fest - Conf√©rence sur la gestion des produits informatiques √† laquelle vous souhaitez vous rendre</a></li>
<li><a href="../fr462511/index.html">Google Play Instantan√©. Refactoring √† vie</a></li>
<li><a href="../fr462513/index.html">D√©localisation: pr√©paration, s√©lection, d√©veloppement du territoire</a></li>
<li><a href="../fr462515/index.html">Bugs lors de l'utilisation du clavier syst√®me</a></li>
<li><a href="../fr462519/index.html">Le livre "Microservices. Mod√®les de d√©veloppement et de refactoring ¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>