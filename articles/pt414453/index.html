<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçÇ üöä üåµ Implementar o Path Finder para agentes de IA com o NavMesh üôáüèø üîù üë©üèª‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seguindo o caminho e controlando o tr√°fego 
 √Äs vezes, precisamos de personagens de IA para percorrer o mundo do jogo, seguindo um caminho mais ou men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementar o Path Finder para agentes de IA com o NavMesh</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414453/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11d/4c5/6ad/11d4c56ad10246e5cb9e56e641938b59.png" alt="imagem"></div><br><h2>  Seguindo o caminho e controlando o tr√°fego </h2><br>  √Äs vezes, precisamos de personagens de IA para percorrer o mundo do jogo, seguindo um caminho mais ou menos definido.  Por exemplo, em um jogo de corrida, os oponentes de IA devem viajar ao longo da estrada e, no RTS, as unidades devem poder se mover para o ponto desejado, se movendo ao longo do terreno e levando em considera√ß√£o a posi√ß√£o um do outro. <br><br>  Para parecerem inteligentes, os agentes de IA devem ser capazes de determinar o que est√£o fazendo e, se n√£o puderem alcan√ßar o ponto desejado, devem ser capazes de tra√ßar a rota mais eficaz e mudar seu caminho quando obst√°culos surgirem. <br><br>  Evitar obst√°culos √© um comportamento simples que permite que as entidades de IA alcancem pontos de destino.  √â importante observar que o comportamento implementado neste post √© para comportamentos como simula√ß√£o de multid√µes, em que o principal objetivo de cada agente √© evitar outros agentes e atingir o objetivo.  Eles n√£o determinam o caminho mais eficiente e o mais curto. <br><br><h2>  Requisitos t√©cnicos </h2><br>  Requer o Unity 2017 instalado em um sistema com Windows 7 SP1 +, 8, 10 ou Mac OS X 10.9+.  O c√≥digo deste artigo n√£o funcionar√° no Windows XP e Vista, e as vers√µes do servidor do Windows e OS X n√£o foram testadas. <br><br>  Os arquivos de c√≥digo para esta postagem podem ser encontrados no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">GitHub</a> . <br><br>  Para aprender o c√≥digo em a√ß√£o, assista a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">este v√≠deo</a> . <br><a name="habracut"></a><br><h2>  Malha de navega√ß√£o </h2><br>  Vamos descobrir como usar o gerador de malha de navega√ß√£o Unity incorporado, que pode simplificar bastante a busca de caminhos para agentes de IA.  Nos est√°gios iniciais do Unity 5.x, a fun√ß√£o NavMesh ficou dispon√≠vel para todos os usu√°rios, incluindo aqueles com licen√ßas de edi√ß√£o pessoal, embora anteriormente fosse uma fun√ß√£o apenas para o Unity Pro.  Antes do lan√ßamento do 2017.1, o sistema era atualizado para fornecer um fluxo de trabalho baseado em componentes, mas como requer um pacote adicional para download, que no momento da reda√ß√£o est√° dispon√≠vel apenas na vers√£o de visualiza√ß√£o, aderiremos ao fluxo de trabalho padr√£o baseado em cena.  N√£o se preocupe, os conceitos de ambas as abordagens s√£o semelhantes e, quando a implementa√ß√£o final finalmente chegar a 2017.x, n√£o haver√° mudan√ßas significativas. <br><br>  Saiba mais sobre o sistema de componentes NavMesh no Unity no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">GitHub</a> . <br><br>  Agora vamos explorar todas as possibilidades que esse sistema pode nos oferecer.  Para procurar caminhos de IA, a cena deve ser apresentada em um formato espec√≠fico;  em um mapa 2D, uma grade bidimensional (matriz) √© usada para procurar caminhos usando o algoritmo A *.  Os agentes de IA precisam saber onde est√£o os obst√°culos, especialmente os est√°ticos.  Lidar com colis√µes entre objetos em movimento din√¢mico √© outro problema comumente chamado de comportamento de dire√ß√£o.  O Unity possui uma ferramenta integrada para gerar o NavMesh, representando a cena em um contexto conveniente para os agentes de IA encontrarem o caminho ideal para o destino.  Para come√ßar, abra um projeto de demonstra√ß√£o e v√° para a cena NavMesh. <br><br><h3>  Cart√£o de estudo </h3><br>  Depois de abrir a cena de demonstra√ß√£o do NavMesh, ela deve aparecer na captura de tela: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a3/35c/15a/7a335c15ad8084dee2aab59de7cdcd3f.png"></div><br>  <em>Cena do obst√°culo e da inclina√ß√£o</em> <br><br>  Esta ser√° a nossa caixa de areia para explicar e testar a funcionalidade do sistema NavMesh.  O esquema geral √© semelhante a um jogo do g√™nero RTS (estrat√©gia em tempo real).  N√≥s dirigimos um tanque azul.  Clique em pontos diferentes para que o tanque se mova em dire√ß√£o a eles.  O indicador amarelo √© o alvo atual do tanque. <br><br><h3>  Navega√ß√£o est√°tica </h3><br>  Primeiro, voc√™ precisa dizer que deve marcar toda a geometria da cena, inserida no NavMesh, como <b>Navega√ß√£o est√°tica</b> .  Voc√™ j√° deve ter visto isso antes, por exemplo, no sistema de mapas de ilumina√ß√£o do Unity.  Para tornar os objetos do jogo est√°ticos √© muito simples, basta marcar a caixa <b>Est√°tica</b> para todas as suas propriedades (navega√ß√£o, ilumina√ß√£o, sele√ß√£o, lotes, etc.) ou use a lista suspensa para especificar propriedades.  A caixa de sele√ß√£o est√° localizada no canto superior direito do inspetor dos objetos selecionados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7c/cfd/224/f7ccfd224088652d0831282397b5eb5c.png"></div><br>  <em>Navega√ß√£o de propriedade Est√°tica</em> <br><br>  Isso pode ser feito individualmente para diferentes objetos ou, se voc√™ tiver uma hierarquia interna de objetos de jogo, aplique o par√¢metro ao objeto pai, ap√≥s o qual o Unity oferecer√° a aplica√ß√£o a todos os objetos filhos. <br><br><h3>  Assar uma malha de navega√ß√£o </h3><br>  Para toda a cena, as op√ß√µes de navega√ß√£o navmesh s√£o aplicadas usando a janela <b>Navega√ß√£o</b> .  Para abrir esta janela, v√° para <b>Janela</b> |  <b>Navega√ß√£o</b>  Como qualquer outra janela, pode ser desconectada para livre circula√ß√£o ou corrigida.  Em nossas capturas de tela, ela √© mostrada como uma guia ancorada ao lado da hierarquia, mas voc√™ pode colocar essa janela em qualquer local conveniente. <br><br>  Abrindo a janela, voc√™ ver√° abas individuais.  Ser√° algo parecido com isto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/872/7a6/b30/8727a6b301be8f979821ab0446ce5e7d.png"></div><br>  <em>Janela de Navega√ß√£o</em> <br><br>  No nosso caso, a captura de tela anterior mostra a guia <b>Bake</b> , mas em seu editor, qualquer guia pode ser selecionada por padr√£o. <br><br>  Vamos olhar para cada uma das guias, come√ßando pela esquerda e movendo para a direita.  Vamos come√ßar com a guia <b>Agents</b> , que se parece com a captura de tela: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e2/3e9/db3/9e23e9db3a55b407af7a7bde83c56c4b.png"></div><br>  <em>Guia Agentes</em> <br><br>  Se voc√™ estiver trabalhando em outro projeto, poder√° achar que algumas das configura√ß√µes s√£o diferentes daquelas que definimos para o projeto de exemplo mostrado na captura de tela.  Na parte superior da guia, h√° uma lista na qual voc√™ pode adicionar novos tipos de agentes clicando no bot√£o <b>+</b> .  Voc√™ pode remover agentes adicionais selecionando-os e clicando no bot√£o <b>-</b> .  A janela mostra claramente o que v√°rias configura√ß√µes fazem ao alter√°-las.  Vamos ver o que cada uma das configura√ß√µes faz: <br><br><ul><li>  Nome: nome do tipo de agente exibido na lista suspensa Tipos de agentes. </li><li>  Raio: Voc√™ pode pensar nisso como o "espa√ßo pessoal" de um agente.  Os agentes tentar√£o evitar contato muito pr√≥ximo com outros agentes com base nesse valor, porque √© usado para evitar. </li><li>  Altura: como voc√™ pode imaginar, essa configura√ß√£o define a altura do agente que ele usa para evitar verticalmente (por exemplo, ao passar sob objetos). </li><li>  Altura da etapa: esse valor determina a altura que o agente pode subir. </li><li>  Max Slope: como veremos na pr√≥xima se√ß√£o, esse valor determina o √¢ngulo m√°ximo no qual o agente pode subir.  Usando esse par√¢metro, voc√™ pode tornar as inclina√ß√µes √≠ngremes do mapa inacess√≠veis ao agente. </li></ul><br>  Em seguida, temos a guia <b>√Åreas</b> , que se parece com a mostrada nesta captura de tela: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68b/e36/4f6/68be364f6605a8b3f567dfeb31bf56db.png"></div><br>  Como voc√™ pode ver na captura de tela, o Unity fornece v√°rios tipos de √°reas que n√£o podem ser alteradas: <b>Walkable</b> , <b>Not Walkable</b> e <b>Jump</b> .  Al√©m de nomear e criar novas √°reas, voc√™ pode atribuir a essas √°reas o custo de se movimentar por elas. <br><br>  As √°reas t√™m dois prop√≥sitos: tornar as √°reas acess√≠veis ou inacess√≠veis ao agente e marcar as √°reas como menos desej√°veis ‚Äã‚Äãem termos de custos de viagem.  Por exemplo, voc√™ pode desenvolver um RPG no qual inimigos demon√≠acos n√£o podem entrar em √°reas marcadas como ‚Äúsolo consagrado‚Äù.  Voc√™ tamb√©m pode marcar algumas √°reas do mapa como um ‚Äúp√¢ntano‚Äù ou ‚Äúp√¢ntano‚Äù, que o agente evitar√° devido ao alto custo de movimenta√ß√£o. <br><br>  A terceira guia <b>Bake</b> √© provavelmente a mais importante.  Permite criar o pr√≥prio NavMesh para a cena.  Voc√™ j√° deve estar familiarizado com algumas das op√ß√µes.  A guia <b>Bake</b> fica assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16a/fc2/a66/16afc2a6659910152c0f4d673c9bcacb.png"></div><br>  <em>Guia Assar</em> <br><br>  As op√ß√µes de tamanho do agente nesta guia determinam como os agentes ir√£o interagir com o ambiente, enquanto as op√ß√µes na guia <b>Agentes</b> controlam intera√ß√µes com outros agentes e objetos em movimento.  Mas eles controlam os mesmos par√¢metros, ent√£o vamos ignor√°-los.  <b>A altura da queda</b> e a <b>dist√¢ncia do salto</b> controlam at√© que ponto o agente pode ‚Äúpular‚Äù para alcan√ßar a parte do NavMesh que n√£o est√° diretamente relacionada √†quela em que o agente est√° localizado atualmente.  Consideraremos isso com mais detalhes abaixo; portanto, se voc√™ n√£o tiver certeza, ainda n√£o poder√° estudar esses par√¢metros. <br><br>  Al√©m disso, existem op√ß√µes avan√ßadas que geralmente est√£o ocultas por padr√£o.  Para expandir essas op√ß√µes, basta clicar no tri√¢ngulo suspenso ao lado do cabe√ßalho <b>Avan√ßado</b> .  <b>O tamanho manual do Voxel</b> pode ser considerado uma configura√ß√£o de "qualidade".  Quanto menor o tamanho, mais detalhes ser√£o armazenados na malha.  <b>A √°rea da regi√£o m√≠nima √©</b> usada para pular plataformas ou superf√≠cies de cozimento abaixo do limite selecionado.  <b>A malha de altura</b> fornece dados verticais mais detalhados ao assar uma malha.  Por exemplo, esta op√ß√£o permite manter o local correto do agente ao subir escadas. <br><br>  O bot√£o <b>Limpar</b> exclui todos os dados do NavMesh da cena e o bot√£o <b>Bake</b> cria uma malha para a cena.  O processo de cozimento √© bem r√°pido.  Contanto que voc√™ tenha uma janela selecionada, poder√° observar a gera√ß√£o do NavMesh com o bot√£o <b>Bake</b> na janela de cena.  Vamos clicar no bot√£o <b>Assar</b> para ver os resultados.  Em nossa cena de exemplo, acabamos com algo semelhante a esta captura de tela: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11d/4c5/6ad/11d4c56ad10246e5cb9e56e641938b59.png"></div><br>  As √°reas azuis mostram NavMesh.  Abaixo retornaremos a isso.  Enquanto isso, vamos para a √∫ltima guia - <b>Objeto</b> , que se parece com isso: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/6c7/4e8/b446c74e8154bca80133ff95ce378d31.png"></div><br>  Os tr√™s bot√µes mostrados na captura de tela anterior - <b>Todos</b> , <b>Renderizadores de malha</b> e <b>Terrains</b> - s√£o usados ‚Äã‚Äãcomo filtros de cena.  Eles s√£o √∫teis ao trabalhar em cenas complexas com muitos objetos na hierarquia.  A sele√ß√£o de uma op√ß√£o filtra o tipo correspondente da hierarquia, facilitando a sele√ß√£o deles.  Voc√™ pode usar os bot√µes para explorar sua cena em busca de objetos que deseja marcar como est√°tico de navega√ß√£o. <br><br><h3>  Usando o Nav Mesh Agent </h3><br>  Agora que montamos a cena com o NavMesh, precisamos de uma maneira do agente usar essas informa√ß√µes.  Felizmente para n√≥s, o Unity possui um componente <b>Nav Mesh Agent</b> que voc√™ pode arrastar para um personagem.  Em nossa cena de exemplo, h√° um objeto de jogo chamado <b>Tank</b> , ao qual um componente j√° est√° anexado.  Olhe para a hierarquia e voc√™ ver√° algo assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/3ba/68f/a313ba68f88b2417e0225c6f724cbce8.png"></div><br>  Existem alguns par√¢metros aqui, e n√£o consideraremos tudo, porque eles s√£o bem claros e a descri√ß√£o pode ser encontrada na documenta√ß√£o oficial do Unity.  Mas vamos mencionar as principais coisas: <br><br><ul><li>  <strong>Tipo de agente</strong> : Lembre-se da guia <strong>Agentes</strong> na janela <strong>Navega√ß√£o</strong> ?  Tipos de agentes atribu√≠veis podem ser selecionados aqui. </li><li>  <strong>Desviar</strong> automaticamente o <strong>link de malha desativada</strong> : essa op√ß√£o permite que os agentes usem automaticamente o recurso <strong>Links de malha desativada</strong> , que discutiremos abaixo. </li><li>  <strong>M√°scara de √°rea</strong> : aqui voc√™ pode selecionar as √°reas configuradas na guia <strong>√Åreas</strong> da janela <strong>Navega√ß√£o</strong> . </li></ul><br>  Isso √© tudo.  Este componente faz 90% do trabalho duro para n√≥s: abrindo o caminho, evitando obst√°culos e assim por diante.  A √∫nica coisa que voc√™ precisa √© transferir o ponto de destino para o agente.  Vamos olhar para este problema. <br><br><h3>  Configura√ß√£o do ponto de destino </h3><br>  Depois de configurar o agente de IA, precisamos de uma maneira de dizer a ele para onde ir.  Em nosso projeto de exemplo, existe um script chamado <b>Target.cs</b> que executa exatamente essa tarefa. <br><br>  Esta √© uma classe simples que faz tr√™s coisas: <br><br><ul><li>  "Dispara" o feixe da c√¢mera para a posi√ß√£o do mouse no mundo </li><li>  Atualiza a posi√ß√£o do marcador </li><li>  Atualiza a propriedade de destino para todos os agentes NavMesh. </li></ul><br>  O c√≥digo √© bastante simples.  Toda a classe √© a seguinte: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Target</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NavMeshAgent[] navAgents; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform targetMarker; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { navAgents = FindObjectsOfType(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(NavMeshAgent)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> NavMeshAgent[]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateTargets</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 targetPosition </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(NavMeshAgent agent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> navAgents) { agent.destination = targetPosition; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GetInput()) { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hitInfo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray.origin, ray.direction, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hitInfo)) { Vector3 targetPosition = hitInfo.point; UpdateTargets(targetPosition); targetMarker.position = targetPosition; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmos</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.DrawLine(targetMarker.position, targetMarker.position + Vector3.up * <span class="hljs-number"><span class="hljs-number">5</span></span>, Color.red); } }</code> </pre> <br>  As seguintes a√ß√µes ocorrem aqui: no m√©todo <b>Start</b> , inicializamos a matriz <b>navAgents</b> usando o m√©todo <b>FindObjectsOfType ()</b> . <br><br>  O m√©todo <b>UpdateTargets ()</b> passa por nossa matriz <b>navAgents</b> e define o ponto de destino para eles no <b>Vector3</b> fornecido.  Essa √© a chave do c√≥digo.  Voc√™ pode usar qualquer mecanismo para obter o ponto de destino e, para o agente ir para l√°, basta definir o campo <b>NavMeshAgent.destination</b> ;  o agente far√° o resto. <br><br>  Em nosso exemplo, os cliques s√£o usados ‚Äã‚Äãpara se mover; portanto, quando um jogador clica no mouse, liberamos o raio da c√¢mera para o mundo na dire√ß√£o do cursor do mouse e, se ele se cruzar com alguma coisa, atribu√≠mos um ponto de colis√£o ao novo agente <b>targetPosition</b> .  Tamb√©m ajustamos o marcador de destino para visualizar facilmente o destino no jogo. <br><br>  Para testar a opera√ß√£o, voc√™ precisa assar o NavMesh de acordo com a descri√ß√£o da se√ß√£o anterior, iniciar o modo de reprodu√ß√£o e selecionar qualquer √°rea no mapa.  Se voc√™ clicar v√°rias vezes, poder√° ver que o agente n√£o pode alcan√ßar algumas √°reas - a parte superior dos cubos vermelhos, a plataforma superior e a plataforma na parte inferior da tela. <br><br>  Cubos vermelhos est√£o muito altos.  A inclina√ß√£o que leva √† plataforma mais alta √© muito acentuada para nossas configura√ß√µes de <b>Max Slope</b> , e o agente n√£o pode subir.  As seguintes capturas de tela mostram como as configura√ß√µes de <b>inclina√ß√£o m√°xima</b> afetam o NavMesh: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd7/539/7b8/fd75397b851d088fc1fd8d4d53210cc9.png"></div><br>  <i>NavMesh com inclina√ß√£o m√°xima = 45</i> <br><br>  Se voc√™ alterar o valor de <b>Max Slope</b> para algo como <b>51</b> e, em seguida, clique no bot√£o <b>Bake</b> novamente para executar o NavMesh novamente, os resultados ser√£o os seguintes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09a/936/b78/09a936b78c4958c9200d00867dbbc418.png"></div><br>  <em>NavMesh com inclina√ß√£o m√°xima = 51</em> <br><br>  Como voc√™ pode ver, podemos personalizar o design do n√≠vel, tornando √°reas inteiras inacess√≠veis, alterando um √∫nico par√¢metro.  Isso pode ser √∫til, por exemplo, quando voc√™ tem uma plataforma ou borda que requer uma corda, escada ou elevador para subir.  Ou talvez uma habilidade especial, por exemplo, a capacidade de escalar? <br><br><h3>  Aplica√ß√£o fora dos links de malha </h3><br>  Voc√™ pode perceber que existem duas interrup√ß√µes em nossa cena.  Nosso agente pode entrar no primeiro, mas o da parte inferior da tela est√° muito longe.  Esses c√°lculos n√£o s√£o completamente arbitr√°rios.  <strong>Os Links fora da malha</strong> criam essencialmente uma ponte entre os espa√ßos entre segmentos NavMesh n√£o relacionados.  Esses links podem ser vistos no editor: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4b/b0a/425/b4bb0a425446298ae08ea4684bbcef10.png"></div><br>  <i>C√≠rculos azuis com linhas de conex√£o s√£o conex√µes.</i> <br><br>  O Unity pode gerar esses links de duas maneiras.  O primeiro que j√° consideramos.  Lembre-se do valor de <b>Dist√¢ncia</b> do <b>salto</b> na guia <b>Assar</b> da janela <b>Navega√ß√£o</b> ?  O Unity usa automaticamente esse valor para gerar esses links ao assar o NavMesh.  Tente alterar o valor em nossa cena de teste para 5 e assar novamente.  Veja - as plataformas agora est√£o conectadas?  Isso ocorre porque as malhas agora est√£o dentro do novo limite especificado. <br><br>  Mude o valor para 2 novamente e asse.  Agora vamos olhar para o segundo caminho.  Crie as esferas que ser√£o usadas para conectar as duas plataformas.  Coloque-os aproximadamente como mostrado na captura de tela: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7a/28e/020/a7a28e020255bb8855d48017da4188f1.png"></div><br>  Voc√™ j√° pode ver o que est√° acontecendo, mas vamos analisar o processo que permite que eles se conectem.  No nosso caso, chamei a esfera no <b>come√ßo</b> direito e a esfera no lado esquerdo.  Voc√™ logo entender√° o porqu√™.  Em seguida, adicionei o componente <b>Off Mesh Link</b> √† plataforma √† direita (em rela√ß√£o √† captura de tela anterior).  Voc√™ notar√° que o componente possui campos de <b>in√≠cio</b> e <b>fim</b> .  Como voc√™ pode imaginar, arrastaremos as esferas criadas anteriormente para os slots correspondentes - a esfera inicial no campo <b>inicial</b> e a esfera final no campo <b>final</b> .  O inspetor ficar√° assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/720/2b4/251/7202b4251068b5d0b1b8b1d7e4b09ff2.png"></div><br>  O valor da <b>Substitui√ß√£o</b> de <b>Custo √©</b> levado em considera√ß√£o quando recebe um valor positivo.  Aplica um fator de custo ao usar esse relacionamento, em vez de uma rota mais econ√¥mica para o destino. <br><br>  <b>Bidirecional,</b> se verdadeiro, permite que o agente se mova nas duas dire√ß√µes.  Para criar links com tr√°fego unidirecional, voc√™ pode desativar esse valor.  O valor <b>Ativado √©</b> usado de acordo com seu nome.  Se falso, o agente ignora essa associa√ß√£o.  Voc√™ pode ativ√°-lo e desativ√°-lo para criar cen√°rios de jogo nos quais, por exemplo, um jogador deve pressionar um bot√£o para ativar uma conex√£o. <br><br>  Para habilitar esse relacionamento, n√£o √© necess√°rio re-assar.  Olhe para o seu NavMesh e voc√™ ver√° que ele se parece exatamente com a captura de tela: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be8/15a/e57/be815ae574360beea94d8907e37fc309.png"></div><br>  Como voc√™ pode ver, o menor espa√ßo ainda se conecta automaticamente e agora temos uma nova conex√£o gerada pelo componente <b>Off Mesh Link</b> entre as duas esferas.  Inicie o modo Play e clique na plataforma remota.  Como esperado, o agente agora pode navegar para a plataforma desconectada: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f6/0c7/a61/7f60c7a61db24f3961ea0b7332de56a1.png"></div><br>  Nos n√≠veis do seu jogo, voc√™ pode precisar alterar esses par√¢metros para alcan√ßar os resultados desejados, mas uma combina√ß√£o desses recursos fornece uma ferramenta conveniente e pronta.  Voc√™ pode criar rapidamente um jogo simples usando a funcionalidade NavMesh. <br><br>  <em>Este tutorial faz parte da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external nofollow">Unity 2017 Game AI Programming - Third Edition</a> de Ray Barrera, Aung Sithu Kyaw e Thet Naing Swe.</em> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414453/">https://habr.com/ru/post/pt414453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414443/index.html">Recursos de chamadas de fun√ß√£o em C ++</a></li>
<li><a href="../pt414445/index.html">Melhorando o Zimbra com o Zextras Suite</a></li>
<li><a href="../pt414447/index.html">Tipos de todos os tempos</a></li>
<li><a href="../pt414449/index.html">Como fazer amigos de todos os operadores do est√°dio e n√£o seme√°-lo com centenas de antenas</a></li>
<li><a href="../pt414451/index.html">"Calend√°rio do testador" para junho. O testador deve pegar o erro, ler Caner e organizar a mudan√ßa.</a></li>
<li><a href="../pt414455/index.html">Algoritmo de gera√ß√£o de paleta de cores</a></li>
<li><a href="../pt414459/index.html">Detectores e descritores de pontos singulares FAST, BREVE, ORB</a></li>
<li><a href="../pt414463/index.html">A pr√≥pria IA aprendeu a construir um cubo de Rubik</a></li>
<li><a href="../pt414465/index.html">Meta Crush Saga: jogo em tempo de compila√ß√£o</a></li>
<li><a href="../pt414467/index.html">Artigos da Confer√™ncia Minsk C ++ CoreHard Spring 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>