<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰 ⏯️ 🚽 Cara kerja codec video. Bagian 2. Apa, mengapa, bagaimana 🧑 🏽 🤓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian I: Video dan Dasar-Dasar Gambar 

  

 Apa? Codec video adalah bagian dari perangkat lunak / perangkat keras yang mengompresi dan / atau mendek...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara kerja codec video. Bagian 2. Apa, mengapa, bagaimana</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/480430/"><h3>  Bagian I: <a href="https://habr.com/ru/company/edison/blog/481418/">Video dan Dasar-Dasar Gambar</a> </h3><br><hr><br> <a href="https://habr.com/ru/company/edison/blog/480430/"><img src="https://habrastorage.org/webt/ta/r8/lt/tar8ltvwz2ubkwwudgcjws-sa9a.png" alt="Sejarah Kodek"></a> <br><br>  <b>Apa?</b>  Codec video adalah bagian dari perangkat lunak / perangkat keras yang mengompresi dan / atau mendekompresi video digital. <br><br>  <b>Untuk apa?</b>  Meskipun ada batasan tertentu dalam hal bandwidth, <br>  dan dalam hal jumlah ruang penyimpanan, pasar membutuhkan video berkualitas tinggi yang semakin banyak.  Ingat bagaimana di posting terakhir kami menghitung minimum yang diperlukan untuk 30 frame per detik, 24 bit per pixel, dengan resolusi 480x240?  Menerima 82.944 Mbps tanpa kompresi.  Kompresi adalah satu-satunya cara untuk mentransfer HD / FullHD / 4K ke layar TV dan Internet.  Bagaimana ini dicapai?  Sekarang kita akan mempertimbangkan secara singkat metode utama. <a name="habracut"></a><blockquote> <a href="https://www.edsd.ru/" title="Perangkat Lunak EDISON - pengembangan web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Perangkat Lunak EDISON - pengembangan web"></a> <br clear="right">  Terjemahan dibuat dengan dukungan Perangkat Lunak EDISON. <br><br>  Kami terlibat dalam <a href="https://www.edsd.ru/integratsiya-sistem-videonablyudeniya-axxon-next-i-sureview-immix">integrasi sistem pengawasan video</a> , serta <a href="https://www.edsd.ru/prilozhenie-dlya-mikrotomografa">mengembangkan mikrotomograf</a> . </blockquote><h3>  Codec vs Container </h3><br>  Kesalahan pemula yang umum adalah mengacaukan codec video digital dan wadah video digital.  Wadah adalah format tertentu.  Pembungkus yang berisi metadata video (dan mungkin audio).  Video terkompresi dapat dianggap sebagai muatan kontainer. <br><br>  Biasanya, ekstensi file video menunjukkan jenis wadah.  Sebagai contoh, file video.mp4 kemungkinan besar merupakan wadah <i>MPEG-4 Bagian 14</i> , dan file bernama video.mkv kemungkinan besar adalah <a href="https://ru.wikipedia.org/wiki/Matroska">boneka</a> Rusia.  Untuk sepenuhnya percaya diri dalam format codec dan wadah, Anda dapat menggunakan <a href="https://www.ffmpeg.org/">FFmpeg</a> atau <a href="https://mediaarea.net/ru/MediaInfo">MediaInfo</a> . <br><br><h3>  Sedikit sejarah </h3><br>  Sebelum kita sampai ke <b>Bagaimana?</b>  , mari selami sedikit sejarah untuk mendapatkan pemahaman yang lebih baik tentang beberapa codec lama. <br><br>  Codec video <b>H.261</b> muncul pada tahun 1990 (secara teknis - pada tahun 1988) dan diciptakan untuk bekerja dengan kecepatan transfer data 64 Kbps.  Ini sudah menggunakan ide-ide seperti subsampling warna, blok makro, dll  Pada tahun 1995, standar codec video <b>H.263</b> diterbitkan, yang dikembangkan hingga tahun 2001. <br><br>  Pada tahun 2003, versi pertama <b>H.264 / AVC</b> selesai.  Pada tahun yang sama, TrueMotion merilis codec video gratisnya yang memampatkan video lossy yang disebut <b>VP3</b> .  Pada 2008, Google membeli perusahaan ini, merilis <b>VP8</b> di tahun yang sama.  Pada Desember 2012, Google merilis <b>VP9</b> , dan didukung sekitar ¾ pasar peramban (termasuk perangkat seluler). <br><br>  <b>AV1</b> adalah codec video open source baru gratis yang dikembangkan <b>oleh Open Media Alliance</b> ( <b>AOMedia</b> ), yang mencakup perusahaan terkenal seperti Google, Mozilla, Microsoft, Amazon, Netflix, AMD, ARM, NVidia, Intel dan Cisco .  Versi pertama dari codec 0.1.0 diterbitkan pada 7 April 2016. <br><br><h3>  Kelahiran AV1 </h3><br>  Pada awal 2015, Google mengerjakan <b>VP10</b> , Xiph (milik Mozilla) mengerjakan <b>Daala</b> , dan Cisco membuat codec video gratis bernama <b>Thor</b> . <br><br>  Kemudian <b>MPEG LA</b> pertama kali mengumumkan batas tahunan untuk <b>HEVC</b> ( <b>H.265</b> ) dan biaya 8 kali lebih tinggi daripada untuk H.264, tetapi mereka segera mengubah aturan lagi: <br><br>  tidak ada batasan tahunan, <br>  biaya konten (0,5% dari pendapatan) dan <br>  biaya unit sekitar 10 kali lebih tinggi daripada untuk H.264. <br><br>  <i>Open Media Alliance</i> dibuat oleh perusahaan dari berbagai bidang: produsen peralatan (Intel, AMD, ARM, Nvidia, Cisco), penyedia konten (Google, Netflix, Amazon), pembuat browser (Google, Mozilla) dan lainnya. <br><br>  Perusahaan memiliki tujuan yang sama - video codec tanpa royalti.  Kemudian datang <b>AV1</b> dengan lisensi paten yang jauh lebih sederhana.  Timothy B. Terriberry membuat presentasi yang memukau, yang menjadi sumber konsep AV1 saat ini dan model lisensinya. <br><br>  Anda akan terkejut mengetahui bahwa Anda dapat menganalisis codec AV1 melalui browser (mereka yang tertarik dapat pergi ke <a href="http://aomanalyzer.org/">aomanalyzer.org</a> ). <br><br><img src="https://habrastorage.org/webt/wa/zz/tv/wazztvoifpc4l11k2_8jzdmiffk.png" alt="gambar"><br><br><h3>  Codec universal </h3><br>  Mari kita menganalisis mekanisme dasar yang mendasari codec video universal.  Sebagian besar konsep ini berguna dan digunakan dalam codec modern seperti <b>VP9</b> , <b>AV1,</b> dan <b>HEVC</b> .  Saya memperingatkan Anda bahwa banyak hal yang dijelaskan akan disederhanakan.  Contoh dunia nyata kadang-kadang akan digunakan (seperti halnya H.264) untuk menunjukkan teknologi. <br><br><h3>  Langkah 1 - membelah gambar </h3><br>  Langkah pertama adalah membagi bingkai menjadi beberapa bagian, subbagian, dan lainnya. <br><br><img width="420" height="238" src="https://habrastorage.org/webt/lo/ze/q1/lozeq18ppa9po16q2ykeiazibpk.png" alt="gambar"><br><br>  Untuk apa?  Ada banyak alasan.  Ketika kita membagi gambar, kita dapat lebih akurat memprediksi vektor gerakan menggunakan bagian kecil untuk bagian bergerak kecil.  Sedangkan untuk latar belakang statis, Anda dapat membatasi diri ke bagian yang lebih besar. <br><br>  Biasanya, codec mengatur bagian-bagian ini menjadi beberapa bagian (atau fragmen), blok makro (atau blok-blok pohon pengkodean) dan banyak subbagian.  Ukuran maksimum partisi ini bervariasi, HEVC menetapkan 64x64, sementara AVC menggunakan 16x16, dan subbagian dapat dibagi hingga 4x4. <br><br>  Ingat jenis-jenis bingkai dari artikel terakhir ?!  Hal yang sama dapat diterapkan pada blok, jadi, kita dapat memiliki fragmen I, blok B, blok makro P, dll. <br><br>  Bagi mereka yang ingin berlatih, lihat bagaimana gambar akan dibagi menjadi beberapa bagian dan subbagian.  Untuk melakukan ini, Anda dapat menggunakan <a href="https://software.intel.com/en-us/video-pro-analyzer">Intel Video Pro Analyzer yang</a> telah disebutkan di artikel sebelumnya (yang dibayar, tetapi dengan versi percobaan gratis, yang memiliki batas pada 10 frame pertama).  Bagian-bagian <b>VP9</b> dianalisis di sini: <br><br><img width="711" height="370" src="https://habrastorage.org/webt/ub/n1/yh/ubn1yh-_d5n68swbd0bgc-lxbha.png" alt="gambar"><br><br><h3>  Langkah 2 - peramalan </h3><br>  Segera setelah kami memiliki bagian, kami dapat membuat perkiraan <s>astrologi</s> pada mereka.  Untuk <b>prediksi-ANT,</b> perlu untuk memindahkan <b>vektor</b> dan sisa <b>gerak</b> , dan untuk prediksi INTRA, <b>arah ramalan</b> dan sisanya ditransmisikan. <br><br><h3>  Langkah 3 - konversi </h3><br>  Setelah kami mendapatkan blok residu (bagian yang diprediksi → bagian yang sebenarnya), dimungkinkan untuk mengubahnya sedemikian rupa untuk mengetahui piksel mana yang dapat dibuang, sambil mempertahankan kualitas keseluruhan.  Ada beberapa transformasi yang memberikan perilaku yang akurat. <br><br>  Meskipun ada metode lain, mari kita pertimbangkan secara lebih terperinci <b>diskrit cosinus transform</b> ( <b>DCT</b> - dari <i>diskrit cosinus transform</i> ).  Fitur utama DCT: <br><br><ul><li>  Mengubah blok piksel menjadi blok koefisien frekuensi yang berukuran sama. </li><li>  Menyegel kekuatan, membantu menghilangkan redundansi spasial. </li><li>  Memberikan reversibilitas. </li></ul><br>  2 Februari 2017 Sintra R.J.  (Cintra, RJ) dan Bayer F.M.  (Bayer FM) menerbitkan artikel tentang konversi mirip DCT untuk kompresi gambar, hanya membutuhkan 14 tambahan. <br><br>  Jangan khawatir jika Anda tidak mengerti manfaat dari setiap item.  Sekarang, dengan contoh nyata, kami akan memverifikasi nilai sebenarnya. <br><br>  Mari kita ambil blok 8x8 piksel seperti ini: <br><br><img width="354" height="139" src="https://habrastorage.org/webt/tf/di/up/tfdiuplow4tut1aww2lrfydamyi.png" alt="gambar"><br><br>  Blok ini dirender ke dalam gambar berikut 8 x 8 piksel: <br><br><img width="362" height="380" src="https://habrastorage.org/webt/rq/gj/hj/rqgjhjuplvgdadziupv-ogpdazo.png" alt="gambar"><br><br>  Terapkan DCT ke blok piksel ini dan dapatkan blok koefisien ukuran 8x8: <br><br><img width="623" height="141" src="https://habrastorage.org/webt/3c/oh/i8/3cohi8vd2yjmxurbzrfhlabc_ni.png" alt="gambar"><br><br>  Dan jika kita membuat blok koefisien ini, kita mendapatkan gambar berikut: <br><br><img width="401" height="328" src="https://habrastorage.org/webt/np/b0/v2/npb0v2_58_1hxinqekagzf6phzi.png" alt="gambar"><br><br>  Seperti yang Anda lihat, ini tidak seperti gambar aslinya.  Anda mungkin memperhatikan bahwa koefisien pertama sangat berbeda dari yang lainnya.  Koefisien pertama ini dikenal sebagai koefisien DC yang mewakili semua sampel dalam array input, sesuatu yang mirip dengan nilai rata-rata. <br><br>  Blok koefisien ini memiliki sifat yang menarik: ia memisahkan komponen frekuensi tinggi dari yang frekuensi rendah. <br><br><img width="293" height="129" src="https://habrastorage.org/webt/n0/4u/1z/n04u1zqlixaeggiw_yfg3umocsy.jpeg" alt="gambar"><br><br>  Pada gambar, sebagian besar daya terkonsentrasi pada frekuensi yang lebih rendah, oleh karena itu, jika Anda mengubah gambar menjadi komponen frekuensinya dan membuang koefisien frekuensi yang lebih tinggi, Anda dapat mengurangi jumlah data yang diperlukan untuk menggambarkan gambar tanpa mengorbankan kualitas gambar terlalu banyak. <blockquote>  Frekuensi berarti seberapa cepat sinyal berubah. </blockquote>  Mari kita coba menerapkan pengetahuan yang diperoleh dalam contoh uji dengan mengubah gambar asli ke frekuensi (blok koefisien) menggunakan DCT, dan kemudian membuang beberapa koefisien yang paling tidak penting. <br><br>  Pertama, konversikan ke domain frekuensi. <br><br><img width="623" height="141" src="https://habrastorage.org/webt/3c/oh/i8/3cohi8vd2yjmxurbzrfhlabc_ni.png" alt="gambar"><br><br>  Selanjutnya, kami membuang sebagian (67%) dari koefisien, terutama sisi kanan bawah. <br><br><img width="624" height="139" src="https://habrastorage.org/webt/h5/dq/ww/h5dqwwheilwuuasgm7xxijdxmt8.png" alt="gambar"><br><br>  Akhirnya, kami mengembalikan gambar dari blok koefisien yang dibuang ini (ingat, itu harus dapat dibalik) dan dibandingkan dengan aslinya. <br><br><img src="https://habrastorage.org/webt/6j/c6/1z/6jc61zgpg5r-vxxh3j0dxjeatha.png" alt="gambar"><br><br>  Kita melihat bahwa itu menyerupai gambar asli, tetapi ada banyak perbedaan dari aslinya.  Kami melempar 67,1875% dan masih mendapatkan sesuatu yang menyerupai sumber aslinya.  Anda dapat lebih sengaja membuang koefisien untuk mendapatkan gambar dengan kualitas yang lebih baik, tetapi ini adalah topik berikutnya. <blockquote><h4>  Setiap koefisien dihasilkan menggunakan semua piksel. </h4><br><br>  Penting: setiap koefisien tidak langsung ditampilkan pada satu piksel, tetapi merupakan jumlah tertimbang dari semua piksel.  Grafik yang luar biasa ini menunjukkan bagaimana koefisien pertama dan kedua dihitung menggunakan bobot yang unik untuk setiap indeks. <br><br><img width="381" height="550" src="https://habrastorage.org/webt/ix/uv/hw/ixuvhwvqvclyzq6astn1d5vsaac.jpeg" alt="gambar"><br><br>  Anda juga dapat mencoba memvisualisasikan DCT dengan melihat pencitraan sederhana berdasarkan itu.  Misalnya, di sini adalah simbol A yang dihasilkan menggunakan masing-masing koefisien bobot: <br><br><img width="241" height="81" src="https://habrastorage.org/webt/oq/ua/3t/oqua3tnacmh7nsucvodymeqzqa0.gif" alt="gambar"></blockquote><br><br><h3>  Langkah 4 - kuantisasi </h3><br>  Setelah kami membuang beberapa koefisien pada langkah sebelumnya, pada langkah terakhir (transformasi), kami menghasilkan bentuk kuantisasi khusus.  Pada titik ini, dibiarkan kehilangan informasi.  Atau, lebih sederhana, kami akan menghitung koefisien untuk mencapai kompresi. <br><br>  Bagaimana blok koefisien dapat dikuantifikasi?  Salah satu metode paling sederhana adalah kuantisasi seragam, ketika kita mengambil blok, membaginya dengan satu nilai (dengan 10) dan melengkapi apa yang terjadi. <br><br><img width="770" height="168" src="https://habrastorage.org/webt/i8/1a/os/i81aosymefwhnp0jboibq0dd_4i.png" alt="gambar"><br><br>  Bisakah kita membalikkan blok koefisien ini?  Ya, kami bisa, dengan mengalikan dengan nilai yang sama dengan yang kami bagi. <br><br><img width="770" height="168" src="https://habrastorage.org/webt/ys/vs/51/ysvs514v-u_hrteesekxdrkjp9c.png" alt="gambar"><br><br>  Pendekatan ini bukan yang terbaik, karena tidak memperhitungkan pentingnya setiap koefisien.  Seseorang dapat menggunakan matriks kuantizer alih-alih nilai tunggal, dan matriks ini dapat menggunakan properti DCT, menghitung sebagian besar kanan bawah dan minoritas kiri atas. <br><br><h3>  5 langkah - pengkodean entropi </h3><br>  Setelah kami menghitung data (blok gambar, fragmen, bingkai), kami masih bisa memampatkannya tanpa kehilangan.  Ada banyak cara algoritmik untuk mengompres data.  Kita akan secara singkat berkenalan dengan beberapa dari mereka, untuk pemahaman yang lebih dalam, Anda dapat membaca buku " <a href="https://www.amazon.com/Understanding-Compression-Data-Modern-Developers/dp/1491961538/">Memahami Kompresi: Kompresi Data untuk Pengembang Modern</a> " (" <a href="https://www.amazon.com/Understanding-Compression-Data-Modern-Developers/dp/1491961538/">Memahami Kompresi: Kompresi Data untuk Pengembang Modern</a> "). <br><br><h3>  Pengkodean Video dengan VLC </h3><br>  Misalkan kita memiliki aliran karakter: <b>a</b> , <b>e</b> , <b>r</b> dan <b>t</b> .  Probabilitas (mulai dari 0 hingga 1) dari seberapa sering setiap simbol muncul dalam aliran disajikan dalam tabel ini. <div class="scrollable-table"><table><tbody><tr><th></th><th>  a </th><th>  e </th><th>  r </th><th>  t </th></tr><tr><th>  Kemungkinan </th><td align="center">  0,3 </td><td align="center">  0,3 </td><td align="center">  0,2 </td><td align="center">  0,2 </td></tr></tbody></table></div>  Kami dapat menetapkan kode biner yang unik (lebih disukai yang kecil) ke kode yang paling memungkinkan, dan kode yang lebih besar lebih kecil kemungkinannya. <div class="scrollable-table"><table><tbody><tr><th></th><th>  a </th><th>  e </th><th>  r </th><th>  t </th></tr><tr><th>  Kemungkinan </th><td align="center">  0,3 </td><td align="center">  0,3 </td><td align="center">  0,2 </td><td align="center">  0,2 </td></tr><tr><th>  Kode biner </th><td align="center">  0 </td><td align="center">  10 </td><td align="center">  110 </td><td align="center">  1110 </td></tr></tbody></table></div>  Kami mengompres aliran, dengan asumsi bahwa pada akhirnya kami menghabiskan 8 bit untuk setiap karakter.  Tanpa kompresi pada karakter, 24 bit akan dibutuhkan.  Jika setiap karakter diganti dengan kodenya, maka kita mendapat penghematan! <br><br>  Langkah pertama adalah menyandikan karakter <b>e</b> , yaitu 10, dan karakter kedua adalah <b>a</b> , yang ditambahkan (tidak secara matematis): [10] [0], dan akhirnya, <b>t</b> karakter ketiga, yang membuat bitstream terkompresi akhir kami sama dengan [10] [0] [1110] atau <b>1001110</b> , yang hanya membutuhkan 7 bit (3,4 kali lebih sedikit ruang daripada yang asli). <br><br>  Harap perhatikan bahwa setiap kode harus berupa kode unik dengan awalan.  <a href="https://en.wikipedia.org/wiki/Huffman_coding">Algoritma Huffman</a> akan membantu menemukan angka-angka ini.  Meskipun metode ini bukan tanpa cacat, ada codec video yang masih menawarkan metode algoritmik ini untuk kompresi. <br><br>  Encoder dan decoder harus memiliki akses ke tabel simbol dengan kode binernya.  Oleh karena itu, perlu juga mengirim tabel dalam input. <br><br><h3>  Pengkodean aritmatika </h3><br>  Misalkan kita memiliki aliran karakter: <b>a</b> , <b>e</b> , <b>r</b> , <b>s</b> dan <b>t</b> , dan probabilitasnya diwakili oleh tabel ini. <div class="scrollable-table"><table><tbody><tr><th></th><th>  a </th><th>  e </th><th>  r </th><th>  s </th><th>  t </th></tr><tr><th>  Kemungkinan </th><td align="center">  0,3 </td><td align="center">  0,3 </td><td align="center">  0,15 </td><td align="center">  0,05 </td><td align="center">  0,2 </td></tr></tbody></table></div>  Dengan tabel ini, kami membuat rentang yang berisi semua karakter yang mungkin, diurutkan berdasarkan jumlah terbesar. <br><br><img width="713" height="86" src="https://habrastorage.org/webt/v2/et/wv/v2etwv7gqr0imlymbanupu6k3fw.png" alt="gambar"><br><br>  Sekarang mari kita kodekan aliran tiga karakter: <b>makan</b> . <br><br>  Pertama, pilih karakter pertama <b>e</b> , yang berada dalam sub-rentang 0,3 hingga 0,6 (tidak termasuk).  Kami mengambil subrange ini dan membaginya lagi dalam proporsi yang sama seperti sebelumnya, tetapi sudah untuk rentang baru ini. <br><br><img width="731" height="86" src="https://habrastorage.org/webt/fv/ra/lx/fvralxpih4rt9d6zowmweah5r8m.png" alt="gambar"><br><br>  Mari kita lanjutkan untuk mengkodekan aliran <b>makan</b> kita.  Sekarang kita ambil simbol kedua <b>a</b> , yang ada di subrange baru dari 0,3 ke 0,39, dan kemudian kita mengambil simbol <b>t</b> terakhir kita dan, mengulangi proses yang sama lagi, kita mendapatkan subrange terakhir dari 0,354 ke 0,372. <br><br><img width="735" height="388" src="https://habrastorage.org/webt/eh/bj/nz/ehbjnz3uckrkkfoei5bt2gqh1zk.png" alt="gambar"><br><br>  Kami hanya perlu memilih nomor di sub-rentang terakhir dari 0,354 hingga 0,372.  Mari kita pilih 0,36 (tetapi Anda dapat memilih nomor lain dalam sub-rentang ini).  Hanya dengan nomor ini kita dapat mengembalikan aliran asli kita.  Seolah-olah kami sedang menggambar garis dalam rentang untuk menyandikan aliran kami. <br><br><img width="712" height="231" src="https://habrastorage.org/webt/a2/y2/ye/a2y2yerdhz8bied1n-4o8pqfiic.png" alt="gambar"><br><br>  Operasi sebaliknya (yaitu, <i>decoding</i> ) sama mudahnya: dengan angka kami 0,36 dan rentang awal kami, kami dapat memulai proses yang sama.  Tapi sekarang, menggunakan nomor ini, kami mengungkapkan aliran yang disandikan menggunakan nomor ini. <br><br>  Dengan rentang pertama, kami perhatikan bahwa nomor kami sesuai dengan sepotong, oleh karena itu, ini adalah karakter pertama kami.  Sekarang lagi, kami membagikan subband ini, melakukan proses yang sama seperti sebelumnya.  Di sini Anda dapat melihat bahwa 0,36 sesuai dengan karakter <b>a</b> , dan setelah mengulangi prosesnya, kita sampai pada karakter terakhir <b>t</b> (membentuk stream <b>makan</b> asli yang disandikan). <br><br>  Baik encoder dan decoder harus memiliki tabel probabilitas simbol, oleh karena itu, perlu untuk mengirimkannya dalam data input. <br><br>  Cukup elegan, bukan?  Seseorang yang datang dengan solusi ini sangat pintar.  Beberapa codec video menggunakan teknik ini (atau, dalam hal apa pun, menawarkannya sebagai opsi). <br><br>  Idenya adalah untuk memampatkan bitstream terkuantisasi lossless.  Tentunya dalam artikel ini tidak ada detail, alasan, kompromi, dll.  Tetapi Anda, jika Anda seorang pengembang, harus tahu lebih banyak.  Codec baru mencoba menggunakan algoritma pengkodean entropi yang berbeda, seperti <b>ANS</b> . <br><br><h3>  6 langkah - format bitstream </h3><br>  Setelah melakukan semua ini, tetap membongkar frame terkompresi dalam konteks langkah-langkah yang diambil.  Dekoder harus secara eksplisit diinformasikan tentang keputusan yang dibuat oleh pembuat sandi.  Dekoder harus dilengkapi dengan semua informasi yang diperlukan: kedalaman bit, ruang warna, resolusi, informasi perkiraan (vektor gerakan, prediksi-directional INTER), profil, level, laju bingkai, jenis bingkai, nomor bingkai, dan banyak lagi. <br><br>  Kami akan melihat bitstream <b>H.264</b> .  Langkah pertama kami adalah membuat bitstream H.264 minimum (FFmpeg secara default menambahkan semua parameter pengkodean, seperti <b>SEI NAL</b> - sedikit lebih jauh kita akan mengetahui apa itu).  Kita dapat melakukan ini menggunakan repositori dan FFmpeg kita sendiri. <br><br> <code>./s/ffmpeg -i /files/i/minimal.png -pix_fmt yuv420p /files/v/minimal_yuv420.h264</code> <br> <br>  Perintah ini akan menghasilkan bitstream <b>H.264</b> mentah dengan satu frame, resolusi 64x64, dengan ruang warna <b>YUV420</b> .  Gambar berikut digunakan sebagai bingkai. <br><br><img width="64" height="64" src="https://habrastorage.org/webt/dk/94/2b/dk942bnujajisjouk6zpwy9p5i8.png" alt="gambar"><br><br><h3>  H.264 Bitstream </h3><br>  Standar <b>AVC</b> ( <b>H.264</b> ) mendefinisikan bahwa informasi akan dikirim dalam bingkai makro (dalam pengertian jaringan) yang disebut <b>NAL</b> (ini adalah tingkat abstraksi jaringan).  Tujuan utama NAL adalah menyediakan presentasi video yang "ramah jaringan".  Standar ini harus bekerja pada TV (berdasarkan aliran), di Internet (berdasarkan paket). <br><br><img width="484" height="41" src="https://habrastorage.org/webt/rd/8r/ag/rd8rag_9adq5fnhkh3bp1l84ljw.png" alt="gambar"><br><br>  Ada penanda sinkronisasi untuk menentukan batas elemen NAL.  Setiap penanda sinkronisasi berisi nilai <nobr><b>0x00 0x00 0x01,</b></nobr> dengan pengecualian yang paling pertama, yaitu <nobr><b>0x00 0x00 0x00 0x01.</b></nobr>  Jika kita menjalankan <b>hexdump</b> untuk bitstream H.264 yang dihasilkan, kami akan mengidentifikasi setidaknya tiga pola NAL di awal file. <br><br><img width="451" height="250" src="https://habrastorage.org/webt/ow/vk/uj/owvkujuxd9qw-yft0b2tecxp3oq.png" alt="gambar"><br><br>  Seperti yang dinyatakan, decoder harus tahu tidak hanya data gambar, tetapi juga detail video, bingkai, warna, parameter yang digunakan, dan banyak lagi.  Byte pertama dari setiap NAL mendefinisikan kategori dan jenisnya. <div class="scrollable-table"><table><tbody><tr><th>  Pengidentifikasi tipe NAL </th><th>  Deskripsi </th></tr><tr><td align="center">  0 </td><td>  Jenis tidak dikenal </td></tr><tr><td align="center">  1 </td><td>  Fragmen kode gambar tanpa IDR </td></tr><tr><td align="center">  2 </td><td>  Bagian Data Berkode Kode </td></tr><tr><td align="center">  3 </td><td>  Bagian Data Kode Berkode <b>B</b> </td></tr><tr><td align="center">  4 </td><td>  Bagian data slice berkode <b>C</b> </td></tr><tr><td align="center">  5 </td><td>  Potongan kode IDR dari gambar IDR </td></tr><tr><td align="center">  6 </td><td>  Informasi Tambahan tentang Perpanjangan SEI </td></tr><tr><td align="center">  7 </td><td>  Set parameter urutan SPS </td></tr><tr><td align="center">  8 </td><td>  Set parameter gambar PPS </td></tr><tr><td align="center">  9 </td><td>  Pembatas akses </td></tr><tr><td align="center">  10 </td><td>  Akhir dari urutan </td></tr><tr><td align="center">  11 </td><td>  Ujung aliran </td></tr><tr><td align="center">  ... </td><td>  ... </td></tr></tbody></table></div>  Biasanya bitstream NAL pertama adalah <b>SPS</b> .  Jenis NAL ini bertanggung jawab untuk melaporkan variabel penyandian umum, seperti profil, level, resolusi, dan banyak lagi. <br><br>  Jika kita melewatkan token sinkronisasi pertama, kita dapat mendekode byte pertama untuk mencari tahu apa jenis NAL yang pertama. <br><br>  Misalnya, byte pertama setelah penanda sinkronisasi adalah <i>01100111</i> , di mana bit pertama ( <i>0</i> ) berada di bidang f <i>orbidden_zero_bit</i> .  2 bit berikutnya ( <i>11</i> ) memberi tahu kita bidang <i>nal_ref_idc,</i> yang menunjukkan apakah NAL ini adalah bidang referensi atau tidak.  Dan sisa 5 bit ( <i>00111</i> ) memberi tahu kita bidang <i>nal_unit_type,</i> dalam hal ini adalah blok NAL SPS ( <i>7</i> ). <br><br>  Byte kedua ( <i>biner</i> = <i>01100100</i> , <i>hex</i> = <i>0x64</i> , <i>dec</i> = <i>100</i> ) di SPS NAL adalah bidang <i>profile_idc,</i> yang menunjukkan profil yang digunakan pembuat enkode.  Dalam kasus ini, profil tinggi terbatas digunakan (mis. Profil tinggi tanpa dukungan untuk segmen-B dua arah). <br><br><img src="https://habrastorage.org/webt/xo/zt/wl/xoztwl_amtveehtmceuijr3wdsm.png" alt="gambar"><br><br>  Jika kita membiasakan diri dengan spesifikasi bitstream <b>H.264</b> untuk SPS NAL, kita akan menemukan banyak nilai untuk nama parameter, kategori, dan deskripsi.  Misalnya, mari kita lihat bidang <i>pic_width_in_mbs_minus_1</i> dan <i>pic_height_in_map_units_minus_1</i> . <div class="scrollable-table"><table><tbody><tr><th>  Nama Parameter </th><th>  Kategori </th><th>  Deskripsi </th></tr><tr><td>  pic_width_in_mbs_minus_1 </td><td align="center">  0 </td><td align="center">  ue (v) </td></tr><tr><td>  pic_height_in_map_units_minus_1 </td><td align="center">  0 </td><td align="center">  ue (v) </td></tr></tbody></table></div>  Jika kami melakukan beberapa operasi matematika dengan nilai-nilai bidang ini, maka kami mendapatkan izin.  Anda dapat membayangkan <nobr>1920 x 1080</nobr> menggunakan <i>pic_width_in_mbs_minus_1</i> dengan nilai <nobr>119 ((119 + 1) * macroblock_size = 120 * 16 = 1920)</nobr> .  Sekali lagi, menghemat ruang, alih-alih mengkodekan 1920 mereka melakukannya dengan 119. <br><br>  Jika kita terus memeriksa video yang kita buat dalam bentuk biner (misalnya: <nobr><i>xxd -b -c 11 v / minimal_yuv420.h264</i></nobr> ), maka kita dapat pergi ke NAL terakhir, yang merupakan bingkai itu sendiri. <br><br><img src="https://habrastorage.org/webt/fc/wt/ru/fcwtruw1ol7zkpc4osveloks_ri.png" alt="gambar"><br><br>  Di sini kita melihat nilai 6 byte pertama: <i>01100101 10001000 10000100 00000000 00100001 11111111</i> .  Karena diketahui bahwa byte pertama menunjukkan jenis NAL, dalam hal ini ( <i>00101</i> ) ini adalah fragmen IDR (5), dan kemudian dimungkinkan untuk mempelajarinya lebih lanjut: <br><br><img width="604" height="458" src="https://habrastorage.org/webt/ip/67/gh/ip67gh7uuxizfnt_5oko5oowohk.png" alt="gambar"><br><br>  Dengan menggunakan informasi spesifikasi, dimungkinkan untuk mendekode jenis fragmen ( <i>slice_type</i> ) dan nomor bingkai ( <i>frame_num</i> ) di antara bidang-bidang penting lainnya. <br><br>  Untuk mendapatkan nilai beberapa bidang ( <i>ue</i> ( <i>v</i> ), <i>me</i> ( <i>v</i> ), <i>se</i> ( <i>v</i> ) atau <i>te</i> ( <i>v</i> )), kita perlu mendekode fragmen menggunakan dekoder khusus berdasarkan <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BA%25D1%2581%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25BE%25D0%25B4_%25D0%2593%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25BC%25D0%25B1%25D0%25B0">kode Golomb eksponensial</a> .  Metode ini sangat efektif untuk mengkodekan nilai variabel, terutama ketika ada banyak nilai default. <br><br>  Nilai <i>slice_type</i> dan <i>frame_num</i> dari video ini adalah 7 (fragmen-I) dan 0 (frame pertama). <br><br>  Bitstream dapat dianggap sebagai protokol.  Jika Anda ingin tahu lebih banyak tentang bitstream, Anda harus merujuk pada spesifikasi <b>ITU H.264</b> .  Berikut ini adalah makro yang menunjukkan di mana data gambar berada ( <b>YUV</b> dalam bentuk terkompresi). <br><br><img src="https://habrastorage.org/webt/sh/ka/sf/shkasfvpn80vva4jfeoxk2be1pe.png" alt="gambar"><br><br>  Anda dapat menjelajahi bitstream lainnya, seperti <b>VP9</b> , <b>H.265</b> ( <b>HEVC</b> ), atau bahkan bitstream <b>AV1</b> baru terbaik kami.  Apakah mereka semua sama?  Tidak, tetapi berurusan dengan setidaknya satu lebih mudah untuk memahami sisanya. <blockquote><h4>  Ingin berlatih?  Jelajahi H.264 Bitstream </h4><br>  Anda dapat menghasilkan video single-frame dan menggunakan MediaInfo untuk memeriksa bitstream <b>H.264</b> .  Bahkan, tidak ada yang mencegah Anda dari melihat kode sumber yang menganalisis bitstream <b>H.264</b> ( <b>AVC</b> ). <br><br><img src="https://habrastorage.org/webt/b0/n5/7v/b0n57v_h_gb2l2m0evkrhkukr_s.png" alt="gambar"><br><br>  Untuk latihan, Anda dapat menggunakan Intel Video Pro Analyzer (Saya sudah mengatakan bahwa program ini berbayar, tetapi apakah ada versi uji coba gratis dengan batas 10 bingkai?). <br><br><img src="https://habrastorage.org/webt/l9/63/ni/l963nix2wqornscrgdpzechdjq8.png" alt="gambar"></blockquote><h3>  Ulasan </h3><br>  Perhatikan bahwa banyak codec modern menggunakan model yang sama dengan yang baru mereka pelajari.  Di sini, mari kita lihat diagram blok codec video <b>Thor</b> .  Ini berisi semua langkah yang telah kami ambil.  Inti dari posting ini adalah bagi Anda untuk setidaknya lebih memahami inovasi dan dokumentasi di bidang ini. <br><br><img width="574" height="507" src="https://habrastorage.org/webt/7q/go/1s/7qgo1so0_mld4wglqvhan3ttwei.png" alt="gambar"><br><br>  Sebelumnya, diperkirakan 139 GB ruang disk akan diperlukan untuk menyimpan file video yang tahan satu jam dengan kualitas 720p dan 30 fps.  Jika Anda menggunakan metode yang dibahas dalam artikel ini (prakiraan antar-bingkai dan internal, konversi, kuantisasi, pengkodean entropi, dll.), Maka Anda dapat mencapainya (dengan asumsi bahwa kami menghabiskan 0,031 bit per piksel), video memiliki kualitas yang cukup memuaskan, yang memakan waktu hanya 367,82 MB, bukan memori 139 GB. <br><br><h3>  Bagaimana H.265 mencapai rasio kompresi yang lebih baik daripada H.264? </h3><br>  Sekarang Anda tahu lebih banyak tentang cara kerja codec, lebih mudah untuk memahami bagaimana codec baru dapat memberikan resolusi lebih tinggi dengan bit lebih sedikit. <br><br>  Saat membandingkan <b>AVC</b> dan <b>HEVC</b> , jangan lupa bahwa ini hampir selalu merupakan pilihan antara beban CPU dan rasio kompresi yang lebih tinggi. <br><br>  <b>HEVC</b> memiliki lebih banyak opsi untuk bagian (dan subbagian) daripada <b>AVC</b> , lebih banyak arahan untuk perkiraan internal, peningkatan kode entropi, dan banyak lagi.  Semua peningkatan ini membuat <b>H.265</b> mampu mengompresi 50% lebih dari <b>H.264</b> . <br><br><img src="https://habrastorage.org/webt/m3/jj/x8/m3jjx88-ppzrakex1sjxlinwjx8.png" alt="gambar"><br><br><hr><br><h3>  Bagian I: <a href="https://habr.com/ru/company/edison/blog/481418/">Video dan Dasar-Dasar Gambar</a> </h3><br><br><hr><br> <a href="https://habr.com/ru/company/edison/blog/485460/"><img align="right" width="404" height="150" src="https://habrastorage.org/webt/2b/9i/gm/2b9igmgpbxunecpetjj6hhqsa9m.png"></a> <br clear="left"><h4>  Baca juga blognya <br>  Perusahaan EDISON: </h4><br>  <a href="https://habr.com/ru/company/edison/blog/485460/"><b>20 perpustakaan untuk</b></a> <a href="https://habr.com/ru/company/edison/blog/485460/"><b><br></b></a>  <a href="https://habr.com/ru/company/edison/blog/485460/"><b>aplikasi iOS yang spektakuler</b></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480430/">https://habr.com/ru/post/id480430/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480416/index.html">Matematika generik tidak aman dalam C #</a></li>
<li><a href="../id480420/index.html">Wawancara dengan Matthew "Oki" O'Connor tentang Atherosclerosis dan Perawatannya</a></li>
<li><a href="../id480422/index.html">Panduan Gaya Google di C ++. Bagian 1</a></li>
<li><a href="../id480424/index.html">Panduan Gaya Google di C ++. Bagian 9</a></li>
<li><a href="../id480428/index.html">Metode steno paling sederhana. Alfabet dan font untuknya.</a></li>
<li><a href="../id480432/index.html">Masalah penampil pertama, atau sulitnya konversi aliran video WebRTC ke HLS</a></li>
<li><a href="../id480440/index.html">Acara digital di St. Petersburg dari 16 hingga 22 Desember</a></li>
<li><a href="../id480444/index.html">Detektif Habra: 24 jam dari kehidupan 24 publikasi</a></li>
<li><a href="../id480446/index.html">Menulis reverse proxy Grafana on Go</a></li>
<li><a href="../id480452/index.html">Pertemuan # 9 OWASP Moscow: Catatan Kinerja</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>